[k"°#==============================================================================
# ** Game
#==============================================================================

APPFOLDER = "Aveyond 4"

def aveyond4

    # User Data folder
    Win32API.new('System/Utils', "AVSetEnv", ["V"], "I").call          
    $appdata = ENV['AV_APPDATA'] + "\\" + APPFOLDER
    Dir.mkdir($appdata) if !File.exists?($appdata) 

    # Who will debug the debug?
    begin
      $debug = DebugManager.new
    rescue StandardError => e
      p e.inspect
    end

    $cache = CacheManager.new
    $audio = AudioManager.new
    $keyboard = KeyboardManager.new
    $mouse = MouseManager.new
    $input = InputManager.new
    $data = DataManager.new
    $tweens = TweenManager.new
    $settings = SettingsManager.new
    $files = FileManager.new
    $battle = Game_Battle.new
    $fonts = FontManager.new
    $game = GameManager.new  
    # $steam = SteamManager.new

    $scratch = Bitmap.new(400,50)

    # Call main method as long as $scene is effective      
    $game.update until $game.quit?
    
    # Set the windowed mode for next time
    $settings.conclude

rescue StandardError => e
    
  line = e.message.split(":")[1].to_i      
  log_err e.inspect
  log_err "------------------"
  
  e.backtrace.each{ |location|
    line_num = location.split(":")[1]
    script_name = location.split(":")[0]
    if script_name.include?("Scripts/")
      script_name['Scripts/'] = ''
    end

    if location.include?("Section")
      section = location[/(?#Section)(\d)*(:)/]
      section_err = section[0, section.length - 1]
      script_name = $RGSS_SCRIPTS[section_err.to_i][1]
    end

    method = location.split(":")[2]
    next if method == nil
    loc_err = "Line " + line_num + ", "+method.to_s+" in "+script_name    
    loc_err = "Game Start" if script_name.include?("{0128")
    log_err("#{loc_err}")
  } 
  
end":#==============================================================================
# ** Sprite_Character
#------------------------------------------------------------------------------
#  This sprite is used to display the character.It observes the Game_Character
#  class and automatically changes sprite conditions.
#==============================================================================

class Sprite_Character < Sprite

  attr_accessor :character     

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     viewport  : viewport
  #     character : character (Game_Character)
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @character = character
    update
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # If tile ID, file name, or hue are different from current ones
    if @character_name != @character.character_name
     
      @character_name = @character.character_name

      self.bitmap = $cache.character(@character.character_name)
      if @character == $player
        self.bitmap = $cache.character("Player/boy")
        
      end
      @cw = bitmap.width / 4
      @ch = bitmap.height / 4
      self.ox = @cw / 2
      self.oy = @ch

      if @character_name.include?("Prop")
        @cw = bitmap.width
        @ch = bitmap.height
        self.ox = @cw / 2
        self.oy = @ch
      end

    end

    # Clear the helper graphics
    if @character_name == "!!!"
      self.bitmap.clear
    end

    # if @character == $player
    #   self.bitmap = $cache.character("Player/boy")
    #   self.bitmap = $cache.character("Player/boy_corn") if @character.bush_depth > 0
    # end

    # Set visible situation
    self.visible = !@character.transparent
    
    sx = @character.pattern * @cw
    sy = (@character.showdir - 2) / 2 * @ch
    self.src_rect.set(sx, sy, @cw, @ch)

    # Set sprite coordinates
    self.x = @character.screen_x
    self.y = @character.screen_y - 8
    self.z = @character.screen_z(@ch)

    # TODO auto name the helper icons

    if $scene.is_a?(Scene_Map) && $settings.debug_draw_names
      w = $scene.debug.bitmap.text_size(@character.name).width + 6 if @character != $player
      $scene.debug.bitmap.fill_rect(self.x-w/2,self.y,w,20,Color.new(23,111,22,200)) if @character != $player
      $scene.debug.bitmap.draw_text(self.x-w/2,self.y,w,20,@character.name,1) if @character != $player
    end
    
    # Set opacity level, blend method, and bush depth
    self.opacity = @character.opacity
    #log_info(@character.opacity) if @character.opacity < 255

    #if @character.bush_depth > 0
      #self.bush_depth = 1.2 * @character.bush_depth 

      #bmp = self.bitmap
      # self.bitmap = Bitmap.new(bmp.width,bmp.height)

      # self.bitmap.blt(0,0,bmp,Rect.new(0,0,bmp.width,16))

    #end
    
    # Animation
    # if @character.animation_id != 0
    #   animation = $data_animations[@character.animation_id]
    #   animation(animation, true)
    #   @character.animation_id = 0
    # end

  end
end
"¹


class MapWrap < Tilemap

  attr_accessor :tileset_id

	def refresh(map)

      @tileset_id = map.tileset_id

      self.tileset = $cache.tileset(map.tileset.tileset_name)
      i = 0 
      map.tileset.autotile_names.each{ |a|
        next if a == ''
        self.autotiles[i] = $cache.autotile(a)
        i+=1
      }
      
      self.map_data = map.data
      self.priorities = map.tileset.priorities

	end

end"A


# Other things of this nature will reside within thine"T#==============================================================================
# Widget_Label
#==============================================================================

class Area < Sprite
  
  # accessors
  attr_accessor :font 
  attr_accessor :fixed_width
  attr_accessor :padding
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug

    @text = "Label"

    @padding = 5
    @spacing = 5

    # Required for next lining
    @fixed_width = 250
    
  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    if @text != text
      @text = text
      refresh
    end
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

  	# Split into lines that fit
  	lines = [""]
  	cx = 0
  	@text.split(" ").each{ |word|
  		w = $fonts.size(word,@font)
  		cx += w.width
  		if cx < @fixed_width
  			lines[-1] += word + ' '
  			cx += w.width + @spacing
  		else
  			lines.push(word + ' ')
  			cx = 0
  		end
  	}

  	log_scr(lines)

  	height = $fonts.size("Happy",@font).height

  	# Build the bitmap now
  	w = @fixed_width
    h = height * lines.count

    self.bitmap = Bitmap.new(w+@padding*2,h+@padding*2)
    self.bitmap.font = @font

    cy = 0
    lines.each{ |line|
    	self.bitmap.draw_text(@padding,@padding+cy,w,height,line)
    	cy += height
    }
    
    
  end
  
end"l

class Bar < Sprite

	attr_accessor :value

	def initialize(vp,w,h)

		super(vp)

		@value = 12
		self.do(go("value",75,3000,:quad_in_out))
		@target = 75

		@drawn = @value

		@max = 120

		@width = w
		@height = h

		@base_color = Color.new(46,46,46,200)
		@ghost_color = Color.new(0,255,0,50)
		@bar_color = Color.new(0,255,0,255)

		self.bitmap = Bitmap.new(w,h)

		redraw

	end

	def update
		#if @drawn != @value.to_i
			redraw
		#end
	end

	def redraw

		@drawn = @value.to_i

		# Draw the 3 layers
		self.bitmap.clear
		self.bitmap.fill(@base_color)

		# Draw ghost
		if @target > @value
			gw = ((@target.to_f/@max) * @width).to_i
			self.bitmap.fill_rect(0,0,gw,@height,@ghost_color)
		end

		# Draw next
		vw = ((@value.to_f/@max) * @width).to_i
		self.bitmap.fill_rect(0,0,vw,@height,@bar_color)

	end

end"i
class Box 

	def initialize(vp,w=100,h=100)

		@wallpaper = Sprite.new(vp)
		@window = Sprite.new(vp)		

		@skin = nil
		@src = nil

		@width = w
		@height = h

		@alpha = 230		

		# Position
		@px, @py = 0.0, 0.0

		# Display position, integer
		@dx, @dy = 0, 0

		# Anim speed
		@sx = 0.2
		@sy = 0.2

	end

	def dispose
		@wallpaper.dispose
		@window.dispose
	end

	def skin=(bmp)
		@skin = bmp
		@window.bitmap = Bitmap.new(@width,@height)
		@window.bitmap.borderskin(@skin)
	end

	def wallpaper=(w)
		@src = w
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		redraw
	end

	def color=(c)
		@color = c
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		@wallpaper.bitmap.fill(c)
	end

	def opacity=(o)
		@wallpaper.opacity = o
		@window.opacity = o
	end

	def hide
		self.opacity = 0
	end

	def show 
		self.opacity = 255
	end

	def x=(v)
		@wallpaper.x = v+4
		@window.x = v
	end

	def y=(v)
		@wallpaper.y = v+4
		@window.y = v
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def width() return @width end
	def height() return @height end

	def resize(w,h)
		@width = w
		@height = h
		@window.bitmap = Bitmap.new(w,h)
		@window.bitmap.borderskin(@skin)
		@wallpaper.bitmap = Bitmap.new(w-8,h-8)	
		if @src != nil	
			redraw
		else
			@wallpaper.bitmap.fill(@color)
		end
	end

	def update

		# Redraw the bmp if needed
		@px += @sx
		@py += @sy

		# Mod to width of bmp
		@px -= @src.width if @px > @src.width
		@px += @src.width if @px < -@src.width
		@py -= @src.height if @py > @src.height
		@py += @src.height if @py < @src.height		

		if @px.to_i != @dx || @py.to_i != @dy
			@dx = @px.to_i
			@dy = @py.to_i
			redraw
		end

	end

	def redraw

		@wallpaper.bitmap.clear

		cx = -@dx
		cy = -@dy

		while cx < @width

			while cy < @height

				rct = @src.rect
				# If draw's over, cancel
				# Also for offset for first

				@wallpaper.bitmap.blt(cx,cy,@src,rct,@alpha)

				cy += @src.height

			end

			cy = -@dy
			cx += @src.width
			#log_info("DRAW #{cx}")

		end

	end

end"d	#==============================================================================
# Button
#==============================================================================

class Button < Sprite
  
  # accessors
  attr_accessor :select, :deselect, :press
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
       
    super(vp)

    # handle mouseovers and that and procs and that
    @select = nil#Proc.new{ self.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = nil#Proc.new{ $tweens.clear(self); self.x = 22; $tweens.clear(self) }
    @press = nil#Proc.new{self.do(pingpong("y",-30,300,:quad_in_out));}

    @state = :idle # :over
    
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    # Check inputs if active?
    if @state == :idle
      #if Input.method == :mouse
        check_hover($mouse.position)
      #end
      # check mouse hover?
    end

    if @state == :active
      check_nhover($mouse.position)
      if @state == :active
        if $input.click?
          @press.call()
        end
      end
    end

    if @state == :active
      # check key presses to change to another
      #if Input.trigger?(Input.right)
        # check hover of all neighbours
      #  self.viewport.sprites.each{ |s| s.check_hover(x+100)}
      #end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x
    return if pos[1] < self.y
    return if pos[0] > self.x + self.width
    return if pos[1] > self.y + self.height
    @state = :active
    @select.call() if @select
    log_info("PROC")
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x
    w = true if pos[1] < self.y
    w = true if pos[0] > self.x + self.width
    w = true if pos[1] > self.y + self.height
    return if w == false
    @state = :idle
    @deselect.call() if @select
    log_info("UNPROC")
  end

end"«#==============================================================================
# Widget_Label
#==============================================================================

class Label < Sprite
  
  # accessors
  attr_accessor :align 
  attr_accessor :font 
  attr_accessor :fixed_width
  attr_accessor :padding
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug

    @text = "Label"

    @align = 0

    @icon = nil

    @padding = 5

    # If there is a width, don't auto size width
    @fixed_width = 0

  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    if @text != text
      @text = text
      refresh
    end
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    # If fixed width, don't recreate
    if @fixed_width > 0 
      if self.bitmap && self.bitmap.width == @fix_width
        self.bitmap.clear
      else
        size = $fonts.size(@text,@font)
        size.height += @padding*2
        self.bitmap = Bitmap.new(@fixed_width,size.height)
      end
    else
      size = $fonts.size(@text,@font)
      size.width += @padding*2
      size.height += @padding*2
      self.bitmap = Bitmap.new(size.width,size.height)
    end

    self.bitmap.font = @font

    # Draw the text
    x = @padding
    y = @padding
    w = self.bitmap.width-@padding*2
    h = self.bitmap.height-@padding*2
    self.bitmap.draw_text(x,y,w,h,@text,@align)
    
  end
  
end"#==============================================================================
# The magical list
#==============================================================================

class List
      
  attr_accessor :x, :y
  attr_accessor :item_width, :item_height
  attr_accessor :item_ox, :item_space

  attr_accessor :select, :cancel, :change

  attr_accessor :active

  attr_reader :page_idx

  attr_accessor :type

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize() 

    # Make own viewport
    @vp = Viewport.new(0,0,1000,1000)
    @vp.z = 9999

    @font = Font.new
    @font.name = "Verdana"
    @font.size = 20 #was 26
    @font.color = Color.new(245,223,200)


    @item_width = 0
    @item_height = 0

    @item_ox = 0
    @item_space = 0

    # Procs
    @select = nil
    @cancel = nil
    @change = nil

  	@x = 0
  	@y = 0

    @type = :item
  	@data = []

  	@scroll_idx = 0
  	@page_idx = 0

  	@per_page = 11

  	# Sprites
  	@sprites = []
  	@per_page.times{ |i|
  		@sprites.push(Sprite.new(@vp))
  	}

  	@dynamo = Sprite.new(@vp)

    @active = true

  end

  def opacity=(o)
    @sprites.each{ |s|
      s.opacity = 0
    }
    @dynamo.opacity = 0
  end

  def dispose
  	@sprites.each{ |s| s.dispose }
  	@dynamo.dispose
  end

  def setup(data)
  	@data = data
    @per_page = @data.count
  	refresh
  end

  def idx
    return @scroll_idx + @page_idx
  end

  def refresh

    @vp.rect = Rect.new(@x,@y,@item_width,@item_space*@per_page)

  	# Rebuild the items from data
  	cy = 0#@y

  	(0..@per_page-1).each{ |i|
  		draw(@data[i+@scroll_idx],@sprites[i],i==@page_idx)
      @current = @data[i+@scroll_idx] if i == @page_idx
  		@sprites[i].y = cy
  		@sprites[i].x = 0#@x
      @sprites[i].opacity = 255
  		cy += @item_space
      #@sprites[i].bitmap.height
  	}

  	@cybt = cy

  end

  def scrollbar_down
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx += 1;self.refresh; self.scroll_up 
  end

  def scrollbar_up
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx -= 1; self.refresh; self.scroll_down
  end

  def current
    return @current[0] if @type == :misc
    return @current
  end

  def draw(data,sprite,on)

  	# Draw the base
    src = $cache.menu("Common/bartest3")
    src = $cache.menu("Common/bartest4") if on
  	sprite.bitmap = Bitmap.new(src.width,src.height)
    sprite.bitmap.blt(0,0,src,src.rect)

    return if data == nil

    # Drw the contents
    case @type
      when :item
        draw_item(data,sprite,on)
      when :skill
        draw_skill(data,sprite,on)
      when :quest
        draw_quest(data,sprite,on)
      when :misc
        draw_misc(data,sprite,on)
    end

  end

  def draw_item(data,sprite,on)

    #return if $data.items.has_key?(data)

    item = $data.items[data]

    ico = $cache.icon(item.icon)
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,item.name,0)

  end

  def draw_skill(data,sprite,on)

  end

  def draw_quest(data,sprite,on)

    item = $data.quests[data]

    ico = $cache.icon('items/map')
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,item.name,0)

  end

  def draw_misc(data,sprite,on)

    ico = $cache.icon(data[1])
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,data[0],0)

  end

  def update

    return if !@active

  	# Check inputs and that
  	if $keyboard.press?(VK_DOWN) #&& @dynamo.done?

      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx += 1
  		if @page_idx > 3
        refresh
  			scroll_up
  		else
  		  refresh
      end
      @change.call(current) if !@change.nil?
  	end

  	if $keyboard.press?(VK_UP) #&& @dynamo.done?
      
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx -= 1 if @page_idx > 0
  		if @page_idx < 3 && @scroll_idx > 0
        refresh
  			scroll_down
  		else
  		  refresh
      end
      @change.call(current) if !@change.nil?
  	end

    pos = $mouse.position

    # Check mouseover
    @sprites.each_index{ |i|
      break
      next if pos[0] < @sprites[i].x
      next if pos[1] < @sprites[i].y
      next if pos[0] > @sprites[i].x + @sprites[i].width
      next if pos[1] > @sprites[i].y + @sprites[i].height
      @page_idx = i
      refresh
      break
    }


    # Selection
    if $input.action?
      @select.call(current) if !@select.nil?
    end

    # Cancel
    if $input.cancel?
      log_info("TRYIT")
      @cancel.call(current) if !@cancel.nil?
    end

  end

  def scroll_down

    @scroll_idx -= 1    
          @pagemod = 1

    # Create the dynamo
    @dynamo.y = 0 - @item_space
    @dynamo.x = 0#@x
    @dynamo.opacity = 205

    dur = 200
    ease = :quad_in_out

    draw_item(@data[@scroll_idx],@dynamo,@page_idx == -1)

    @dynamo.do(go("y",@item_space,dur,ease))
    @dynamo.do(go("opacity",50,dur,ease))

    @dynamo.do(proc(Proc.new{
      @page_idx += 1

      self.refresh
      @dynamo.opacity = 205
    },dur+30))

    @sprites.each{ |s|
      s.do(go("y",@item_space,dur,ease))
    }

    @sprites[-1].do(go("opacity",-50,dur,ease))

  end

  def scroll_up

    @scroll_idx += 1    
          @pagemod = -1

  	# Create the dynamo
  	@dynamo.y = @cybt
  	@dynamo.x = 0#@x
  	@dynamo.opacity = 205

    dur = 200
    ease = :quad_in_out

  	draw_item(@data[@scroll_idx + @per_page - 1],@dynamo,@page_idx == @per_page)

  	@dynamo.do(go("y",-@item_space,dur,ease))
  	@dynamo.do(go("opacity",50,dur,ease))



  	@dynamo.do(proc(Proc.new{

      @page_idx -= 1
      self.refresh
      @dynamo.opacity = 205
    },dur+30))

  	@sprites.each{ |s|
  		s.do(go("y",-@item_space,dur,ease))
  	}

  	@sprites[0].do(go("opacity",-50,dur,ease))

  end

 end">
class Spark < Sprite

	def initialize(fx,vp)
		super(vp)

		self.bitmap = $cache.menu("Sparks/#{fx}")

		@frame = -1

		# No frame per row

		@delay = 3
		@next = 0

		update

	end

	def width
		return self.bitmap.width / 5
	end

	def height
		return self.bitmap.width / 5
	end

	def update

		# Step counters
		@next -= 1
		if @next < 1
			@next = @delay

			@frame += 1

			fx = @frame % 5 # frames_per_row
			fy = @frame / 5

			# Refresh
			
			self.src_rect = Rect.new(fx*width,fy*height,width,height)


		end

	end

end"a
class SpriteGroup

	attr_reader :sprites

	def initialize
		@sprites = [] # [spr,ox,oy] -- maybe add opacity offset
		@opacity = 255
		@x = 0
		@y = 0
	end

	def update
		@sprites.each{ |s| s[0].update }
	end

	def add(spr,ox=0,oy=0)
		@sprites.push([spr,ox,oy])
	end

	def change(spr,ox,oy)
		@sprites.each{ |s|
			if s[0] == spr
				s[1] = ox
				s[2] = oy
			end
		}
	end

	def move(nx,ny)
		self.x = nx
		self.y = ny
	end

	def x=(v)
		@x = v
		@sprites.each{ |s| s[0].x = v + s[1] }
	end
	def x
		return @x
	end

	def y=(v)
		@y = v
		@sprites.each{ |s| s[0].y = v + s[2] }
	end
	def y
		return @y
	end

	def opacity=(v)
		@opacity = v
		@sprites.each{ |s| s[0].opacity = v }
	end
	def opacity
		return @opacity
	end

	def hide
		self.opacity = 0
	end

	def show
		self.opacity = 255
	end

end"#==============================================================================
# Tabs
#==============================================================================

# Horizontal list of sorts
# Image based only
# Drawn to single sprite

class Tabs < Sprite

  SPACING = 5

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

  	#@parent = nil
    @names = []
  	@gfx = []
    @gfx_on = []

    @ranges = []

  	@idx = 0

  end

  def push(name)
    @names.push(name)
    @gfx.push($cache.menu_tab(name))
    @gfx_on.push($cache.menu_tab(name+"-on"))
    refresh
  end

  def dispose
  	
  end

  def refresh

    # Calc width
    width = @gfx.inject(0){ |t,b| t += b.width + SPACING } - SPACING
    height = @gfx[0].height#@gfx.max_by{ |b| b.height }

    self.bitmap = Bitmap.new(width,height)

    # Draw the tabs
    cx = 0
    idx = 0
    @gfx.each{ |b|
      src = b
      src = @gfx_on[idx] if idx == @idx
      self.bitmap.blt(cx,0,src,src.rect)
      cx += b.width + SPACING
      idx += 1
    }

  end

  def update

  	# Check inputs and that
  	if $input.right?
      @idx += 1
      refresh      
  	end

  	if $input.left? #&& @dynamo.done?
      @idx -= 1
      refresh  
  	end

    pos = $mouse.position

    # Check mouseover
    # @sprites.each_index{ |i|
      
    # }

  end

 end"G#==============================================================================
# ** Camera Functions
#==============================================================================

def camera(e)
	$map.camera_to(gev(e))
end

def camera_xy(x,y)
	$map.camera_xy(x,y)
end

def scenecam()

end

def camspeed

end"X#==============================================================================
# ** Common Functions
#==============================================================================

def plr
	return $player
end

def me
	return $map.interpreter.event_id
end

def this
	return $map.events[me]
end

def dummy
	# return a dummy event that can be screwed around
end

def gid(str)

	# empty means eid

	# If already a number send it
	if str.kind_of?(Integer)
		return str
	end

end

def gev(str)

	if str.kind_of?(Integer)
		return $map.events[str]
	end

	if str.include?(',')

			coords = str.split(",")
			# Get by coords
			return $map.event_at(coords[0].to_i,coords[1].to_i)

	end

	case str

		when $player
			return $player

		when this
			return str

		when nil
			return this

		when 'up'
			return $map.event_at(this.x,this.y-1) # || dummy
		when 'down'
			return $map.event_at(this.x,this.y+1)
		when 'left'
			return $map.event_at(this.x-1,this.y)
		when 'right'
			return $map.event_at(this.x+1,this.y)
		when 'under'
			return $map.lowest_event_at(this.x,this.y)
		when 'facing'
			return $map.event_at(this.x,this.y-1) if $player.direction == 8
			return $map.event_at(this.x,this.y+1) if $player.direction == 2
			return $map.event_at(this.x-1,this.y) if $player.direction == 4
			return $map.event_at(this.x+1,this.y) if $player.direction == 6

		
		else

			# Check if name of event
			ev = $map.event_by_name(str)
			return ev if !ev.nil?

		end

	# Return some sort of dummy event
	log_info(str)
	log_err("BIGPROBLEMS")

end
"î#==============================================================================
# ** Event Functions
#==============================================================================

# Jumpings
def jump(e,x,y)
	gev(e).jump(x,y)
end

def jump_xy(e,x,y)
	ev = gev(e)
	ev.jump(x-ev.x,y-ev.y)
end

def jump_to(e,t)
	ev = gev(e)
	target = gev(t)
	ev.jump(target.x-ev.x,target.y-ev.y)
end

# Opacity
def hide(e)
	gev(e).opacity = 0
end
def unhide(e)
	gev(e).opacity = 255
end"½#==============================================================================
# ** General Functions
#==============================================================================

def text()

end

def w(f=5)
	$map.interpreter.wait_count = f
end

def fadeout
	$scene.overlay.do(to("opacity",255,7))
end

def fadein
	$scene.overlay.do(to("opacity",0,7))
end

def fade(ev)
	log_info(ev)
	gev(ev).do(to("opacity",0,2))
end"ë#==============================================================================
# ** Item Functions
#==============================================================================

def gold(amount)
	$party.add_gold(amount)
	# SHOW TEXT
end

def gold_s(amount)
	$party.add_gold(amount)
end

def ungold(amount)
	$party.lose_gold(amount)
end

def gold?(amount)
	return $party.has_gold?(amount)
end


def item(id,number=1)
	$party.add_item(id,number)
	# Show the text
end

def item_s(id,number=1)
	$party.add_item(id,number)
end

def unitem(id,number=1)
	$party.lose_item(id,number)
end

def item?(id,number=1)
	$party.has_item?(id,number)
end

def all_items
	$data.items.each{ |i|
		item(i.id,99)
	}
end

"k#==============================================================================
# ** Item Functions
#==============================================================================

def item(id,number=1)
	$party.add_item(id,number)
	# Show the text
end

def item_s(id,number=1)

end

def unitem(id,number=1)

end

def item?(id,number=1)

end

"ÿ#==============================================================================
# ** Progress Functions
#==============================================================================

# Quests
def quest(id) 
	$progress.add_quest(id) 
	# Pop up a text
end

def quest_s(id)

end

def unquest(id)
	$progress.end_quest(id)
	# show quest complete
end

def quest?(id)
	return active?(id) || complete?(id)
end

def active?(id)
	return $progress.quest_active?(id)
end

def complete?(id)
	return $progress.quest_complete?(id)
end


# Progress
def progress(id) $progress.progress(id) end
def progress?(id) return $progress.progress?(id) end

def before?(id) return $progress.before?(id) end
def beyond?(id) return $progress.beyond?(id) end"0#==============================================================================
# ** Route Functions
#==============================================================================

def wfc
	$map.interpreter.command_210
end

def td(e) gev(e).turn_down end
def tl(e) gev(e).turn_left end
def tr(e) gev(e).turn_right end
def tu(e) gev(e).turn_up end

def path(ev,tx,ty)

	char = gev(ev)

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	x = 0
	y = 0
	sx = sy = 0

	sx = char.x
	sy = char.y
	x = char.x
	y = char.y

	result = char.setup_map(sx,sy,tx,ty)

	if !result[0]
		log_err("CANNOT FIND PATH")
		return
	end
	map = result[1]
	map[sx,sy] = result[2] if result[2] != nil

	# Now step through the path building cmds
	step = map[x,y] 
	while step != 1

	     if map[x+1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(3))
	     	x+=1
	     end
	     if map[x,y+1] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(1))
	     	y+=1
	     end
	     if map[x-1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(2))
	     	x-=1
	     end
	     if map[x,y-1] == step - 1 and step != 0
			route.list.push(RPG::MoveCommand.new(4))
			y -= 1
	     end

	     step = map[x,y] 

	end		

	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)

end

def route(ev,move)

	char = gev(ev)

	data = move.split(',')

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	data.each{ |step|

		params = []

		# build params split off step
		if step.include?("-")
			dta = step.split("-")
			step = dta[0]
			params.push(dta[1].to_i) if dta.count > 1
			params.push(dta[2].to_i) if dta.count > 2
			params.push(dta[3].to_i) if dta.count > 3
		end

		case step

			when 'd'
				route.list.push(RPG::MoveCommand.new(1))
			when 'l'
				route.list.push(RPG::MoveCommand.new(2))
			when 'r'
				route.list.push(RPG::MoveCommand.new(3))
			when 'u'
				route.list.push(RPG::MoveCommand.new(4))

			when 'td'
				route.list.push(RPG::MoveCommand.new(16))
			when 'tl'
				route.list.push(RPG::MoveCommand.new(17))
			when 'tr'
				route.list.push(RPG::MoveCommand.new(18))
			when 'tu'
				route.list.push(RPG::MoveCommand.new(19))


			when 'walk'
				route.list.push(RPG::MoveCommand.new(31))
			when 'unwalk'
				route.list.push(RPG::MoveCommand.new(32))

			when 'step'
				route.list.push(RPG::MoveCommand.new(33))
			when 'unstep'
				route.list.push(RPG::MoveCommand.new(34))

			when 'fix'
				route.list.push(RPG::MoveCommand.new(35))
			when 'unfix'
				route.list.push(RPG::MoveCommand.new(36))

			when 'thr', 'through'
				route.list.push(RPG::MoveCommand.new(37))
			when 'unthr', 'unthrough'
				route.list.push(RPG::MoveCommand.new(38))	


			when 'w'
				route.list.push(RPG::MoveCommand.new(15,[params[0]]))

			when '180'
				route.list.push(RPG::MoveCommand.new(21))
				route.list.push(RPG::MoveCommand.new(15,[5]))
				route.list.push(RPG::MoveCommand.new(21))

			when 'j'
				route.list.push(RPG::MoveCommand.new(14,[0,0]))


		end

	}

	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)
	#$map.interpreter.command_210

end
"8#==============================================================================
# ** State Functions
#==============================================================================

# Flag shorthands
def flag(id) $state.flag(id) end
def unflag(id) $state.unflag(id) end
def flag?(id) return $state.flag?(id) end

# Var shorthands
def var(id,a=1) $state.var(id,a) end
def unvar(id,a=1) $state.var(id,a) end
def var?(id,a) return $state.var?(id,a) end

# State shortands
def state(e,s) 
	$state.state(gid(e),s)
end
def unstate(e,s)
	$state.unstate(gid(e),s)
end
def state?(e,s)
	return $state.state?(gid(e),s)
end

# Misc shorthands
def loc(e) gev(e).saveloc end

def erase(e) gev(e).erase end
def delete(e) gev(e).delete end
def disable(e) gev(e).disable end

def enable(e) gev(e).enable end
"


def transfer(map,room)

	# Find the map

	# Find the event of the room

	# Do the transfer

end

def transfer_in

	# Get name of transfer
	room = $map.event_at($player.x,$player.y).name

	# Find child map
	map = find_child_id($map.id,"Indoors")

	# Do the transfer
	$player.transfer_to(map,room)

end

def transfer_up

	# Get name of transfer
	room = $map.event_at($player.x,$player.y).name

	# Find child map
	map = find_parent_id($map.id)

	# Do the transfer
	$player.transfer_to(map,room)

end

def find_parent_id(map_id)
	return $data.mapinfos[map_id].parent_id
end

def find_child_id(parent_id,name)

	$data.mapinfos.each{ |k,map|
		next if map.name != name
		next if map.parent_id != parent_id
		return k
	}

	return 0

 end"ë
# Update self perhamps? Disregard else
# Uses $battle and that's it

# Handle all inputs?

class BattleHud

	def initialize(vp)

		# Bottom bar
		@chars = []
		idx = 0
		$party.active.each{ |char|
			char = CharView.new(vp,$party.actor_by_id(char),idx)
			char.x = 5 + (idx * 158)
			char.y = 340
			@chars.push(char)
			idx += 1
		}


		# Help box
		@help_box = Box.new(vp)
		@help_box.skin = $cache.menu_common("skin-plain")
    	@help_box.wallpaper = $cache.menu_wallpaper("diamonds")
		@help_box.resize(300,50)
		@help_box.move(166,8)

	    @help_text = Sprite.new(vp)
	    @help_text.bitmap = Bitmap.new(300,50)
	    @help_text.bitmap.font = $fonts.message
	    @help_text.bitmap.draw_text(0,0,300,50,"Shadow - Gain Darkness",1)
		@help_text.move(166,9)

	end

	def set_help(text)

		@help_text.bitmap.clear
		@help_text.bitmap.draw_text(0,0,300,50,text,1)

	end
	
	def update

		@chars.each{ |c|
			c.update
		}

		@help_box.update

	end

end"Ö

class Popper < Sprite

	attr_accessor :value

	def initialize(vp)
		super(vp)

		@value = 0
		@old_value = 0

		self.bitmap = Bitmap.new(200,50)
		self.bitmap.font = $fonts.namebox

		refresh

	end

	def update

		if @value != @old_value
			refresh
		end

	end

	def done?
		return self.opacity == 0
	end

	def refresh

		# Draw the value out!
		self.bitmap.clear
		self.bitmap.draw_text(0,0,200,50,@value.to_i.to_s,2)

	end

end"x
class ActorCmd

	def initialize(vp)

		@vp = vp

		@icons = []
		#@text = Sprite.new(@vp)

		@idx = 0

	end

	def setup(battler)

		close

		@battler = battler

		@icons.each{ |i| i.dispose }
		@icons = []

		# Read the categories for this guy
		@battler.actions.each{ |action|
			# Add an icon?
			spr = Sprite.new(@vp)
			spr.bitmap = $cache.menu("Battlehud/Commands/icon")
			@icons.push(spr)
		}



		# Position the things
		reposition

		select

		# Prep the text
		#@text.bitmap = Cache.menu("Battle/text")
		#@text.center(battler.ev.screen_x,battler.ev.screen_y + 24)

	end

	def close
		@icons.each{ |i|
			$tweens.clear(i)
		}
		@icons.each{ |i| i.dispose }
		#@text.bitmap = nil
		@icons = []
		@battler = nil
	end

	def get_action
		return @battler.actions[@idx]
	end

	def reposition
		sx = @battler.ev.screen_x
		sy = @battler.ev.screen_y-50

		if @icons.count == 3
			@icons[0].center(sx-36,sy-16)
			@icons[1].center(sx,sy-25)
			@icons[2].center(sx+36,sy-16)
		end

		if @icons.count == 4
			@icons[0].center(sx-48,sy-16)
			@icons[1].center(sx-18,sy-25)
			@icons[2].center(sx+18,sy-25)
			@icons[3].center(sx+48,sy-16)
		end


	end

	def select
		@icons.each{ |i|
			$tweens.clear(i)
		}
		reposition
		seq = sequence(go("y",-8,250,:quad_in_out),go("y",8,250,:cubic_in_out))
		@icons[@idx].do(repeat(seq))
	end

	def update

		return if @battler.nil?

		# Left and right to change
		if $input.right?
			@idx += 1 if @idx < @icons.count-1
			$scene.hud.set_help(@battler.actions[@idx])
			select
		end

		if $input.left?
			@idx -= 1 if @idx > 0
			$scene.hud.set_help(@battler.actions[@idx])
			select
		end

		pos = $mouse.position
		@icons.each{ |i|
			if i.within?(pos[0],pos[1])
				@idx = @icons.index(i)
				$scene.hud.set_help(@battler.actions[@idx])
			end
		}

	end

end"J
# Actor view, show portrait, hp etc

class CharView < SpriteGroup

	def initialize(vp,char,id)

		super()

		@box = Box.new(vp)
		@box.skin = $cache.menu_common("skin-plain")
    	@box.wallpaper = $cache.menu_wallpaper("back2")
		@box.resize(153,135)
		add(@box)   

		@port = Sprite.new(vp)
		@port.bitmap = $cache.menu_char("boy")
		add(@port,34,-20)

		@shadow = Sprite.new(vp)
		@shadow.bitmap = $cache.menu_char("battlehud-shadow")
		add(@shadow,6,74)

		@xform = Sprite.new(vp)
		@xform.bitmap = $cache.menu_char("Transforms/frog") if rand(10) > 3
		add(@xform,15,65)



		# Health
		#bars

		@hp_bar = Bar.new(vp,110,8)
		add(@hp_bar,11,118)

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200
		add(@hp_label,12,110)

		@mp_bar = Bar.new(vp,110,8)
		add(@mp_bar,11,100)

		@mp_label = Sprite.new(vp)
		@mp_label.bitmap = $cache.menu_char("label-mp")
		@mp_label.opacity = 200
		add(@mp_label,12,92)

	end

	def update

		@box.update
		@hp_bar.update
		@mp_bar.update

	end

end"
class SkillCmd

	def initialize(vp)

		@icons = []
		
		@text = Sprite.new
		#@text.bitmap = $cache.menu("battle/text.png")

	end

end"e
class TargetCmd

	attr_reader :active

	def initialize(vp)

		@vp = vp

		@arrow = Sprite.new(@vp)
		@arrow.bitmap = $cache.menu("BattleHud/target")
		@arrow.hide

		@targets_sy = nil
		@targets_sx = nil
		@targets = nil

		@active = nil

		@idx = 0

	end

	def setup(targets)

		@arrow.show

		@targets = targets

		# Sort targets by y pos
		# Maybe x sort for left and right?
		@targets_sy = targets.sort_by{ |t| t.ev.screen_y }
		@targets_sx = targets.sort_by{ |t| t.ev.screen_x }

		# Arrow pos
		@active = targets[0]
		point_at(targets[0])

	end

	def point_at(char)
		@arrow.center(char.ev.screen_x,char.ev.screen_y)
	end

	def close
		@arrow.hide
	end

	def update

		# Left and right to change
		if $input.right?


			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx += 1
			if idx >= @targets_sx.count
			  idx -=1
			end
			@active = @targets_sx[idx]

			point_at(@active)
			
		end

		if $input.left?
			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			end
			@active = @targets_sx[idx]

			point_at(@active)
		end



		# Left and right to change
		if $input.down?	
			
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx += 1
			if idx >= @targets_sy.count
			  idx -=1
			end
			@active = @targets_sy[idx]

			point_at(@active)
			
		end

		if $input.up?
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			end
			@active = @targets_sy[idx]

			point_at(@active)
		end

		pos = $mouse.position
		@targets.each{ |i|
			next if pos[0] < i.ev.screen_x - 20
			next if pos[0] > i.ev.screen_x + 20
			next if pos[1] < i.ev.screen_y - 64
			next if pos[1] > i.ev.screen_y
			@active = i
			point_at(@active)
		}

	end

end
"Í#==============================================================================
# Ui_Screen
#==============================================================================

class Ui_Screen

	attr_reader :message
  
	def initialize(vp)

		@vp = vp
		
		@message = Ui_Message.new(vp)

		@bar = Ui_Bar.new(vp)
		#@info = Ui_Info.new(vp)

		@item = nil

	end

	def update
		@message.update
		@bar.update
		#@info.update

		if @item
			@item.update 
			if $input.action?
				@item.dispose
				@item = nil
			end
		end
	end

	def open_item(i)
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move(40,40)
	end

    def busy?() 
    	return @message.busy? || @item
    end

end"ç#==============================================================================
# Ui_Bar
#==============================================================================

class Ui_Bar < SpriteGroup

	def initialize(vp)
		super()

		@base = Sprite.new(vp)
		@base.bitmap = Bitmap.new(640,32)
		@base.bitmap.fill_rand
		add(@base)

		# Buttons
		cx = 4

		@quit = Button.new(vp)
		@quit.bitmap = $cache.icon("misc/quit")
		@quit.press = Proc.new{ log_info("QUIT BUTTON") }
		add(@quit,cx,4)

		cx += 24 + 4

		@char = Button.new(vp)
		@char.bitmap = $cache.icon("misc/char")
		add(@char,cx,4)

		cx += 24 + 4

		@save = Button.new(vp)
		@save.bitmap = $cache.icon("misc/keys")
		add(@save,cx,4)

		cx += 24 + 4

		@journal = Button.new(vp)
		@journal.bitmap = $cache.icon("misc/journal")
		add(@journal,cx,4)

		cx += 24 + 4

		@items = Button.new(vp)
		@items.bitmap = $cache.icon("misc/coins")
		add(@items,cx,4)

		cx += 24 + 4

		@settings = Button.new(vp)
		@settings.bitmap = $cache.icon("misc/settings")
		add(@settings,cx,4)

		cx += 24 + 4

		@help = Button.new(vp)
		@help.bitmap = $cache.icon("misc/unknown")
		add(@help,cx,4)

		move(0,480-32)
	end

	def update
		super()
	end

end"â#==============================================================================
# Ui_Info
#==============================================================================

class Ui_Info

	def initialize(vp)

	end

end"96#==============================================================================
# Ui_Message
#==============================================================================

class Ui_Message

  # Consts
  MIN_WIDTH = 200
  MAX_WIDTH = 350
  TAB_WIDTH = 35

  MIN_HEIGHT_FACE = 90

  SPACING = 7
  LINE_HEIGHT = 27
  PADDING_X = 22
  PADDING_Y = 16

  SPEED_1 = 0
  SPEED_2 = 1
  SPEED_3 = 2
  SPEED_4 = 3
  SPEED_5 = 4
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize(vp)

    @vp = vp

    # Create the pieces but do nothing besides
    @state = :idle

    # Hold on to the convo
    @text = ""

    # This line data
    @name = ''



    @scratch = Bitmap.new(400,50)

    @lines = []

    # Settings
    @color = nil

    # Text display
    @text_delay = SPEED_3
    @wait_frames = 0
    @next_char = 0

    @cx = 0
    @cy = 0
    
    @line_idx = nil
    @word_idx = nil
    @char_idx = nil

    @width = 0
    @height = 0

    @speakr = nil

    @sprites = SpriteGroup.new

    @box = Box.new(vp)
    @box.skin = $cache.menu_common("skin")
    @box.wallpaper = $cache.menu_wallpaper("diamonds")

    # Setup sprites    
    @textbox = Sprite.new(vp)
    @textbox.z += 50

    @namebox = Sprite.new(vp)
    @namebox.bitmap = Bitmap.new(220,40)
    @namebox.bitmap.hskin($cache.menu("Common/namebox"))

    @nametext = Sprite.new(vp)
    @nametext.bitmap = Bitmap.new(220,40)
    @nametext.bitmap.font = $fonts.namebox
    @nametext.bitmap.draw_text(0,0,220,40,"texter")

    @next = Sprite.new(vp)
    @next.bitmap = $cache.menu("Common/next")
    
    @face = Sprite.new(vp)
    @face.z += 10
    
    @tail = Sprite.new(vp)
    @tail.bitmap = $cache.menu("Common/tail")


    # Group system
    @sprites.add(@box)
    @sprites.add(@textbox)
    @sprites.add(@namebox)
    @sprites.add(@nametext)
    @sprites.add(@next)
    @sprites.add(@face)
    @sprites.add(@tail)

    @sprites.opacity = 0


    @sparks = []

    # Draw to textbox
    @text_bmp = nil

    # merge text_bmp into textbox, use a sprite for the final char
    # could do better effects maybe and use tweens
    
  end
  
  #--------------------------------------------------------------------------
  # Frame Update
  #--------------------------------------------------------------------------
  def update

    @speaker = plr

    # Put over speaker
    @sprites.x = @speaker.screen_x - @width/2 - 10
    @sprites.y = @speaker.screen_y - @height - 70

    @box.update
    @sparks.each{ |s| s.update }
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end      
    
    # Skip to end of this text
    # if $input.action?
    #   @skip_all = true
    # end

    case @state

      when :closed
        #nothing

      when :opening
        @state = :texting if self.zoom_y == 1.0

      when :closing
        @state = :idle

      when :texting
        @next_char -= 1
        if @next_char <= 0 || $keyboard.state?(VK_ENTER)
          #log_err "DOING"
          update_message
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
          update_message if $keyboard.state?(VK_ENTER) && @state == :texting
        end
        redraw
        
      when :waiting
        update_waiting

        # Choices in here too

      when :pausing
        check_input_next
      when :done
        check_input_done
        
    end

    # skipping
    # while @state == :texting && $input.action?
    #   @next_char > 0 ? @next_char -= 1 : update_message
    # end

  end
  
  #--------------------------------------------------------------------------
  # Show Convo
  #--------------------------------------------------------------------------
  def start(text, choices = nil)

    @scratch.font = $fonts.message

    # Clear out the previous word
    @word = nil

    text_data = text.split(":")

    # Find speaker name, use to get face / event
    if text_data.count > 1
      speaker = text_data[0]
      content = text_data[1]
    else
      speaker = ""
      content = text_data[0]
    end

    # TODO - add actor name to this check
    # Get face if exists
    if $data.actors.keys.include?(speaker[0..2])
      @face.bitmap = $cache.menu_face(speaker)
    else
      @face.bitmap = nil
    end

    @nametext.bitmap.clear
    @namebox.bitmap.clear

    if speaker != ""
      @namebox.bitmap.hskin($cache.menu("Common/namebox"))
      @nametext.bitmap.draw_text(0,0,220,40,speaker)
    end

    # Prepare the words to be written
    @lines = split_text(content)    

    # Now of the height? How many lines are there?
    @width = max_width
    @height = @lines.count * (LINE_HEIGHT)

    @height = MIN_HEIGHT_FACE if @face.bitmap

    # Add padding
    @width += PADDING_X * 2
    @height += PADDING_Y * 2

    if @face.bitmap
      @width += @face.width 
      fx = -10 + max_width + PADDING_X + PADDING_X
      fy = 7 + @height - @face.height - PADDING_Y
      @sprites.change(@face,fx,fy)
    end

    # Prepare the sprites  
    @box.resize(@width,@height)

    #@textbox.move(@box.x,@box.y)
    @textbox.bitmap = Bitmap.new(@width,@height)

    # Can this be cut?
    @text_bmp = Bitmap.new(@width,@height)

    @scratch.font = $fonts.message
    @text_bmp.font = $fonts.message
    @textbox.bitmap.font = $fonts.message

    # COMBINE FONT AND SIZE
    @sprites.change(@tail,@width/2,@height)
    @sprites.change(@next,@width/2,@height-20)

    @sprites.change(@namebox,20,-@namebox.height)
    @sprites.change(@nametext,40,-@namebox.height+5)



    @sprites.do(go("opacity",255,500,:quad_in_out))
    #@sprites.do(go("y",-25,500,:quad_in_out))

    @line_idx = 0
    @word_idx = -1

    @cx = PADDING_X
    @cy = PADDING_Y

    # Start text
    @state = :texting

        
  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    next_word if @word == nil || @char_idx > @word.length
        
    # if not texting then don't go
    return unless @state == :texting
            
    # Add the next character to the final word
    @char_idx += 1

    # Play a lovely character sound
    #sound(:text_char) if $settings.value('text_sound') 
    
    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    #(@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  def redraw

    @textbox.bitmap.clear    
    @textbox.bitmap.blt(0,0,@text_bmp,@text_bmp.rect)

    return if @word == nil

    @scratch.font.bold = @word.include?("*")
    @scratch.font.italic = @word.include?("^")

    @textbox.bitmap.font.bold = @word.include?("*")
    @textbox.bitmap.font.italic = @word.include?("^")

    #txt = @word[0..@char_idx-1]
    txt = @word.delete('*^')[0..@char_idx-1]
    size = @scratch.text_size(txt)

    @textbox.bitmap.draw_text(@cx,@cy,300,LINE_HEIGHT,txt)
    # Half draw the final
    return if @char_idx >= @word.length

    # Offset the y here to animate
    #r = rand(4)
    r = 0
    @textbox.bitmap.draw_text(@cx+size.width,@cy+r,100,LINE_HEIGHT,@word.delete('*^').split('')[@char_idx])


    # Spawn spark
    sprk = Spark.new("magic",@vp)
    
    x = @sprites.x + @cx+size.width
    y = @sprites.y + @cy
    sprk.center(x+6,y+16)
    sprk.blend_type = 1
    @sparks.push(sprk)


  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @word = nil
    if @line_idx >= @lines.count
      @state = :done
    else
      @word_idx = 0
      @cy += LINE_HEIGHT
      @cx = PADDING_X
    end
  end

    #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    # blit last word onto the main bmp
    if @word != nil

      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')

      txt = @word.delete('*^')[0..@char_idx]


      @text_bmp.draw_text(@cx,@cy,300,LINE_HEIGHT,txt)

      # Step cursor
      @cx += word_width(@word)

    end

    @word_idx += 1
    @char_idx = 0
    
    if @word_idx >= @lines[@line_idx].count
      next_line
      return if @line_idx >= @lines.count
    end

    @word = @lines[@line_idx][@word_idx]

    return if @word == nil

    # CHECK FOR COMMANDS
    if @word.include?('$')
      cmd = @word.split(".")
      wrd = cmd[0]

      # check for command words
      case wrd
      
        when "$n" # New line
          next_line
          
        when "$w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
                    
        when "$sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
                    
        when "$s" # play sound
          #log_err("TRYPLAYIT")
          #Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "$m"
          
          case cmd[1]
            when 'stop'
              Audio.bgm_stop            
            when 'fade'
              Audio.bgm_fade(750)                   
            else
              Audio.bgm_play(cmd[1])            
          end
          
        when "$nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "$end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      @word = nil
      next_word

    end

  end  

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all #|| Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if $input.action? || $input.click?
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @textbox.bitmap.clear
      @sprites.opacity = 0
      #@sprites.do(go("opacity",-255,300,:quad_in_out))
    end
  end

  #--------------------------------------------------------------------------
  # Calculate size
  #--------------------------------------------------------------------------
  def word_width(word)
      return TAB_WIDTH if word == "$t"
      return 0 if word.include?("$")
      @scratch.font.bold = word.include?('*')
      @scratch.font.italic = word.include?('^')
      return @scratch.text_size(word.delete('*^')).width + SPACING
  end

  def max_width
    max = 0
    @lines.each{ |line|
      width = line.inject(0) { |t,w| t + word_width(w) }
      max = width if width > max
    }
    return max - SPACING
  end

  def split_text(text)

    # Split all text into lines
    # Then calc widths and that

    total_width = text.split(" ").inject(0) { |t, w| t + word_width(w) }

    # use total width to split into lines

    # If there is a forced newline, there will be no autosizing
    if text.include?("$n")
      return text.split("$n").map { |i| i = i.split(" ") }  
    end

    # If less than split width, just one line
    if total_width < MIN_WIDTH
      return [text.split(" ")]
    end

    # If width is less than max * 2, we are splitting at the first word after half point
    if total_width < MAX_WIDTH * 2
      limit = total_width / 2
      cursor = 0
      lines = [[]]
      text.split(" ").each{ |word|
        lines[-1].push(word)
        cursor += word_width(word)
        if cursor >= limit
          lines.push([])
          cursor = 0
        end
      }
      return lines
    end

    # Else we are autosizing max width
    lines = [[]]
    limit = MAX_WIDTH
    cursor = 0
    text.split(" ").each{ |word|
      cursor += word_width(word)
      if cursor > limit
        cursor = 0
        lines.push([])
      end
      lines[-1].push(word)
    }
    return lines

  end

  #--------------------------------------------------------------------------
  # Misc
  #--------------------------------------------------------------------------
  def clear() end
  def busy?() return @state != :idle end

end"@


class Ui_Popper

	def initialize(vp)

	end

end"@#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Items

	attr_accessor :closed

	def initialize(vp)

		@closed = false

		@title = Page_Title.new(vp)
		@title.change('inventory')

		@tabs = nil

		@menu = List_Common.new(vp)
		@menu.list.select = Proc.new{ |option| self.select(option) }
		@menu.list.cancel = Proc.new{ |option| self.cancel(option) }
		@menu.list.change = Proc.new{ |option| self.change(option) }

		data = []
		data.push('covey')
		data.push('covey')
		data.push('covey')

		@menu.list.setup(data)


		@info = Info_Box.new(vp)

		@port = Port_Full.new(vp)

		@item_box = Item_Box.new(vp)
		@item_box.center(462,130)

	end

	def dispose
		@menu.dispose
	end

	def update
		@menu.update
		@info.update
	end

	def close
		@closed = true
		@menu.hide
		@title.hide
		@info.hide
		@port.hide
	end

	def open
		@menu.show
		@title.show
		@info.show
		@port.show
		@menu.list.refresh
	end

	def change(option)
		@info.title.text = option
		@item_box.item(option)
		@item_box.center(462,130+@menu.list.page_idx*@menu.list.item_height)
	end

	def select(option)	
		
	end

	def cancel(option)
		$scene.close_sub
	end

end"#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Journal

	attr_accessor :closed

	def initialize(vp)

		@closed = false

		@title = Page_Title.new(vp)
		@title.change('journal')

		@tabs = Tabs.new(vp)
		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")
		@tabs.move(120,78)

		@menu = List_Common.new(vp)
		@menu.list.select = Proc.new{ |option| self.select(option) }
		@menu.list.cancel = Proc.new{ |option| self.cancel(option) }
		@menu.list.change = Proc.new{ |option| self.change(option) }

		@menu.list.type = :quest

		data = []
		data.push('ch2-to-ferry')
		data.push('ch2-to-briar')
		data.push('ch2-return-ferry')

		@menu.list.setup(data)

		@info = Info_Box.new(vp)

		# Right side journal
		@window = Box.new(vp,300,360)
    	@window.skin = $cache.menu_common("skin-dry")
    	@window.wallpaper = $cache.menu_wallpaper("journal_page_line")
    	#@window.color = Color.new(47,45,41)
    	@window.move(320,110)

    	# Quest Name
    	@title = Label.new(vp)
    	@title.fixed_width = 250
    	@title.font = $fonts.page_ttl
    	@title.text = "Board the Ferry"
    	@title.move(340,127)

    	@desc = Area.new(vp)
    	@desc.fixed_width =  400
    	@desc.font = $fonts.page_text
    	@desc.text = "Rescue them guys in the briar woods"
    	@desc.move(340,180)

    	# Requirements


    	# Zone
    	@zone = Sprite.new(vp)
    	@zone.bitmap = $cache.menu("Zones/whisper")
    	@zone.move(340,352)



	end

	def dispose
		@menu.dispose
	end

	def update
		@tabs.update
		@menu.update
		@info.update
	end

	def close
		@closed = true
		@menu.hide
		@title.hide
		@info.hide
	end

	def open
		@menu.show
		@title.show
		@info.show
		@menu.list.refresh
	end

	def change(option)
		@info.title.text = option
	end

	def select(option)	
		
	end

	def cancel(option)
		$scene.close_sub
	end

end"Æ#==============================================================================
# ** Mnu_Main
#==============================================================================

class Mnu_Main # MAYBE SPRITEGROUP FOR EASY MOVING OF ALL

	def initialize(vp)

		@vp = vp

		# Character Boxes
		# @char_boxes = []
		#@char_boxes.push(CHARBOX.new)

		@charbox = Char_Box_Large.new(vp)
		@charbox.move(196,25)

		@charbox2 = Char_Box_Large.new(vp)
		@charbox2.move(416,25)

		@charbox3 = Char_Box_Large.new(vp)
		@charbox3.move(196,201)

		@charbox4 = Char_Box_Large.new(vp)
		@charbox4.move(416,201)

		@charbox5 = Char_Box_Small.new(vp)
		@charbox5.move(196,376)

		@charbox6 = Char_Box_Small.new(vp)
		@charbox6.move(343,376)

		@charbox7 = Char_Box_Small.new(vp)
		@charbox7.move(490,376)


		data = []
		data.push('Items')
		data.push('Journal')
		data.push('Party')
		data.push('Equip')
		data.push('Skills')
		data.push('Profiles')
		data.push('Options')
		data.push('Quit')
		#data.push(['Load','items/map'])
		#data.push(['Save','items/map'])

		@data = data

		cy = 25

		@buttons = []
		@texts = []
		@icons = []

		data.each{ |item|

			btn = Box.new(vp,168,50)
	     	btn.skin = $cache.menu_common("skin-plain")
	     	btn.wallpaper = $cache.menu_wallpaper("diamonds")
	     	btn.move(10,cy)
	     	@buttons.push(btn)

	     	text = Label.new(vp)
	     	text.font = $fonts.list
	     	text.text = item
	     	text.move(90,cy+10)
	     	@texts.push(text)

	     	icon = Sprite.new(vp)
	     	icon.bitmap = $cache.menu("Icons/#{['journal','inventory'].sample}")
	     	icon.move(-10+28,cy-8)
	     	icon.src_rect = Rect.new(32,0,120,50)
	     	icon.z += 50
	     	@icons.push(icon)

	     	cy += 55

     	}

     	@glow = Sprite.new(vp)
     	@glow.bitmap = $cache.menu_common("box-glow")
     	@glow.do(pingpong("opacity",-100,300,:quad_in_out))

     	@idx = 0
     	@sr = 0

     	setidx(0)

     	

	end

	def dispose

		@charbox.dispose
		@charbox2.dispose
		@charbox3.dispose
		@charbox4.dispose

		@glow.dispose
		@icons.each{ |i| i.dispose }
		@texts.each{ |i| i.dispose }
		@buttons.each{ |i| i.dispose }
	end

	def update
		#@menu.update

		if $input.action?
			select(@data[@idx])
		end

		if $input.down?
			@idx += 1
			setidx(@idx)
		end
		if $input.up?
			@idx -= 1
			setidx(@idx)
		end
	end

	def open

		@charbox.show
		@charbox2.show
		@charbox3.show
		@charbox4.show


		@glow.show
		@icons.each{ |i| i.show }
		@texts.each{ |i| i.show }
		@buttons.each{ |i| i.show }
	end

	def close

		@charbox.hide
		@charbox2.hide
		@charbox3.hide
		@charbox4.hide

		@glow.hide
		@icons.each{ |i| i.hide }
		@texts.each{ |i| i.hide }
		@buttons.each{ |i| i.hide }
	end

	def setidx(idx)
		@sr = 0
		idx2 = 0
		@icons.each{ |i|
			i.src_rect = Rect.new(32,0,120,50)
			i.y = 25+(idx2*55)-8
			$tweens.clear(i)
			idx2 += 1
		}
		@icons[idx].do(go("y",-12,250,:quad_in_out))
		self.do(go("srcrecter",12,250,:quad_in_out))

		@glow.move(16,25+(idx*55)+6)

	end

	def srcrecter
		return @sr
	end

	def srcrecter=(y)
		@sr = y
		@icons[@idx].src_rect = Rect.new(32,0,120,50+y)
	end

	def select(option)

		if option == "Items"
			$scene.open_sub(Mnu_Items.new(@vp))
		end
		if option == "Journal"
			$scene.open_sub(Mnu_Journal.new(@vp))
		end
	end

	def cancel(option)
		# save cursor pos for later
		$game.pop_scene
	end

end"¯

class Char_Box_Large < SpriteGroup

	def initialize(vp)

		super()

		@window = Box.new(vp,205,160)
		@window.skin = $cache.menu_common("skin")
		@window.wallpaper = $cache.menu_wallpaper("portback")
		add(@window)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.menu_face("boy")
		@port.src_rect.width = 155
		add(@port,42,-30)

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient")
		@gradient.opacity = 160
		add(@gradient,2,50)




		@mp_bar = Bar.new(vp,180,8)
		add(@mp_bar,11,102)

		@mp_label = Sprite.new(vp)
		@mp_label.bitmap = $cache.menu_char("label-mp")
		@mp_label.opacity = 200
		add(@mp_label,12,94)


		@hp_bar = Bar.new(vp,180,8)
		add(@hp_bar,11,120)

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200
		add(@hp_label,12,112)


		@xp_bar = Bar.new(vp,180,8)
		add(@xp_bar,11,138)

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-rp")
		@xp_label.opacity = 200
		add(@xp_label,12,130)



	end

	def dispose
		@window.dispose
		@gradient.dispose
		@port.dispose
	end

	def setup(char)

	end

end"

class Char_Box_Small < SpriteGroup

	def initialize(vp)

		super()

		@window = Box.new(vp,130,84)
		@window.skin = $cache.menu_common("skin")
		@window.wallpaper = $cache.menu_wallpaper("portback")
		add(@window)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.menu_face_small("boy")
		add(@port,31,-15)

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient-small")
		@gradient.opacity = 160
		add(@gradient,5,30)



		@xp_bar = Bar.new(vp,106,8)
		add(@xp_bar,11,64)

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-rp")
		@xp_label.opacity = 200
		add(@xp_label,12,56)

	end

	def dispose
		@window.dispose
		#@gradient.dispose
		#@port.dispose
	end

	def setup(char)

	end

end"æ
class Info_Box < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@window = Box.new(vp,300,60)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@title = Label.new(vp)
    	@title.fixed_width = 250
    	@title.text = "Active Quests:"
    	add(@title,10,13)
    	
    	move(10,410)

	end

	def update
		@window.update
	end

	def change


	end

end"î
class Item_Box < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		# Resize to whatever is needed
		@window = Box.new(vp,300,120)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@title = Label.new(vp)
    	@title.fixed_width = 250
    	@title.font = $fonts.pop_ttl
    	@title.text = "Active Quests:"
    	add(@title,16,10)

    	@type = Label.new(vp)
    	@type.fixed_width = 250
    	@type.font = $fonts.pop_type
    	@type.align = 0
    	@type.text = "POTION"
    	add(@type,226,13)

    	@desc = Area.new(vp)
    	@desc.font = $fonts.pop_text
    	@desc.text = "Missing Descriptor"
    	add(@desc,16,40)

    	@stat_a = Label.new(vp)
    	@stat_b = Label.new(vp)
    	@stat_c = Label.new(vp)
    	
    	move(0,0)

    	item('unknown')

	end

	def center(x,y)
		move(x-150,y-60)
	end

	def dispose

		self.sprites.each{ |s|
			s[0].dispose
		}

	end

	def update
		@window.update
	end

	def item(id)

		item = $data.items[id]
		log_info(item)

		# Set values
		@title.text = item.name
		@desc.text = item.description
		#@type.text = item.type

	end

	def skill(id)

	end

end"`
class List_Common < SpriteGroup

	attr_reader :list

	def initialize(vp)
		super()

		# Left side window
		@window = Box.new(vp,300,292)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	add(@window)
    	
		# Left side list
		@list = List.new()

		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 35
		add(@list,6,6)


		move(10,110)
		@list.refresh

	end

	def dispose

	end

	def update
		@list.update
	end




	# All the various data that can be shown
	def items(category)

	end

	

end"
class List_Main < SpriteGroup

	attr_accessor :list

	def initialize(vp)
		super()

		# Left side window
		@window = Box.new(vp)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	@window.resize(178,362)
    	add(@window)

		# Left side list
		@list = List.new()
		@list.type = :misc

		# @list.item_width = 156
		# @list.item_height = 42
		#@list.item_space = 43

		@list.item_width = 166
		@list.item_height = 34
		@list.item_space = 35
		

		add(@list,6,6)

		data = []
		data.push(['Items',"items/map"])
		data.push(['Journal','items/map'])
		data.push(['Party','items/map'])
		data.push(['Equip','items/map'])
		data.push(['Skills','items/map'])
		data.push(['Profiles','items/map'])
		data.push(['Options','items/map'])
		data.push(['Quit','items/map'])
		data.push(['Load','items/map'])
		data.push(['Save','items/map'])

		@list.setup(data)

		move(10,490)
		@list.refresh

	end

	def dispose
		@window.dispose
		@list.dispose
	end

	def update
		@list.update
	end

end

def _db(*args)
	DataBox.new(args[0],args[1],args[2],args[3])
end"#

class Page_Tabs



end"


class Page_Title < SpriteGroup

	def initialize(vp)
		super()

		@web = Sprite.new(vp)
		@web.bitmap = $cache.menu_common("webber")
		#@web.opacity = 20
		add(@web,-40,-50)

		@icon = Sprite.new(vp)
		@icon.bitmap = $cache.menu("Icons/journal")
		add(@icon,0,-5)

		@title = Sprite.new(vp)
		@title.bitmap = $cache.menu("Titles/journal")
		add(@title,100,20)

		move(0,0)

	end

	def change(page)
		@icon.bitmap = $cache.menu("Icons/"+page)
		@title.bitmap = $cache.menu("Titles/"+page)
	end

end"#==============================================================================
# ** Part_Char
#==============================================================================

# Could auto choose the right char, but maybe just put as sprite
class Port_Full

	def initialize(vp)

		@boyle = Sprite.new(vp)
		@boyle.bitmap = $cache.menu("tempboyle")
		@boyle.x = 330

	end

	def hide
		@boyle.hide
	end

	def show
		@boyle.show
	end

	def dispose

		@boyle.dispose

	end

	def update

	end

end"ú
#==============================================================================
# ** Game_Battler (part 1)
#==============================================================================

# STATS

class Game_Battler
 
  attr_reader :id
  attr_reader :actions

  attr_accessor :action, :skill_id, :item_id
  attr_accessor :target
  attr_accessor :target_type, :target_idx
  attr_accessor :ev
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    @is_actor = true

    # Current values
    @hp = 0
    @mp = 0

    @restype = nil#data.resource

    # Stats - enemy base and player bonus    
    @hp_init, @mp_init, @atk_init, @def_init = 0, 0, 0, 0
    @hp_rate, @mp_rate, @atk_rate, @def_rate = 0, 0, 0, 0
    @hp_plus,  @mp_plus, @atk_plus, @def_plus = 0, 0, 0, 0

    @xp = 0
    @level = 1

    @equips = {}

    @states = []
    @states_turn = {}

    @skills = []
    @skill_cooldown = {}

    # Skill selection
    @action = 0
    @skill_id = 0

    @target = nil
    @target_type = nil # <-- Scope?
    @target_index = -1

    @ev = nil # Mid battle hold even number for easy access

    @form = nil # <- fox or frog or etc, maybe for battler? turn enemy to frog he shoot water at you? interesting

  end

  def init_actor(id)

    @is_actor = true

    data = $data.actors[id]
    @id = id

    @name = data.name

    # Prepare equipment slots
    data.slots.split(" | ").each{ |s|
      @equips[s] = nil
    }
    
    @actions = data.actions.split(" | ")

    # Add actions as skills, maybe not now, only when checking
    @actions.each{ |a| @skills.push(a) }


  end

  def init_enemy(id)

    @is_actor = false

  end
  
  def is_actor?
    return @is_actor
  end

  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    @sp = maxsp
    for i in @states.clone
      remove_state(i)
    end
  end

  # perhamps cut these things
  def down?
    @hp == 0 
  end
  def attackable?
    return !down?
  end

  def inputable?() restriction <= 1 end
  def movable?() restriction < 4 end  


  # PROBABLY DON'T HAVE THIS HERE
  def slip_damage_effect

    # Set damage
    self.damage = self.maxhp / 20 # 10
    # Dispersion
    if self.damage.abs > 0
      amp = [self.damage.abs * 15 / 100, 1].max
      self.damage += rand(amp+1) + rand(amp+1) - amp
    end
    # Subtract damage from HP
    self.hp -= self.damage
    # End Method
    return true

  end


end
"Q
class Game_Battler

  #--------------------------------------------------------------------------
  # * Stat Calcs
  #--------------------------------------------------------------------------
  def maxhp

  end

  def maxsp

  end

  def str
  	val = @str_init + (@str_rate * @level) + @str_plus
	val += stat_from_equip('str')
	val += stat_from_state('str')
  end

  def atk
    n = base_atk
    for i in @states
      n *= $data_states[i].atk_rate / 100.0
    end
    return Integer(n)
  end

  def def
    n = base_pdef
    for i in @states
      n *= $data_states[i].pdef_rate / 100.0
    end
    return Integer(n)
  end

  #--------------------------------------------------------------------------
  # * Secondary Calculated Stats
  #--------------------------------------------------------------------------
  def eva
    n = base_eva
    for i in @states
      n += $data_states[i].eva
    end
    return n
  end

  def hit
    n = 100
    for i in @states
      n *= $data_states[i].hit_rate / 100.0
    end
    return Integer(n)
  end

end"&
class Game_Battler


  #--------------------------------------------------------------------------
  # * States
  #--------------------------------------------------------------------------

def state?(state_id)
    return @states.include?(state_id)
  end

  def add_state(state_id)
    @states.push(state_id)
  end

  def remove_state(id)
    @states.delete(id)
  end

  #--------------------------------------------------------------------------
  # * Get Restriction
  #--------------------------------------------------------------------------
  def restriction
    restriction_max = 0
    # Get maximum restriction from currently added states
    for i in @states
      if $data_states[i].restriction >= restriction_max
        restriction_max = $data_states[i].restriction
      end
    end
    return restriction_max
  end

  #--------------------------------------------------------------------------
  # â Has Restriction
  #   Determines if battler has a special restriction
  #--------------------------------------------------------------------------
  def has_restriction?(restriction)
    for i in @states
      if $data_states[i].restriction == restriction
        return true
      end
    end
    
    return false
  end

  #--------------------------------------------------------------------------
  # * Determine [Slip Damage] States
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Remove Battle States (called up during end of battle)
  #--------------------------------------------------------------------------
  def remove_states_battle
    for i in @states.clone
      if $data_states[i].battle_only
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Natural Removal of States (called up each turn)
  #--------------------------------------------------------------------------
  def remove_states_auto
    for i in @states_turn.keys.clone
      if @states_turn[i] > 0
        @states_turn[i] -= 1
      elsif rand(100) < $data_states[i].auto_release_prob
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * State Removed by Shock (called up each time physical damage occurs)
  #--------------------------------------------------------------------------
  def remove_states_shock
    for i in @states.clone
      if rand(100) < $data_states[i].shock_release_prob
        remove_state(i)
      end
    end
  end

 end"»class Game_Battler

  def learn(skill)
  	@skills.push(skill)
  end


  def skills_for(action)
    # log_info("SKILLS")
    # log_info(@skills)
    # log_info(action)

    return @skills.select{ |s| 
      #log_info s
      $data.skills[s].id == action || 
      $data.skills[s].book == action
    }
  end

  def choose_action
  	return 'attack'
  end
  

  #--------------------------------------------------------------------------
  # * Determine Usable Skills
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    # If there's not enough SP, the skill cannot be used.
    if $data.skills[skill_id].sp_cost > self.sp
      return false
    end
    
    # If silent, only physical skills can be used
    if $data_skills[skill_id].atk_f == 0 and self.has_restriction?(1)
      return false
    end

    return true
  end

end"È
class Game_Battler

	def stat_from_equip(stat)
		total = 0
		@equips.values.each{ |e|
			
		}
	end

	def change_equip(slot,new_equip)

		if @equips[slot] == nil
			
		end

	end

end"
class Game_Battler

  #--------------------------------------------------------------------------
  # * XP Calcs
  #--------------------------------------------------------------------------
  def exp_percent
    
  end
  
  def next_exp 
     
  end


end"Ì
class Attack_Result

	attr_accessor :target
	
	attr_accessor :damage
	attr_accessor :critical
	attr_accessor :state_add

end

class Attack_Round

	attr_accessor :anim_a
	attr_accessor :anim_b

	attr_accessor :skill

end

class Attack_Plan

	def initialize

		@attacks = []

	end

	def add(attack)
		@attacks.push(attack)
	end

	def next_attack
		return @attacks.shift
	end

	def done?
		return @attacks.empty?
	end

end"É¡#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  
  attr_reader   :x                        # map x-coordinate (logical)
  attr_reader   :y                        # map y-coordinate (logical)
  attr_reader   :real_x                   # map x-coordinate (real * 128) # For precision
  attr_reader   :real_y                   # map y-coordinate (real * 128)
  
  
  # Graphics

  attr_accessor   :character_name           # character file name

  attr_accessor   :opacity                  # opacity level
  
  
  attr_accessor :direction                # direction

  attr_accessor :showdir


  attr_accessor   :pattern                  # pattern
  attr_reader   :move_route_forcing       # forced move route flag
  attr_reader   :through                  # through
  attr_accessor :animation_id             # animation ID
  attr_accessor :transparent              # transparent flag
  attr_accessor :ignore_movement          # ignore movement when finding path
  attr_accessor :step_anime               # stop animation
  
  
  # Custom
  attr_accessor :off_x, :off_y
  
   
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @character_name = ""
    

    @direction = 2
    @showdir = 4
    @lockdir = 0

    @move_angle = 0

    @prev_terrain = 0


    @off_x = 0
    @off_y = 0


    @pattern = 0

    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0

    @move_type = 0
    @move_speed = 3
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0

    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0 #how long has paused for between steps

    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
    @ignore_movement = false

    @opacity = 255
  end
  #--------------------------------------------------------------------------
  # * Determine if Moving
  #--------------------------------------------------------------------------
  def moving?
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # * Determine if Jumping
  #--------------------------------------------------------------------------
  def jumping?
    return @jump_count > 0
  end

  #--------------------------------------------------------------------------
  # * Straighten Position
  #--------------------------------------------------------------------------
  def straighten
    # If moving animation or stop animation is ON
    if @walk_anime or @step_anime
      # Set pattern to 0
      @pattern = 0
    end
    # Clear animation count
    @anime_count = 0
    # Clear prelock direction
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # * Force Move Route
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # Save original move route
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end

    # Change move route
    @move_route = move_route
    @move_route_index = 0
    # Set forced move route flag
    @move_route_forcing = true
    # Clear prelock direction
    @prelock_direction = 0
    # Clear wait count
    @wait_count = 0
    # Move cutsom
    move_type_custom
    
  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d) #d0 = jump

    return true

    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
       
    # If coordinates are outside of map
    return false unless $map.valid?(new_x, new_y)
    return true if @through
    
    # To new tile and from new tile
    return false unless $map.passable?(x, y, d, self)
    return false unless $map.passable?(new_x, new_y, 10 - d) 

    # end
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Determine if Can Fight 
  #--------------------------------------------------------------------------
  def canfight?()

    d = 2 if @x == $player.x and @y == $player.y - 1
    d = 8 if @x == $player.x and @y == $player.y + 1
    d = 4 if @y == $player.y and @x == $player.x + 1
    d = 6 if @y == $player.y and @x == $player.x - 1
    
    return passable?(x,y,d)

  end

  #--------------------------------------------------------------------------
  # * Lock
  #--------------------------------------------------------------------------
  def lock
    return if @locked
    @prelock_direction = @direction
    turn_toward_player
    @locked = true
  end

  #--------------------------------------------------------------------------
  # * Determine if Locked
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end

  #--------------------------------------------------------------------------
  # * Unlock
  #--------------------------------------------------------------------------
  def unlock
    return if !@locked

    # Clear locked flag
    @locked = false
    # If direction is not fixed
    unless @direction_fix
      # If prelock direction is saved
      if @prelock_direction != 0
        # Restore prelock direction
        @direction = @prelock_direction
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x 
    @y = y 
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end

  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    # Get screen coordinates from real coordinates and map display position
    return  @off_x + (@real_x - $map.display_x + 3) / 4 + 16
  end

  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    # Get screen coordinates from real coordinates and map display position
    y = (@real_y - $map.display_y + 3) / 4 + 32
    # Make y-coordinate smaller via jump count
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    return @off_y + y - (@jump_peak * @jump_peak - n * n) / 2
  end
  #--------------------------------------------------------------------------
  # * Get Screen Z-Coordinates
  #     height : character height
  #--------------------------------------------------------------------------
  def screen_z(height = 0)

    # Some sort of below character here
    # return 0 if @always on bottom

    return 999 if @always_on_top

    # Get screen coordinates from real coordinates and map display position
    z = (@real_y - $map.display_y + 3) / 4 + 32

    # If height exceeds 32, then add 31
    return z #+ ((height > 32) ? 31 : 0)


  end

  #--------------------------------------------------------------------------
  # * Get Thicket Depth
  #--------------------------------------------------------------------------
  def bush_depth
    return 0 if @always_on_top
    return 0 if jumping?
    dx = ((@x * 128) - @real_x).abs
    #log_info(dx) if dx > 0
    return 12 if $map.bush?(@x, @y) && dx < 24
    return 0
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #--------------------------------------------------------------------------
  def terrain_tag() return $map.terrain_tag(@x, @y) end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    # Mouse pathfinding
    run_path if @runpath == true

    # Update facing dir
        @lockdir -= 1
    if @lockdir <= 0
      @showdir = @direction
    end
    
    # Branch with jumping, moving, and stopping
    if jumping?
      update_jump
    elsif moving?
      update_move
      if !moving?
        @move_angle = 0
      end
    else
      update_stop
    end

    # If animation count exceeds maximum value
    # * Maximum value is move speed * 1 taken from basic value 18
    if @anime_count > 18 - @move_speed * 2
      # If stop animation is OFF when stopping
      if not @step_anime and @stop_count > 0
        # Return to original pattern
        @pattern = @original_pattern
      # If stop animation is ON when moving
      else
        # Update pattern
        @pattern = (@pattern + 1) % 4
      end
      # Clear animation count
      @anime_count = 0
    end


    # If waiting
    if @wait_count > 0
      # Reduce wait count
      @wait_count -= 1
      return
    end


    # If move route is forced
    if @move_route_forcing
      # Custom move
      move_type_custom
      return
    end
    # When waiting for event execution or locked
    if @starting or lock?
      # Not moving by self
      return
    end

    # If stop count exceeds a certain value (computed from move frequency)
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # Branch by move type
      case @move_type
        when 1  # Random
          move_type_random
        when 2  # Approach
          move_type_toward_player
        when 3  # Custom
          move_type_custom
      end
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (jump)
  #--------------------------------------------------------------------------
  def update_jump
    # Reduce jump count by 1
    @jump_count -= 1
    # Calculate new coordinates
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)
  end

  #--------------------------------------------------------------------------
  # * Update frame (move)
  #--------------------------------------------------------------------------
  def update_move

    #if moving?

    #end

    
    

    # Convert map coordinates from map move speed into move distance
    distance = 2 ** @move_speed 

    #LADDER
    if terrain_tag == 3

      # turn to get on ladder
      if @direction == 2 #&& @prev_terrain != 3
        @showdir = 4
        @direction = 8
        @lockdir = 4
     else
        @direction = 8
        #@showdir = 8
      end
      @move_angle += 0.2
      # Convert map coordinates from map move speed into move distance
      distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs

      Audio.se_play("Audio/SE/step3.ogg") if (2.4-@move_angle).abs < 0.2 && (@prev_terrain == 4 || @prev_terrain == 3)
      #Audio.se_play("Audio/SE/step.ogg") if (4.8 - @move_angle).abs < 0.21

    elsif terrain_tag == 5 && @prev_terrain == 3
      #@showdir = 8
      #@direction = 8

      @move_angle += 0.2

      if @move_angle < 3.14
        @showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs
      else
        #if @lockdir > 0
          @direction = 2
          @showdir = 4
          @lockdir = 2
       # end
        distance = 2 ** @move_speed 
      end

      Audio.se_play("Audio/SE/step.ogg") if @move_angle == 2.4 && @prev_terrain != 3


    elsif terrain_tag == 2 # Stairs

      #@showdir = 8
      #@direction = 8

      @move_angle += 0.15

      #if @move_angle < 3.14
        #@showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 2.0 ** @move_speed * (Math.sin(@move_angle)).abs
      #end

      Audio.se_play("Audio/SE/step.ogg") if @move_angle == 2.4 && @prev_terrain != 3


    else
      @move_angle = 0
    end

    # If logical coordinates are further down than real coordinates
    if @y * 128 > @real_y
      @real_y = [@real_y + distance, @y * 128].min
    end
    # If logical coordinates are more to the left than real coordinates
    if @x * 128 < @real_x
      @real_x = [@real_x - distance, @x * 128].max
    end
    # If logical coordinates are more to the right than real coordinates
    if @x * 128 > @real_x
      @real_x = [@real_x + distance, @x * 128].min
    end
    # If logical coordinates are further up than real coordinates
    if @y * 128 < @real_y
      @real_y = [@real_y - distance, @y * 128].max
    end

    # If move animation is ON
    if @walk_anime
      # Increase animation count by 1.5
      @anime_count += 1.5
    # If move animation is OFF, and stop animation is ON
    elsif @step_anime
      # Increase animation count by 1
      @anime_count += 1
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (stop)
  #--------------------------------------------------------------------------
  def update_stop

    @prev_terrain = terrain_tag if @prev_terrain != terrain_tag

    # If stop animation is ON
    if @step_anime
      # Increase animation count by 1
      @anime_count += 1
    # If stop animation is OFF, but current pattern is different from original
    elsif @pattern != @original_pattern
      # Increase animation count by 1.5
      @anime_count += 1.5
    end
    # When waiting for event execution, or not locked
    # * If lock deals with event execution coming to a halt
    unless @starting or lock?
      @stop_count += 1
    end
  end
  
  #--------------------------------------------------------------------------
  # * Move Type : Random
  #--------------------------------------------------------------------------
  def move_type_random
    # Branch by random numbers 0-5
    case rand(6)
      when 0..3  # Random
        move_random
      when 4  # 1 step forward
        move_forward
      when 5  # Temporary stop
        @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # Get difference in player coordinates
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end

    # What if they follow more aggressively on harder difficulty?
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_toward_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end
  end

  #--------------------------------------------------------------------------
  # * Move Type : Custom
  #--------------------------------------------------------------------------
  def move_type_custom
    # Interrupt if not stopping
    return if jumping? or moving?

    # Loop until finally arriving at move command list
    while @move_route_index < @move_route.list.size

      # Acquiring move command
      command = @move_route.list[@move_route_index]

      # If command code is 0 (last part of list)
      if command.code == 0

        # Restart
        @move_route_index = 0 if @move_route.repeat

        # If [repeat action] option is OFF
        if !@move_route.repeat
          # If move route is forcing
          if @move_route_forcing

            # Release forced move route
            @move_route_forcing = false

            # Restore original move route
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # Clear stop count
          @stop_count = 0
        end
        return
      end

      # COL 1

      # During move command (from move down to jump)
      if command.code <= 14
        # Branch by command code
        case command.code
          when 1; move_down
          when 2  # Move left
            move_left
          when 3  # Move right
            move_right
          when 4  # Move up
            move_up
          when 5  # Move lower left
            move_lower_left
          when 6  # Move lower right
            move_lower_right
          when 7  # Move upper left
            move_upper_left
          when 8  # Move upper right
            move_upper_right
          when 9  # Move at random
            move_random
          when 10  # Move toward player
            move_toward_player
          when 11  # Move away from player
            move_away_from_player
          when 12  # 1 step forward
            move_forward
          when 13  # 1 step backward
            move_backward
          when 14  # Jump
            jump(command.parameters[0], command.parameters[1])
        end
        # If movement failure occurs when [Ignore if can't move] option is OFF
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end

      # If waiting
      if command.code == 15
        # Set wait count
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end

      # COL 2

      # If direction change command
      if command.code >= 16 and command.code <= 26
        # Branch by command code
        case command.code
        when 16  # Turn down
          turn_down
        when 17  # Turn left
          turn_left
        when 18  # Turn right
          turn_right
        when 19  # Turn up
          turn_up
        when 20  # Turn 90Â° right
          turn_right_90
        when 21  # Turn 90Â° left
          turn_left_90
        when 22  # Turn 180Â°
          turn_180
        when 23  # Turn 90Â° right or left
          turn_right_or_left_90
        when 24  # Turn at Random
          turn_random
        when 25  # Turn toward player
          turn_toward_player
        when 26  # Turn away from player
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end

      # COL 3

      # If other command
      if command.code >= 27
        # Branch by command code
        case command.code
        
        when 29  # Change speed
          @move_speed = command.parameters[0]
        when 30  # Change freq
          @move_frequency = command.parameters[0]
        when 31  # Move animation ON
          @walk_anime = true
        when 32  # Move animation OFF
          @walk_anime = false
        when 33  # Stop animation ON
          @step_anime = true
        when 34  # Stop animation OFF
          @step_anime = false
        when 35  # Direction fix ON
          @direction_fix = true
        when 36  # Direction fix OFF
          @direction_fix = false
        when 37  # Through ON
          @through = true
        when 38  # Through OFF
          @through = false
        when 39  # Always on top ON
          @always_on_top = true
        when 40  # Always on top OFF
          @always_on_top = false
        when 41  # Change Graphic
          @character_name = command.parameters[0]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # Change Opacity
          @opacity = command.parameters[0]
        when 43  # Change Blending
          @blend_type = command.parameters[0]
        when 44  # Play SE
          $game_system.se_play(command.parameters[0])
        when 45  # Script
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end


    end


  end

  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    # Clear stop count
    @stop_count = 0
  end



    #--------------------------------------------------------------------------
  # * Move Down
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)


@move_angle = 0

    # Turn down
    if turn_enabled
      turn_down
    end
    # If passable
    if passable?(@x, @y, 2)

      # Turn down
      turn_down
      # Update coordinates
      @y += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered IF ENEMY ONLY
      #check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Left
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)

@move_angle = 0

    # Turn left
    if turn_enabled
      # If facing right, turn down for just second
      turn_left
    end
    # If passable
    if passable?(@x, @y, 4)
      # Turn left
      turn_left
      # Update coordinates
      @x -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      #check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Right
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)

    @move_angle = 0

    # Turn right
    if turn_enabled
      turn_right
    end
    # If passable
    if passable?(@x, @y, 6)
      # Turn right
      turn_right
      # Update coordinates
      @x += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
     # check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move up
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)

    @move_angle = 0

    # Turn up
    if turn_enabled
      turn_up
    end
    # If passable
    if passable?(@x, @y, 8)
      # Turn up
      turn_up
      # Update coordinates
      @y -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
     # check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Left
  #--------------------------------------------------------------------------
  def move_lower_left
    # If no direction fix
    unless @direction_fix
      # Face down is facing right or up
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # When a down to left or a left to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # Update coordinates
      @x -= 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Right
  #--------------------------------------------------------------------------
  def move_lower_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face down if facing up
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # When a down to right or a right to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # Update coordinates
      @x += 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Left
  #--------------------------------------------------------------------------
  def move_upper_left
    # If no direction fix
    unless @direction_fix
      # Face left if facing right, and face up if facing down
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # When an up to left or a left to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # Update coordinates
      @x -= 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Right
  #--------------------------------------------------------------------------
  def move_upper_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face up if facing down
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # When an up to right or a right to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # Update coordinates
      @x += 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move at Random
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # Move down
      move_down(false)
    when 1  # Move left
      move_left(false)
    when 2  # Move right
      move_right(false)
    when 3  # Move up
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * Move toward Player
  #--------------------------------------------------------------------------
  def move_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Move away from Player
  #--------------------------------------------------------------------------
  def move_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move away from player, prioritize left and right directions
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # If vertical distance is longer
    else
      # Move away from player, prioritize up and down directions
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Forward
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Backward
  #--------------------------------------------------------------------------
  def move_backward
    # Remember direction fix situation
    last_direction_fix = @direction_fix
    # Force directino fix
    @direction_fix = true
    # Branch by direction
    case @direction
    when 2  # Down
      move_up(false)
    when 4  # Left
      move_right(false)
    when 6  # Right
      move_left(false)
    when 8  # Up
      move_down(false)
    end
    # Return direction fix situation back to normal
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # * Jump
  #     x_plus : x-coordinate plus value
  #     y_plus : y-coordinate plus value
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # If plus value is not (0,0)
    if x_plus != 0 or y_plus != 0
      # If horizontal distnace is longer
      if x_plus.abs > y_plus.abs
        # Change direction to left or right
        x_plus < 0 ? turn_left : turn_right
      # If vertical distance is longer, or equal
      else
        # Change direction to up or down
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # Calculate new coordinates
    new_x = @x + x_plus
    new_y = @y + y_plus
    # If plus value is (0,0) or jump destination is passable
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # Straighten position
      straighten
      # Update coordinates
      @x = new_x
      @y = new_y
      # Calculate distance
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # Set jump count
      @jump_peak = 10 + distance - @move_speed
      @jump_count = @jump_peak * 2
      # Clear stop count
      @stop_count = 0
    end
  end

  #--------------------------------------------------------------------------
  # * Turns
  #--------------------------------------------------------------------------
  def turn_down() 
    return if @direction_fix 
    return if terrain_tag == 3 #on ladder
    return if terrain_tag == 4 #&& @previous_terrain == 3
    if @direction == 8
        @showdir=4
        @direction = 2
        @lockdir = 6
      else
        @direction = 2 
      end  


  end


  def turn_left() 
    return if @direction_fix 
      if @direction == 6
        @showdir=2
        @direction =4
        @lockdir = 7
      else
        @direction = 4 unless @direction_fix 
      end
    
  end

  def turn_right() 
    return if @direction_fix 
    if @direction == 4
        @showdir=2
        @direction = 6
        @lockdir = 7
    else
      @direction = 6 unless @direction_fix 
    end
  end



  def turn_up() 
    return if @direction_fix 
    if @direction == 2
        @showdir=6
        @direction = 8
        @lockdir = 6
      else
        @direction = 8 unless @direction_fix 
      end  

  end
  
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Left
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 180Â°
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right or Left
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # * Turn at Random
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Towards Player
  #--------------------------------------------------------------------------
  def turn_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Away from Player
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left away from player
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down away from player
      sy > 0 ? turn_down : turn_up
    end
  end

  #--------------------------------------------------------------------------
  # * Turn Towards Event
  #--------------------------------------------------------------------------
  def turn_toward_event(event_id)
    # Get difference in player coordinates
    evt = $map.events[event_id]
    return if evt == nil
    sx = @x - evt.x
    sy = @y - evt.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end

  def turn_toward_pos(x,y)

    sx = @x - x
    sy = @y - y

    # If coordinates are equal
    return if sx == 0 and sy == 0

    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end
  #   #--------------------------------------------------------------------------
#   # * Frame Update (run_path)
#   #--------------------------------------------------------------------------
  def run_path

    return if moving?

    step = @map[@x,@y]
    if step == 1 # AT TARGET POS
      @map = nil
      @runpath = false
      return
    end
      
    # maybe cut the step != 0, would be broken if there

    dir = rand(2)
    case dir
    when 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_up if @map[@x,@y-1] == step - 1 and step != 0
    when 1
      move_up if @map[@x,@y-1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
    end
  end

  #--------------------------------------------------------------------------
  # * Find Path
  #--------------------------------------------------------------------------
  def find_path(x,y)
    sx, sy = @x, @y
    @tx, @ty = x, y
    tx, ty = x,y
    result = setup_map(sx,sy,tx,ty)
    @runpath = result[0]
    @map = result[1]
    @map[sx,sy] = result[2] if result[2] != nil
  end
  #--------------------------------------------------------------------------
  # * Clear Path
  #--------------------------------------------------------------------------
  def clear_path
    @map = nil
    @runpath = false
  end
  #--------------------------------------------------------------------------
  # * Setup Map
  #--------------------------------------------------------------------------
  def setup_map(sx,sy,tx,ty) #tx and ty in params for external call

    map = Table.new($map.width, $map.height)

    update_counter = 0
    map[tx,ty] = 1
    old_positions = [[tx, ty]]
    new_positions = []

    depth = 2

    depth.upto(100){ |step|
      while !old_positions.empty?

        x,y = old_positions.shift

        #log_sys([x,y])

        if x == sx and y == sy
          log_scr("WINWINWINW")
          return [true, map, step-1] 
        end

        if map[x,y + 1] == 0 and passable?(x, y, 2) 
          #log_err "IN"
          map[x,y + 1] = step
          new_positions.push([x,y + 1])
        end

        if map[x - 1,y] == 0 and passable?(x, y, 4) 
          map[x - 1,y] = step
          new_positions.push([x - 1,y])
        end

        if map[x + 1,y] == 0 and passable?(x, y, 6) 
          map[x + 1,y] = step
          new_positions.push([x + 1,y])
        end

        if map[x,y - 1] == 0 and passable?(x, y, 8) 
          map[x,y - 1] = step
          new_positions.push([x,y - 1])
        end

      end

      old_positions = new_positions
      new_positions = []

      #log_info (old_positions)
    }
      
      log_err "FAILFAIL"
    return [false, nil, nil]     

  end


end
"R0#==============================================================================
# ** Game_Event
#==============================================================================

class Game_Event < Game_Character

  attr_reader   :trigger   
  attr_reader   :list          
  attr_reader   :starting  
  
  attr_reader   :name
  attr_reader   :event

  attr_reader :above
  attr_reader :below

  attr_reader :page_idx
      
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------

  def initialize(event)
    super()

    @event = event
    @id = event.id
    
    @erased = false
    @disabled = $state.disable?(@id)
    @deleted = $state.delete?(@id)

    @starting = false
    @through = true
    @above = false
    @below = false

    @width = 1
    @height = 1

    @page = nil
    @page_idx = -1

    # Name breakdown
    name = @event.name

    clone_ev = nil
    
    # Clone map clone
    if name.include?('::')
      clone = name.delete('::')
      name = $data.clones[clone].name
      clone_ev = $data.clones[clone]
    elsif name.include?(':')
      clone = name.delete(':')
      clone_ev = $map.event_by_name(clone).event
      name = clone_ev.name
    end

    if name == '' || name == '#'
      @icon = nil
      @name = 'nil'
    else
      data = name.split('#').first.split('.')
      if data.size > 1
        @icon = data[0].strip
        @name = data[1].strip
      else
        @icon = @name = data[0].strip
      end
    end   
    
    # Set pages from clone or event
    if clone_ev
      @pages = clone_ev.pages
    else
      @pages = @event.pages 
    end

    # Restore saved location if relevant
    if $state.loc?(@id)
      loc = $state.getloc(@id)
      moveto(loc[0],loc[1])
    else
      moveto(@event.x, @event.y)
    end
    
    refresh
  end

  def at?(x,y)
    return self.x == x && self.y == y
  end

  #--------------------------------------------------------------------------
  # * Clear Starting Flag
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end

  def icon
    return nil if @erased || @disabled || @deleted
    return @icon
  end

  def collide?(x,y)
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine if Over Trigger
  #    is this event under player
  #--------------------------------------------------------------------------
  def over_trigger?
    # If not through situation with character as graphic
    if @character_name != "" and not @through
      # Starting determinant is face
      return false
    end
    # If this position on the map is impassable
    unless $map.passable?(@x, @y, 0)
      # Starting determinant is face
      return false
    end
    # Starting determinant is same position
    return true
  end

  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  def start  
    return if @erased || @deleted || @disabled
    return if !@list || @list.size < 1
    refresh
    @starting = true    

  end

  def stop

    log_sys("STATEENABLEING")

    # Enable the second state if there is one
    state(@id,"second_#{@page_idx}") if !is_second?(@page)

  end

  def find_page
    return nil if @erased || @deleted
    page = @pages.count-1
    while page >= 0
      return page if conditions_met?(page)
      page -= 1
    end
  end

  def conditions_met?(idx)
        #return false if page == 0

        page = @pages[idx]
      
        # DANHAX - check super conditions
        page.list.each{ |line|
      
          if line.code == 108
            comment = line.parameters[0]
            if comment[0] == '?'[0]
              data = comment.split(' ')
              if !condition_applies?(data,idx)
                return false
              end
            end
          end        
        }  

        return true
  end

  # Can also be called by script
  def condition_applies?(cond,idx)
      # cond is [code,data1.....]

    case cond[0]

      # Second
      when '?second'
        return false if !conditions_met?(idx-1)
        return false if !state?(@id,"second_#{idx-1}")
       

      # Flag
      when '?flag'
          return false if !flag?(cond[1])
              
      # Progress
      when '?before'
        return false if !$state.before?(cond[1])
      when '?progress'
        return false if !$state.progress?(cond[1])
      when '?after'
        return false if !$state.beyond?(cond[1])

      # States
      when '?state'


      # Active Quest
      when '?active'
        return false if !$progress.active?(cond[1])
      when '?inactive'
        return false if $progress.active?(cond[1])
      when '?complete'
        return false if !$progress.complete?(cond[1])
      when '?incomplete'
        return false if $progress.complete?(cond[1])
      when '?quest'
        return false if !$progress.quest?(cond[1])

      # Party member check
      when '?boyle', '?boy'
        return false if !$party.has_member?('boy')
      when '?ingrid', '?ing'
        return false if !$party.has_member?('ing')
      when '?myst', '?mys'
        return false if !$party.has_member?('mys')
      when '?robin', '?rob'
        return false if !$party.has_member?('rob')
      when '?hiberu', '?hib'
        return false if !$party.has_member?('hib')
      when '?rowen', '?row'
        return false if !$party.has_member?('row')
      when '?phye', '?phy'
        return false if !$party.has_member?('phy')

      # Inventory
      when '?gold'
        return false if !$party.has_gold?(cond[1].to_i)

      when '?item'
        return false if !$game_party.has_item?(cond[1])



    end

    return true

  end

  def label_applies?(label)

    case label
      
      when '@first'
        return false if state?(me,"second_#{this.page_idx}")
      when '@second'
        return false if !state?(me,"second_#{this.page_idx}")

      when '@boy'
        return false if $party.leader != 'boy'      
      when '@ing'
        return false if $party.leader != 'ing'
      when '@mys'
        return false if $party.leader != 'mys'
      when '@rob'
        return false if $party.leader != 'rob'
      when '@hib'
        return false if $party.leader != 'hib'
      when '@row'
        return false if $party.leader != 'row'
      when '@phy'
        return false if $party.leader != 'phy'

    end

    return true

  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    @page_idx = find_page
    new_page = @pages[@page_idx]
    setup_page(new_page) if new_page != @page
  end

  def is_second?(page)

    # DANHAX - check super conditions
    page.list.each{ |line|
  
      if line.code == 108
        comment = line.parameters[0]
        if comment[0] == '?'[0]
          data = comment.split(' ')
          return true if data[0] == '?second'
        end
      end        
    }  

    return false

  end  
  
  def setup_page(new_page)

    # Set @page as current event page
    @page = new_page
    if @page
      setup_page_settings
      read_comment_data
    else
      clear_page_settings
    end

    # Clear starting flag
    clear_starting
    
    # If trigger is [parallel process]
    if @trigger == 4
      @interpreter = Interpreter.new
      @interpreter.setup(@list, @event.id)
    end

    # Auto event start determinant
    check_event_trigger_auto

  end
  

  def clear_page_settings
      @character_name = ""
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
  end

  def setup_page_settings
    
    # Set each instance variable
    @character_name = @page.graphic.character_name
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    #XP - VX @opacity = @page.graphic.opacity
    #XP - VX @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil

    # Do things based on the name
    if @character_name == "!!!"
      @through = true
      @trigger = 1 if @trigger == 0
    end

  end
  
  def read_comment_data
    comment_data = []

    @list.each{ |line|
      next if line.code != 108
      if line.parameters[0].include?('#')
        comment_data.push(line.parameters[0].split(" "))
      end
    }

    comment_data.each{ |data|
      case data[0]

        when '#above'
          @above = true
        when '#below'
          @below = true

        when '#opacity'
          self.opacity = data[1].to_i
        when '#hide'
          self.opacity = 0

        when '#width'
          @width = data[1].to_i
        when '#height'
          @height = data[1].to_i
        when '#gfx'

          if @character_name == "!!Prop"
            @character_name = "Props/"+data[1]
          end

          if @character_name.include?("NPC")
            @character_name = "NPCs/"+@character_name.delete("NPC-")+"/"+data[1]
          end

        when '#ox'
          @off_x = data[1].to_i
        when '#oy'
          @off_y = data[1].to_i

        when '#disable'
          disable

      end
    }
    

  end

  #--------------------------------------------------------------------------
  # * Automatic Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # # If trigger is [touch from event] and consistent with player coordinates
    # if @trigger == 2 and @x == $player.x and @y == $player.y
    #   # If starting determinant other than jumping is same position event
    #   if not jumping? and over_trigger?
    #     start
    #   end
    # end
    # If trigger is [auto run]
    if @trigger == 3 || @event.name == 'AUTORUN'
      start
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    # Automatic event starting determinant
    check_event_trigger_auto

    # If parallel process is valid
    if @interpreter != nil
      @interpreter.update
    end

  end
    
  #--------------------------------------------------------------------------
  # * Save Position
  #--------------------------------------------------------------------------
  def saveloc
    $state.loc!(@event.id)
  end

  #--------------------------------------------------------------------------
  # * Temporarily Erase
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    self.opacity = 0
    refresh
  end

  def disable
    @disabled = true
    $state.disable(@id)
    refresh
  end

  def enable
    @disabled = false
    $state.enable(@id)
    refresh
  end

  def delete
    @deleted = true
    $state.delete(@id)
    self.opacity = 0
    refresh
  end

end"·X#==============================================================================
# ** Interpreter (part 1)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter

  attr_accessor :common_event_id

  attr_accessor :wait_count

  attr_accessor :event_id
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #     main  : main flag
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main

    @common_event_id = 0
    
    # Depth goes up to level 100
    if depth > 100
      print("Common event call has exceeded maximum limit.")
      exit
    end
    
    # Clear inner situation of interpreter
    clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Reset
  #   Remove any queued items 
  #--------------------------------------------------------------------------
  def reset
    @list = nil
  end
  
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # map ID when starting up
    @event_id = 0                     # event ID
    @message_waiting = false          # waiting for message to end
    @move_route_waiting = false       # waiting for move completion
    @wait_count = 0                   # wait count
    @child_interpreter = nil          # child interpreter
    @branch = {}                      # branch data
  end

  #--------------------------------------------------------------------------
  # * Event Setup
  #     list     : list of event commands
  #     event_id : event ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    
    # Clear inner situation of interpreter
    clear
    
    # Remember map ID
    @map_id = $map.id
    
    # Remember event ID
    @event_id = event_id
    
    # Remember list of event commands
    @list = list
    
    # Initialize index
    @index = 0
    
    # Clear branch data hash
    @branch.clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Current event (as event, not id)
  #--------------------------------------------------------------------------
  def event
    return $map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Running
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  
  #--------------------------------------------------------------------------
  # * Starting Event Setup
  #--------------------------------------------------------------------------
  def setup_starting_event
    
    # Refresh map if necessary
    if $map.need_refresh
      $map.refresh
    end
    
    # If common event call is reserved
    if @common_event_id > 0
      
      # Set up event
      setup($data.commons[@common_event_id].list, 0)
      
      # Release reservation
      @common_event_id = 0
      
      return
      
    end
    
    # Loop (map events)
    $map.starting_events.each{ |e| 

        # If not auto run
        if e.trigger < 3
          
          e.clear_starting
          e.lock          
        end
        
        # Set up event
        setup(e.list, e.id)
        
        return      
    }
    
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    
    # Initialize loop count
    @loop_count = 0
    
    # Loop
    loop do
      
      # Add 1 to loop count
      @loop_count += 1
      
      # If 100 event commands ran
      if @loop_count > 100
        # Call Graphics.update for freeze prevention
        Graphics.update
        @loop_count = 0
      end
      
      # If map is different than event startup time
      if $map.id != @map_id
        # Change event ID to 0
        @event_id = 0
      end
      
      # If a child interpreter exists, run it then check if done
      if @child_interpreter != nil
        @child_interpreter.update
        @child_interpreter = nil if !@child_interpreter.running?  
        return if @child_interpreter != nil        
      end
      
      # If waiting for message to end
      return if @message_waiting

      # Misc hud busy
      return if $scene.busy?

      # If waiting for move to end
      if @move_route_waiting

        # If player is forcing move route
        if $player.move_route_forcing
          return
        end
        
        # Loop (map events)
        for event in $map.events.values
          
          # If this event is forcing move route
          if event.move_route_forcing
            return
          end
          
        end
        
        # Clear move end waiting flag
        @move_route_waiting = false
        
      end
      
      # If waiting
      if @wait_count > 0
        # Decrease wait count
        @wait_count -= 1
        return
      end

      # If list of event commands is empty
      if @list == nil
        
        # If main map event
        if @main
          # Set up starting event
          setup_starting_event
        end
        
        # If nothing was set up
        if @list == nil
          return
        end
        
      end
      
      # If return value is false when trying to execute event command
      if execute_command == false
        return
      end
      
      # Advance index
      @index += 1
      
    end
  end

    #--------------------------------------------------------------------------
  # * Event Command Execution
  #--------------------------------------------------------------------------
  def execute_command
   
    # If last to arrive for list of event commands
    if @index >= @list.size - 1
      command_end
      return true
    end

    # Make event command parameters available for reference via @parameters
    @parameters = @list[@index].parameters

    # Check if this is a label marker
    # If it is check if applies, if so keep going,
    # Otherwise skip to next label
    if @list[@index].code == 108 && @parameters[0].include?('@')

      # Keep going until a label passes or end of events
      while true

        # No more commands, end it
        if @index >= @list.size - 1
          command_end
          return true
        end

        if @list[@index].code == 108
          break if this.label_applies?(@list[@index].parameters[0])
        end

        @index += 1

      end

    end

    # Branch by command code
    return true if @list[@index].code == 108
    return true if @list[@index].code == 509
    send("command_"+@list[@index].code.to_s)
    
  end
  #--------------------------------------------------------------------------
  # * End Event
  #--------------------------------------------------------------------------
  def command_end
    # Clear list of event commands
    @list = nil
    # If main map event and event ID are valid
    if @main and @event_id > 0
      # Unlock event
      $map.events[@event_id].unlock
    end

    # Tell the even that it is stopping so it can mark second
    this.stop 
  end

  #--------------------------------------------------------------------------
  # * Command Skip
  #--------------------------------------------------------------------------
  def command_skip
    # Get indent
    indent = @list[@index].indent
    # Loop
    loop do
      # If next event command is at the same level as indent
      if @list[@index+1].indent == indent
        # Continue
        return true
      end
      # Advance index
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # * Get Character
  #     parameter : parameter
  #--------------------------------------------------------------------------
  def get_character(parameter)
    # Branch by parameter
    case parameter
    when -1  # player
      return $player
    when 0  # this event
      events = $map.events
      return events == nil ? nil : events[@event_id]
    else  # specific event
      events = $map.events
      return events == nil ? nil : events[parameter]
    end
  end

  #--------------------------------------------------------------------------
  # * Calculate Operated Value
  #     operation    : operation
  #     operand_type : operand type (0: invariable 1: variable)
  #     operand      : operand (number or variable ID)
  #--------------------------------------------------------------------------
  def operate_value(operation, operand_type, operand)
    # Get operand
    if operand_type == 0
      value = operand
    else
      value = $game_variables[operand]
    end
    # Reverse sign of integer if operation is [decrease]
    if operation == 1
      value = -value
    end
    # Return value
    return value
  end


    def next_event_code
    @list[@index+1].code
  end

    #--------------------------------------------------------------------------
  # * Show Text
  #--------------------------------------------------------------------------
  def command_101

    message = []
    message.push(@list[@index].parameters[0])
    while next_event_code == 401
      @index += 1
      message.push(@list[@index].parameters[0])
    end

    message = message.join(' ')

    # If there is a choice next, add it
    if next_event_code == 102
      @index+=1
      while next_event_code == 402

      end
    end

    $scene.hud.message.start(message)
    
    # Return mouse to default cursor
    #$mouse_sprite.set_bitmap(MouseCursor::Default_Cursor)
    
    # Continue
    return true

  end

  #--------------------------------------------------------------------------
  # * Wait
  #--------------------------------------------------------------------------
  def command_106
    @wait_count = @parameters[0]
    return true
  end

  #--------------------------------------------------------------------------
  # * Conditional Branch
  #--------------------------------------------------------------------------
  def command_111
    
    result = eval(@parameters[1])
    return true if result
  
    # Skip it
    @branch[@list[@index].indent] = result
    return command_skip
  
  end
  #--------------------------------------------------------------------------
  # * Else
  #--------------------------------------------------------------------------
  def command_411
    # If determinant results are false
    if @branch[@list[@index].indent] == false
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the conditions: command skip
    return command_skip
  end
 
  #--------------------------------------------------------------------------
  # * Exit Event Processing
  #--------------------------------------------------------------------------
  def command_115
    command_end
    return true
  end

  #--------------------------------------------------------------------------
  # * Label
  #--------------------------------------------------------------------------
  def command_118
    return true
  end

  #--------------------------------------------------------------------------
  # * Jump to Label
  #--------------------------------------------------------------------------
  def command_119
    # Get label name
    label_name = @parameters[0]
    # Initialize temporary variables
    temp_index = 0
    # Loop
    loop do

      # If a fitting label was not found
      return true if temp_index >= @list.size-1

      # If this event command is a designated label name
      if @list[temp_index].code == 118 and
         @list[temp_index].parameters[0] == label_name
        # Update index
        @index = temp_index
        # Continue
        return true
      end
      # Advance index
      temp_index += 1
    end
  end

  #--------------------------------------------------------------------------
  # * Transfer Player
  #--------------------------------------------------------------------------
  def command_201

    # If transferring player, showing message, or processing transition
    return false if $player.transferring || $scene.busy?
    
    # If appointment method is [direct appointment]
    $player.queue_xfer(@parameters[1],@parameters[2],@parameters[3],@parameters[4])
    
    # Advance index
    @index += 1

    # If fade is set <---- CUT
    # if @parameters[5] == 0
    #   # Prepare for transition
    #   Graphics.freeze
    #   # Set transition processing flag
    #   $game_temp.transition_processing = true
    #   $game_temp.transition_name = ""
    # end

    # End
    return false
  end

  #--------------------------------------------------------------------------
  # * Set Event Location
  #--------------------------------------------------------------------------
  def command_202

    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # If appointment method is [direct appointment]
    if @parameters[1] == 0
      # Set character position
      character.moveto(@parameters[2], @parameters[3])
    # If appointment method is [appoint with variables]
    elsif @parameters[1] == 1
      # Set character position
      character.moveto($game_variables[@parameters[2]],
        $game_variables[@parameters[3]])
    # If appointment method is [exchange with another event]
    else
      old_x = character.x
      old_y = character.y
      character2 = get_character(@parameters[2])
      if character2 != nil
        character.moveto(character2.x, character2.y)
        character2.moveto(old_x, old_y)
      end
    end
    # Set character direction
    case @parameters[4]
      when 8  # up
        character.turn_up
      when 6  # right
        character.turn_right
      when 2  # down
        character.turn_down
      when 4  # left
        character.turn_left
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Map Settings
  #--------------------------------------------------------------------------
  def command_204
    case @parameters[0]
    when 0  # panorama
      $game_map.panorama_name = @parameters[1]
      $game_map.panorama_hue = @parameters[2]
    when 1  # fog
      $game_map.fog_name = @parameters[1]
      $game_map.fog_hue = @parameters[2]
      $game_map.fog_opacity = @parameters[3]
      $game_map.fog_blend_type = @parameters[4]
      $game_map.fog_zoom = @parameters[5]
      $game_map.fog_sx = @parameters[6]
      $game_map.fog_sy = @parameters[7]
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Fog Opacity
  #--------------------------------------------------------------------------
  def command_206
    # Start opacity level change
    $game_map.start_fog_opacity_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Show Animation
  #--------------------------------------------------------------------------
  def command_207
    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # Set animation ID
    character.animation_id = @parameters[1]
    # Continue
    return true

  end
  #--------------------------------------------------------------------------
  # * Change Transparent Flag
  #--------------------------------------------------------------------------
  def command_208
    $game_player.transparent = (@parameters[0] == 0)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Move Route
  #--------------------------------------------------------------------------
  def command_209
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    return true if character == nil

    # Force move route - pushes on top of auto movers
    character.force_move_route(@parameters[1])
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Wait for Move's Completion
  #--------------------------------------------------------------------------
  def command_210
    @move_route_waiting = true
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Change Screen Color Tone
  #--------------------------------------------------------------------------
  def command_223
    $game_screen.start_tone_change(@parameters[0], @parameters[1] * 2)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Weather Effects
  #--------------------------------------------------------------------------
  def command_236
    # Set Weather Effects
    $game_screen.weather(@parameters[0], @parameters[1], @parameters[2])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Play BGM
  #--------------------------------------------------------------------------
  def command_241
    # Play BGM
    $game_system.bgm_play(@parameters[0])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Fade Out BGM
  #--------------------------------------------------------------------------
  def command_242
    # Fade out BGM
    $game_system.bgm_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play BGS
  #--------------------------------------------------------------------------
  def command_245
    # Play BGS
    $game_system.bgs_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Fade Out BGS
  #--------------------------------------------------------------------------
  def command_246
    # Fade out BGS
    $game_system.bgs_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Memorize BGM/BGS
  #--------------------------------------------------------------------------
  def command_247
    # Memorize BGM/BGS
    $game_system.bgm_memorize
    $game_system.bgs_memorize
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Restore BGM/BGS
  #--------------------------------------------------------------------------
  def command_248
    # Restore BGM/BGS
    $game_system.bgm_restore
    $game_system.bgs_restore
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play ME
  #--------------------------------------------------------------------------
  def command_249
    # Play ME
    $game_system.me_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play SE
  #--------------------------------------------------------------------------
  def command_250
    $audio.play_se(@parameters[0])
    return true
  end
  #--------------------------------------------------------------------------
  # * Stop SE
  #--------------------------------------------------------------------------
  def command_251
    # Stop SE
    Audio.se_stop
    # Continue
    return true
  end


  #--------------------------------------------------------------------------
  # * Shop Processing
  #--------------------------------------------------------------------------
  def command_302

    # Set shop calling flag
    $game_temp.shop_calling = true
    # Set goods list on new item
    $game_temp.shop_goods = [@parameters]
    # Loop
    loop do
      # Advance index
      @index += 1
      # If next event command has shop on second line or after
      if @list[@index].code == 605
        # Add goods list to new item
        $game_temp.shop_goods.push(@list[@index].parameters)
      # If event command does not have shop on second line or after
      else
        # End
        return false
      end
    end
  end


    #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    # Set first line to script
    script = @list[@index].parameters[0] + "\n"
    # Loop
    loop do
      # If next event command is second line of script or after
      if @list[@index + 1].code == 655
        # Add second line or after to script
        script += @list[@index + 1].parameters[0] + "\n"
      # If event command is not second line or after
      else
        # Abort loop
        break
      end
      # Advance index
      @index += 1
    end
    
    # Evaluation
    result = eval(script)

    return true

  rescue Exception => e

    line = e.message.split(":")[1].to_i      
    log_scr e.inspect.split(":in `")[0]
    log_scr e.inspect.split(":in `")[1]

    lc = 0
      script.split("\n").each{ |s|
        if lc == line
          s = "---> "+s
        end
        log_scr s
        lc+=1
      }

    # Continue
    return true
     
  end

end
"¿!#==============================================================================
# ** Game_Map
#==============================================================================

class Game_Map

  # Keep the zone? 
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :tileset  
  
  # Camera offsets
  attr_accessor :cam_ox, :cam_oy


  attr_accessor :need_refresh             # refresh request flag

  attr_reader   :map_name                 # name of the map

  attr_reader :interpreter

  attr_reader :id

  # Try to cut this
  attr_reader :events

  attr_reader :map

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @interpreter = Interpreter.new(0,true)

    @cam_target = $player
    @cam_xy = [0,0]
    @cam_snap = false
    @cam_ox = 0
    @cam_oy = 0

    #self.do(pingpong("cam_ox",50,70,:quad_in_out))
    #self.do(pingpong("cam_oy",-70,350,:quad_in_out))

    @namecache = {}
  end
  
  #--------------------------------------------------------------------------
  # * Setup
  #     map_id : map ID
  #--------------------------------------------------------------------------
  def setup(id)
    
    # Put map ID in @map_id memory
    @id = id
    @namecache = {} # reset each map
    
    # Load map from file and set @map
    @map = load_data(sprintf("Data/Map%03d.rxdata", @id))
    @map_name = $data.mapinfos[id].name 
        
    # Hold onto the tileset
    @tileset = $data.tilesets[@map.tileset_id]        
    @passages = @tileset.passages 
    
    # Initialize displayed coordinates
    @display_x = 0
    @display_y = 0
    @target = $player
    
    @need_refresh = false
    
    # Set map event data
    @events = {}
    @map.events.keys.each{ |i|
      @events[i] = Game_Event.new(@map.events[i])
    }

    # Disregard if battle map? or use battle zone?
    # Or various battle zones?

    # What is the zone
    autoplay = false
    newzone = get_zone(@id)
    if newzone != @zone.id

      @zone = $data.zones[newzone]
      log_info "Changing Zone: #{newzone}"

      if @zone.id == "@clear"
        $audio.bgm_stop
        $audio.bgs_stop
        autoplay = true
      elsif @zone.id == "@nil"
        # Play nothing do nothing
        autoplay = true
      else
        # Play music from the zone
        #$audio.play(@zone.bgm)
        #$audio.play(@zone.bgs)
        # Init tints and that
      end

    end
    
    # If a null or clear zone
    if autoplay
      $audio.bgm_play(@map.bgm) if @map.autoplay_bgm
      $audio.bgs_play(@map.bgs) if @map.autoplay_bgs
    end
    
  end

  def display_x
    return @display_x + (@cam_ox*4)
  end

  def display_y
    return @display_y + (@cam_oy*4)
  end

  #--------------------------------------------------------------------------
  # * Get Tileset ID
  #--------------------------------------------------------------------------
  def tileset_id() return @map.tileset_id end
  def width() return @map.width end
  def height() return @map.height end
  def data() return @map.data end

  #--------------------------------------------------------------------------
  # * Camera
  #--------------------------------------------------------------------------
  def camera_to(ev)
    @cam_target = ev
    @cam_snap = false
  end

  def camera_xy(x,y)
    @cam_xy = [x,y]
    @cam_target = nil
    @cam_snap = false
  end

  def camera_snap
    @cam_snap = true
  end

  def refresh
    @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    @interpreter.update

    # Anti lag here
    @events.values.each{ |e| e.update }

    # Refresh map if necessary
    if @need_refresh
      @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

    # Camera update
    @cam_target = $player

    # Camera update, maybe split to camera class
    if @cam_target != nil

      if @cam_target != nil
        @target_x = @cam_target.real_x- (128 * 9.5)
        @target_y = @cam_target.real_y- (128 * 7)
      else
        @target_x = @cam_xy[0] * 128
        @target_y = @cam_xy[1] * 128
      end

      if @target_x != @display_x
        @display_x += (@target_x-@display_x) * 0.15
      end

      if @target_y != @display_y
        @display_y += (@target_y-@display_y) * 0.15
      end

      if (@target_x-@display_x) < 5 && (@target_y-@display_y) < 5
        @cam_snap = true
      end

      if @cam_snap
        @display_x = @target_x
        @display_y = @target_y
      end

    end

    # Limit cam to screen
    @display_x = 0 if @display_x < 0
    @display_y = 0 if @display_y < 0

    w = ($map.width * 32) - $game.width
    h = ($map.height * 32) - $game.height

    #@display_x = w if @display_x > w
    #@display_y = w if @display_y > h



  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil)

    return false unless valid?(x, y)

    # Change direction (0,2,4,6,8,10) to obstacle bit (0,1,2,4,8,0)
    bit = (1 << (d / 2 - 1)) & 0x0f

    # Loop in all events
    events.values.each{ |e| 
      if e != self_event and e.at?(x,y)
         return false if !(e.through || e.above || e.below)
      end
    }

    # Loop searches in order from top of layer
    [2, 1, 0].each{ |i|

      tile_id = data[x, y, i]

      # If obstacle bit is set
      return false if @passages[tile_id] & bit != 0
        
      # If obstacle bit is set in all directions
      return false if @passages[tile_id] & 0x0f == 0x0f
        
      # If priorities other than that are 0
      return true if @tileset.priorities[tile_id] == 0

    }

    # passable
    return true

  end

  #--------------------------------------------------------------------------
  # * Determine Thicket
  #--------------------------------------------------------------------------
  def bush?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x40 == 0x40 }.empty? end
  def counter?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x80 == 0x80 }.empty? end
  def terrain_tag(x, y)

    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return 0
        elsif tile_id > 0   # @terrain_tags[tile_id] > 0
          return @tileset.terrain_tags[tile_id]
        end
      end
    end
    return 0
  
  end

  #--------------------------------------------------------------------------
  # * Event At
  #--------------------------------------------------------------------------
  def valid?(x, y) x >= 0 and x < width and y >= 0 and y < height end
  def event_at(x, y) @events.values.find{ |e| e.at?(x,y) } end
  def events_at(x, y) @events.values.select{ |e| e.at?(x,y) } end
  def lowest_event_at(x, y) nil end #events_at(x,y).min_by{ |e| e.y } end
  

  def starting_events() @events.values.select{ |e| e.starting } end

  def event_by_name(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.name == name }
    @namecache[name] = ev
    return ev
  end

  def event_by_evname(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.event.name == name }
    @namecache[name] = ev
    return ev
  end

  #--------------------------------------------------------------------------
  # Find the zone name for this map
  #--------------------------------------------------------------------------
  def get_zone(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return map_zone_or_nil(id)
  end

  # Return zone name, parent map or @nil if top map
  def map_zone_or_nil(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return '@nil' if $data.mapinfos[id].parent_id == 0
    return map_zone_or_nil($data.mapinfos[id].parent_id)
  end

end"%#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. Its functions include event starting
#  determinants and map scrolling. Refer to "$game_player" for the one
#  instance of this class.
#==============================================================================

class Game_Player < Game_Character

  attr_accessor :transferring      # player place movement flag

  def initialize
    super
    @character_name = "boyle"

    @transferring = false
    @xfer_data = nil
  end

  def transfer(map,x,y,dir)
    @transferring = true
    @xfer_data = [map,x,y,dir]
  end

  def transfer_to(map,target)
    @transferring = true
    @xfer_data = [map,target]
  end

  def name
    return "Player"
  end

  #--------------------------------------------------------------------------
  # * Passable Determinants
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    if DEBUG and Input.press?(Input::CTRL)
      return true
    end
    super
  end

  #--------------------------------------------------------------------------
  # * Same Position Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.collide?(@x,@y) and triggers.include?(event.trigger)
      #if event.x == @x and event.y == @y and triggers.include?(event.trigger)
        # If starting determinant is same position event (other than jumping)
        if not event.jumping? and event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Front Envent Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end

    # Calculate front event coordinates
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(new_x,new_y) &&
         triggers.include?(event.trigger) and event.list.size > 1


        # If starting determinant is front event (other than jumping)
        if !event.jumping? and !event.over_trigger?
          event.start
          result = true
        end
      end
    end
    # If fitting event is not found

    # COUNTER CHECK

    if result == false

      # If front tile is a counter
      if $map.counter?(new_x, new_y)
        # Calculate 1 tile inside coordinates
        new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
        new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
        # All event loops
        for event in $map.events.values
          # If event coordinates and triggers are consistent
          if event.x == new_x and event.y == new_y and
             triggers.include?(event.trigger) and event.list.size > 1
            # If starting determinant is front event (other than jumping)
            if not event.jumping? and not event.over_trigger?
              event.start
              result = true
            end
          end
        end
      end
    end

    return result
  end

  #--------------------------------------------------------------------------
  # * Touch Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?
      
    result = false

    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(x,y) and [1,2].include?(event.trigger)
        # If starting determinant is front event (other than jumping)
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    return super if @move_route_forcing
    return if ($scene.busy?) || $debug.busy?
    return if $map.interpreter.running?
    

    transfer_player if @transferring 

    # Unless Interpretter Running, Forcing a Route or Message Showing

    if $input.click?

        # Gets Mouse X & Y
        mx, my = *$mouse.grid

        $scene.add_spark($mouse.x,$mouse.y)

        log_info([mx,my])
        
        # Turn Character in direction
        #turn_toward_pos(mx,my)
        
        # Run Pathfinding
        evt = $map.lowest_event_at(mx, my)
#        if evt == nil
          find_path(mx, my)
          @eventarray = @runpath ? $map.events_at(mx, my) : nil
        # else
        #   find_path(evt.x, evt.y)
        #   @eventarray = [evt]
        # end
        
        # If Event At Grid Location
        unless @eventarray.nil?
          @eventarray = nil if @eventarray.empty?
        end
        
      end
    
    if @move_route_forcing == true
      clear_path
      @eventarray = nil
    end

    # Clear path if any direction keys pressed
    clear_path if $input.dir4 != 0
    
    # Remember whether or not moving in local variables
    last_moving = moving?
    # If moving, event running, move route forcing, and message window
    # display are all not occurring
    unless moving? || $map.interpreter.running? || @move_route_forcing
      case $input.dir4
        when 2; move_down
        when 4; move_left
        when 6; move_right
        when 8; move_up
      end
    end

    # Remember coordinates in local variables
    last_real_x = @real_x
    last_real_y = @real_y

    super
   
    # If not moving
    unless moving?
      # If player was moving last time
      if last_moving
        # Event determinant is via touch of same position event
        result = check_event_trigger_here([1,2])
      end
      # If C button was pressed
      if $input.action?
        # Same position and front event determinant
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
      end
    end
    
    # If Non-nil Event Autostarter
    if @eventarray != nil && !moving? && # @mouse_event_autostarter != nil && !moving? &&
      (!@ovrdest || @map.nil? || @map[@x,@y] == 1)

      @eventarray.each do |event|
      
        # If Event Within Range
        # if event and (event.at?(@x,@y) || @ovrdest
          
        #   # SHAZ - trigger event when:
        #   # - Autotouch and standing on or beside, or with a counter between
        #   # - player/event touch and standing as close as possible (on, if possible)
        #   distance = Math.hypot(@x - event.x, @y - event.y)

        #   dir = @x < event.x ? 6 : @x > event.x ? 4 : @y < event.y ? 2 : @y > event.y ? 8 : 0

        #   # if (event.trigger == 0 and (distance < 2 or (distance == 2 and 
        #   #   $map.counter?((@x+event.x)/2, (@y+event.y)/2))))             or ([1,2].include?(event.trigger) and ((distance == 0 and $game_player.passable?(@x, @y, dir))             or (distance == 1 and (@ovrdest || !$game_player.passable?(@x, @y, dir)))))

        #   #   # Turn toward Event
        #   #   if @x == event.x
        #   #     @y > event.y ? turn_up : turn_down
        #   #   else
        #   #     @x > event.x ? turn_left : turn_right
        #   #   end

        #   #   # Start Event
        #   #   clear_path
        #   #   event.start
        #   #   @eventarray.delete(event)
        #   #   @eventarray = nil if @eventarray.empty?

        #   # end
        # end
      end      
    end
    

  end

  #--------------------------------------------------------------------------
  # * Teleport the Player
  #--------------------------------------------------------------------------
  def transfer_player
   
    @transferring = false
    $player.clear_path

    # Map to teleport to 
    if $map.id != @xfer_data[0]
      log_info @xfer_data
      $map.setup(@xfer_data[0])      
    end

    # Location on the map to teleport to
    if @xfer_data.count > 2
      $player.moveto(@xfer_data[1],@xfer_data[2])
      $player.direction = @xfer_data[3]
      $player.straighten  
    else
      ev = gev(@xfer_data[1])
      $player.moveto(ev.x,ev.y)
      #$player.direction = @xfer_data[3]
      $player.straighten  
    end

    # AUTO SAVING

    # autosave your game (but not on the ending map)
   # if !ENDING_MAPS.include?($game_map.map_id)
   #   save = Scene_Save.new(1)
   #   save.autosave      
   # end
    
  end

end
"
class Game_Battle

  attr_accessor :map, :weather

  attr_reader :enemies

	def initialize
		@enemies = []
    @props = []
    @actor_index = 0

    @map = 26
	end

  def add(enemy)
    battler = Game_Battler.new
    battler.init_enemy(enemy)
    @enemies.push(battler)
  end

  def start
    $game.push_scene(Scene_Battle.new)
  end

  def win?
    return false
  end


  def build_attack_queue

    return [$party.actor_by_id("boy")]

  end

  def build_attack_plan(attacker)

    plan = Attack_Plan.new

    skill = $data.skills[attacker.skill_id]
    hits = calc_hits(skill)

    hits.times{ |t|

      round = Attack_Round.new
      round.anim_a = skill.anim_a
      round.anim_b = skill.anim_b
      round.skill = skill

      plan.add(round)
    }

    # Add followup attacks


    # Use up the item or mana for the skill used


    return plan

  end

  def build_attack_results(attacker,skill)

    results = []

    # Attack already has skill selected, and targets if scope requires
    targets = build_target_list(attacker,skill)

    # Calculate damage per target i suppose
    targets.each{ |t|

      result = Attack_Result.new

      result.target = t
      result.damage = 154


      results.push(result)

    }

    return results    

  end

  def build_target_list(attacker,skill)

    # Get scope, prepare targets, return list
    case skill.scope

      when 'one', 'ally', 'down'

        # Will be in attacker, already chosen
        return [attacker.target]

      when 'random'

        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }.sample
        else
          return $party.active.select{ |b| b.attackable? }.sample
        end

      when 'two'

        # Random 2
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }.sample(2)
        else
          return $party.active.select{ |b| b.attackable? }.sample(2)
        end

      when 'three'

        # Random 3
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }.sample(3)
        else
          return $party.active.select{ |b| b.attackable? }.sample(3)
        end

      when 'all'

        # All enemy
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }
        else
          return $party.active.select{ |b| b.attackable? }
        end

      when 'party'

        # All allies
        if attacker.is_actor?
          return $party.active.select{ |b| b.attackable? }
        else          
          return @enemies.select{ |b| b.attackable? }
        end

    end

    return []

  end

  def calc_hits(skill)
    hits = skill.hits
    if hits.include?("-")
      data = hits.split("-")
      low = data[0].to_i
      high = data[0].to_i
      return low + rand(hi-low)
    else
      return skill.hits.to_i
    end
  end



  def get_targetable(attacker)

    case $data.skills(attack.skill_id).scope

      when 'one'

      when 'ally'

      when 'down'

    end

  end

  
end


# BATTLE SYSTEM!!!!!!!!

# THEN START BUILDING THE ACTIONS ARRAY
# WILL BE EASY AS
  
# Can't calc damage or anything yet
# Can only make a list of skills
# [hit,hit,heal]

# Then play it out
# Cacl the results at the start of each attack
# Instead of at the start of the whole thing"
# Menu state
# Hold cursor positions, current character etc etc etc

class DataBox
	attr_accessor :type
	attr_accessor :text
	attr_accessor :icon
	attr_accessor :misc

	def initialize(type,text,icon="",misc="")
		@type = type
		@text = text
		@icon = icon
		@misc = misc
	end

end

class MenuData

	attr_accessor :actor
	attr_accessor :category
	attr_accessor :tab

end"#==============================================================================
# ** Game_Party
#==============================================================================

class Game_Party

  attr_accessor :active                  # actors
  attr_accessor :reserve                  # reserve party

  attr_reader   :gold                     # amount of gold

  attr_accessor :all_actors

  attr_reader :leader

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    # Create all actors    
    @actors = {}
    $data.actors.each{ |k,v| 
      battler = Game_Battler.new
      battler.init_actor(k)
      @actors[k] = battler 
    }    

    # Create actor array
    @active = []
    @reserve = []

    # Initialize amount of gold
    @gold = 0

    # Create amount in possession hash for items, weapons, and armor
    @items = {}
    @weapons = {}
    @armors = {}
    
    # TEMP DISABLE
    set_active("boy")
    set_active("ing")
    set_active("phy")
    set_active("rob")

    @leader = 'ing'

    @actors["boy"].learn('fireburn')
    @actors["boy"].learn('flames')

  end

  #--------------------------------------------------------------------------
  # * Getting Maximum Level
  #--------------------------------------------------------------------------
  def max_level
    return @actors.max_by(&:level).level
  end

  def actor_by_id(actor)
    return @actors[actor]
  end

  def actor_by_index(idx)
    return @actors[@active[idx]]
  end

  #--------------------------------------------------------------------------
  # * Add an Actor
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def set_active(actor)

    # if @active.size < 4 and not @actors.include?(actor)
      
      @active.push(actor)

    # end
   # if !@active.include?(actor)
   #    @reserve.push(actor)
   #  end

  end

  def set_reserve(actor)
    @reserve.push(actor)
  end

  def back_to_pavillion(actor)
    @actors.delete(actor)
    @reserve.delete(actor)
  end

  #--------------------------------------------------------------------------
  # * Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def add_item(id,n) add(@items,id,n) end
  def lose_item(item,n) add(@items,id,n) end
  def item_number(id) count(@items,id) end
  def has_item?(id) count(type,id) > 0 end



  def add(type,id,number)
    type.has_key?(id) ? type[id] += number : type[id] = number
  end

  def count(type,id)
    return type.has_key?(id) ? type[id] : 0
  end

  #--------------------------------------------------------------------------
  # * Determine Everyone is Dead
  #--------------------------------------------------------------------------
  def all_dead?
    return @active.select{ |a| @actors[a].hp > 0}.empty?
  end

  #--------------------------------------------------------------------------
  # * Slip Damage Check (for map)
  #--------------------------------------------------------------------------
  def check_map_slip_damage
    for actor in @active + @reserve
      if actor.hp > 0 and actor.slip_damage?
        actor.hp -= [actor.maxhp / 100, 1].max
        if actor.hp == 0
          $audio.play_se($data_system.actor_collapse_se)
        end
        $map.world.start_flash(Color.new(255,0,0,128), 4)
        $temp.gameover = $party.all_dead?
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # â check if actor is in party
  #--------------------------------------------------------------------------  
  def has_member?(guy)
    return (@active + @reserve).include?(guy)
  end

  #--------------------------------------------------------------------------
  # â check if all actors are 'normal' state
  #--------------------------------------------------------------------------  
  def all_normal
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        if (actor.states & ([1] + BAD_STATES)).size > 0 # non-shield status inflicted
          return false
        end
      end
    end
    
    return true
  end

  #--------------------------------------------------------------------------
  # â remove inflictions
  #--------------------------------------------------------------------------  
  def remove_inflictions()
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        for state in BAD_STATES
          actor.remove_state(state, true)
        end
      end
    end
  end

  #--------------------------------------------------------------------------
  # â Actor Lineup
  #   Provides a list of party members
  #-------------------------------------------------------------------------- 
  def actor_lineup()
    @lineup = []
    for i in 1..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil and !@lineup.include?(actor) && $game_player.is_present(actor.id)
        @lineup.push(actor)
      end
    end
  end
        
end"Qclass Progress

	#attr_accessor :quests, :complete
	#attr_accessor :progress


	def initialize
		@quests = []
		@complete = []
		@progress = 0
	end

	def add_quest(q)
		@quests.push(q)
		$map.need_refresh = true
		log_info("Quest Added: #{q}")
	end

	def end_quest(q)
		@quests.delete(q)
		@complete.push(q)
		$map.need_refresh = true
		log_info("Quest Ended: #{q}")
	end

	def quest_active?(q)
		return @quests.include?(q)
	end

	def quest_complete?(q)
		return @complete.include?(q)
	end

	def progress(pro)
		@progress= $data.progress[pro]
		$map.need_refresh = true
		log_info("Progress Set: #{pro}")
	end

	def get_progress
		return @progress
	end

	def progress?(progress)
	    return false if !$data.progress.include?(progress)
		return @progress >= $data.progress[progress]
	end

	def beyond?(progress)
		return false if !$data.progress.include?(progress)
		return @progress > $data.progress[progress]
	end

	def before?(progress)
		return false if !$data.progress.include?(progress)
		return @progress < $data.progress[progress]
	end

end"class State

	def initialize

		@flags = []
		@vars = {}

		# Event modifiers
		@states = {} # Event states
		@locs = {}
		@deleted = []
		@disabled = []

		# Menu indexes?

	end

	def flag(f)
		@flags.push(f) if !@flags.include?(f)
		$map.need_refresh = true
	end

	def unflag(f)
		@flags.delete(f)
		$map.need_refresh = true
	end

	def flag?(f)
		return @flags.include?(f)
	end

	def var(v,a)
		if @vars.has_key?(v)
			@vars[v] += a
		else
			@vars[v] = a
		end
		$map.need_refresh = true
	end

	def unvar(v,a)
		if @vars.has_key?(v)
			@vars[v] -= a
		else
			@vars[v] = -a
		end
		$map.need_refresh = true
	end

	def var?(v,t)
		return false if !@vars.has_key?(v)
		return @vars[v] >= t
	end

	def state(e,s)
		@states[[$map.id,e,s]] = true
		$map.need_refresh = true
	end

	def unstate(e,s)
		@states[[$map.id,e,s]] = false
		$map.need_refresh = true
	end

	def state?(e,s)
		return false if !@states.has_key?([$map.id,e,s])
		return @states[[$map.id,e,s]]
	end

	def loc(e)
		@locs[[$map.id,e]] = [e.x,e.y]
	end
	def nloc(e)

	end

	def loc?(e)
		return @locs.has_key?([$map.id,e])			
	end

	def getloc(e)
		return @locs[[$map.id,e]]
	end



	def delete(e)
		@deleted.push([$map.id,e])
	end

	def delete?(e)
		return @deleted.include?([$map.id,e])
	end

	def disable(e)
		@disabled.push([$map.id,e])
	end

	def disable?(e)
		return @disabled.include?([$map.id,e])
	end

	def enable(e)
		@disabled.delete([$map.id,e])
	end

end
"+#==============================================================================
# ** Scene_Map
#==============================================================================

# Phases

# Rename actor to active_battler

class Scene_Battle

  attr_accessor :hud
  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    Graphics.freeze

    @phase = :intro_init
    @wait_frames = 0
    @active_battler = nil

    # Auto viewports to fullscreen and set z in init
    @vp = Viewport.new(0, 0, $game.width, $game.height)
    @vp_pops = Viewport.new(0,0,$game.width,$game.height)
    @vp_hud = Viewport.new(0, 0, $game.width, $game.height)
    @vp.z = 6000  
    @vp_pops.z = 6500
    @vp_hud.z = 7500

    @dbg_phase = Sprite.new(@vp_hud)
    @dbg_phase.bitmap = Bitmap.new(150,30)

    #@panorama = Sprite.new(@vp)
    #@panorama.z = -100

    @map = Game_Map.new
    @map.setup($battle.map)

    @player = Game_Player.new
    
    # Get rid of this after figuring out camera pos as pos instead of event
    $player = @player 
    #@player.moveto(5,5)
    #@map.camera_to(@player)
    @map.camera_xy(5,15)
    @map.cam_oy = 150
    @map.do(go("cam_oy",-150,3500,:quad_in_out))    

    @tilemap = MapWrap.new(@vp) 
    @tilemap.refresh(@map)

    @character_sprites = []
    @map.events.keys.sort.each{ |i|
      sprite = Sprite_Character.new(@vp, @map.events[i])
      @character_sprites.push(sprite)
    }

    # Create Hud Elements
    @hud = BattleHud.new(@vp_hud)
    @actor_cmd = ActorCmd.new(@vp_hud)
    @skill_cmd = SkillCmd.new(@vp_hud)
    @target_cmd = TargetCmd.new(@vp_hud)

    # Prepare battler events
    [0,1,2,3].each{ |i| 
      ev = @map.event_by_evname("A.#{i}")
      act = $party.actor_by_index(i).id
      ev.character_name = "Player/#{act}-idle"
      ev.pattern = rand(4)
      ev.step_anime = true
      if $party.active.count > i
        $party.actor_by_index(i).ev = ev
      end
    }
    [0,1,2,3,4].each{ |i| 
      ev = @map.event_by_evname("E.#{i}") 
      if $battle.enemies.count > i
        $battle.enemies[i].ev = ev
      end
    }



    # Poppers
    @poppers = []


    Graphics.transition(50,'Graphics/System/trans')  
            
  end
  
  def terminate
    @map.dispose
    @character_sprites.each{ |s| s.dispose }    
  end

  def busy?
    return false
  end

  def wait(w)
    @wait_frames = w
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------

  def update

    @hud.update
    @map.update    
    @character_sprites.each{ |s| s.update }

    # Remove pops that are invisible
    @poppers.each{ |p| p.dispose if p.done? }
    @poppers.delete_if{ |p| p.disposed? }

    @poppers.each{ |p| p.update }

    # Draw phase
    @dbg_phase.bitmap.fill(Color.new(0,0,0))
    @dbg_phase.bitmap.draw_text(10,0,150,30,@phase.to_s,0)

    update_phase

  end

  def update_phase

    # Wait count here
    if @wait_frames > 0
      @wait_frames -= 1
      return
    end

    case @phase

      # Introduction Phase
      when :intro_init
        phase_intro_init

      # Actor Phase
      when :actor_init
        phase_actor_init
      when :actor_action
        phase_actor_action
      when :actor_skill
        phase_actor_skill
      when :actor_item
        phase_actor_item
      when :actor_target
        phase_actor_target
      when :actor_next
        phase_actor_next

      # Battle phase
      when :main_init
        phase_main_init
      when :main_prep
        phase_main_prep
      when :main_start
        phase_main_start
      when :main_attack
        phase_main_attack
      when :main_defend
        phase_main_defend
      when :main_hit
        phase_main_hit
      when :main_crit
        phase_main_crit
      when :main_state
        phase_main_state
      when :main_next
        phase_main_next

      # Victory Phase
      when :victory_init
        phase_victory_init

    end

  end


  def pop_dmg(target,amount)
    #ev = gev(target)
    pop = Popper.new(@vp_pops)
    pop.value = 0#amount #- amount/10
    pop.x = target.screen_x-200-20
    pop.y = target.screen_y-40-12+45
    @poppers.push(pop)

    pop.opacity = 1
    pop.do(go("value",amount,700,:quad_in_out))
    pop.do(sequence(go("opacity",254,500),go("opacity",0,1500),go("opacity",-255,500)))
    pop.do(sequence(go("y",-30,500,:quad_in_out),go("y",-20,1500),go("y",-30,500,:quad_in_out)))


  end

  def pop_crit(target)

  end



end"[
class Scene_Battle

  def phase_intro_init
    @phase = :actor_init
  end

end"

class Scene_Battle

  # Could auto do next actor
  def phase_actor_init
    @actor_idx = -1  
    @phase = :actor_next
    return
  end

  def phase_actor_action

    @actor_cmd.update

    if $input.cancel?
      return actor_prev
    end

    # Player command inputs section
    if $input.action?

      action = @actor_cmd.get_action
      @actor_cmd.close

      #log_info "ACTIOn"
      #log_info action

      # HMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
      if action == "items"

      else
        skills = @active_battler.skills_for(action)
      end

      #log_info(skills)

      # If a multi-skill open the menu
      if skills.count > 1

        # Open skill_cmd

      else

        select_skill(skills[0])        

      end

    end 

  end

  #==============================================================================
  # ** actor_skill
  #==============================================================================

  def phase_actor_skill

    @skill_cmd.update

    if $input.cancel?
      @actor_idx -= 1
      @phase = :actor_next
      return
    end

    if $input.action?

    end

  end

  #==============================================================================
  # ** actor_item
  #==============================================================================

  def phase_actor_item

    @skill_cmd.update

    if $input.cancel?
      @actor_idx -= 1
      @phase = :actor_next
      return
    end

    if $input.action?

    end

  end

  #==============================================================================
  # ** actor_target
  #==============================================================================

  def phase_actor_target

    @target_cmd.update

    if $input.cancel?
      @target_cmd.close
      # Switch to actor_action instead
      # Then actor prev could combine into a actor_skill that could do items also
      @actor_idx -= 1
      @phase = :actor_next
      return
    end

    if $input.action?
      @active_battler.target = @target_cmd.active
      @target_cmd.close
      @phase = :actor_next
      return
    end

  end  

  def phase_actor_next

    @actor_idx += 1
    if @actor_idx >= $party.active.count
      @actor_cmd.close
      @phase = :main_init
      return
    end

    @phase = :actor_action 
    @active_battler = $party.actor_by_index(@actor_idx)
    @actor_cmd.setup(@active_battler)
    
  end

  #==============================================================================
  # ** select_skill
  #==============================================================================
  # Select a skill and decide whether targeting phase is needed

  def select_skill(id)

    @active_battler.skill_id = id

    log_info(id)

    # If single, targetable?
    if ["one","ally"].include?($data.skills[id].scope)
      targets = $battle.enemies #$battle.build_target_list(@active_battler)
      @target_cmd.setup(targets)
      @phase = :actor_target      
    else
      @phase = :actor_next
      return
    end

  end



  def actor_prev
    return if @actor_idx == 0
    @actor_idx -= 1
    @active_battler = $party.actor_by_index(@actor_idx)
    @actor_cmd.setup(@active_battler)
  end

end"	
class Scene_Battle

  def phase_main_init
   	
    # Choose enemy actions
    $battle.enemies.each{ |e|
    	e.choose_action
    }

    # Determine order of attacks
    @battle_queue = $battle.build_attack_queue
    
    # certain attacks always go first, robin's team move with phye for example

	  @active_battler = @battle_queue.shift
	  @phase = :main_prep

  end

  # Prepare attack of next guy to attack, next_actor called before this
  def phase_main_prep

  	# Calculate results now, then play out the anims
  	@attack_plan = $battle.build_attack_plan(@active_battler)

    @attack_round = @attack_plan.next_attack

  	@phase = :main_start

  end

  # Start a round of the attack
  def phase_main_start

    # Calculate damage here and now
    @attack_results = $battle.build_attack_results(@active_battler,@attack_round.skill)

    # Attack anim if there is one
    @phase = :main_attack
    wait(20)

  end

  # Show anim on attacker
  def phase_main_attack

    # Hit anim if there is one
    if @attack_round.anim_a == nil
      @phase = :main_defend # RENAME TO MAIN_ANIM_HIT
      return
    end

    @phase = :main_defend
    wait(20)

  end

  # Show anim on defender
  def phase_main_defend

    # Hit anim if there is one
    if @attack_round.anim_b == nil
      @phase = :main_hit # RENAME TO MAIN_ANIM_HIT
      return
    end

  	# Onto the next
  	@phase = :main_hit
    wait(20)

  end

  def phase_main_hit

    # Show the damage of @attack-result on each guy hit
    # Better figure damage pops
    @attack_results.each{ |result|

        pop_dmg(result.target.ev,result.damage)

    }

    # Onto the next
    @phase = :main_crit
    wait(20)

  end

  def phase_main_crit

    # Onto the next

    @phase = :main_state
    wait(20)

  end

  def phase_main_state

    # Onto the next
    @phase = :main_next
    wait(20)

  end

  def phase_main_next

  	# If a multi stage, go back to attack
    if !@attack_plan.done?
      @active_attack = @attack_plan.next_attack
      @phase = :main_start
      return
    end

  	# Onto the next battler
	  if !@battle_queue.empty?
		
  		# Good place to check for end of battle also
	 	  @active_battler = @battle_order.shift
	   	@phase = :main_prep
      return

    end

    # Go to next turn, actor select
    @phase = :actor_init


	end

end
"E
class Scene_Battle

  def phase_victory_init

  end

end"q#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Map

  attr_reader :hud


  attr_reader :overlay
  attr_reader :debug

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize


    # Make viewports - Also in the scene
    @vp_main = Viewport.new(0,0,$game.width,$game.height)   
    @vp_overlay = Viewport.new(0,0,$game.width,$game.height)
    @vp_ui = Viewport.new(0,0,$game.width,$game.height)

    # Prep model
    @map = Game_Map.new
    $map = @map
    @map.setup($data.system.start_map_id)

    @player = Game_Player.new
    $player = @player
    @player.moveto($data.system.start_x, $data.system.start_y)

   # @map.camera_to(@player)

    # Make tilemap
    #@panorama = Plane.new(@vp_main,-1000)
    @tilemap = MapWrap.new(@vp_main)
    @character_sprites = []  

    # weather in map data
    @weather = nil

    @overlay = Sprite.new(@vp_overlay)
    @overlay.bitmap = Bitmap.new($game.width,$game.height)
    @overlay.bitmap.fill(Color.new(0,0,0))
    @overlay.opacity = 0
    @overlay.z = 999
    
    # UI
    @hud = Ui_Screen.new(@vp_ui)

    @debug = Sprite.new(@vp_overlay)
    @debug.bitmap = Bitmap.new($game.width,$game.height)
    @debug.bitmap.font = $fonts.debug_min

    # TESTING THE SPARKS
    @sparks = []

    #Graphics.transition
    Graphics.transition(20,'Graphics/System/trans') 
            
  end
  
  def terminate

    # Dispose of tilemap  
    @panorama.dispose  
    @tilemap.dispose
    @character_sprites.each{ |s| s.dispose }
    @weather.dispose  
    @hud.dispose
    
    # Dispose of viewports
    @vp_main.dispose
    @vp_ui.dispose

  end

  def busy?
    return @hud.busy?
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update

    @debug.bitmap.clear

    # Update the sparks
    @sparks.each{ |s| 
      s.ox = @map.display_x/4
      s.oy = @map.display_y/4
      s.update 
    }


    @map.update      
    @player.update

    @hud.update

    # check for changes
    refresh_tileset if $map.tileset_id != @tilemap.tileset_id

    #refresh_panorama if @panorama_name != @map.tileset.panorama_name

    # Update tilemap
    @tilemap.ox = @map.display_x / 4
    @tilemap.oy = @map.display_y / 4
    @tilemap.update

    # Update panorama plane
    #@panorama.ox = 0 # $map.display_x / 8
    #@panorama.oy = 0 # $map.display_y / 8

    # # Update character sprites
    @character_sprites.each{ |s|
      s.update
    }

  
    # Set screen color tone and shake position
    #@vp_main.tone = @tone

    # Open Menu at player's request
    unless @map.interpreter.running? or @hud.busy?

      # Check inputs
      if $input.cancel? || Input.trigger?(Input::F7)
        $game.push_scene(Scene_Menu.new)
      end

    end
    
  end

  def add_spark(x,y)

    # Spawn spark
    sprk = Spark.new("magic",@vp_main)
    
    #x = @sprites.x + @cx+size.width
    #y = @sprites.y + @cy

    dx = -@map.display_x/4
    dy = -@map.display_y/4
    sprk.center(x+3-dx,y+3-dy)
    sprk.blend_type = 1
    @sparks.push(sprk)

  end

  #--------------------------------------------------------------------------
  # * Refresh Tileset
  #--------------------------------------------------------------------------
  def refresh_tileset
    
    @tilemap.refresh(@map)

    @character_sprites.each{ |s| s.dispose }
    @character_sprites = []

    @map.events.keys.sort.each{ |i|
      sprite = Sprite_Character.new(@vp_main, @map.events[i])
      @character_sprites.push(sprite)
    }

    @character_sprites.push(Sprite_Character.new(@vp_main, @player))

  end

  def refresh_panorama
      @panorama_name = $map.tileset.panorama_name
      if @panorama.bitmap != nil
        @panorama.bitmap.dispose
        @panorama.bitmap = nil
      end
      if @panorama_name != ""
        @panorama.bitmap = Cache.panorama(@panorama_name)
      end
      Graphics.frame_reset
  end

end
"Ö#==============================================================================
# ** Scene_Menu
#==============================================================================

class Scene_Menu
  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    Graphics.freeze

    # Vp
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 5000

    # Background
    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = $cache.menu_background("sample")
    #@bg.do(repeat(sequence(go("x",-50,7000),go("x",50,7000))))

    # Choose background by location

    # The current menu
    @menu = Mnu_Main.new(@vp)
    @sub = nil

    Graphics.transition(20,'Graphics/System/trans')     

  end
  
  def terminate

    @menu.dispose if @menu != nil
    @sub.dispose if @sub != nil
    @bg.dispose

    @vp.dispose

  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    if @sub == nil || @sub.closed
      @menu.update
    else
      @sub.update
    end
    
  end

  def open_sub(menu)
    @menu.close
    @sub = menu
    @sub.open
  end

  def close_sub
    @sub.close
    @sub.dispose
    @menu.open
  end

  def close_all

  end

end" " "ê#==============================================================================
# ** Audio Manager
#==============================================================================

class AudioManager

  def initialize
  	@bgm = nil
  	@bgs = nil
  end

  # send_blank to force start music
  def play_bgm(bgm)
    @bgm = bgm
    return if !$settings.music
    if !FileTest.exists?("Audio/BGM/" + se.name)
      return log_err("Missing Music: #{bgm.name}")
    end
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def play_bgs(bgs)
	  @bgm = bgm
	  return if !$settings.music
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def stop_bgm
    Audio.bgm_stop
  end

  def stop_bgs
    Audio.bgs_stop
  end

  def fadeout_bgm(time)
    @bgm = nil
    Audio.bgm_fade(time * 1000)
  end
  
  def fadeout_bgs(time)
    @bgs = nil
    Audio.bgs_fade(time * 1000)
  end

  def play_me(me)
  	return if !$settings.music
    if !FileTest.exists?("Audio/ME/" + me.name)
      return log_err("Missing ME: #{me.name}")
    end
    Audio.me_play("Audio/ME/" + me.name, me.volume, me.pitch)
  end

  def play_se(se)
    return if !$settings.sound
    if !FileTest.exists?("Audio/SE/" + se.name)
      return log_err("Missing Sound: #{se.name}")
    end
    Audio.se_play("Audio/SE/" + se.name, se.volume, se.pitch)
  end

  #--------------------------------------------------------------------------
  # * Turn on music
  #--------------------------------------------------------------------------
  def enable_music
    Audio.bgm_play("Audio/BGM/" + @bgm.name, @bgm.volume, @bgm.pitch)
    Audio.bgs_play("Audio/BGS/" + @bgs.name, @bgs.volume, @bgs.pitch)
  end     
  
  #--------------------------------------------------------------------------
  # * Turn off music
  #--------------------------------------------------------------------------
  def disable_music
      stop_bgm
      stop_bgs
  end     

end"
class CacheManager

    def initialize
        @cache = {}
    end

    def animation(filename, hue)
      load_bitmap("Graphics/Animations/", filename, hue)
    end
    def autotile(filename)
      load_bitmap("Graphics/Autotiles/", filename)
    end
    def character(filename)
      load_bitmap("Graphics/Characters/", filename)
    end
    def cursor(filename)
      load_bitmap("Graphics/Cursors/", filename)
    end
    def face(filename)
      load_bitmap("Graphics/Faces/", filename)
    end
    def fog(filename, hue)
      load_bitmap("Graphics/Fogs/", filename, hue)
    end
    def icon(filename)
      load_bitmap("Graphics/Icons/", filename)
    end

    def menu(filename)
      load_bitmap("Graphics/Menus/", filename)
    end
    def menu_common(filename)
      load_bitmap("Graphics/Menus/Common/", filename)
    end
    def menu_wallpaper(filename)
      load_bitmap("Graphics/Menus/Wallpapers/", filename)
    end
    def menu_background(filename)
      load_bitmap("Graphics/Menus/Backgrounds/", filename)
    end

    def menu_face(filename)
      load_bitmap("Graphics/Menus/Ports/Message/", filename)
    end
    def menu_face_small(filename)
      load_bitmap("Graphics/Menus/Ports/Small/", filename)
    end
    def menu_tab(filename)
      load_bitmap("Graphics/Menus/Tabs/", filename)
    end

    def menu_char(filename)
      load_bitmap("Graphics/Menus/Char/", filename)
    end

    def panorama(filename, hue)
      load_bitmap("Graphics/Panoramas/", filename, hue)
    end
    def picture(filename)
      load_bitmap("Graphics/Pictures/", filename)
    end
    def tileset(filename)
      load_bitmap("Graphics/Tilesets/", filename)
    end
    def title(filename)
      load_bitmap("Graphics/Titles/", filename)
    end
    def windowskin(filename)
      load_bitmap("Graphics/Windowskins/", filename)
    end




    def tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end


    def load_bitmap(folder_name, filename, hue = 0)
      path = folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          begin
            @cache[path] = Bitmap.new(path)
          rescue
            log_err("MISSING GRAPHICS: #{path}")
            @cache[path] = Bitmap.new(32, 32)
          end  
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def clear
      @cache = {}
      GC.start
    end

  end



# module RPG
#   module Cache

#     def self.animation(filename, hue)
#       self.load_bitmap("Graphics/Animations/", filename, hue)
#     end
#     def self.autotile(filename)
#       self.load_bitmap("Graphics/Autotiles/", filename)
#     end
#     def self.character(filename, hue)
#       self.load_bitmap("Graphics/Characters/", filename, hue)
#     end
#     def self.cursor(filename)
#       self.load_bitmap("Graphics/Cursors/", filename)
#     end
#     def self.face(filename)
#       self.load_bitmap("Graphics/Faces/", filename)
#     end
#     def self.fog(filename, hue)
#       self.load_bitmap("Graphics/Fogs/", filename, hue)
#     end
#     def self.icon(filename)
#       self.load_bitmap("Graphics/Icons/", filename)
#     end
#     def self.menu(filename)
#       self.load_bitmap("Graphics/Menus/", filename)
#     end
#     def self.panorama(filename, hue)
#       self.load_bitmap("Graphics/Panoramas/", filename, hue)
#     end
#     def self.picture(filename)
#       self.load_bitmap("Graphics/Pictures/", filename)
#     end
#     def self.tileset(filename)
#       self.load_bitmap("Graphics/Tilesets/", filename)
#     end
#     def self.title(filename)
#       self.load_bitmap("Graphics/Titles/", filename)
#     end
#     def self.windowskin(filename)
#       self.load_bitmap("Graphics/Windowskins/", filename)
#     end
#     def self.tile(filename, tile_id, hue)
#       key = [filename, tile_id, hue]
#       if not @cache.include?(key) or @cache[key].disposed?
#         @cache[key] = Bitmap.new(32, 32)
#         x = (tile_id - 384) % 8 * 32
#         y = (tile_id - 384) / 8 * 32
#         rect = Rect.new(x, y, 32, 32)
#         @cache[key].blt(0, 0, self.tileset(filename), rect)
#         @cache[key].hue_change(hue)
#       end
#       @cache[key]
#     end

#     @cache = {}
#     def self.load_bitmap(folder_name, filename, hue = 0)
#       path = folder_name + filename
#       if not @cache.include?(path) or @cache[path].disposed?
#         if filename != ""
#           @cache[path] = Bitmap.new(path)
#         else
#           @cache[path] = Bitmap.new(32, 32)
#         end
#       end
#       if hue == 0
#         @cache[path]
#       else
#         key = [path, hue]
#         if not @cache.include?(key) or @cache[key].disposed?
#           @cache[key] = @cache[path].clone
#           @cache[key].hue_change(hue)
#         end
#         @cache[key]
#       end
#     end

#     def self.clear
#       @cache = {}
#       GC.start
#     end
#   end
# end"[#==============================================================================
# ** Data Manager
#==============================================================================

class DataManager

  # JsonData
	attr_reader :items
  attr_reader :weapons
  attr_reader :armors

  attr_reader :actors
  attr_reader :enemies
  attr_reader :skills
  attr_reader :states

  attr_reader :progress
  attr_reader :quests
  attr_reader :zones

  # Clone events
  attr_reader :clones

  # RxData
  attr_reader :commons
  attr_reader :tilesets
  attr_reader :system
  attr_reader :mapinfos

	def initialize

    # Create an icon list
    create_icon_list if DEBUG

    # Load up json data
    
    @items = load_json("items",ItemData).merge(load_json("keyitems",ItemData))
    @weapons = load_json("weapons",WeaponData)
    @armors = load_json("armors",ArmorData)

    @actors = load_json("actors",ActorData)
    @enemies = load_json("enemies",EnemyData)
    @skills = load_json("skills",SkillData)
    @states = load_json("states",StateData)
    
    @progress = load_json("progress",ProgressData)
    @quests = load_json("quests",QuestData)
    @zones = load_json("zones",ZoneData)

    @clones = load_clones

		# Convert to json
    # Currently doesn't work in ace
    @commons = load_data("Data/CommonEvents.rxdata")
    @tilesets = load_data("Data/Tilesets.rxdata")
    @system = load_data("Data/System.rxdata")
    @mapinfos = load_data("Data/MapInfos.rxdata")

	end

  def create_icon_list

    list = Dir.glob('Graphics/Icons/**/*').select{ |e| File.file? e }
    list.each_index { |i|
      list[i] = list[i].gsub("Graphics/Icons/","")
      list[i] = list[i].gsub(".png","")
    }

    File.open('Editor/icons.json', 'w') { |file|
      file.puts("[")
      list.each{ |l| file.puts("\""+l+"\",") }
      file.puts("\"\"")
      file.puts("]")
    }

  end

  def load_clones

    clones = {}
    map = load_data("Data/Map001.rxdata")

    map.events.each{ |k,ev|
      dta = ev.name.split('#').first.split('.')
      if dta.count > 1
        name = dta[1].rstrip
      else
        name = dta[0].rstrip
      end
      clones[name] = ev
    }

    return clones

  end

  def load_json(file,type)

    # Load from rxdata if not debug
    if !DEBUG
      return load_data("Data/Json/#{file}.rxdata")
    end

    # Clear out garbage files
    process_data_files(file)

    # If there is no data file, make blank
    if !FileTest.exist?("Editor/json/#{file}.json")
      log_sys "Missing data file: #{file}.json"
      return {}
    end

    # Load up the data
    json_data = File.read("Editor/json/#{file}.json")
    json_data = json_data.gsub(/[:]/, '=>')
    json_data = eval(json_data)

  
    # Create datas
    data = {}
    json_data.each{ |v|
      item = type.new
      v.each{ |var,val|
        # Attempt to convert val to int or float

        item.instance_variable_set("@#{var}", val)
      }
      data[item.id] = item
      
    }

    # Export to rxdata for later
    # Disabled for now to not crowd up github commits
    #save_data(data,"Data/Json/#{file}.rxdata")

    return data

  end

  def process_data_files(file)

    # RIGHT, START AT 50 DOWN TO NOTHING! WHEN FOUND REPLACE THE BASE
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        # Found it! Delete the base and rename this one
        File.delete("Editor/json/#{file}.json")
        File.rename("Editor/json/#{file}(#{idx}).json","Editor/json/#{file}.json")
        break
      end
      idx -= 1
    end

    # Delete any with brackets
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        File.delete("Editor/json/#{file}(#{idx}).json")
      end      
      idx -= 1
    end

  end

 end"X#==============================================================================
# ** Debug
#==============================================================================

def log_err(msg) $debug.log(msg,'ERROR') end
def log_scr(msg) $debug.log(msg,'SCRIPT') end
def log_info(msg) $debug.log(msg,'INFO') end
def log_sys(msg) $debug.log(msg,'SYSTEM') end
def log_ev(msg) $debug.log(msg,'EVENT') end

class DebugManager

	OSD_OPACITY = 230

	INFO_COLOR = Color.new(220,171,1,OSD_OPACITY)
	SCRIPT_COLOR = Color.new(128,0,64,OSD_OPACITY)
	ERROR_COLOR = Color.new(202,0,0,OSD_OPACITY)
	SYSTEM_COLOR = Color.new(128,0,128,OSD_OPACITY)
	EVENT_COLOR = Color.new(0,128,128,OSD_OPACITY)

	attr_reader :last_color

	def initialize		
		return if !DEBUG

		$DEBUG = true

		# Prepare log file
		@path = $appdata + "\\log.txt"
		File.open(@path, 'w') { |file| }	

		
		# Prepare on screen log
		@viewport = Viewport.new(0,0,640,480)
		@viewport.z = 8888
		
		@console = DebugConsole.new(@viewport)

		@menu = DebugMenu.new(@viewport)

		@last_color = INFO_COLOR

	end	

	def update
		return if !DEBUG

		@console.update if !@menu.active?
		@menu.update if !@console.active?

	end



	def log(msg,type='LOG')
	    return if !DEBUG

	    msg = "NIL" if msg == nil
	    if msg.is_a?(Array)
	    	msg = "Array: "+msg.join(", ")
	    end
	    if msg.is_a?(Hash)

	    end
		out = type + "\t" + msg.to_s
		File.open(@path, 'a') { |file| file.puts(out) }

		out = msg.to_s
		color = nil

		case type
			when 'INFO'; color = INFO_COLOR
			when 'SCRIPT'; color = SCRIPT_COLOR
			when 'ERROR'; color = ERROR_COLOR
			when 'SYSTEM'; color = SYSTEM_COLOR
			when 'EVENT'; color = EVENT_COLOR
		end

		@console.log([out,color])

		@last_color = color

	end

	def busy?
		return @console.active? || @menu.active?
	end
end"Ó#==============================================================================
# ** Save File Manager
#==============================================================================

# 99 save files
class FileManager
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def any_save_files?
    !Dir.glob('Av4-*.save').empty?
  end
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def file_exists?(which)
    file = 'Av4-'+which+'.save'
    File.exist?($appPath + file)
  end
  
  #--------------------------------------------------------------------------
  # * Create Filename
  #--------------------------------------------------------------------------
  def make_filename()
    file = "Av4-"+$settings.value('active')+".dean"
    return $appdata + file
  end

  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  def save_game
    File.open(make_filename(), "wb") { |file|
      header = make_save_header  
      body = make_save_contents
      Marshal.dump(header, file)
      Marshal.dump(body, file)
      @last_savefile_index = index
    }
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Execute Load (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_game
    File.open(make_filename(), "rb") do |file|
      Marshal.load(file)
      extract_save_contents(Marshal.load(file))
      reload_map_if_updated
      @index = index
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Load Save Header (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_header
    File.open(make_filename(), "rb") do |file|
      return Marshal.load(file)
    end
    return nil
  end
  
  #--------------------------------------------------------------------------
  # * Delete Save File
  #--------------------------------------------------------------------------
  def delete_save_file()
    File.delete(make_filename()) rescue nil
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Header
  #--------------------------------------------------------------------------
  def make_save_header
    header = {}
    header[:progress] = 140
    #header[:characters] = $game_party.characters_for_savefile
    #header[:playtime_s] = $game_system.playtime_s
    header
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Contents
  #--------------------------------------------------------------------------
  def make_save_contents
    contents = {}
    contents[:state]       = $state
    contents[:progress]         = $progress
    contents[:party]      = $party
    contents[:battle]     = $battle

    contents[:map]        = $map
    contents[:player]        = $player
    contents
  end
  
  #--------------------------------------------------------------------------
  # * Extract Save Contents
  #--------------------------------------------------------------------------
  def extract_save_contents(contents)
    $journal       = contents[:journal]
    $flags         = contents[:flags]
    $switches      = contents[:switches]
    $variables     = contents[:variables]
    $states        = contents[:states]
    $harvey        = contents[:harvey]
  end
  
  #--------------------------------------------------------------------------
  # * Get Update Date of Save File
  #--------------------------------------------------------------------------
  def savefile_time_stamp()
    File.mtime(make_filename()) rescue Time.at(0)
  end
  
  #--------------------------------------------------------------------------
  # * Get File Index with Latest Update Date
  #--------------------------------------------------------------------------
  def latest_savefile_index
    savefile_max.times.max_by {|i| savefile_time_stamp(i) }
  end
  
end
"
class FontManager

	attr_reader :debug, :debug_min, :debug_ttl
	attr_reader :message, :namebox

	attr_reader :list

	attr_reader :pop_ttl, :pop_text, :pop_type

	attr_reader :page_ttl, :page_text


	def initialize

		@scratch = Bitmap.new(600,50)


		# Debug Fonts

		@debug = Font.new
	    @debug.name = "Consolas"
	    @debug.size = 22

	    @debug_min = Font.new
	    @debug_min.name = "Consolas"
	    @debug_min.size = 20

	    @debug_ttl = Font.new
	    @debug_ttl.name = "Consolas"
	    @debug_ttl.size = 28


	    # List

	    @list = Font.new
    	@list.name = "Verdana"
    	@list.size = 20 #was 26
    	@list.color = Color.new(245,223,200)


		# Message box

		@message = Font.new
	    @message.name = "Georgia"
	    @message.size = 24
	    @message.color = Color.new(245,223,200)

	    @namebox = Font.new
	    @namebox.name = "Bitter"
	    @namebox.size = 28
	    @namebox.bold = true
	    @namebox.gradient = true
	    @namebox.gradient_color1 = Color.new(255,0,0)
	    @namebox.gradient_color2 = Color.new(245,223,200)


	    # Menus
	    
	    @pop_ttl = Font.new
	    @pop_ttl.name = "Verdana"
	    @pop_ttl.size = 22
	    @pop_ttl.color = Color.new(245,223,200)

	    @pop_text = Font.new
	    @pop_text.name = "Verdana"
	    @pop_text.size = 19
	    @pop_text.color = Color.new(245,223,200)

	   	@pop_type = Font.new
	    @pop_type.name = "Verdana"
	    @pop_type.size = 16
	    @pop_type.color = Color.new(245,223,200)


	    # Page 

	    @page_ttl = Font.new
		@page_ttl.name = "Georgia"
	    @page_ttl.size = 30
	    #@page_ttl.bold = true
	    @page_ttl.color = Color.new(44,44,44)

	   	@page_text = Font.new
		@page_text.name = "Georgia"
	    @page_text.size = 24
	    @page_text.color = Color.new(44,44,44)

	end

	def size(text,font)
		@scratch.font = font
		return @scratch.text_size(text)
	end

end"W#==============================================================================
# ** Game Manager
#==============================================================================

class GameManager

  attr_reader :width, :height

	def initialize

    $game = self

    # Setup font
    Font.default_size = 22
    Font.default_name = "Consolas"

    if ACE_MODE
      Font.default_outline = false
      Font.default_shadow = true
    end

    Graphics.frame_rate = 60
    #resize(853,480)
    resize(640,480)

    @scenes = []

    # Game State Objects
    $progress = Progress.new
    $state = State.new
    $party = Game_Party.new
    $battle = Game_Battle.new    

    # Make scene object (title screen)
    if DEBUG && $settings.debug_skip_title
      push_scene(Scene_Map.new)    
    else
      push_scene(Scene_Splash.new)
    end

  end

  def resize(w,h)
    @width = w
    @height = h
    if ACE_MODE
      Graphics.resize_screen(w,h)
    end
    #set_rez(w,h)
  end

  def push_scene(scene)
    $scene = scene
    @scenes.unshift(scene)
  end

  def pop_scene
    #Graphics.freeze
    @scenes.shift.terminate
    $scene = @scenes[0]
  end

  def quit?
    return false
  end

  def update

    $keyboard.update
    $mouse.update
    $debug.update
    $tweens.update
    Graphics.update
    Input.update
    @scenes[0].update

  end

  def flip_window
    showm = Win32API.new('user32', 'keybd_event', %w(l l l l), '')
    showm.call(18,0,0,0)
    showm.call(13,0,0,0)
    showm.call(13,0,2,0)
    showm.call(18,0,2,0)
  end

end"#============================================================================== 
# ** Input
#==============================================================================

class InputManager

	def dir4
		return 2 if $keyboard.state?(VK_DOWN)
		return 4 if $keyboard.state?(VK_LEFT)
		return 6 if $keyboard.state?(VK_RIGHT)
		return 8 if $keyboard.state?(VK_UP)
		return 0
	end

	def action?
		return $keyboard.press?(VK_ENTER) ||
			   $keyboard.press?(VK_SPACE) 
	end

	def click?
		return $keyboard.press?(VK_LBUTTON)
	end

	def cancel?
		return $keyboard.press?(VK_ESC)
	end

	def left?
		return $keyboard.press?(VK_LEFT)
	end

	def right?
		return $keyboard.press?(VK_RIGHT)
	end

	def up?
		return $keyboard.press?(VK_UP)
	end

	def down?
		return $keyboard.press?(VK_DOWN)
	end

	def shortcut?(s)

	end

	def shift?
		return $keyboard.state?(VK_SHIFT)
	end

end"N#==============================================================================
# ** Keyboard Manager
#==============================================================================


VK_LBUTTON = 1

VK_BS = 8
VK_TAB = 9
VK_ENTER = 13
VK_SHIFT = 16
VK_ESC = 18
VK_SPACE = 32
VK_TILDE = 192

VK_LEFT = 37
VK_UP = 38
VK_RIGHT = 39
VK_DOWN = 40

class KeyboardManager

	KeyState = Win32API.new("user32","GetKeyState",['i'],'i')
	
	def initialize
		@keys_held = {}
	end

	def state?(key)
		check = KeyState.call(key) #& 0x80 == 128
		return !(check == 1 || check == 0)
	end

	def press?(key)
	  if !@keys_held.has_key?(key) && state?(key)
	  	@keys_held[key] = Graphics.frame_count
	  	return true
	  else
	  	return false
	  end
	end 

  def hold?(key)
    return true if press?(key)
    if @keys_held.has_key?(key)
      if (Graphics.frame_count - @keys_held[key]) % 8 == 7
        return true
      end
    end
    return false
  end 

  def down?(key)
    return state?(key)
  end

  def up?(key)
    return !state?(key)
  end

	def update
		@keys_held.delete_if { |k,v| !state?(k)}
	end

	  # http://www.mods.com.au/budapi_docs/Virtual%20Key%20Codes.htm

  def to_char(key)

    shift = $input.shift?

    case key

      when 32; " "
      when 48; shift ? ')' : '0'
      when 49; shift ? '!' : '1'
      when 50; shift ? '@' : '2'
      when 51; shift ? '#' : '3'
      when 52; shift ? '$' : '4'
      when 53; shift ? '%' : '5'
      when 54; shift ? '^' : '6'
      when 55; shift ? '&' : '7'
      when 56; shift ? '*' : '8'
      when 57; shift ? '(' : '9'

      when 65..90; shift ? key.chr.upcase : key.chr.downcase

      when 186; shift ? ':' : ';' 
      when 187; shift ? '+' : '=' 
      when 188; shift ? '<' : ',' 
      when 189; shift ? '_' : '-' 
      when 190; shift ? '>' : '.' 
      when 191; shift ? '?' : '/' 
      
      when 219; shift ? '{' : '[' 
      when 220; shift ? '|' : '\\'
      when 221; shift ? '}' : ']' 
      when 222; shift ? '"' : '\''

      else; ''

    end

  end

end"(#============================================================================== 
# ** Modules.Mouse Input (7.0)              By Near Fantastica & SephirothSpawn
#==============================================================================

class MouseManager

  #--------------------------------------------------------------------------
  # * API Declaration
  #--------------------------------------------------------------------------
  Cursor_Pos = Win32API.new('user32', 'GetCursorPos', 'p', 'i')
  ShowCursor = Win32API.new('user32', 'ShowCursor', 'i', 'l')
  Scr2cli = Win32API.new('user32', 'ScreenToClient', %w(l p), 'i')
  Findwindow = Win32API.new('user32', 'FindWindowA',%w(p p),'l')

  def initialize
    @pos = [0,0]
    @hwnd = Findwindow.call(nil, "Aveyond")
    @sprite = Sprite.new()
    @sprite.z = 10100
    @sprite.ox = 4
    change_cursor("Default")
  end

  def x() @pos[0] end
  def y() @pos[1] end
  
  def position() @pos; end
  def grid() 
    x = (@pos[0] + $map.display_x / 4) / 32
    y = (@pos[1] + $map.display_y / 4) / 32
    return [x.to_i,y.to_i]
  end
  def on_screen?() !(@pos[0] < 0 || @pos[1] < 0 || @pos[0] >= 640 || @pos[1] >= 480); end
        
  #--------------------------------------------------------------------------
  # * Update Mouse Position
  #--------------------------------------------------------------------------
  def update
    
    # Update Position
    pos = [0,0].pack('ll')
    Cursor_Pos.call(pos)
    Scr2cli.call(@hwnd, pos) 
    @pos = pos.unpack('ll')

    # Update sprite pos
    @sprite.x = @pos[0]
    @sprite.y = @pos[1]

    ShowCursor.call(0)#on_screen?.to_i) # on_screen && mouse_mode
    
  end

  def change_cursor(c)
    @sprite.bitmap = $cache.cursor(c)
  end

end

#==============================================================================
# ** Sprite_Mouse
#==============================================================================

class Sprite_Mouse < Sprite

  #--------------------------------------------------------------------------
  # ** Frame Update : Update Event Cursors
  #--------------------------------------------------------------------------
  def update_event_cursors
    
    # If Nil Grid Position
    if Mouse.grid.nil? 
      # Set Default Cursor
      set_bitmap(MouseCursor::Default_Cursor)
      return
    end
    
    # Gets Mouse Position
    x, y = *Mouse.grid
    
    # Gets Mouse Position
    mx, my = *Mouse.position    
    
    # Gets Mouse Event
    event = $game_map.lowest_event_at(x, y)
    
    # If Non-Nil Event or not over map HUD
    unless event.nil? || my >= 448
      # If Not Erased or Nil List
      if event.list != nil && event.erased == false && event.list[0].code == 108
        # Get the cursor to show
        icon = nil
        event.list[0].parameters.to_s.downcase.gsub!(/icon (.*)/) do
          icon = $1.to_s
        end
        
        if !((icon == "talk") || 
           (icon == "touch") || 
           (icon == "fight") || 
           (icon == "examine") || 
           (icon == "point") ||
           (icon == "exit"))
           icon = MouseCursor::Default_Cursor
        end        
        xNPCname = nil 
        if event.list.size > 1 && event.list[1].code == 108
          text = event.list[1].parameters.to_s
          text.gsub!(/[Nn][Aa][Mm][Ee] (.*)/) do
            xNPCname = $1.to_s
          end
        end
        set_bitmap(icon, xNPCname)  
        #self.x = self.x - self.bitmap.width + 24 if self.x + self.bitmap.width > 640
        if event.name != "BOTTOM" # and ["Arrow2", "Arrow4"].include?(icon)
          self.y -= 8
        end
        return
      end
      return
    end
    
    # Set Default Cursor
    set_bitmap(MouseCursor::Default_Cursor)
    
  end
end
"%#==============================================================================
# ** Game_Settings
#==============================================================================

class SettingsManager

  attr_accessor :music
  attr_accessor :sound
  attr_accessor :window
  attr_accessor :effects
  attr_accessor :mouse

  attr_accessor :debug_skip_title
  attr_accessor :debug_draw_fps
  attr_accessor :debug_draw_names
  attr_accessor :debug_draw_sprites # Draw rect under sprites
  

  # In settings
  attr_accessor :last_file_index          # last save file no.

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize

    # Defaults
    @music = false
    @sound = true
    @window = false
    @effects = false
    @mouse = false

    # Debug options - keys 1-9
    @debug_skip_title = true
    @debug_draw_fps = true
    @debug_draw_names = true
    @debug_draw_sprites = false
        
    # Load from settings file real quick   
    File.open($appdata+'\settings.txt', "r").each do |line|
      dta = line.split(" ")
      val = dta[1]
      if val.to_i.to_s == val
        val = val.to_i
      elsif val.to_f.to_s == val
        val = val.to_f
      elsif val == "true"
        val = true
      elsif val == "false"
        val = false
      end
      self.instance_variable_set(dta[0],val)
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Get/Set Settings
  #--------------------------------------------------------------------------
  def save() 
    File.open($appdata+'\settings.txt', 'w') { |file|  
      # Write some stats      
      self.instance_variables.each{ |var|
        next if !DEBUG && var.to_s.include?("debug")
        file.puts(var.to_s+" "+self.instance_variable_get(var).to_s)
      }
    }
  end

  def conclude
    @window = Win32API.new('Utils', "IsFullScreen", ["V"], "I").call
  end

end"Õ
class SteamManager

	def initialize
		# Sync with steam

		#dll, func, send, rec

		# Steam test
		log_info "STARTING STEAM"
    	log_info Win32API.new('System/steamstub', "OpenSteam", "I", "I").call(364270)
		log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	
    	log_info Win32API.new('System/steamstub', "GetSteamAchievement", "P", "I").call("START_GAME")
log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	log_info Win32API.new('System/steamstub', "SetSteamAchievement", "P", "I").call("START_GAME")
log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	log_info Win32API.new('System/steamstub', "GetSteamAchievement", "P", "I").call("START_GAME")
    	log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	#stats =  Win32API.new('System/steam_api', "SteamUserStats", ["V"], "P").call     	

	end


	def unlock(ach)

	end

	def card(crd)

	end

end"ö#==============================================================================
# ** Nano Manager
#==============================================================================

class TweenManager

	def initialize
		@tweens = []
		@last = Time.now
	end

	def update

		# calc delta
		delta = ((Time.now - @last) * 1000).to_i
		@last = Time.now

		@tweens.delete_if{ |n| (n.is_a?(Sprite) && n.disposed?) || n == nil || n.done? }
	    @tweens.each{ |n| n.update(delta) }

	end

	def register(tween)
		@tweens.push(tween)
	end

	def clear(object)
		@tweens.delete_if{ |n| n.parent == object } 
	end

	def clear_all
		@tweens.clear
	end

	def done?(object)
		return @tweens.select{ |n| n.parent == object }.empty?
	end

end"øclass Bitmap

	def fill(color)
		self.fill_rect(0,0,self.width,self.height,color)
	end

	def fill_rand
		self.fill_rect(0,0,self.width,self.height,Color.new(rand(255),rand(255),rand(255)))
	end

	# xp windowskin style
	def windowskin(skin)
		src = $cache.windowskin(skin)
		dest = rect.dup
		dest.x += 3
		dest.y += 3
		dest.width -= 6
		dest.height -= 6
		stretch_blt(dest,src,Rect.new(0,0,128,128),210)

		w = 16
		h = 16
		sx = 128
		sy = 0

		o = 255

		# CORNERS
	    blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
	    blt(width-w,0,src,Rect.new(sx+48,sy,w,h),o) # top right
	    blt(0,height-h,src,Rect.new(sx,sy+48,w,h),o) # bottom left
	    blt(width-w,height-h,src,Rect.new(sx+48,sy+48,w,h),o) # bottom right
	    
	    #dest_rect, bmp, src_rect

	   #  # Middle
	   #stretch_blt(Rect.new(w,h,width-16,height-16),src,Rect.new(sx+16,0,w,h),o)

	   #  # left side
	   stretch_blt(Rect.new(0,h,w,height-32),src,Rect.new(sx,h+16,w,h),o)

	   #  # Right
	     stretch_blt(Rect.new(width-w,h,w,height-32),src,Rect.new(sx+48,h,w,h),o)

	   #  #top
	   stretch_blt(Rect.new(w,0,width-32,h),src,Rect.new(sx+16,0,w,h),o)

	   # #bottom
	   stretch_blt(Rect.new(w,height-h,width-32,h),src,Rect.new(sx+16,h+32,w,h),o)


	end

	def borderskin(src)

		# 32px corners, 64px edges

		w = 32
		h = 32

		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(96,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,96,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(96,96,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-64),src,Rect.new(0,h+16,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-64),src,Rect.new(96,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-64,32),src,Rect.new(32,0,64,32))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-64,32),src,Rect.new(32,96,64,32))

	end

	def skin(src)
		
		w = src.width/3
		h = src.height/3


		# Inside
		dest = Rect.new(w,h,width-w,height-h)
		srect = Rect.new(w,h,w,h)
		stretch_blt(dest,src,srect)
    	
		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(w*2,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,h*2,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(w*2,h*2,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-h),src,Rect.new(0,w,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-h),src,Rect.new(w*2,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-w,h),src,Rect.new(w,0,w,h))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-w,h),src,Rect.new(w,h*2,w,h))




	end

	def vskin(src)
		size = src.height/3
    	blt(0,0,src,Rect.new(0,0,src.width,size)) # top left
    	blt(0,height-size,src,Rect.new(0,size*2,src.width,size)) # bottom right    
    	stretch_blt(Rect.new(0,size,size,height-size),src,Rect.new(0,size,src.width,size))
	end

	def hskin(src)
		size = src.width/3
    	blt(0,0,src,Rect.new(0,0,size,src.height)) #left
    	blt(width-size,0,src,Rect.new(size*2,0,size,src.height)) # bottom right    
    	stretch_blt(Rect.new(size,0,width-size*2,src.height),src,Rect.new(size,0,size,src.height))
	end

end
"n
class ItemData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class WeaponData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class ArmorData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class SkillData
	attr_reader :id
	attr_reader :name
	attr_reader :book
	attr_reader :description
	attr_reader :hits
	attr_reader :scope
	attr_reader :anim_a
	attr_reader :anim_b
	attr_reader :stats
	attr_reader :effects
end

class StateData

end

class ActorData
	attr_reader :id
	attr_reader :name
	attr_reader :profile
	attr_reader :actions
	attr_reader :resource
	attr_reader :slots
	attr_reader :statratings
end

class EnemyData

end

class ZoneData
	attr_reader :id
	attr_reader :bgm
	attr_reader :bgs
	attr_reader :tint
	attr_reader :weather
end

class ProgressData
	attr_reader :category
	attr_reader :id
	attr_reader :value
end

class QuestData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	#attr_reader :category
	#attr_reader :icon
	#attr_reader :price
	#attr_reader :action
end
"+#==============================================================================
# ** Gradient Font Color
#------------------------------------------------------------------------------
#   Original code by poccil
#   Rewritten by Dargor, 2008
#   05/07/08
#   Version 1.0
#------------------------------------------------------------------------------
#   VERSION HISTORY:
#    - 1.0 (05/07/08), Initial release
#------------------------------------------------------------------------------
#   INSTRUCTIONS:
#    - Paste this above main
#    - Edit the font's gradient parameters in a window like that:
#            self.contents.font.gradient = true/false
#            self.contents.font.gradient_color1 = color
#            self.contents.font.gradient_color2 = color
#            self.contents.font.gradient_mode = mode
#                  Modes: (0 : Vertical, 1: Horizontal, 2: Diagonal)
#    - By default, the gradient effect is on. You can turn it off by
#       setting the @gradient flag in the Font class to false. (*line 47)
#------------------------------------------------------------------------------
#   NOTES:
#       This script is compatible with both XP and VX
#==============================================================================
 
#==============================================================================
# ** Font
#==============================================================================
 
class Font
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :gradient
  attr_accessor :gradient_color1
  attr_accessor :gradient_color2
  
  #--------------------------------------------------------------------------
  # * Alias Listing
  #--------------------------------------------------------------------------
  alias dargor_vx_font_gradient_initialize initialize

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(*args)
     dargor_vx_font_gradient_initialize(*args)
     #@gradient = true
     @gradient_color1 = Color.new(255,255,255)
     @gradient_color2 = Color.new(255,255,255)
  end
  
end
 
#==============================================================================
# ** Bitmap
#==============================================================================
 
class Bitmap
  #--------------------------------------------------------------------------
  # * Alias Listing
  #--------------------------------------------------------------------------
  alias dargor_vx_bitmap_gradient_draw_text draw_text
  #--------------------------------------------------------------------------
  # * Draw Text
  #--------------------------------------------------------------------------
  def draw_text(*args)

     # Original font color
     if self.font.gradient
        
        # Get text variables
        if args[0].is_a?(Rect)
           x = args[0].x
           y = args[0].y
           width = args[0].width
           height = args[0].height
           text = args[1]
           align = args[2].nil? ? 0 : args[2]
        else
           x = args[0]
           y = args[1]
           width = args[2]
           height = args[3]
           text = args[4]
           align = args[5].nil? ? 0 : args[5]
        end

        original_color = self.font.color
        alpha = original_color.alpha.to_f if alpha.nil?
        # Create temporary text bitmap
        text1=Bitmap.new(width, height)
        text2=Bitmap.new(width, height)
        text1.font.size = self.font.size
        text1.font.name = self.font.name
        text1.font.color = self.font.gradient_color2
        text_height = text1.text_size(text).height
        text_width = text1.text_size(text).width
        return if text_width < 1 or text_height < 1

        # Temporary remove the gradient effect
        self.font.gradient = false
        text1.dargor_vx_bitmap_gradient_draw_text(0, 0, width, height, text, align)
        self.font.gradient = true

        # What in the world .....
           text_position = (height / 2) - (text_height / 2)
           for i in 0...height
              if i < text_position
                 opacity = 0
              elsif i > text_position + text_height
                 opacity = 255
              else
                 ratio = ((i - text_position) * 1.0 / text_height)
                 ratio -=(0.5 - ratio) * 0.5
                 opacity = ratio * 255.0
                 opacity = 255.0 if opacity > 255.0
                 opacity = 0.0 if opacity < 0.0
              end
              text2.blt(0, i, text1, Rect.new(0,i,width,1), opacity)
           end


        # Draw gradient text
        self.font.color = Color.new(255,0,0)#self.font.gradient_color1
        self.font.color.alpha = alpha
        # Temporary remove the gradient effect
        self.font.gradient = false
        dargor_vx_bitmap_gradient_draw_text(*args)
        # Temporary remove the gradient effect
        self.font.gradient = true
        self.font.color = original_color
        self.font.color.alpha = 255#alpha
        self.blt(x, y, text2, text2.rect, alpha)
        # Dispose gradient text bitmap
        text1.dispose
        text2.dispose
     else
        # The usual
        dargor_vx_bitmap_gradient_draw_text(*args)
     end

    def draw_special

    end

  end
end"~# if !ACE_MODE
#   class Font
#     attr_accessor :outline, :shadow
#   end
# end


# module RPG
#   class Tileset
#     def initialize
#       @id = 0
#       @name = ""
#       @tileset_name = ""
#       @autotile_names = [""]*7
#       @panorama_name = ""
#       @panorama_hue = 0
#       @fog_name = ""
#       @fog_hue = 0
#       @fog_opacity = 64
#       @fog_blend_type = 0
#       @fog_zoom = 200
#       @fog_sx = 0
#       @fog_sy = 0
#       @battleback_name = ""
#       @passages = Table.new(384)
#       @priorities = Table.new(384)
#       @priorities[0] = 5
#       @terrain_tags = Table.new(384)
#     end
#     attr_accessor :id
#     attr_accessor :name
#     attr_accessor :tileset_name
#     attr_accessor :autotile_names
#     attr_accessor :panorama_name
#     attr_accessor :panorama_hue
#     attr_accessor :fog_name
#     attr_accessor :fog_hue
#     attr_accessor :fog_opacity
#     attr_accessor :fog_blend_type
#     attr_accessor :fog_zoom
#     attr_accessor :fog_sx
#     attr_accessor :fog_sy
#     attr_accessor :battleback_name
#     attr_accessor :passages
#     attr_accessor :priorities
#     attr_accessor :terrain_tags
#   end
# end

# module RPG
#   class System
#     def initialize
#       @magic_number = 0
#       @party_members = [1]
#       @elements = [nil, ""]
#       @switches = [nil, ""]
#       @variables = [nil, ""]
#       @windowskin_name = ""
#       @title_name = ""
#       @gameover_name = ""
#       @battle_transition = ""
#       @title_bgm = RPG::AudioFile.new
#       @battle_bgm = RPG::AudioFile.new
#       @battle_end_me = RPG::AudioFile.new
#       @gameover_me = RPG::AudioFile.new
#       @cursor_se = RPG::AudioFile.new("", 80)
#       @decision_se = RPG::AudioFile.new("", 80)
#       @cancel_se = RPG::AudioFile.new("", 80)
#       @buzzer_se = RPG::AudioFile.new("", 80)
#       @equip_se = RPG::AudioFile.new("", 80)
#       @shop_se = RPG::AudioFile.new("", 80)
#       @save_se = RPG::AudioFile.new("", 80)
#       @load_se = RPG::AudioFile.new("", 80)
#       @battle_start_se = RPG::AudioFile.new("", 80)
#       @escape_se = RPG::AudioFile.new("", 80)
#       @actor_collapse_se = RPG::AudioFile.new("", 80)
#       @enemy_collapse_se = RPG::AudioFile.new("", 80)
#       @words = RPG::System::Words.new
#       @test_battlers = []
#       @test_troop_id = 1
#       @start_map_id = 1
#       @start_x = 0
#       @start_y = 0
#       @battleback_name = ""
#       @battler_name = ""
#       @battler_hue = 0
#       @edit_map_id = 1
#     end
#     attr_accessor :magic_number
#     attr_accessor :party_members
#     attr_accessor :elements
#     attr_accessor :switches
#     attr_accessor :variables
#     attr_accessor :windowskin_name
#     attr_accessor :title_name
#     attr_accessor :gameover_name
#     attr_accessor :battle_transition
#     attr_accessor :title_bgm
#     attr_accessor :battle_bgm
#     attr_accessor :battle_end_me
#     attr_accessor :gameover_me
#     attr_accessor :cursor_se
#     attr_accessor :decision_se
#     attr_accessor :cancel_se
#     attr_accessor :buzzer_se
#     attr_accessor :equip_se
#     attr_accessor :shop_se
#     attr_accessor :save_se
#     attr_accessor :load_se
#     attr_accessor :battle_start_se
#     attr_accessor :escape_se
#     attr_accessor :actor_collapse_se
#     attr_accessor :enemy_collapse_se
#     attr_accessor :words
#     attr_accessor :test_battlers
#     attr_accessor :test_troop_id
#     attr_accessor :start_map_id
#     attr_accessor :start_x
#     attr_accessor :start_y
#     attr_accessor :battleback_name
#     attr_accessor :battler_name
#     attr_accessor :battler_hue
#     attr_accessor :edit_map_id
#   end
# end

# module RPG
#   class System
#     class Words
#       def initialize
#         @gold = ""
#         @hp = ""
#         @sp = ""
#         @str = ""
#         @dex = ""
#         @agi = ""
#         @int = ""
#         @atk = ""
#         @pdef = ""
#         @mdef = ""
#         @weapon = ""
#         @armor1 = ""
#         @armor2 = ""
#         @armor3 = ""
#         @armor4 = ""
#         @attack = ""
#         @skill = ""
#         @guard = ""
#         @item = ""
#         @equip = ""
#       end
#       attr_accessor :gold
#       attr_accessor :hp
#       attr_accessor :sp
#       attr_accessor :str
#       attr_accessor :dex
#       attr_accessor :agi
#       attr_accessor :int
#       attr_accessor :atk
#       attr_accessor :pdef
#       attr_accessor :mdef
#       attr_accessor :weapon
#       attr_accessor :armor1
#       attr_accessor :armor2
#       attr_accessor :armor3
#       attr_accessor :armor4
#       attr_accessor :attack
#       attr_accessor :skill
#       attr_accessor :guard
#       attr_accessor :item
#       attr_accessor :equip
#     end
#   end
# end

# module RPG
#   class System
#     class TestBattler
#       def initialize
#         @actor_id = 1
#         @level = 1
#         @weapon_id = 0
#         @armor1_id = 0
#         @armor2_id = 0
#         @armor3_id = 0
#         @armor4_id = 0
#       end
#       attr_accessor :actor_id
#       attr_accessor :level
#       attr_accessor :weapon_id
#       attr_accessor :armor1_id
#       attr_accessor :armor2_id
#       attr_accessor :armor3_id
#       attr_accessor :armor4_id
#     end
#   end
# end


"I class Array
 	def count
 		return length
 	end
 	def sample
      self[rand(length)]
  	end

 end

 class String
  def is_integer?
    self.to_i.to_s == self
  end
end

class FalseClass; def to_i; 0 end end
class TrueClass; def to_i; 1 end end


class Fixnum
	def odd?
		return self % 2 == 1
	end
end

"# Extensions to sprite class

class Sprite

	def hide
		self.visible = false
	end

	def show
		self.visible = true
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def center(x,y)
		self.x = x - width/2
		self.y = y - height/2
	end

	def width
		return self.bitmap.width
	end

	def height 
		return self.bitmap.height
	end

	def within?(x,y)
		return false if x < self.x
		return false if y < self.y
		return false if x > self.x + width
		return false if y > self.y + height
		return true
	end

end"Ò#==============================================================================
# ** Console
#==============================================================================

class DebugConsole

	INPUT_COLOR = Color.new(30,30,30,210)

	MAX_LOGS = 11


	def initialize(vp)

		# Prepare log
		@history = []
		@console_text = ""
		@console_sprite = Sprite.new(vp)
		@console_sprite.move(0,410)
		refresh_console

		# Showing previous
		@logs = []
		@osd_sprite = Sprite.new(vp)

		hide

	end

	def update

		# If console not showing
		if !active?
			show if $keyboard.press?(VK_TAB) 
		end

		# Hide console if press TILDE
		hide if active? && $keyboard.press?(VK_TAB)
		hide if active? && $keyboard.press?(VK_ESC)

		if !active?
			if $keyboard.state?(VK_BS)
				@osd_sprite.show
			else
				@osd_sprite.hide
			end
		end

		return if !active?

		# Show last
		if $keyboard.press?(VK_DOWN)
			@console_text = @history.empty? ? "" : @history.pop
			refresh_console
		end
									
		# Check console input
		console_chars.each{ |c|
			if $keyboard.press?(c)
				@console_text += $keyboard.to_char(c)
				refresh_console
			end
		}

		# Check inputs now
		if $keyboard.press?(VK_ENTER)
			begin
				eval(@console_text)
			rescue Exception => e
			 	log_scr(e.class.to_s+" --- '" + @console_text + "'")		      
		    end
		    @history.push(@console_text)
			@console_text = ""
			refresh_console
		end

		if $keyboard.hold?(VK_BS)
			@console_text.chop!
			refresh_console
		end

	end

	def hide
		@console_sprite.hide
		@osd_sprite.hide
	end

	def show
		@console_sprite.show
		@osd_sprite.show
	end

	def active?
		return @console_sprite.visible
	end

	def refresh_console
		@console_sprite.bitmap = Bitmap.new(640,60)

		@console_sprite.bitmap.fill_rect(0,0,640,30,INPUT_COLOR)
		@console_sprite.bitmap.draw_text(8,0,640,30,"-> "+@console_text) # Make gfx.width

		if !@history.empty?
			@console_sprite.bitmap.fill_rect(0,30,640,30,Color.new(0,0,0,120))
			@console_sprite.bitmap.draw_text(8,30,640,30,"   "+@history[-1]) # Make gfx.width
		end	

	end

	def refresh_osd

		@osd_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		cx = 0
		cy = 6

		@osd_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@osd_sprite.bitmap.font.size = 28
		@osd_sprite.bitmap.draw_text(cx+8,cy,640,50,"::LOG HISTORY::")

		cy += 60

		@osd_sprite.bitmap.font.size = 22

		@logs.each{ |log|

			out = log[0]
			color = log[1]

			size = @osd_sprite.bitmap.text_size(out)
			@osd_sprite.bitmap.fill_rect(cx,cy,size.width+20,size.height+6,color)
			@osd_sprite.bitmap.draw_text(cx+8,cy+3,600,size.height,out)

			cy += 32

		}

	end

	def log(msg)

		@logs.push(msg)
		@logs.shift while @logs.count > MAX_LOGS
		refresh_osd

	end

	def console_chars
		chars = (48..57).to_a
		chars += (65..90).to_a
		chars += (186..222).to_a
		chars += [32]
		return chars
	end

end"Cmodule Graphics
 
  @fps, @fps_tmp = 0, []
 
  class << self
    
    attr_reader :fps
    
    alias fps_update update unless method_defined?(:fps_update)
    def update

      if !$settings.debug_draw_fps
      	fps_sprite.hide
      	back_sprite.hide
      	fps_update
      	return
      else
		fps_sprite.show
      	back_sprite.show
      end

	  t = Time.now
	  fps_update
	  @fps_tmp[frame_count % frame_rate] = Time.now != t
	  @fps = 0
	  frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
	  fps_sprite.src_rect.y = @fps * 30

	  if @old_color != $debug.last_color
	  	back_sprite.bitmap.fill($debug.last_color)
	  	@old_color = $debug.last_color
	  end

    end
    
    def fps_sprite
	  if !@fps_sprite or @fps_sprite.disposed?
	    @fps_sprite = Sprite.new
	    @fps_sprite.z = 9999
	    @fps_sprite.x = $game.width-45
	    @fps_sprite.y = 16
	    @fps_sprite.bitmap = Bitmap.new(30, 30*62)
	    @fps_sprite.bitmap.font.size = 28
	    @fps_sprite.bitmap.font.name = "Consolas"
	    @fps_sprite.bitmap.font.color.set(255, 255, 255)
	    61.times {|i| @fps_sprite.bitmap.draw_text(-2, i*30, 36, 30, "% 3d"%i)}
	    @fps_sprite.bitmap.draw_text(-2, 61*30, 36, 30, "++")
	    @fps_sprite.src_rect.height = 30
	  end
	  return @fps_sprite
    end

    def back_sprite
	  if !@back_sprite or @back_sprite.disposed?
	    @back_sprite = Sprite.new
	    @back_sprite.z = 9997
	    @back_sprite.x = $game.width-40
	    @back_sprite.y = 16
	    @back_sprite.bitmap = Bitmap.new(30, 30)
	  end
	  return @back_sprite
    end
    
  end
end"7#==============================================================================
# ** Actions
#==============================================================================

class DebugMenu

	def initialize(vp)

		@actions = []
		@idx = 0

		@mnu_sprite = Sprite.new(vp)
		@idx_sprite = Sprite.new(vp)
		@text_sprite = Sprite.new(vp)
		@text_sprite.z += 10

		@idx_sprite.y = 10

		@menu_title = "DEBUG MENU"

		@esc = Proc.new{ hide }

		@cursor_pos = {}

		page(:main)

		hide

	end

	def page(newpage)

		@cursor_pos[@page] = @idx

		clear

		@page = newpage

		case newpage
			when :main

				add(">> General Settings",Proc.new{ page(:settings) })
				add(">> Debug Settings",Proc.new{ page(:debug) })
				
				add("-- Progress: #{$progress.get_progress}",nil) if !$progress.nil?

				@esc = Proc.new{ hide }

			when :settings

				@menu_title = "GENERAL SETTINGS"

				add(":: Toggle Fullscreen",Proc.new{ $game.flip_window })

				@esc = Proc.new{ page(:main) }

			when :debug

				@menu_title = "DEBUG SETTINGS"

				add(":: Toggle skip title - "+$settings.debug_skip_title.to_s.upcase,Proc.new{ $settings.debug_skip_title ^= true })
				add(":: Toggle draw fps - "+$settings.debug_draw_fps.to_s.upcase,Proc.new{ $settings.debug_draw_fps ^= true })
				add(":: Toggle draw names - "+$settings.debug_draw_names.to_s.upcase,Proc.new{ $settings.debug_draw_names ^= true })

				@esc = Proc.new{ page(:main) }

		end
		refresh
	end


	def clear
		#@idx = 0
		@actions.clear
		refresh
	end

	def add(text,proc)
		@actions.push([text,proc])
	end

	def update

		if $keyboard.press?(VK_TILDE)
			active? ? @esc.call : show
		end

		if $keyboard.press?(VK_ESC)
			@esc.call if active?
		end

		return if !active?

		if $keyboard.press?(VK_ENTER)
			@actions[@idx][1].call if @actions[@idx][1] != nil
			page(@page)
		end
		
		if $keyboard.press?(VK_DOWN)
			@idx += 1 if @idx != @actions.count - 1
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		if $keyboard.press?(VK_UP)
			@idx -= 1 if @idx != 0
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		@idx_sprite.y = 66 + (@idx * 34)
		

		#refresh

	end

	def refresh


		@idx = @cursor_pos.has_key?(@page) ? @cursor_pos[@page] : 0

		@mnu_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)
		@text_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		@idx_sprite.bitmap = Bitmap.new(400,30)
		@idx_sprite.bitmap.fill(Color.new(40,110,170,240))

		cx = 0
		cy = 6

		@mnu_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@text_sprite.bitmap.font.size = 28
		@text_sprite.bitmap.draw_text(cx+8,cy,640,50,"::"+@menu_title+"::")

		cy += 60

		@text_sprite.bitmap.font.size = 22

		@actions.each_index{ |i|

			out = @actions[i][0]
			color = Color.new(30,30,30,210)

			size = @mnu_sprite.bitmap.text_size(out)
			@mnu_sprite.bitmap.fill_rect(cx,cy,400,30,color)
			@text_sprite.bitmap.draw_text(cx+8,cy+0,600,size.height+6,out)

			cy += 34

		}

	end


	def show
		page(:main)
		@mnu_sprite.show
		@idx_sprite.show
		@text_sprite.show
	end

	def hide
		@mnu_sprite.hide
		@idx_sprite.hide
		@text_sprite.hide
	end

	def active?
		@mnu_sprite.visible
	end

end


"Ú#==============================================================================
# ** SpellCheck
#==============================================================================

def execute_spellcheck
    
    data = {} # map name, dialogues?
    
    # Each map
    $data_maps.each{ |k,v| 
    
      map_id = k
      map_name = v.name
      
      event_list = load_data(sprintf("Data/Map%03d.rvdata2",map_id)).events
      next if event_list.empty?
      
      events = {}
      
      # Do for each event
      event_list.each{ |k,v|
      
        ev_id = k
        ev_name = v.name
        
        dialogues = []
        
        # Do for each page
        v.pages.each{ |page|
        
        @cmd_idx = 0        
        while page.list[@cmd_idx] do

            # Do something according to command          
            case page.list[@cmd_idx].code
            
              when 101; # Short text
                
                text = ""
                while page.list[@cmd_idx+1].code == 401       # Text data
                  @cmd_idx += 1
                  text += page.list[@cmd_idx].parameters[0]
                  text += ' '      
                end
                dialogues.push(text)
                
              when 105; # Long text
            
                while page.list[@cmd_idx+1].code == 405
                  @cmd_idx += 1
                  line = page.list[@cmd_idx].parameters[0]
                  if line[0] == "@"
                    dialogues[dialogues.size-1] += " " + line
                  else
                    dialogues.push(line)
                  end
                end
            
            end
              
            @cmd_idx += 1  
          
          end # page        
        
        }

        # any dialogues? save it
        if !dialogues.empty?
          #p dialogues
          events[[ev_id,ev_name]] = dialogues
        end
        
      }

      # Add to overall
      if !events.empty?
        data[[map_id,map_name]] = events
      end
      
      #p name
      #p event_list.size
      
      
      #break
      
      
    }
    
    # Output to file
    # Create a new file and write to it  
    File.open('spellcheck.txt', 'w') do |file|  

      # Write some stats
      file.puts("Total Maps: "+$data_maps.size.to_s)
      file.puts("Maps with dialogue: "+data.size.to_s)

      # Word counts
      words = 0
      data.values.each{ |map|
        map.values.each{ |ev|
          ev.each{ |line|
            words += line.split(" ").size
          }
        }
      }
      file.puts("Word Count: "+words.to_s)

      file.puts("\n")
      file.puts("\n")

      # Each Map
      data.each{ |mk,mv|

        # Map name
        file.puts("Map "+mk[0].to_s+": "+mk[1])
        file.puts("----------------------------------------")
        file.puts("\n")

        # Contents
        mv.each{ |ek,ev|

          # Event name
          file.puts("Event "+ek[0].to_s+": "+ek[1])

          # Event contents
          ev.each{ |line|
            file.puts(line)
          }

          file.puts("\n")

        }
        file.puts("\n")
      }

    end  

    
  end"O# Fullscreen++ v2.2 for VX and VXace by Zeus81
# Free for non commercial and commercial use
# Licence : http://creativecommons.org/licenses/by-sa/3.0/
# Contact : zeusex81@gmail.com
# (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
# (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
 
 if ACE_MODE


class << Graphics
  Disable_VX_Fullscreen = false
 
  CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
  GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
  GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
  GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
  GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
  FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
  FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
  ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
  SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
  SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
  SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
  ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
  SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
  UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
  GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
  WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
  CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
  DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
 
  unless method_defined?(:zeus_fullscreen_update)
    HWND     = FindWindow.call('RGSS Player', 0)
    BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
    alias zeus_fullscreen_resize_screen resize_screen
    alias zeus_fullscreen_update        update
  end
private
  def initialize_fullscreen_rects
    @borders_size    ||= borders_size
    @fullscreen_rect ||= screen_rect
    @workarea_rect   ||= workarea_rect
  end
  def borders_size
    GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
    GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
    wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
    Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
  end
  def screen_rect
    Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
  end
  def workarea_rect
    SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
    rect = rect.unpack('l4')
    Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
  end
  def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
  def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
  def hide_back()    ShowWindow.call(BackHWND, 0)              end
  def show_back
    ShowWindow.call(BackHWND, 3)
    UpdateWindow.call(BackHWND)
    dc    = GetDC.call(BackHWND)
    rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
    brush = CreateSolidBrush.call(0)
    FillRect.call(dc, rect, brush)
    ReleaseDC.call(BackHWND, dc)
    DeleteObject.call(brush)
  end
  def resize_window(w, h)
    if @fullscreen
      x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
    else
      w += @borders_size.width
      h += @borders_size.height
      x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
      y = @workarea_rect.y + (@workarea_rect.height - h) / 2
      z = -2
    end
    SetWindowPos.call(HWND, z, x, y, w, h, 0)
  end
  def release_alt
    inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
    SendInput.call(3, inputs, 28)
  end
public
  def load_fullscreen_settings
    buffer = [].pack('x256')
    section = 'Fullscreen++'
    filename = './Game.ini'
    get_option = Proc.new do |key, default_value|
      l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
      buffer[0, l]
    end
    @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
    @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
    @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
    toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
    fullscreen? ? fullscreen_mode : windowed_mode
  end
  def save_fullscreen_settings
    section = 'Fullscreen++'
    filename = './Game.ini'
    set_option = Proc.new do |key, value|
      WritePrivateProfileString.call(section, key, value.to_s, filename)
    end
    set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
    set_option.call('FullscreenRatio', @fullscreen_ratio)
    set_option.call('WindowedRatio'  , @windowed_ratio)
  end
  def fullscreen?
    @fullscreen or vx_fullscreen?
  end
  def vx_fullscreen?
    rect = screen_rect
    rect.width == 640 and rect.height == 480
  end
  def toggle_fullscreen
    fullscreen? ? windowed_mode : fullscreen_mode
  end
  def toggle_vx_fullscreen
    windowed_mode if @fullscreen and !vx_fullscreen?
    inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
    SendInput.call(4, inputs, 28)
    zeus_fullscreen_update
    self.ratio += 0 # refresh window size
  end
  def vx_fullscreen_mode
    return if vx_fullscreen?
    toggle_vx_fullscreen
  end
  def fullscreen_mode
    return if vx_fullscreen?
    initialize_fullscreen_rects
    show_back
    hide_borders
    @fullscreen = true
    self.ratio += 0 # refresh window size
  end
  def windowed_mode
    toggle_vx_fullscreen if vx_fullscreen?
    initialize_fullscreen_rects
    hide_back
    show_borders
    @fullscreen = false
    self.ratio += 0 # refresh window size
  end
  def toggle_ratio
    return if vx_fullscreen?
    self.ratio += 1
  end
  def ratio
    return 1 if vx_fullscreen?
    @fullscreen ? @fullscreen_ratio : @windowed_ratio
  end
  def ratio=(r)
    return if vx_fullscreen?
    initialize_fullscreen_rects
    r = 0 if r < 0
    if @fullscreen
      @fullscreen_ratio = r
      w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
    else
      @windowed_ratio = r
      w_max = @workarea_rect.width  - @borders_size.width
      h_max = @workarea_rect.height - @borders_size.height
    end
    if r == 0
      w, h = w_max, w_max * height / width
      h, w = h_max, h_max * width / height if h > h_max
    else
      w, h = width * r, height * r
      return self.ratio = 0 if w > w_max or h > h_max
    end
    resize_window(w, h)
    save_fullscreen_settings
  end
  def update
    release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
    zeus_fullscreen_update
    toggle_fullscreen if Input.trigger?(Input::F5)
    toggle_ratio      if Input.trigger?(Input::F6)
  end
  def resize_screen(width, height)
    zeus_fullscreen_resize_screen(width, height)
    self.ratio += 0 # refresh window size
  end
end
Graphics.load_fullscreen_settings


end"ê# if ACE_MODE
  
#   def set_rez(width,height)

#     eval "

#     # Do not edit
#     wt, ht = width.divmod(32), height.divmod(32)
#     #wt.last + ht.last == 0 || fail('Incorrect width or height')
#     wh = -> w, h, off = 0 { [w + off, h + off].pack('l2').scan /.{4}/ }
#     w, h = wh.(width, height)
#     ww, hh = wh.(width, height, 32)
#     www, hhh = wh.(wt.first.succ, ht.first.succ)
#     base = 0x10000000  # fixed?
#     mod = -> adr, val { DL::CPtr.new(base + adr)[0, val.size] = val }
#     mod.(0x195F, \"\x90\" * 5)  # ???   
#     mod.(0x19A4, h)
#     mod.(0x19A9, w)
#     mod.(0x1A56, h)
#     mod.(0x1A5B, w)
#     mod.(0x20F6, w)
#     mod.(0x20FF, w)
#     mod.(0x2106, h)
#     mod.(0x210F, h)
#     # speed up y?
#     #mod.(0x1C5E3, h)
#     #mod.(0x1C5E8, w)
#     zero = [0].pack ?l
#     mod.(0x1C5E3, zero)
#     mod.(0x1C5E8, zero)
#     mod.(0x1F477, h)
#     mod.(0x1F47C, w)
#     mod.(0x211FF, hh)
#     mod.(0x21204, ww)
#     mod.(0x21D7D, hhh[0])
#     mod.(0x21E01, www[0])
#     mod.(0x10DEA8, h)
#     mod.(0x10DEAD, w)
#     mod.(0x10DEDF, h)
#     mod.(0x10DEF0, w)
#     mod.(0x10DF14, h)
#     mod.(0x10DF18, w)
#     mod.(0x10DF48, h)
#     mod.(0x10DF4C, w)
#     mod.(0x10E6A7, w)
#     mod.(0x10E6C3, h)
#     mod.(0x10EEA9, w)
#     mod.(0x10EEB9, h)
#     Graphics.resize_screen width, height
#     GC.start"

#   end

# else

#   def set_rez(x,y)
#     log_err "Can't resize in XP mode"
#   end

# end"^#=============================================================================
# * Snapshot script from screenshot.dll, Modified from GAMEGUY's SCRIPT
#=============================================================================
module Snapshot
  def self.snap
    snp = Win32API.new('screenshot.dll', 'Screenshot', %w(l l l l p l l), '')
    window = Win32API.new('user32', 'FindWindowA', %w(p p), 'l')
    ini = (Win32API.new 'kernel32', 'GetPrivateProfileStringA', %w(p p p p l p), 
      'l')
    game_name = '\0' * 256
    ini.call('Game', 'Title', '', game_name, 255, '.\Game.ini')
    game_name.delete!('\0')
    win = window.call('RGSS Player', game_name)
    count = 0
    
    file_name = "Graphics/Pictures/temp_screenshot#{rand(30)}.png"


    log_info 'works to here'

    snp.call(0, 0, 640, 480, file_name, win, 2)
  end
end"1# # Zeus Video Player v2.3 for XP, VX and VXace by Zeus81
# # Free for commercial use
# # Licence : http://creativecommons.org/licenses/by/4.0/
# # Contact : zeusex81@gmail.com
# #
# # How to Use :
# #   Graphics.play_movie( filename, cancellable, fit_to_screen )
# #   - filename = path of the video file.
# #   - cancellable = true if you want to allow the player to stop the video
# #                   by pressing Enter or Escape, false otherwise.
# #                   This option can be omitted and default value is true.
# #   - fit_to_screen = true if you want the video to be stretched to fit the screen in
# #                     case it doesn't match, false if you just want it to be centered.
# #                     If you're using scripts like Fullscreen++ true is recommended.
# #                     This option can be omitted and default value is true.
# #   ex : Graphics.play_movie( "Movies/prout.avi", true, true )
# #   or   Graphics.play_movie( "Movies/prout.avi" )
# #
# # Codec choice :
# #   I haven't tested all of them but I guess wmv9 (standard) would be a good choice.
# #   You can find a list of codecs installed by default on windows here :
# #   http://support.microsoft.com/kb/899113
# #
# # Background Image :
# #   You can choose the background image of the player (in case your video doesn't fill all the space).
# #   It will automatically load the image named "ZeusVideoPlayer" if found in Pictures folder (the extension doesn't matter).
# #   If not found it will be black.
# #
# # Known bugs :
# #  - With some video codecs stretching to fit screen doesn't work in fullscreen mode.
# #  - When switching fullscreen mode during playback the display can freeze.
# #  - Sometimes the display doesn't render when playing a video for the second time.
# #  - Weird behaviour in fullscreen mode.
# #
# # ZVP_OldAviMode :
# #   Just bellow you can enable this mode by setting the variable to true.
# #   Advantages :
# #     - More stable, no known bugs.
# #   Drawbacks :
# #     - It can only play avi files.
# #     - You must use vfw codecs for video, and windows defaults vfw codecs are very limited.
# #       Exhaustive list : MS RLE, MS Video 1, Cinepak, iyuv. And they all sucks.
# #       Any other codec will require to be installed on user side to ensure that it's supported.
# #       But if it's not a problem then you can find very nice vfw codecs on the internet, eg x264vfw.
# #     - You must use acm codecs for audio.
# #       Windows defaults : mp3, pcm.
# #       You can also find better codecs like aac acm.
 
# module Graphics
#   ZVP_OldAviMode = false
# end
 
# $imported ||= {}
# $imported[:Zeus_Video_Player] = __FILE__
 
# def xp?() false end ; 
# def vx?() false end ; 
# def vxace?() false end
  
# RUBY_VERSION == '1.8.1' ? defined?(Hangup) ?
# def xp?() true  end : def vx?() true  end : def vxace?() true  end
 
# #Cache = RPG::Cache if xp?
 
# class String
#   alias getbyte  []
#   alias setbyte  []=
#   alias bytesize size
# end unless vxace?
 
# module Zeus
#   module Encode # 1.1
#     MultiByteToWideChar = Win32API.new('kernel32', 'MultiByteToWideChar', 'iipipi'  , 'i')
#     WideCharToMultiByte = Win32API.new('kernel32', 'WideCharToMultiByte', 'iipipipp', 'i')
#     CodePages = {
#       'ANSI'=>0, 'OEM'=>1, 'MAC'=>2, 'THREAD_ANSI'=>3, 'SYMBOL'=>42,
#       'WINDOWS874'=>874, 'SHIFT_JIS'=>932, 'BIG5'=>950, 'WINDOWS1250'=>1250,
#       'WINDOWS1251'=>1251, 'WINDOWS1252'=>1252, 'WINDOWS1253'=>1253,
#       'WINDOWS1254'=>1254, 'WINDOWS1255'=>1255, 'WINDOWS1256'=>1256,
#       'WINDOWS1257'=>1257, 'WINDOWS1258'=>1258, 'US_ASCII'=>20127,
#       'ISO8859_1'=>28591, 'ISO8859_2'=>28592, 'ISO8859_3'=>28593,
#       'ISO8859_4'=>28594, 'ISO8859_5'=>28595, 'ISO8859_6'=>28596,
#       'ISO8859_7'=>28597, 'ISO8859_8'=>28598, 'ISO8859_9'=>28599,
#       'ISO8859_13'=>28603, 'ISO8859_15'=>28605, 'ISO8859_8I'=>38598,
#       'ISO2022_JP'=>50220, 'ISO2022_KR'=>50225, 'ISO2022_CN'=>50227,
#       'EUC_JP'=>51932, 'EUC_CN'=>51936, 'EUC_KR'=>51949, 'GB2312'=>52936,
#       'UTF7'=>65000, 'UTF8'=>65001, 'UTF16'=>-1
#     }
#     def self.encode(str, from, to, dchar=nil, dflag=nil)
#       if from != -1
#         l = MultiByteToWideChar.call(from, 0, str, str.bytesize, nil, 0)
#         utf16 = [].pack('x') * (l*2)
#         MultiByteToWideChar.call(from, 0, str, str.bytesize, utf16, l)
#       else utf16 = str
#       end
#       if to != -1
#         l = WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, nil, 0, dchar, dflag)
#         str = [].pack('x') * l
#         WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, str, l, dchar, dflag)
#       else str = utf16
#       end
#       case to
#       when 20127; str.force_encoding('US-ASCII')
#       when 65001; str.force_encoding('UTF-8')
#       when    -1; str.force_encoding('UTF-16LE')
#       end if vxace?
#       str
#     rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
#     end
#     def self.method_missing(method, str, *options)
#       from, to = *method.to_s.upcase.split('_TO_', 2).map! {|s| CodePages[s]}
#       super unless from and to
#       encode(str, from, to, *options)
#     rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
#     end
#   end
# end
 
# module Graphics
#   DefWindowProc       = Win32API.new('user32', 'DefWindowProc'      , 'iiii', 'i')
#   DestroyWindow       = Win32API.new('user32', 'DestroyWindow'      , 'i'   , 'i')
#   EnableWindow        = Win32API.new('user32', 'EnableWindow'       , 'ii'  , 'i')
#   FindWindow          = Win32API.new('user32', 'FindWindow'         , 'pp'  , 'i')
#   GetClientRect       = Win32API.new('user32', 'GetClientRect'      , 'ip'  , 'i')
#   GetForegroundWindow = Win32API.new('user32', 'GetForegroundWindow', ''    , 'i')
#   GetMessage          = Win32API.new('user32', 'GetMessage'         , 'piii', 'i')
#   GetWindowLong       = Win32API.new('user32', 'GetWindowLong'      , 'ii'  , 'i')
#   PostMessage         = Win32API.new('user32', 'PostMessage'        , 'iiii', 'i')
#   RedrawWindow        = Win32API.new('user32', 'RedrawWindow'       , 'ipii', 'i')
#   SetWindowLong       = Win32API.new('user32', 'SetWindowLong'      , 'iii' , 'i')
#   MciGetErrorString   = Win32API.new('winmm' , 'mciGetErrorStringW' , 'ipi' , 'i')
#   MciSendString       = Win32API.new('winmm' , 'mciSendStringW'     , 'ppii', 'i')
#   class << self
#     def hwnd() @hwnd ||= FindWindow.call('RGSS Player', nil) end
#     def play_movie(filename, cancellable = true, fit_to_screen = true)
#       @zvp ||= {:buffer => [].pack('x') * 256}
#       @zvp[:filename] = Dir["#{filename}.*"][0] || filename
#       @zvp[:cancellable] = cancellable
#       @zvp[:fit_to_screen] = fit_to_screen
#       return unless open_video_player
#       back_sprite = Sprite.new
#       back_sprite.z = 0x7FFF_FFFF
#       begin
#         cached = true
#         back_sprite.bitmap = $cache.picture('ZeusVideoPlayer')
#         back_sprite.zoom_x = width  / back_sprite.bitmap.width.to_f
#         back_sprite.zoom_y = height / back_sprite.bitmap.height.to_f
#       rescue
#         cached = false
#         back_sprite.bitmap = Bitmap.new(1, 1)
#         back_sprite.bitmap.set_pixel(0, 0, Color.new(0,0,0))
#         back_sprite.zoom_x = width
#         back_sprite.zoom_y = height
#       end
#       frame_reset
#       update
#       update_video_player
#       back_sprite.bitmap.dispose unless cached
#       back_sprite.dispose
#     ensure
#       close_video_player
#     end
#     def width()  640 end unless method_defined?(:width)
#     def height() 480 end unless method_defined?(:height)
#   private
#     def mci(command)
#       error = mci_silent(command)
#       return true if error == 0
#       MciGetErrorString.call(error, @zvp[:buffer], @zvp[:buffer].bytesize/2)
#       print(mci_result, "\nCommand : ", command)
#       return false
#     end
#     def mci_silent(command)
#       command = Zeus::Encode.utf8_to_utf16("#{command}\0")
#       MciSendString.call(command, @zvp[:buffer], @zvp[:buffer].bytesize/2, hwnd)
#     end
#     def mci_result
#       str = Zeus::Encode.utf16_to_utf8(@zvp[:buffer])
#       str[0, str.index("\0")]
#     end
#     def open_video_player(position=0)
#       if ZVP_OldAviMode
#         return false unless mci("open \"#{@zvp[:filename]}\" type AVIVideo alias ZeusVideoPlayer")
#         return false unless mci("window ZeusVideoPlayer handle #{hwnd}")
#         return false unless mci("play ZeusVideoPlayer from #{position} notify")
#       else
#         return false unless mci("open \"#{@zvp[:filename]}\" type MPEGVideo style Child parent #{hwnd} alias ZeusVideoPlayer")
#         return false unless mci("play ZeusVideoPlayer from #{position} notify")
#         return false unless mci('status ZeusVideoPlayer window handle')
#         @zvp[:hwnd] = mci_result.to_i
#         EnableWindow.call(@zvp[:hwnd], 0)
#         style = GetWindowLong.call(hwnd, -16) #GWL_STYLE
#         SetWindowLong.call(hwnd, -16, style | 0x02000000) #WS_CLIPCHILDREN
#       end
#       return true
#     end
#     def close_video_player
#       if !ZVP_OldAviMode and @zvp[:hwnd]
#         DestroyWindow.call(@zvp[:hwnd])
#         @zvp[:hwnd] = nil
#       end
#       mci_silent('stop ZeusVideoPlayer')
#       mci_silent('close ZeusVideoPlayer')
#     end
#     def resize_video_player
#       if mci_silent('where ZeusVideoPlayer source') == 0
#         x, y, w, h = *mci_result.split(' ', 4).map! {|s| s.to_i}
#         GetClientRect.call(hwnd, @zvp[:buffer])
#         client_w, client_h = *@zvp[:buffer].unpack('x8L2')
#         if @zvp[:fit_to_screen]
#           ratio = w / h.to_f
#           w, h = client_w, (client_w / ratio).round
#           h, w = client_h, (client_h * ratio).round if h > client_h
#         end
#         x, y = (client_w-w)/2, (client_h-h)/2
#         window = ZVP_OldAviMode ? 'destination' : 'window'
#         mci_silent("put ZeusVideoPlayer #{window} at #{x} #{y} #{w} #{h}")
#       end
#       RedrawWindow.call(@zvp[:hwnd] || hwnd, nil, 0, 0)
#     end
#     def update_video_player
#       focus = false
#       loop do
#         GetMessage.call(@zvp[:buffer], 0, 0, 0)
#         DefWindowProc.call(*msg = @zvp[:buffer].unpack('L4'))
#         if focus != (GetForegroundWindow.call == hwnd)
#           focus = !focus
#           mci_silent("#{focus ? 'resume' : 'pause'} ZeusVideoPlayer")
#           resize_video_player
#         end
#         next unless focus
#         Input.update
#         # if Input.trigger?(Input::B) or Input.trigger?(Input::C)
#           mci_silent('stop ZeusVideoPlayer') if @zvp[:cancellable]
#         elsif Input.trigger?(Input::F5) or Input.trigger?(Input::F6)
#           if $imported[:Zeus_Fullscreen] and !vx_fullscreen?
#             update
#             resize_video_player
#           end
#         end
#         case msg[1]
#         when 0x0012 #WM_QUIT
#           exit
#         when 0x0100 #WM_KEYDOWN
#           next if msg[3][30] == 1
#           case msg[2]
#           when 0x70, 0x7B #VK_F1, VK_F12
#             focus = false
#             mci_silent('pause ZeusVideoPlayer')
#             PostMessage.call(*msg)
#             update
#           end
#         when 0x0104 #WM_SYSKEYDOWN
#           next if msg[2] != 0x0D or msg[3][30] == 1
#           next if $imported[:Zeus_Fullscreen] and Disable_VX_Fullscreen
#           if ZVP_OldAviMode
#             PostMessage.call(*msg)
#             update
#             resize_video_player
#           else
#             next if mci_silent('status ZeusVideoPlayer position') != 0
#             position = mci_result.to_i
#             close_video_player
#             PostMessage.call(*msg)
#             update
#             break unless open_video_player(position)
#             resize_video_player
#           end
#         else
#           mci_silent('status ZeusVideoPlayer length')
#           length = mci_result.to_i
#           mci_silent('status ZeusVideoPlayer position')
#           break if mci_result.to_i >= length
#           mci_silent('status ZeusVideoPlayer mode')
#           break if mci_result == 'stopped'
#         end
#       end
#     end
#     if xp?
#       alias anti_hangup_update_video_player update_video_player
#       def update_video_player
#         anti_hangup_update_video_player
#       rescue Hangup
#         retry
#       end
#     end
#   end
# end"?
# Copyright (c) 2013 DamiÃ¡n Silvani

# MIT License

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# https://github.com/munshkr/easing-ruby

  # Added function
  def easing(t,b,c,d,e)

  	t = t.to_f; b = b.to_f; c = c.to_f; d = d.to_f

  	case e
  		when :linear; linear_tween(t,b,c,d)

  		when :quad_in; ease_in_quad(t,b,c,d)
  		when :quad_out; ease_out_quad(t,b,c,d)
  		when :quad_in_out; ease_in_out_quad(t,b,c,d)

  		when :cubic_in; ease_in_cubic(t,b,c,d)
  		when :cubic_out; ease_out_cubic(t,b,c,d)
  		when :cubic_in_out; ease_in_out_cubic(t,b,c,d)

  		when :quart_in; ease_in_quart(t,b,c,d)
  		when :quart_out; ease_out_quart(t,b,c,d)
  		when :quart_in_out; ease_in_out_quart(t,b,c,d)

  		when :quint_in; ease_in_quint(t,b,c,d)
  		when :quint_out; ease_out_quint(t,b,c,d)
  		when :quint_in_out; ease_in_out_quint(t,b,c,d)

  		when :sine_in; ease_in_sine(t,b,c,d)
  		when :sine_out; ease_out_sine(t,b,c,d)
  		when :sine_in_out; ease_in_out_sine(t,b,c,d)

  		when :expo_in; ease_in_expo(t,b,c,d)
  		when :expo_out; ease_out_expo(t,b,c,d)
  		when :expo_in_out; ease_in_out_expo(t,b,c,d)

  		when :circ_in; ease_in_circ(t,b,c,d)
  		when :circ_out; ease_out_circ(t,b,c,d)
  		when :circ_in_out; ease_in_out_circ(t,b,c,d)

      when :bounce_in; ease_in_bounce(t,b,c,d)
      when :bounce_out; ease_out_bounce(t,b,c,d)
      when :bounce_in_out; ease_in_out_bounce(t,b,c,d)

  	end

  end

  def linear_tween(t, b, c, d)
    c * t / d + b
  end

  def ease_in_quad(t, b, c, d)
    return c*(t/=d)*t + b;
  end

  def ease_out_quad(t, b, c, d)
    return -c *(t/=d)*(t-2) + b;
  end

  def ease_in_out_quad(t, b, c, d)
    t /= d / 2
    return c / 2*t*t + b if (t < 1)
    t -= 1
    return -c/2 * (t*(t-2) - 1) + b
  end

  def ease_in_cubic(t, b, c, d)
    return c*(t/=d)*t*t + b
  end

  def ease_out_cubic(t, b, c, d)
    return c*((t=t/d-1)*t*t + 1) + b
  end

  def ease_in_out_cubic(t, b, c, d)
    return c/2*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t + 2) + b
  end

  def ease_in_quart(t, b, c, d)
    return c*(t/=d)*t*t*t + b
  end

  def ease_out_quart(t, b, c, d)
    return -c * ((t=t/d-1)*t*t*t - 1) + b
  end

  def ease_in_out_quart(t, b, c, d)
    return c/2*t*t*t*t + b if ((t/=d/2) < 1)
    return -c/2 * ((t-=2)*t*t*t - 2) + b
  end

  def ease_in_quint(t, b, c, d)
    return c*(t/=d)*t*t*t*t + b
  end

  def ease_out_quint(t, b, c, d)
    return c*((t=t/d-1)*t*t*t*t + 1) + b
  end

  def ease_in_out_quint(t, b, c, d)
    return c/2*t*t*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t*t*t + 2) + b
  end

  def ease_in_sine(t, b, c, d)
    return -c * Math.cos(t/d * (Math::PI/2)) + c + b
  end

  def ease_out_sine(t, b, c, d)
    return c * Math.sin(t/d * (Math::PI/2)) + b
  end

  def ease_in_out_sine(t, b, c, d)
    return -c/2 * (Math.cos(Math::PI*t/d) - 1) + b
  end

  def ease_in_expo(t, b, c, d)
    return (t==0) ? b : c * (2 ** (10 * (t/d - 1))) + b
  end

  def ease_out_expo(t, b, c, d)
    return (t==d) ? b+c : c * (-2**(-10 * t/d) + 1) + b
  end

  def ease_in_out_expo(t, b, c, d)
    return b if t == 0
    return b + c if t == d
    return (c/2) * 2**(10 * (t-1)) + b if ((t /= d/2) < 1)
    return (c/2) * (-2**(-10 * t-=1) + 2) + b
  end

  def ease_in_circ(t, b, c, d)
    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b
  end

  def ease_out_circ(t, b, c, d)
    return c * Math.sqrt(1 - (t=t/d-1)*t) + b
  end

  def ease_in_out_circ(t, b, c, d)
    return -c/2 * (Math.sqrt(1 - t*t) - 1) + b if ((t/=d/2) < 1)
    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b
  end

  # Added
  def ease_in_bounce(t,b,c,d)
  	return c - ease_out_bounce(d-t,0,c,d) + b
  end

  def ease_out_bounce(t,b,c,d)
  	t /= d
  	if ( (t) < (1 / 2.75))
  		return c * (7.5625 * t * t) + b
  	elsif (t < (2 / 2.75))
  		t -= (1.5 / 2.75)
  		return c * (7.5625 * (t) * t + 0.75) + b
  	elsif (t < (2.5 / 2.75))
  		t -= (2.25 / 2.75)
  		return c * (7.5625 * (t) * t + 0.9375) + b
  	else
  		t -= (2.625 / 2.75)
  		return c * (7.5625 * (t) * t + 0.984375) + b
  	end
  end

  def ease_in_out_bounce(t,b,c,d)
  	if (t < d / 2)
  		return ease_in_bounce(t * 2, 0, c, d) * 0.5 + b;
  	else
  		return ease_out_bounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  	end
  end"class Object
	def do(tween)
		# Register
		tween.set_parent(self)
		$tweens.register(tween)
		tween.start
	end

	# These don't work for some reason
	def go(var,amount,dur,ease=:linear)
		self.do(TimedTween.new(var,amount,dur,ease))
	end

	def to(var,target,speed=nil)
		self.do(TargetTween.new(var,target,speed))
	end

	def done?
		return $tweens.done?(self)
	end
end"[
def sequence(*args)
	return SequenceTween.new(*args)
end

def repeat(a,times=-1)
	return LoopTween.new(a,times)
end

def parallel(*args)
	return ParallelTween.new(args)
end

def pingpong(var,amount,duration,ease=:linear)
	return PingPongTween.new(var,amount,duration,ease)
end

def set(var,value)
	return SetTween.new(var,value)
end

def delay(duration)
	return DelayTween.new(duration)
end

def call(script)
	return CallTween.new(script)
end

def go(var,amount,dur,ease=:linear)
	return TimedTween.new(var,amount,dur,ease)
end

def to(var,target,speed=nil)
	return TargetTween.new(var,target,speed)
end

def proc(prc,delay=0)
	return ProcTween.new(prc,delay)
end


#==============================================================================
# ** Tweens
#==============================================================================

class Tween

	attr_reader :parent

	def initialize
		@parent = nil
	end

	def set_parent(parent)
		@parent = parent
	end

	def disposed?
		return @parent.disposed? if !@parent.nil?
		return false
	end

	def start
	end

end

class SetTween < Tween

	def initialize(var,value)
		@var = var
		@value = value
	end

	def done?
		return true
	end

	def start
		@parent.send(@var+"=",@value)
	end

	def copy
		return SetTween(@var,@value)
	end

end

class CallTween < Tween

	def initialize(script)
		@script = script
	end

	def done?
		return true
	end

	def start
		eval(@script)
	end

	def copy
		return CallTween(@script)
	end

end

class ProcTween < Tween

	def initialize(proc,delay)
		@proc = proc
		@delay = delay
	end

	def done?
		return @delay <= 0
	end

	def update(delta)
		@delay -= delta
		@proc.call()if done?
	end

end

class DelayTween < Tween

	def initialize(duration)
		@elapsed = 0
		@duration = duration
	end

	def done?
		return @elapsed >= @duration
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
	end

end

# Timed Tween
class TimedTween < Tween

	attr_accessor :elapsed, :duration, :ease

	def initialize(var,amount,duration,ease=:linear)
		@elapsed = 0
		@duration = duration
		@ease = ease
		@var = var
		@amount = amount
	end

	def done?
		return @elapsed >= @duration
	end

	def start
		@initial = @parent.send(@var)
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
		var = easing(elapsed, @initial, @amount, @duration, @ease)
		@parent.send(@var+"=",var)
	end

	def reverse
		nano = TimedTween.new(@var,-@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

	def copy
		nano = TimedTween.new(@var,@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

end

class TargetTween < Tween

	attr_accessor :initial, :target, :speed

	def initialize(var,target,speed=nil) # speed default to 10% distance
		@target = target
		@var = var
		@speed = speed
	end

	def done?
		return @target == @parent.send(@var)
	end

	def start
		@initial = @parent.send(@var)
		@dist = @target - @initial
		@speed = @dist.to_f/10 if @speed == nil
	end

	def update(delta)
		val = @parent.send(@var)
		if (@target-val).abs < @speed.abs
			val = @target
		else
			val += @speed
		end		
		@parent.send(@var+"=",val)
	end

	def reverse

	end

	def copy
		nano = TargetTween.new(@var,@target,@speed)
		nano.set_parent(@parent)
		return nano
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class PingPongTween < TimedTween

	def done?
		# Never ending nano
		return false
	end

	def update(delta)
		super(delta)
		if @elapsed == @duration
			@initial = @parent.send(@var)
			@elapsed = 0
			@amount= -@amount
		end
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class LoopTween < Tween

	def initialize(child,times=-1)
		#super
		@initial = child.copy
		@child = child
		@times = times
	end

	def done?
		return @child.done? && @times == 0
	end

	def set_parent(parent)
		super(parent)
		@initial.set_parent(parent) if @initial
		@child.set_parent(parent)
	end

	def start
		@child.start
	end

	def update(delta)
		@child.update(delta)
		if @child.done?
			@times -= 1
			if @times != 0
				@child = @initial
				@initial = @child.copy
				@child.set_parent(@parent)
				#log_append 'start child'
				@child.start
			end
		end
	end

	def reverse

	end

	def copy
		return LoopTween.new(@child.copy, @times)
	end

end

class SequenceTween < Tween

	def initialize(*args)
		@sequence = args
	end

	def push(nano)
		@sequence.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@sequence.each{ |n| n.set_parent(parent)}
	end

	def done?
		return @sequence.empty?
	end

	def clear
		@sequence.clear
	end

	def start
		start_instants
	end

	def start_instants
		return if @sequence.empty?
		#log_append @sequence.first
		@sequence.first.start
		while !@sequence.empty? && @sequence.first.done?
			@sequence.shift#.dispose
			@sequence.first.start if !@sequence.empty?
		end
	end

	def update(delta)
		return if @sequence.empty?
		@sequence.first.update(delta)
		if @sequence.first.done?
			@sequence.shift#.dispose
			start_instants
		end
	end

	def count
		return @sequence.count
	end

	def reverse
		nano = SequenceTween.new()
		@sequence.reverse.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

	def copy
		nano = SequenceTween.new()
		@sequence.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end

class ParallelTween < Tween

	def initialize(*args)
		@nanos = args
	end

	def push(nano)
		@nanos.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@nanos.each{ |n| n.set_parent(parent)}
	end

	def done?
		@nanos.each{ |n|
			return false if !n.done?
		}
		return true
	end

	def start
		@nanos.each{ |n| 
			n.start
		}
	end

	def update(delta)
		@nanos.each{ |n| 
			n.update(delta)
		}
	end

	def reverse

	end

	def copy
		nano = ParallelTween.new()
		@nanos.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end