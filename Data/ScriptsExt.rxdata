[~"Ø#==============================================================================
# ** Game
#==============================================================================

APPFOLDER = "Aveyond 4"

def aveyond4

    # User Data folder
    Win32API.new('System/Utils', "AVSetEnv", ["V"], "I").call          
    $appdata = ENV['AV_APPDATA'] + "\\" + APPFOLDER
    Dir.mkdir($appdata) if !File.exists?($appdata) 

    # Who will debug the debug?
    begin
      $debug = DebugManager.new
    rescue StandardError => e
      p e.inspect
    end

    $cache = CacheManager.new
    $audio = AudioManager.new
    $keyboard = KeyboardManager.new
    $mouse = MouseManager.new
    $input = InputManager.new
    $data = DataManager.new
    $tweens = TweenManager.new
    $settings = SettingsManager.new
    $files = FileManager.new
    $battle = Game_Battle.new
    $fonts = FontManager.new
    $game = GameManager.new  
    # $steam = SteamManager.new

    $scratch = Bitmap.new(400,50)

    # Call main method as long as $scene is effective      
    $game.update until $game.quit?
    
    # Set the windowed mode for next time
    $settings.conclude
    $audio.dispose

rescue StandardError => e

  $audio.dispose
    
  line = e.message.split(":")[1].to_i      
  log_err e.inspect
  log_err "------------------"
  
  e.backtrace.each{ |location|
    line_num = location.split(":")[1]
    script_name = location.split(":")[0]
    if script_name.include?("Scripts/")
      script_name['Scripts/'] = ''
    end

    if location.include?("Section")
      section = location[/(?#Section)(\d)*(:)/]
      section_err = section[0, section.length - 1]
      script_name = $RGSS_SCRIPTS[section_err.to_i][1]
    end

    method = location.split(":")[2]
    next if method == nil
    loc_err = "Line " + line_num + ", "+method.to_s+" in "+script_name    
    loc_err = "Game Start" if script_name.include?("{0128")
    log_err("#{loc_err}")
  } 
  
end"(#==============================================================================
# ** Sprite_Character
#------------------------------------------------------------------------------
#  This sprite is used to display the character.It observes the Game_Character
#  class and automatically changes sprite conditions.
#==============================================================================

class Sprite_Character < Sprite

  attr_accessor :character     

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     viewport  : viewport
  #     character : character (Game_Character)
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @character = character
    @iconmode = false
    update
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # If tile ID, file name, or hue are different from current ones
    if @character_name != @character.character_name
     
      @character_name = @character.character_name

      if @character_name.include?("Icons")
        self.bitmap = $cache.get(@character.character_name)
        @cw = bitmap.width
        @ch = bitmap.height
        self.ox = @cw/2
        self.oy = @ch
        @iconmode = true
        return
      end

      @iconmode = false

      self.bitmap = $cache.character(@character.character_name)

      @cw = bitmap.width / 4
      @ch = bitmap.height / 4
      self.ox = @cw / 2
      self.oy = @ch

      if @character_name.include?("Prop")
        @cw = bitmap.width
        @ch = bitmap.height
        self.ox = @cw / 2
        self.oy = @ch
        @iconmode = true
      end

    end

    # Clear the helper graphics
    # if @character_name == "!!!"
    #   self.bitmap.clear
    # end

    # if @character == $player
    #   self.bitmap = $cache.character("Player/boy")
    #   self.bitmap = $cache.character("Player/boy_corn") if @character.bush_depth > 0
    # end

    if @character.fxtrail != nil && @character.moving?
      spark(@character.id,'redstar') if rand > 0.80
    end

    # Set visible situation
    self.visible = !@character.transparent
    

    if !@iconmode
      if @character.force_pattern
        sx = @character.force_pattern * @cw
      else
        sx = @character.pattern * @cw
      end
      sy = (@character.showdir - 2) / 2 * @ch
      self.src_rect.set(sx, sy, @cw, @ch)
    end

    # Set sprite coordinates
    self.x = @character.screen_x
    self.y = @character.screen_y - 8
    self.z = @character.screen_z(@ch)

    # TODO auto name the helper icons

    if $scene.is_a?(Scene_Map) && $settings.debug_draw_names
      w = $scene.debug.bitmap.text_size(@character.name).width + 6 if @character != $player
      $scene.debug.bitmap.fill_rect(self.x-w/2,self.y,w,20,Color.new(23,111,22,200)) if @character != $player
      $scene.debug.bitmap.draw_text(self.x-w/2,self.y,w,20,@character.name,1) if @character != $player
    end
    
    # Set opacity level, blend method, and bush depth
    self.opacity = @character.opacity
    #log_info(@character.opacity) if @character.opacity < 255

    #if @character.bush_depth > 0
      self.bush_depth = @character.bush_depth 

     # bmp = self.bitmap
      #self.bitmap = Bitmap.new(bmp.width,bmp.height)

      #self.bitmap.blt(0,0,bmp,Rect.new(0,0,bmp.width,16))

    #end
    
    # Animation
    # if @character.animation_id != 0
    #   animation = $data_animations[@character.animation_id]
    #   animation(animation, true)
    #   @character.animation_id = 0
    # end

  end
end
"©


class MapWrap < Tilemap

  attr_accessor :map_id

	def refresh(map)

      @map_id = map.id

      self.tileset = $cache.tileset(map.tileset.tileset_name)
      i = 0 
      map.tileset.autotile_names.each{ |a|
        next if a == ''
        self.autotiles[i] = $cache.autotile(a)
        i+=1
      }
      
      self.map_data = map.data
      self.priorities = map.tileset.priorities

	end

end"ã
class Panorama

  attr_accessor :spd_x, :spd_y # Speed
  attr_accessor :pad_x, :pad_y # Padding
  attr_accessor :off_x, :off_y 
  attr_accessor :att_x, :att_y # Attach
  attr_accessor :start_x, :start_y 
  attr_accessor :repeat
 
  def initialize(v)
    @sprite = Sprite.new(v)
    @bitmap = nil

    @spd_x = @spd_y = 0
    @pad_x = @pad_y = 0
    @off_x = @off_y = 0

    @repeat = true
    @att_x = 0.0
    @att_y = 0.0

    @start_x = 0
    @start_y = 0

  end
 
 def dispose
    @sprite.bitmap.dispose
    @sprite.dispose
    @bitmap.dispose
  end
 
  def update
    
    @off_x += @spd_x
    @off_y += @spd_y

    @sprite.ox = -@off_x
    @sprite.oy = -@off_y

    @sprite.ox += ($map.display_x / 4 * @att_x)
    @sprite.oy += ($map.display_y / 4 * @att_y)

    @sprite.ox = @sprite.ox % @bitmap.width
    @sprite.oy = @sprite.oy % @bitmap.height

    @sprite.x = @start_x
    @sprite.y = @start_y

  end

  def bitmap=(bmp)
   
    w, h = 640,480
   
    nw = bmp.width <= 100 ? 2 : 3
    nh = bmp.height <= 100 ? 2 : 3
   
    dx = [(w / bmp.width).ceil, 1].max * nw
    dy = [(h / bmp.height).ceil, 1].max * nh

    dy = 1 if !@repeat
 
    bw = dx * bmp.width
    bh = dy * bmp.height
 
    @bitmap = bmp
    @sprite.bitmap = Bitmap.new(bw, bh)
     
      dx.times do |x|
        dy.times do |y|
          @sprite.bitmap.blt((x * bmp.width), (y * bmp.height), @bitmap, @bitmap.rect)
        end
      end

   end

end"O
class Pop < Sprite

	def initialize(ein,eout,vp)
		super(vp)

		anim_seq = seq()

		case ein

			when :fade
				self.opacity = 0
				#anim_seq.push(set("opacity",0))
				anim_seq.push(go("opacity",255,500,:qio))

			when :blast
				self.zoom_x = 1
				self.zoom_y = 0
				#anim_seq.push(para(go("zoom_x",1,500,:bounce_io),go("zoom_y",1,500,:bounce_io)))
				anim_seq.push(go("zoom_y",1,700,:bounce_o))

		end

		anim_seq.push(delay(1000))

		case eout

			when :fade
				anim_seq.push(go("opacity",-255,500,:qio))

			when :blast
				#anim_seq.push(para(go("zoom_x",1,500,:bounce_io),go("zoom_y",1,500,:bounce_io)))
				anim_seq.push(go("zoom_y",-1,700,:bounce_i))				

		end

		self.do(anim_seq)

	end

	def icon=(ico)

		self.bitmap = $cache.icon(ico)

		self.ox = width/2
		self.oy = height/2

	end

	def number=(num)

		# prepare number data
	    data = num.to_i.to_s.split(//)
	    nums = []
	    data.each{ |n| nums.push(n.to_i) }

	    size = 22

	    # build the gfx of this number
	    src = $cache.numbers('pop_'+size.to_s)
	    cw = src.width/10
	    ch = src.height/7

	    # Colors
	    colors = [:yellow,:orange,:purple,:green,:red,:gray,:white]
	    ic = 0#colors.index(color)
	    
	    # prepare the final image
	    width = 0
	    nums.each{ |n| width+=cw*0.75 }
	    bmp = Bitmap.new(width,ch)
	    c = 0

	    nums.each{ |n|

	      s = n * cw

	      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
	      c += cw*0.65

	    }

	    self.bitmap = bmp
	    
		self.ox = width/2
		self.oy = height/2 

	end


end"# #==============================================================================
# # Sprite_Pop
# #==============================================================================

# class Sprite_Pop < Sprite_Elebase
  
#   attr_accessor :life,:vx,:vy,:fx,:fy,:dx,:dy
#   attr_accessor :base_type
#   attr_accessor :type
    
#   #--------------------------------------------------------------------------
#   # * Init
#   #--------------------------------------------------------------------------
#   def initialize(vp)
#     super(vp)
    
#     @state = :in
        
#     # Defaults
#     @life = 45
#     @fx = 0.0
#     @fy = 0.4
#     @dx = 0.0
#     @dy = 0.0
#     @vx = rand*2.0-1.0
#     @vy = rand*-5.0-10.0
#     @base_type = :normal
#     @type = :fall
    
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare icon popper
#   #--------------------------------------------------------------------------
#   def pop_icon(ic,double=false)
#     prep_sprite(Cache.icon(ic,true)) 
#   end
  
#   def pop_gfx(gfx)
#     prep_sprite(Cache.menu(gfx))
#   end
  
#   def pop_hit(gfx)
#     prep_sprite(Cache.menu(gfx))
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare damage popper
#   #--------------------------------------------------------------------------
#   def pop_dmg(dmg,size,color)

#     
    
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare damage popper
#   #--------------------------------------------------------------------------
#   def pop_xp(dmg,size,color)

#     # prepare number data
#     anums = dmg.to_i.to_s.split(//)
#     nums = []
#     anums.each{ |n| nums.push(n.to_i) }

#     # build the gfx of this number
#     src = Cache.system('pop_'+size.to_s)
#     cw = src.width/10
#     ch = src.height/7

#     # Colors
#     colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
#     ic = colors.find_index(color)
    
#     # prepare the final image
#     width = 0
#     nums.each{ |n| width+=cw }
#     bmp = Bitmap.new(width+20,ch)
#     c = 0

#     nums.each{ |n|

#       s = n * cw

#       bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
#       c += cw*0.65

#     }
    
#     src = Cache.menu('xp')
#     bmp.blt(c+2,9,src,src.rect)
    
#     prep_sprite(bmp)    
    
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare sharp popper
#   #--------------------------------------------------------------------------
#   def pop_sharp(dmg,size,color)

#     # prepare number data
#     anums = dmg.to_i.to_s.split(//)
#     nums = []
#     anums.each{ |n| nums.push(n.to_i) }

#     # build the gfx of this number
#     src = Cache.system('pop_'+size.to_s)
#     cw = src.width/10
#     ch = src.height/7

#     # Colors
#     colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
#     ic = colors.find_index(color)

#     # prepare the final image
#     width = 0
#     nums.each{ |n| width+=cw }
#     bmp = Bitmap.new(width+38,ch+3)
#     c = 0
    
    

#     nums.each{ |n|

#       s = n * cw

#       bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
#       c += cw*0.65

#     }

    
#     src = Cache.menu('dmg')
#     bmp.blt(c+1,4,src,src.rect)
    
#     prep_sprite(bmp)    

#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare sharp popper
#   #--------------------------------------------------------------------------
#   def pop_block(dmg,size,color)

#     # prepare number data
#     anums = dmg.to_i.to_s.split(//)
#     nums = []
#     anums.each{ |n| nums.push(n.to_i) }

#     # build the gfx of this number
#     src = Cache.system('pop_'+size.to_s)
#     cw = src.width/10
#     ch = src.height/7

#     # Colors
#     colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
#     ic = colors.find_index(color)
    
#     # prepare the final image
#     width = 0
#     nums.each{ |n| width+=cw }
#     bmp = Bitmap.new(width+40,ch)
#     c = 0

#     nums.each{ |n|

#       s = n * cw

#       bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
#       c += cw*0.65

#     }
    
#     src = Cache.menu('block')
#     bmp.blt(c+1,5,src,src.rect)
    
#     prep_sprite(bmp)    
    
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare damage popper
#   #--------------------------------------------------------------------------
#   def pop_hp(dmg,size,color)

#     # prepare number data
#     anums = dmg.to_i.to_s.split(//)
#     nums = []
#     anums.each{ |n| nums.push(n.to_i) }

#     # build the gfx of this number
#     src = Cache.system('pop_'+size.to_s)
#     cw = src.width/10
#     ch = src.height/7

#     # Colors
#     colors = [:yellow,:orange,:purple,:green,:red,:gray,:white]
#     ic = colors.find_index(color)
    
#     # prepare the final image
#     width = 0
#     nums.each{ |n| width+=cw }
#     bmp = Bitmap.new(width+20,ch+15)
#     c = 0

#     nums.each{ |n|

#       s = n * cw

#       bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
#       c += cw*0.65

#     }
    
#     if color == :green
#       src = Cache.menu('hp_heal')
#     elsif color == :purple
#       src = Cache.menu('hp_poison')
#     else
#       src = Cache.menu('hp')
#     end
#     bmp.blt(c+2,9,src,src.rect)
    
#     prep_sprite(bmp)    
    
#   end
  
#   #--------------------------------------------------------------------------
#   # * Prepare sprite
#   #--------------------------------------------------------------------------
#   def prep_sprite(bmp)
    
#     # setup sprite
#     self.opacity = 0
#     self.bitmap = bmp
#     self.auto_size
#     @loc_y = y.to_f-bmp.height/2
#     @loc_x = self.x
#     @base_y = @base_type == :normal ? @loc_y - (bmp.height/2)+10 : 220
    
#   end  
  
#   #--------------------------------------------------------------------------
#   # * Dispose
#   #--------------------------------------------------------------------------
#   def dispose

#     self.bitmap.dispose if self.bitmap != nil
#     super

#   end

#   #--------------------------------------------------------------------------
#   # * Update
#   #--------------------------------------------------------------------------
#   def update
#     super
    
#     @vy += @fy if @type == :fall
#     @vx += @fx if @type == :fall
    
#     @vx *= (1-@dx)
#     @vy *= (1-@dy)

#     @loc_y += @vy
#     @loc_x += @vx
    
#     if @type == :fall
#       if @vy > 0 && @loc_y >= @base_y
#         @vy > 2.0 ? @vy *= -0.5 : @vy = 0
#         @loc_y = @base_y
#       end
#     elsif @type == :zoom
      
#     else
#       @vy *= 0.9
#       @vx *= 0.8
#     end

#     # Positioning
#     self.y = @loc_y
#     self.x = @loc_x

#     if @state == :in
#       self.opacity += 20
#       @state = :up if self.opacity >= 255
#     elsif @state == :up
#       @life -= 1
#       @state = :out if @life <= 0
#     elsif @state == :out
#       self.opacity -= 8
#       @state = :done if self.opacity <= 0
#     end
    
#     #p @state

#   end

#   #--------------------------------------------------------------------------
#   # * Mischecks
#   #--------------------------------------------------------------------------
#   def dead?() return self.opacity <= 0 end

# end"c
class Spark < Sprite

	def initialize(fx,x,y,vp)
		super(vp)

		@reverse = false


		# fx is database id, also gfx name
		# If not in database, use defaults

		self.bitmap = $cache.animation(fx)

		# Defaults
		@frames = 25
		@delay = 0

		@fade_out = true

		self.opacity = 122
		self.blend_type = 0

		@sound = nil
		@sound_delay = 0

		if $data.anims.has_key?(fx)

			anim = $data.anims[fx]
			@frames = anim.frames
			@delay = anim.delay
			@fadeout = anim.fadeout
			self.opacity = anim.opacity
			case anim.order
				when 'below'
				when 'same'
				when 'above'
			end

			#self.blend_type = anim.blend

			# Split sound input
			if anim.sound != ''
				dta = anim.split(':')
				if dta.count > 1
					@sound_delay = dta[1].to_i
				end
				@sound = dta[0]
			end

		end

		self.center(x,y)

		@idx = -1
		@next = 0
		update

	end

	def reverse
		@reverse = true
	end

	def width
		return self.bitmap.width / 5
	end

	def height
		return self.bitmap.width / 5
	end

	def done?
		return false if @fade_out && self.opacity > 0
		return @idx == @frames
	end

	def update

		#self.ox = -$scene.map.display_x
    	#self.oy = -$scene.map.display_y

		# Step counters
		@next -= 1
		if @next < 1
			@next = @delay

			@idx += 1

			@idx = @frames if @idx > @frames

			self.opacity -= 30 if @idx >= @frames - 2

			idx = @idx
			if @reverse
				idx = @frames - @idx
			end

			fx = idx % 5 # frames_per_row
			fy = idx / 5



			# Refresh
			
			self.src_rect = Rect.new(fx*width,fy*height,width,height)


		end

	end

end"[
# Spawn and manage weather particles

class Particle < Sprite

  attr_accessor :mx, :my, :sx, :sy, :opac
  
end

class Weather

end

class Weather_DarkDots

	def initialize(vp)

		@stars = []
	    (1..30).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle(['yellow','blue'].sample)
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4+ rand(640+220) - 320#-120+800)#rand(640)
	      s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	      s.mx = rand * 0.5
	      s.my = rand * 0.5
	      s.x = s.sx
	      s.y = s.sy
	   	  s.opac = 70 + rand(100)
	      s.opacity = 0
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      s.sx += s.mx * (0.3+rand)
	      s.sy += s.my * (0.3+rand)
	      s.x = s.sx
	      s.y = s.sy

	      s.opacity += 3 if s.opac > s.opacity
	      
	      if s.x > $scene.map.display_x/4 + 860 || s.y > $scene.map.display_y/4+720 || s.x < $scene.map.display_x/4 - 320 || s.y < $scene.map.display_y/4 - 240
	        s.mx = rand
	        s.my = rand
	      	s.sx = $scene.map.display_x/4+ rand(640+320) - 320#-120+800)#rand(640)
	      	s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	        s.opac = 70 + rand(100)
	        s.opacity = 0
	      end		      
		}

	end

	def dispose

	end

end"K#==============================================================================
# Widget_Label
#==============================================================================

class Area < Sprite
  
  # accessors
  attr_accessor :font 
  attr_accessor :fixed_width
  attr_accessor :padding
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug

    @text = "Label"

    @padding = 5
    @spacing = 5

    # Required for next lining
    @fixed_width = 250
    
  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    if @text != text
      @text = text
      refresh
    end
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

  	# Split into lines that fit
  	lines = [""]
  	cx = 0
  	@text.split(" ").each{ |word|
  		w = $fonts.size(word,@font)
  		cx += w.width
  		if cx < @fixed_width
  			lines[-1] += word + ' '
  			cx += @spacing
  		else
  			lines.push(word + ' ')
  			cx = 0
  		end
  	}

  	#log_scr(lines)

  	height = $fonts.size("Happy",@font).height

  	# Build the bitmap now
  	w = @fixed_width
    h = height * lines.count

    self.bitmap = Bitmap.new(w+@padding*2,h+@padding*2)
    self.bitmap.font = @font

    cy = 0
    lines.each{ |line|
    	self.bitmap.draw_text(@padding,@padding+cy,w,height,line)
    	cy += height
    }
    
    
  end
  
end"J

class Bar < Sprite

	attr_accessor :value, :max

	def initialize(vp,w,h)

		super(vp)

		
		@value = 100
		@drawn = @value

		@target = @value
		@max = 100

		@width = w
		@height = h

		@base_color = Color.new(46,46,46,200)
		@ghost_color = Color.new(0,255,0,50)
		@bar_color = Color.new(0,255,0,255)

		self.bitmap = Bitmap.new(w,h)

		redraw

	end

	def update
		if @drawn != @value.to_i
			redraw
		end
	end

	def redraw

		@drawn = @value.to_i

		# Draw the 3 layers
		self.bitmap.clear
		self.bitmap.fill(@base_color)

		# Draw ghost
		if @target > @value
			gw = ((@target.to_f/@max) * @width).to_i
			self.bitmap.fill_rect(0,0,gw,@height,@ghost_color)
		end

		# Draw next
		vw = ((@value.to_f/@max) * @width).to_i
		self.bitmap.fill_rect(0,0,vw,@height,@bar_color)

	end

end"M

class Box 

	attr_accessor :name
	attr_accessor :window

	attr_accessor :alpha
	
	def initialize(vp,w=100,h=100)

		@wallpaper = Sprite.new(vp)
		@window = Sprite.new(vp)		

		@skin = nil
		@src = nil

		@width = w
		@height = h

		@alpha = 210#230		

		# Keep a hold of it
		@x = 0
		@y = 0

		# Wallapper Position
		@px, @py = 0.0, 0.0

		# Display position, integer
		@dx, @dy = 0, 0

		# Anim speed - default to still
		@sx = 0.0#0.2
		@sy = 0.0#0.2

	end

	def scroll(x,y)
		@sx = x
		@sy = y
	end

	def dispose
		@wallpaper.dispose
		@window.dispose
	end

	def skin=(bmp)
		@skin = bmp
		@window.bitmap = Bitmap.new(@width,@height)
		@window.bitmap.borderskin(@skin)
	end

	def wallpaper=(w)
		@src = w
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		redraw
	end

	def color=(c)
		@color = c
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		@wallpaper.bitmap.fill(c)
	end

	def opacity=(o)
		@wallpaper.opacity = o
		@window.opacity = o
	end

	def opacity
		return @window.opacity
	end

	def hide
		@wallpaper.opacity = 0
		@window.opacity = 0
	end

	def show 
		@wallpaper.opacity = 255
		@window.opacity = 255
	end

	def x=(v)
		@x = v
		@wallpaper.x = v+4
		@window.x = v
	end

	def x
		return @x
	end

	def y=(v)
		@y = v
		@wallpaper.y = v+4
		@window.y = v
	end

	def y
		return @y
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def width() return @width end
	def height() return @height end

	def height=(h)
		resize(@width,h)
	end

	def width=(w)
		resize(w,@height)
	end

	def resize(w,h)
		@width = w
		@height = h
		@window.bitmap = Bitmap.new(w,h)
		@window.bitmap.borderskin(@skin)
		@wallpaper.bitmap = Bitmap.new(w-8,h-8)	
		if @src != nil	
			redraw
		else
			@wallpaper.bitmap.fill(@color)
		end
	end

	def update

		# Redraw the bmp if needed
		@px += @sx
		@py += @sy

		# Mod to width of bmp
		@px -= @src.width if @px > @src.width
		@px += @src.width if @px < -@src.width
		@py -= @src.height if @py > @src.height
		@py += @src.height if @py < @src.height		

		if @px.to_i != @dx || @py.to_i != @dy
			@dx = @px.to_i
			@dy = @py.to_i
			redraw
		end

	end

	def redraw

		@wallpaper.bitmap.clear

		cx = -@dx
		cy = -@dy

		while cx < @width

			while cy < @height

				rct = @src.rect
				# If draw's over, cancel
				# Also for offset for first

				@wallpaper.bitmap.blt(cx,cy,@src,rct,@alpha)

				cy += @src.height

			end

			cy = -@dy
			cx += @src.width
			#log_info("DRAW #{cx}")

		end

	end

end"h	#==============================================================================
# Button
#==============================================================================

class Button < Sprite
  
  # accessors
  attr_accessor :select, :deselect, :press
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp=nil)
       
    super(vp)

    # handle mouseovers and that and procs and that
    @select = nil#Proc.new{ self.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = nil#Proc.new{ $tweens.clear(self); self.x = 22; $tweens.clear(self) }
    @press = nil#Proc.new{self.do(pingpong("y",-30,300,:quad_in_out));}

    @state = :idle # :over
    
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    # Check inputs if active?
    if @state == :idle
      #if Input.method == :mouse
        check_hover($mouse.position)
      #end
      # check mouse hover?
    end

    if @state == :active
      check_nhover($mouse.position)
      if @state == :active
        if $input.click?
          @press.call()
        end
      end
    end

    if @state == :active
      # check key presses to change to another
      #if Input.trigger?(Input.right)
        # check hover of all neighbours
      #  self.viewport.sprites.each{ |s| s.check_hover(x+100)}
      #end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x
    return if pos[1] < self.y
    return if pos[0] > self.x + self.width
    return if pos[1] > self.y + self.height
    @state = :active
    @select.call() if @select
    log_info("PROC")
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x
    w = true if pos[1] < self.y
    w = true if pos[0] > self.x + self.width
    w = true if pos[1] > self.y + self.height
    return if w == false
    @state = :idle
    @deselect.call() if @select
    log_info("UNPROC")
  end

end"ì	#==============================================================================
# Widget_Label
#==============================================================================

class Label < Sprite
  
  # accessors
  attr_accessor :align 
  attr_accessor :font 
  attr_accessor :shadow
  attr_accessor :fixed_width
  attr_accessor :padding

  attr_accessor :gradient
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug
    @shadow = nil

    @text = "Label"

    @align = 0

    @icon = nil

    @padding = 5

    # If there is a width, don't auto size width
    @fixed_width = 0

  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    text = text.to_s
    if @text != text
      @text = text
      refresh
    end
  end

  def icon=(icon)
    @icon = icon
    refresh
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    # If fixed width, don't recreate
    if @fixed_width > 0 
      if self.bitmap && self.bitmap.width == @fix_width
        self.bitmap.clear
      else
        size = $fonts.size(@text,@font)
        size.height += @padding*2
        self.bitmap = Bitmap.new(@fixed_width,size.height)
      end
    else
      size = $fonts.size(@text,@font)
      size.width += @padding*2
      size.width += 32 if @icon
      size.height += @padding*2
      self.bitmap = Bitmap.new(size.width,size.height)
    end

    self.bitmap.font = @font

    # Draw the icon
    if @icon

      self.bitmap.blt(@padding,(size.height-28)/2+3,@icon,@icon.rect)

    end

    # Draw the text
    x = @padding
    x += 26 if @icon
    y = @padding
    w = self.bitmap.width-@padding*2
    h = self.bitmap.height-@padding*2
    
    if @shadow
      self.bitmap.font = @shadow
      self.bitmap.draw_text(x+1,y+1,w,h,@text,@align)
    end

    self.bitmap.font = @font
    if @gradient
      self.bitmap.draw_gtext(x,y,w,h,@text,@align)
    else
      self.bitmap.draw_text(x,y,w,h,@text,@align)
    end
        
  end
  
end"(#==============================================================================
# The magical list REDUX
#==============================================================================

class List
      
  attr_accessor :x, :y
  attr_accessor :per_page
  attr_accessor :item_width, :item_height
  attr_accessor :item_ox, :item_space

  attr_accessor :select, :cancel, :change

  attr_accessor :active

  attr_reader :page_idx

  attr_accessor :type

  attr_reader :scroll_idx

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize() 

    # Make own viewport
    @vp = Viewport.new(0,0,1000,1000)
    @vp.z = 4500

    @font = Font.new
    @font.name = "Verdana"
    @font.size = 20 #was 26
    @font.color = Color.new(245,223,200)

    @item_width = 0
    @item_height = 0

    @item_ox = 0
    @item_space = 0

    # Procs
    @select = nil
    @cancel = nil
    @change = nil

  	@x = 0
  	@y = 0

    @type = :item
  	@data = []

  	@scroll_idx = 0
  	@page_idx = 0

  	@max_per_page = 8

  	# Sprites
    @back_sprite = Sprite.new(@vp)
    @select_sprite = Sprite.new(@vp)    
    @content_sprite = Sprite.new(@vp)

    @scroll_box = Sprite.new()
    @scroll_box.bitmap = $cache.menu_common('scroll-box')
    @scroll_box.x = 234
    @scroll_box.y = 422
    @scroll_box.z = 5000

    @scroll_down = Button.new()
    @scroll_down.bitmap = $cache.menu_common('scroll-down')
    @scroll_down.x = 239
    @scroll_down.y = 424
    @scroll_down.z = 5000
    @scroll_down.press = Proc.new{ self.scrollbar_down }

    @scroll_up = Button.new()
    @scroll_up.bitmap = $cache.menu_common('scroll-up')
    @scroll_up.x = 262
    @scroll_up.y = 424
    @scroll_up.z = 5000
    @scroll_up.press = Proc.new{ self.scrollbar_up }

    # Setup
    @select_sprite.bitmap = $cache.menu_common('list-bar-on')
    

    @active = true

  end

  def move(x,y)
    @x = x
    @y = y
  end

  def opacity=(o)
    @back_sprite.opacity = o
    @content_sprite.opacity = o
    @select_sprite.opacity = o
    @scroll_box.opacity = 0
    @scroll_down.opacity = 0
    @scroll_up.opacity = 0
  end

  def opacity
    return @back_sprite.opacity
  end

  def dispose
  	@back_sprite.dispose
    @select_sprite.dispose
    @content_sprite.dispose
    @scroll_box.dispose
    @scroll_down.dispose
    @scroll_up.dispose
  end

  def setup(data)
    log_sys(data)
  	@data = data
    # Need an original per page in case less items are given
    # And then aditional items are given
    #@per_page = @data.count if @data.count < @per_page
    #@per_page = 1 if @per_page == 0
    @scroll_idx = 0
    @page_idx = 0
    @select_sprite.y = idx * row_height
    @active = true
  	refresh
  end

  def idx
    return @scroll_idx + @page_idx
  end

  def row_height
    @item_height + @item_space
  end

  def can_scroll?
    @data.count > @max_per_page
  end

  def call_change

        i = idx
        #i -= 1 if !can_scroll?
        @change.call(current) if !@change.nil?

  end

  # When data changes
  def refresh

    @vp.rect = Rect.new(@x,@y,@item_width,row_height*@max_per_page)

    # Draw the background sprite and position it
    rows = [@max_per_page,@data.count].min
    rows += 2 if can_scroll?
    rows = 1 if rows == 0
    height = row_height * rows

    log_info(rows)

    @back_sprite.bitmap = Bitmap.new(@item_width,height)
    @content_sprite.bitmap = Bitmap.new(@item_width,height)

    @back_sprite.y = can_scroll? ? -row_height : 0
    @content_sprite.y = can_scroll? ? -row_height : 0



    src = $cache.menu_common('list-bar')

    i = 0
    rows.times{ 
      @back_sprite.bitmap.blt(0,i*row_height,src,src.rect)
      # Draw each row
      draw(@data[@scroll_idx + i],i)
      i += 1
    }

    call_change

  end

  # ADD THIS MOUSE CONTROL
  def scrollbar_down
      @page_idx += 1
      scroll_up 
  end

  def scrollbar_up
      @page_idx -= 1
      scroll_down
  end

  def current
    return @current[0] if @type == :misc
    return @data[idx+1] if can_scroll?
    return @data[idx]
  end

  def draw(data,row)

    #return if data == nil # For above or below accessible

    # Drw the contents
    case @type
      when :item
        draw_item(data,row)
      when :equip
        draw_equip(data,row)
      when :skill
        draw_skill(data,row)
      when :quest
        draw_quest(data,row)
      when :misc
        draw_misc(data,row)
    end

  end

  def draw_item(data,row)

    item = $data.items[data]

    if item != nil
      name = item.name
      ico = $cache.icon(item.icon)
      number = $party.item_number(data)
    else
      name = "Remove"
      ico = $cache.icon("misc/unknown")
      number = 0
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    if number > 0
      @content_sprite.bitmap.draw_text(222+21,row*row_height,@item_width,@item_height,"x"+number.to_s,0)
    end

  end

  def draw_equip(data,row)

    if data == nil
      icon =  $cache.icon("misc/unknown")
      name = "Nothing"
      slot = "NONE"
    else
      item = $data.items[data]
      name = item.name
      icon =  $cache.icon(item.icon)
      slot = item.slot
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,icon,icon.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

    #sprite.bitmap.font = @font 
    #sprite.bitmap.draw_text(-10,-1,@item_width,@item_height,slot,2)

  end

  def draw_skill(data,row)

    item = $data.skills[data]

    ico = $cache.icon(item.icon)
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

    @content_sprite.bitmap.draw_text(222+21,row*row_height,@item_width,@item_height,"-"+item.cost.to_s,0)

  end

  def draw_quest(data,row)

    item = $data.quests[data]

    ico = $cache.icon('misc/unknown')

    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

  end

  def draw_misc(data,row)

    ico = $cache.icon(data[1])
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,data[0],0)

  end







  def update

    @vp.rect.x = @x
    @vp.rect.y = @y

    return if !@active

    return if !$tweens.done?(@back_sprite)

    @scroll_down.update
    @scroll_up.update

  	# Check inputs and that
  	if $keyboard.press?(VK_DOWN)

      return if idx >= @data.count - 1

      # If the tweens are going, skip to done
      $tweens.resolve(@back_sprite)
      $tweens.resolve(@content_sprite)
      $tweens.resolve(@select_sprite)

      sys('select')

      # Move the sprite down, but not too far!
      @select_sprite.y += row_height  		
      @page_idx += 1

      if @select_sprite.y > (@per_page-1) * row_height
        @select_sprite.y -= row_height
        @page_idx -= 1
      end
  		
      #if @data.count > @max_per_page

      if can_scroll? && @page_idx >= 6 && @scroll_idx < (@data.count - @max_per_page) -1
        scroll_up
  		else
        i = idx
        #i -= 1 if !can_scroll?
  		  @change.call(current) if !@change.nil?
      end
      

      #@change.call(current) if !@change.nil?

  	end

  	if $keyboard.press?(VK_UP) #&& @dynamo.done?

      return if idx <= 0

      # If the tweens are going, skip to done
      $tweens.resolve(@back_sprite)
      $tweens.resolve(@content_sprite)
      $tweens.resolve(@select_sprite)

      sys('select')      
      
      # Move the sprite down
      @select_sprite.y -= row_height
  		@page_idx -= 1

       if @select_sprite.y < 0
        @select_sprite.y += row_height
        @page_idx += 1
      end

  		if can_scroll? && @scroll_idx > 0 && @page_idx <= 1
        scroll_down
      else
        i = idx
        #i -= 1 if !can_scroll?
        @change.call(current) if !@change.nil?
      end
      
      #@change.call(current) if !@change.nil?

  	end

    pos = $mouse.position
    pos[0] -= @x
    pos[1] -= @y
    if pos[0] < @item_width
      row = pos[1] / row_height
      return if row < 0
      return if row >= @per_page
      return if row >= @data.count
      return if row == @page_idx
      @select_sprite.y = row * row_height
      @page_idx = row
      @change.call(current) if !@change.nil?
      #sys('select')
    end

    # Selection
    if !@select.nil? && ($input.action? || $input.click?)
      @select.call(current)
    end

    # Cancel
    if !@cancel.nil? && ($input.cancel? || $input.rclick?)
      sys('cancel')
      @cancel.call(current)
    end

  end

  def scroll_down

    
    @change.call(current) if !@change.nil?
    
    @scroll_idx -= 1    
    #      @pagemod = 1




    dur = 180
    ease = :quad_in_out

    @back_sprite.do(go("y",row_height,dur,ease))
    @content_sprite.do(go("y",row_height,dur,ease))
    @select_sprite.do(go("y",row_height,dur,ease))

    @back_sprite.do(proc(Proc.new{

      @page_idx += 1
      refresh

    },dur+1))

  end

  def scroll_up

     @change.call(current) if !@change.nil?

    @scroll_idx += 1    
          #@pagemod = -1

         

    dur = 180
    ease = :quad_in_out

  	#draw_item(@data[@scroll_idx + @per_page-1],@dynamo,@page_idx == @per_page)

  	@back_sprite.do(go("y",-row_height,dur,ease))
    @content_sprite.do(go("y",-row_height,dur,ease))
    @select_sprite.do(go("y",-row_height,dur,ease))

  	@back_sprite.do(proc(Proc.new{

      @page_idx -= 1
      refresh      

    },dur+1))

  end

 end
"¨"#==============================================================================
# The magical list
#==============================================================================

class OLDList
      
  attr_accessor :x, :y
  attr_accessor :per_page
  attr_accessor :item_width, :item_height
  attr_accessor :item_ox, :item_space

  attr_accessor :select, :cancel, :change

  attr_accessor :active

  attr_reader :page_idx

  attr_accessor :type

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize() 

    # Make own viewport
    @vp = Viewport.new(0,0,1000,1000)
    @vp.z = 4500

    @font = Font.new
    @font.name = "Verdana"
    @font.size = 20 #was 26
    @font.color = Color.new(245,223,200)


    @item_width = 0
    @item_height = 0

    @item_ox = 0
    @item_space = 0

    # Procs
    @select = nil
    @cancel = nil
    @change = nil

  	@x = 0
  	@y = 0

    @type = :item
  	@data = []

  	@scroll_idx = 0
  	@page_idx = 0

  	@per_page = 8

  	# Sprites

    @dynamo = Sprite.new(@vp)
    
  	@sprites = []
  	@per_page.times{ |i|
  		@sprites.push(Sprite.new(@vp))
  	}

  	

    @active = true

  end

  def move(x,y)
    @x = x
    @y = y
  end

  def opacity=(o)
    @sprites.each{ |s|
      s.opacity = o
    }
    @dynamo.opacity = o
  end

  def dispose
  	@sprites.each{ |s| s.dispose }
  	@dynamo.dispose
  end

  def setup(data)
    log_sys(data)
  	@data = data
    # Need an original per page in case less items are given
    # And then aditional items are given
    #@per_page = @data.count if @data.count < @per_page
    @per_page = 1 if @per_page == 0
  	refresh
  end

  def idx
    return @scroll_idx + @page_idx
  end

  def refresh
    return if @dynamo.disposed?

    @vp.rect = Rect.new(@x,@y,@item_width,@item_space*@per_page)

  	# Rebuild the items from data
  	cy = 0#@y

    if !@data.empty?
    	(0..@per_page-1).each{ |i|
        next if @sprites[i] == nil
    		draw(@data[i+@scroll_idx],@sprites[i],i==@page_idx)
        @current = @data[i+@scroll_idx] if i == @page_idx
    		@sprites[i].y = cy
    		@sprites[i].x = 0#@x
        @sprites[i].opacity = 255
    		cy += @item_space
        #@sprites[i].bitmap.height
    	}
    end

  	@cybt = cy


    # If empty, draw dynamo as "Nothing here"
    if @data.empty?
      @dynamo.bitmap = Bitmap.new(@item_width,@item_height)
      @dynamo.bitmap.font = @font
      @dynamo.bitmap.draw_text(0,0,@item_width,@item_height,"Sorry, no items",1)
      #@dynamo.bitmap.draw_text(0,0,100,40,"Nothing",2)
      @dynamo.x = 0
      @dynamo.y = 0
      @dynamo.opacity = 150
    end

  end

  def scrollbar_down
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx += 1;self.refresh; self.scroll_up 
  end

  def scrollbar_up
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx -= 1; self.refresh; self.scroll_down
  end

  def current
    return @current[0] if @type == :misc
    return @current
  end

  def draw(data,sprite,on)

    return if sprite == nil
    sprite.bitmap.clear if sprite.bitmap != nil

  	# Draw the base
    src = $cache.menu("Common/bartest3")
    src = $cache.menu("Common/bartest4") if on
  	sprite.bitmap = Bitmap.new(src.width,src.height)
    sprite.bitmap.blt(0,0,src,src.rect)

    #return if data == nil

    # Drw the contents
    case @type
      when :item
        draw_item(data,sprite,on)
      when :equip
        draw_equip(data,sprite,on)
      when :skill
        draw_skill(data,sprite,on)
      when :quest
        draw_quest(data,sprite,on)
      when :misc
        draw_misc(data,sprite,on)
    end

  end

  def draw_item(data,sprite,on)

    #return if $data.items.has_key?(data)

    return if data == nil

    item = $data.items[data]

    ico = $cache.icon(item.icon)
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,item.name,0)

  end

  def draw_equip(data,sprite,on)

    if data == nil
      icon =  $cache.icon("misc/unknown")
      name = "Nothing"
      slot = "NONE"
    else
      item = $data.items[data]
      name = item.name
      icon =  $cache.icon(item.icon)
      slot = item.slot
    end
    
    sprite.bitmap.blt(8,5,icon,icon.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,name,0)

    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(-10,-1,@item_width,@item_height,slot,2)

  end

  def draw_skill(data,sprite,on)

    return if data == nil

    #log_info(data)

    item = $data.skills[data]

    ico = $cache.icon(item.icon)
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,item.name,0)

  end

  def draw_quest(data,sprite,on)

    item = $data.quests[data]

    ico = $cache.icon('items/map')
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,item.name,0)

  end

  def draw_misc(data,sprite,on)

    ico = $cache.icon(data[1])
    
    sprite.bitmap.blt(8,5,ico,ico.rect)
    sprite.bitmap.font = @font 
    sprite.bitmap.draw_text(18+21,-1,@item_width,@item_height,data[0],0)

  end

  def update

    @vp.rect.x = @x
    @vp.rect.y = @y

    return if !@active

  	# Check inputs and that
  	if $keyboard.press?(VK_DOWN) #&& @dynamo.done?

      return if @page_idx + @scroll_idx >= @data.count - 1

      sys('select')

      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx += 1
  		if @data.count > @per_page && @page_idx > 3
        refresh
  			scroll_up
  		else
  		  refresh
      end
      @change.call(current) if !@change.nil?
  	end

  	if $keyboard.press?(VK_UP) #&& @dynamo.done?

      sys('select')
      
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx -= 1 if @page_idx > 0
  		if @page_idx < 3 && @scroll_idx > 0
        refresh
  			scroll_down
  		else
  		  refresh
      end
      @change.call(current) if !@change.nil?
  	end

    pos = $mouse.position
    pos[0] -= @x
    pos[1] -= @y

    # Check mouseover
    @sprites.each_index{ |i|
      next if @page_idx == i
      next if @sprites[i] == nil
      next if @sprites[i].bitmap == nil
      next if pos[0] < @sprites[i].x
      next if pos[1] < @sprites[i].y
      next if pos[0] > @sprites[i].x + @sprites[i].width
      next if pos[1] > @sprites[i].y + @sprites[i].height
      sys('select')
      @page_idx = i
      refresh
      break
    }


    # Selection
    if !@select.nil? && ($input.action? || $input.click?)
      @select.call(current)
    end

    # Cancel
    if !@cancel.nil? && ($input.cancel? || $input.rclick?)
      sys('cancel')
      @cancel.call(current)
    end

  end

  def scroll_down

    @dynamo.bitmap.clear

    @scroll_idx -= 1    
          @pagemod = 1

    # Create the dynamo
    @dynamo.y = 0 - @item_space
    @dynamo.x = 0#@x
    @dynamo.opacity = 205

    dur = 200
    ease = :quad_in_out

    draw_item(@data[@scroll_idx],@dynamo,@page_idx == -1)

    @dynamo.do(go("y",@item_space,dur,ease))
    @dynamo.do(go("opacity",50,dur,ease))

    @dynamo.do(proc(Proc.new{
      @page_idx += 1

      self.refresh
      @dynamo.opacity = 205
    },dur+30))

    @sprites.each{ |s|
      s.do(go("y",@item_space,dur,ease))
    }

    @sprites[-1].do(go("opacity",-50,dur,ease))

  end

  def scroll_up

    @dynamo.bitmap.clear

    @scroll_idx += 1    
          @pagemod = -1

  	# Create the dynamo
  	@dynamo.y = @cybt
  	@dynamo.x = 0#@x
  	@dynamo.opacity = 205

    dur = 200
    ease = :quad_in_out

  	draw_item(@data[@scroll_idx + @per_page-1],@dynamo,@page_idx == @per_page)

  	@dynamo.do(go("y",-@item_space,dur,ease))
  	@dynamo.do(go("opacity",50,dur,ease))



  	@dynamo.do(proc(Proc.new{

      @page_idx -= 1
      self.refresh
      @dynamo.opacity = 205
    },dur+30))

  	@sprites.each{ |s|
  		s.do(go("y",-@item_space,dur,ease))
  	}

  	@sprites[0].do(go("opacity",-50,dur,ease))

  end

 end
" "
class SpriteGroup

	attr_reader :sprites

	def initialize
		@sprites = [] # [spr,ox,oy] -- maybe add opacity offset
		@opacity = 255
		@x = 0
		@y = 0
	end

	def disposed?
		return @sprites[0][0].disposed?
	end

	def update
		@sprites.each{ |s| s[0].update }
	end

	def add(spr,ox=0,oy=0)
		@sprites.push([spr,ox,oy])
	end

	def delete(spr)
		@sprites.delete_if{ |a| a[0] == spr}
	end

	def change(spr,ox,oy)
		@sprites.each{ |s|
			if s[0] == spr
				s[1] = ox
				s[2] = oy
			end
		}
	end

	def move(nx,ny)
		self.x = nx
		self.y = ny
	end

	def remove
		move(@x,@y)
	end

	def x=(v)
		@x = v
		@sprites.each{ |s| s[0].x = v + s[1] }
	end
	def x
		return @x
	end

	def y=(v)
		@y = v
		@sprites.each{ |s| s[0].y = v + s[2] }
	end
	def y
		return @y
	end

	def opacity=(v)
		@opacity = v
		@sprites.each{ |s| s[0].opacity = v }
	end
	def opacity
		return @opacity
	end

	def hide
		self.opacity = 0
	end

	def show
		self.opacity = 255
	end

end"	#==============================================================================
# ** Common Functions
#==============================================================================

def plr
	return $player
end

def me
	return $scene.map.interpreter.event_id
end

def this
	return $scene.map.events[me]
end

def dummy
	# return a dummy event that can be screwed around
end

def gid(str)

	if str == 'me'
		return me
	end

	# empty means eid
	return gev(str).id

end

def gev(str)

	if str.is_a?(Game_Event)
		return str
	end


	#check for int that is in a string
	#treat as an int

	return $player if str == -1
	return $player if str == 'plr'

	if str.kind_of?(Integer)
		return $scene.map.events[str]
	end

	if str.include?(',')

		coords = str.split(",")
		# Get by coords
		return $scene.map.event_at(coords[0].to_i,coords[1].to_i)

	end

	if str.numeric?
		return $scene.map.events[str.to_i]
	end

	if str == 'me'
		return $scene.map.events[me] 
	end

	case str

		when $player
			return $player

		when this
			return str

		when nil
			return this

			# Move all of this elsewhere
		when '@up'
			return $scene.map.event_at(this.x,this.y-1) # || dummy
		when '@up2'
			return $scene.map.event_at(this.x,this.y-2) # || dummy
		when '@down'
			return $scene.map.event_at(this.x,this.y+1)
		when '@down2'
			return $scene.map.event_at(this.x,this.y+2)
		when '@left'
		 	return $scene.map.event_at(this.x-1,this.y)
		when '@left2'
		 	return $scene.map.event_at(this.x-2,this.y)
		when '@right'
			return $scene.map.event_at(this.x+1,this.y)
		when '@right2'
			return $scene.map.event_at(this.x+2,this.y)
		when '@under'
			return $scene.map.lowest_event_at(this.x,this.y)
		when '@facing'
			return $scene.map.event_at(this.x,this.y-1) if $player.direction == 8
			return $scene.map.event_at(this.x,this.y+1) if $player.direction == 2
			return $scene.map.event_at(this.x-1,this.y) if $player.direction == 4
			return $scene.map.event_at(this.x+1,this.y) if $player.direction == 6

		
		else

			# Check if name of event
			ev = $scene.map.event_by_name(str)
			return ev if !ev.nil?

		end

	log_err("Can't find event: #{str}")
	return nil

end

def moblin(ev,delay=1)

	$scene.add_moblin(ev,delay)

end"#==============================================================================
# ** Event Functions
#==============================================================================

# Jumpings
def jump(e,x,y)
	gev(e).jump(x,y)
end

def jump_xy(e,x,y)
	ev = gev(e)
	ev.jump(x-ev.x,y-ev.y)
end

def jump_to(e,t)
	ev = gev(e)
	target = gev(t)
	ev.jump(target.x-ev.x,target.y-ev.y)
end

# Opacity
def hide(e)
	gev(e).opacity = 0
end
def unhide(e)
	gev(e).opacity = 255
end

def unhide3(*args)
	args.each{ |a|
		unhide(a+'3')
	}
end



def roll(range)
	gev(me).random = rand(range) + 1
end

def fade(ev)
	gev(ev).do(go("opacity",-255,300))
end

def gfx(ev,name)
	gev(ev).character_name = name	
end

# Routes

def wfc
	$map.interpreter.command_210
end

def td(e) gev(e).turn_down end
def tl(e) gev(e).turn_left end
def tr(e) gev(e).turn_right end
def tu(e) gev(e).turn_up end

def path(ev,tx,ty,after=nil)

	char = gev(ev)

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	x = 0
	y = 0
	sx = sy = 0

	sx = char.x
	sy = char.y
	x = char.x
	y = char.y

	result = char.setup_map(sx,sy,tx,ty)

	if !result[0]
		log_err("CANNOT FIND PATH")
		return
	end
	map = result[1]
	map[sx,sy] = result[2] if result[2] != nil

	# Now step through the path building cmds
	step = map[x,y] 
	while step != 1

	     if map[x+1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(3))
	     	x+=1
	     end
	     if map[x,y+1] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(1))
	     	y+=1
	     end
	     if map[x-1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(2))
	     	x-=1
	     end
	     if map[x,y-1] == step - 1 and step != 0
			route.list.push(RPG::MoveCommand.new(4))
			y -= 1
	     end

	     step = map[x,y] 

	end		

	if after != nil
		case after
			when 2, 'd'
				route.list.push(RPG::MoveCommand.new(16))
			when 4, 'l'
				route.list.push(RPG::MoveCommand.new(17))
			when 6, 'r'
				route.list.push(RPG::MoveCommand.new(18))
			when 8, 'u'
				route.list.push(RPG::MoveCommand.new(19))
		end
	end
	
	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)

end

def route(ev,move)

	char = gev(ev)

	data = move.split(',')

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	live_dir = char.direction

	data.each{ |step|

		params = []

		# build params split off step
		if step.include?("-")
			dta = step.split("-")
			step = dta[0]
			params.push(dta[1].to_i) if dta.count > 1
			params.push(dta[2].to_i) if dta.count > 2
			params.push(dta[3].to_i) if dta.count > 3
		end

		case step

			when 'd'
				live_dir = 2
				route.list.push(RPG::MoveCommand.new(1))
			when 'l'
				live_dir = 4
				route.list.push(RPG::MoveCommand.new(2))
			when 'r'
				live_dir = 6
				route.list.push(RPG::MoveCommand.new(3))
			when 'u'
				live_dir = 8
				route.list.push(RPG::MoveCommand.new(4))

			when 'td'
				live_dir = 2
				route.list.push(RPG::MoveCommand.new(16))
			when 'tl'
				live_dir = 4
				route.list.push(RPG::MoveCommand.new(17))
			when 'tr'
				live_dir = 6
				route.list.push(RPG::MoveCommand.new(18))
			when 'tu'
				live_dir = 8
				route.list.push(RPG::MoveCommand.new(19))

			when 'f'
				route.list.push(RPG::MoveCommand.new(12))

			when 'b'
				route.list.push(RPG::MoveCommand.new(13))


			when 'walk'
				route.list.push(RPG::MoveCommand.new(31))
			when 'unwalk'
				route.list.push(RPG::MoveCommand.new(32))

			when 'step'
				route.list.push(RPG::MoveCommand.new(33))
			when 'unstep'
				route.list.push(RPG::MoveCommand.new(34))

			when 'fix'
				route.list.push(RPG::MoveCommand.new(35))
			when 'unfix'
				route.list.push(RPG::MoveCommand.new(36))

			when 'thr', 'through'
				route.list.push(RPG::MoveCommand.new(37))
			when 'unthr', 'unthrough'
				route.list.push(RPG::MoveCommand.new(38))	

			when 'sp'
				route.list.push(RPG::MoveCommand.new(29,[params[0]]))


			when 'w'
				route.list.push(RPG::MoveCommand.new(15,[params[0]]))

			when 'j'
				route.list.push(RPG::MoveCommand.new(14,[0,0]))
			when 'jf'
				jc = [0,1] if live_dir == 2
				jc = [-1,0] if live_dir == 4
				jc = [1,0] if live_dir == 6
				jc = [0,-1] if live_dir == 8
				route.list.push(RPG::MoveCommand.new(14,jc))
			when 'jb'
				jc = [0,1] if live_dir == 8
				jc = [-1,0] if live_dir == 6
				jc = [1,0] if live_dir == 4
				jc = [0,-1] if live_dir == 2
				live_dir = 10 - live_dir
				route.list.push(RPG::MoveCommand.new(14,jc))


		end

	}

	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)
	#$map.interpreter.command_210

end
"8#==============================================================================
# ** Item Functions
#==============================================================================

def gold(amount,type='f')
	sys('coins')
	$party.add_gold(amount)
	pop_gold(amount,type)
end

def ungold(amount)
	$party.lose_gold(amount)
end

def gold?(amount)
	return $party.has_gold?(amount)
end


def item(id,number=1,type='f')
	if !number.is_a?(Integer)
		type = number
		number = 1
	end
	$party.add_item(id,number)
	return if !$scene.is_a?(Scene_Map)
	pop_item(id,number,type) if type != 's'
end

def unitem(id,number=1)
	$party.lose_item(id,number)
end

def item?(id,number=1)
	$party.has_item?(id,number)
end

def grant_items
	$data.items.each{ |k,v|
		#log_scr(v.id)
		item(v.id,99,'s')
	}
end"?
def pop_item(item,number,type)

	data = $data.items[item]
	
	b = data.name
	ib = $cache.icon(data.icon)
	if number > 1 
		b = data.name + " x #{number}"
	end		

	pop_get(type,b,ib)

end

def pop_gold(number,type)

	ib = $cache.icon('misc/coins')
	b = "#{number} Gold"	

	pop_get(type,b,ib)

end

def pop_get(type,b,ib)

	case type

		when 'f'
			a = "You found: "
			ia = nil

		when 'b'
			a = "You bought: "
			ia = nil

		when 'r'
			a = "You receive: "
			ia = nil

		when 'fang'
			a = "Fang receives: "
			ia = nil

		when 'rat'
			a = "Trevor found: "
			ia = nil

		when 'boy','ing','hib','mys','phy','rob','row'
			a = $data.actors[type].name+" receives: "
			ia = $cache.icon("faces/#{type}")

		when 's'
			return

	end

	popper = $scene.hud.open_popper
	popper.color = 'blue'
	popper.setup(a,ia,b,ib)

end

def pop_friends

	a = "Hi'beru and "
	ia = $cache.icon("faces/hib")
	
	b = "Rowen are good now friends"
	ib = $cache.icon("faces/row")

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_quest(q)

	popper = $scene.hud.open_popper
	popper.setup("New quest: ",nil,$data.quests[q].name,nil)

end

def pop_unquest(q)

	popper = $scene.hud.open_popper
	popper.setup("Quest complete: ",nil,$data.quests[q].name,nil)

end"Û#==============================================================================
# ** Progress Functions
#==============================================================================

# Quests
def quest(id) 
	$progress.add_quest(id) 
	pop_quest(id)
end

def unquest(id)
	$progress.end_quest(id)
	pop_unquest(id)
end

def quest?(id)
	return active?(id) || complete?(id)
end

def active?(id)
	return $progress.quest_active?(id)
end

def complete?(id)
	return $progress.quest_complete?(id)
end

# Progress
def progress(id) $progress.progress(id) end
def progress?(id) return $progress.progress?(id) end

def before?(id) return $progress.before?(id) end
def beyond?(id) return $progress.beyond?(id) end"Ï

def shop_choice

	case $menu.grid_action

		when 'Buy'

			# Have money, buy it
			item(gev(me).name,'b')


		when 'Info'

			text("That's a covey balm")


		when 'Cancel'

	end


end"5
def spark(ev,fx,ox=0,oy=0)

	$scene.add_spark(fx,gev(ev).real_x/4+16+ox,gev(ev).real_y/4+16-10+oy)

end

def spark_r(ev,fx,ox=0,oy=0)
	sprk = $scene.add_spark(fx,gev(ev).real_x/4+16+ox,gev(ev).real_y/4+16-10+oy)
	sprk.reverse
end

def pop_huh(ev)

	pop_icon(ev,"misc/exclaim")

end

def pop_wha(ev)

	pop_icon(ev,"misc/unknown")

end

def pop_sweat(ev)
	pop_icon(ev,"misc/sweat")
end

def pop_dots(ev)
	pop_icon(ev,"misc/dots")
end

def pop_bulb(ev)
	pop_icon(ev,"misc/bulb")
end

def pop_icon(ev,icon)

	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	x = gev(ev).screen_x+2
	y = gev(ev).screen_y - 70
	$scene.add_icon(icon,x,y,:blast,:fade)

	sfx('jump')

end

def pop_num(ev,number)

	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	x = gev(ev).screen_x+2
	y = gev(ev).screen_y - 70
	$scene.add_num(number,x,y,:blast,:fade)

	sfx('jump')

end

def icon(ev,icon,ein=:blast,eout=:blast)

	x = gev(ev).screen_x
	y = gev(ev).screen_y - 32
	$scene.add_icon(icon,x,y,ein,eout)

end"G#==============================================================================
# ** State Functions
#==============================================================================

# Flag shorthands
def flag(id) $state.flag(id) end
def unflag(id) $state.unflag(id) end
def flag?(id) return $state.flag?(id) end

# Var shorthands
def var(id,a=1) $state.var(id,a) end
def unvar(id,a=1) $state.var(id,a) end
def var?(id,a) return $state.var?(id,a) end
#def gvar(id)

# State shortands
def state(e,s) 
	$state.state(gid(e),s)
end
def unstate(e,s)
	$state.unstate(gid(e),s)
end
def state?(e,s)
	return $state.state?(gid(e),s)
end

# Misc shorthands
def loc(e) gev(e).saveloc end

def erase(e) gev(e).erase end
def delete(e) gev(e).delete end
def disable(e) gev(e).disable end

def enable(e) gev(e).enable end
"
# Misc

def text()

end

def text_wall(w='diamonds')
	$scene.hud.message.wallpaper = w
end

def w(f=5)
	$map.interpreter.wait_count = f
end

# Camera

def camera(e,spd='mid')
	$map.camera_to(gev(e),spd)
end

def camera_xy(x,y,spd='mid')
	$map.camera_xy(x,y,spd)
end

def cam_oy(amount)
	$map.do(go("cam_oy",amount,amount.abs*6,:qio))
end

def cam_ox(amount)
	$map.do(go("cam_ox",amount,amount.abs*6,:qio))
end

# Audio

def sfx(file,vol=1.0)
	$audio.sfx(file,vol)
end

def sys(file,vol=1.0)
	$audio.sys(file,vol)
end

def music(file,vol=1.0)
	$audio.music(file,vol)
end

# Menus Access

def open_main_menu
	sys('action')
	$game.menu_page = "Main"
	$game.push_scene(Scene_Menu.new)
end

def open_shop_buy
	sys('action')
	$game.menu_page = "Shop"
	$game.push_scene(Scene_Menu.new)
end

def open_shop_sell
	sys('action')
	$game.menu_page = "Shop"
	$game.push_scene(Scene_Menu.new)
end

def open_difficulty_options
	grid = $scene.hud.open_grid
	grid.x = 70
	grid.y = 60
	grid.add_difficulty('easy')
	grid.add_difficulty('mid')
	grid.add_difficulty('hard')
	return grid
end

# Fades

def fadeout(f=30)
	$scene.overlay.do(to("opacity",255,255/f))
	w f
end

def fadein(f=30)
	$scene.overlay.do(to("opacity",0,-255/30))
	w f
end"ïWORLD_MAP_ID = 25

def transfer(map,room=nil,dir=nil)

	id = find_map_id(map) if map.is_a?(String)
	room = map if room == nil
	$player.transfer_to(id,room,dir)

end

def transfer_cross(map,room=nil,dir=nil)
	$player.trans_type = :cross
	transfer(map,room,dir)
end

def transfer_fade(map,room=nil,dir=nil)
	$player.trans_type = :fade
	transfer(map,room,dir)
end

def transfer_cave(map,room=nil,dir=nil)
	$player.trans_type = :cave
	transfer(map,room,dir)
end

def transfer_same(dir=nil)
	id = $scene.map.id
	room = $map.events[me].name
	$player.transfer_to(id,room)
end

def transfer_world(dir=nil)

	# Get name of transfer
	room = $map.events[me].name

	# Do the transfer
	$player.transfer_to(WORLD_MAP_ID,room,dir)

end

def transfer_map(dir=nil)
	
	# Get name of transfer
	room = $map.events[me].name

	# Find child map
	map = find_map_id(room.split(" *")[0])

	# Do the transfer
	$player.transfer_to(map,room,dir)

end

def transfer_house_in(dir=nil)
	transfer_in(dir)
	$player.trans_type = :fade
end

def transfer_house_out(dir=nil)
	transfer_out(dir)
	$player.trans_type = :fade
end

def transfer_cave_in(dir=nil)
	transfer_in(dir)
	$player.trans_type = :cave
end

def transfer_cave_out(dir=nil)
	transfer_out(dir)
	$player.trans_type = :cave
end

def transfer_in(dir=nil)

	$player.trans_type = :cross

	# Get name of transfer
	room = $map.events[me].name

	# Find child map of name
	map = find_child_id($map.id,room)

	# If couldn't find, use default
	if map == 0
		map = find_child_id($map.id,".Indoor")
	end

	# Do the transfer
	$player.transfer_to(map,room,dir)

end

def transfer_out(dir=nil)

	$player.trans_type = :cross

	# Get name of transfer
	room = $map.events[me].name

	# Find child map
	map = find_parent_id($map.id)

	# Do the transfer
	$player.transfer_to(map,room,dir)

end


def find_parent_id(map_id)
	return $data.mapinfos[map_id].parent_id
end

def find_child_id(parent_id,name)

	$data.mapinfos.each{ |k,map|
		next if map.parent_id != parent_id
		next if map.name.split(" @")[0] != name
		return k
	}

	return 0

 end

 def find_map_id(name)

	$data.mapinfos.each{ |k,map|
		return k if map.name == name
	}

	return 0

 end"
# Update self perhamps? Disregard else
# Uses $battle and that's it

# Handle all inputs?

class BattleHud

	def initialize(vp)

		# Bottom bar
		@chars = []
		idx = 0
		$party.active.each{ |char|
			char = CharView.new(vp,$party.actor_by_id(char),idx)
			char.x = 5 + (idx * 158)
			char.y = 340
			@chars.push(char)
			idx += 1
		}

		# Help box
		@help_box = Box.new(vp)
		@help_box.skin = $cache.menu_common("skin-plain")
    	@help_box.wallpaper = $cache.menu_wallpaper("diamonds")
		@help_box.resize(300,50)
		@help_box.move(166,8)

	    @help_text = Sprite.new(vp)
	    @help_text.bitmap = Bitmap.new(300,50)
	    @help_text.bitmap.font = $fonts.message
	    @help_text.bitmap.draw_text(0,0,300,50,"Shadow - Gain Darkness",1)
		@help_text.move(166,9)

	end

	def dispose

	end

	def set_help(text)

		@help_text.bitmap.clear
		@help_text.bitmap.draw_text(0,0,300,50,text,1)

	end
	
	def update

		@chars.each{ |c|
			c.update
		}

		@help_box.update

	end

end"Ö

class Popper < Sprite

	attr_accessor :value

	def initialize(vp)
		super(vp)

		@value = 0
		@old_value = 0

		self.bitmap = Bitmap.new(200,50)
		self.bitmap.font = $fonts.namebox

		refresh

	end

	def update

		if @value != @old_value
			refresh
		end

	end

	def done?
		return self.opacity == 0
	end

	def refresh

		# Draw the value out!
		self.bitmap.clear
		self.bitmap.draw_text(0,0,200,50,@value.to_i.to_s,2)

	end

end"
class ActorCmd

	def initialize(vp)

		@vp = vp

		@icons = []
		@texts = []
		#@text = Sprite.new(@vp)

		@idx = 0

	end

	def setup(battler)

		close

		@battler = battler

		@icons.each{ |i| i.dispose }
		@icons = []

		@texts.each{ |i| i.dispose }
		@texts = []

		# Read the categories for this guy
		@battler.actions.each{ |action|
			# Add an icon?
			spr = Sprite.new(@vp)
			@icons.push(spr)

			spr = Sprite.new(@vp)
			@texts.push(spr)
		}

		# Position the things
		#@idx = 1
		

		reposition
		select

		# Prep the text
		#@text.bitmap = Cache.menu("Battle/text")
		#@text.center(battler.ev.screen_x,battler.ev.screen_y + 24)

	end

	def close
		return if !@icons || @icons.empty?

		@icons.each{ |i|
			$tweens.clear(i)
		}
		@texts.each{ |i|
			$tweens.clear(i)
		}

		if @icons.count == 2

			@icons[0].do(go("x",18,250,:qio))
			@icons[0].do(go("y",25,250,:qio))

			@icons[1].do(go("x",-18,250,:qio))
			@icons[1].do(go("y",25,250,:qio))

		end

		if @icons.count == 3

			@icons[0].do(go("x",36,250,:qio))
			@icons[0].do(go("y",16,250,:qio))

			@icons[1].do(go("y",25,250,:qio))

			@icons[2].do(go("x",-36,250,:qio))
			@icons[2].do(go("y",16,250,:qio))

		end

		if @icons.count == 4

			@icons[0].do(go("x",54,250,:qio))
			@icons[0].do(go("y",16,250,:qio))

			@icons[1].do(go("x",18,250,:qio))
			@icons[1].do(go("y",25,250,:qio))

			@icons[2].do(go("x",-18,250,:qio))
			@icons[2].do(go("y",25,250,:qio))

			@icons[3].do(go("x",-54,250,:qio))
			@icons[3].do(go("y",16,250,:qio))

		end

		(@texts + @icons).each{ |i|
			i.do(go("opacity",-255,250,:qio))
			i.do(go("opacity",-255,250,:qio))
			i.do(go("opacity",-255,250,:qio))
		}

	end

	def get_action
		return @battler.actions[@idx]
	end

	def reposition
		sx = @battler.ev.screen_x
		sy = @battler.ev.screen_y-44

		@icons.each{ |i|

				# Hide and fade in
				i.opacity = 0
				i.do(go("opacity",255,250,:qio))

				# Move
				i.move(sx,sy+12)

			}

		if @icons.count == 2

			cx = -18

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-25,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

		end

		if @icons.count == 3

			cx = -36

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-16,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[2].do(go("x",cx,250,:qio))
			@icons[2].do(go("y",-16,250,:qio))

			@texts[2].move(sx+cx+2,sy-35)

		end

		if @icons.count == 4

			cx = -36-18

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-16,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[2].do(go("x",cx,250,:qio))
			@icons[2].do(go("y",-25,250,:qio))

			@texts[2].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[3].do(go("x",cx,250,:qio))
			@icons[3].do(go("y",-16,250,:qio))

			@texts[3].move(sx+cx+2,sy-35)
			
		end


	end

	def select
		sys('select')
		
		idx = 0
		@icons.each{ |i|
			#$tweens.resolve(i)
			
			i.bitmap = $cache.icon("battle/#{@battler.actions[idx]}")

			i.ox = i.width/2
			i.oy = i.height
			idx += 1
		}
		idx = 0
		@texts.each{ |i|
			$tweens.resolve(i)

			i.opacity = 0
			
			i.bitmap = $cache.icon("texts/#{@battler.actions[idx]}")

			i.ox = i.width/2
			i.oy = i.height
			idx += 1
		}

		
		#reposition
		@icons[@idx].bitmap = $cache.icon("battle/#{@battler.actions[@idx]}-on")
		#seq = sequence(go("y",-3,400),go("y",3,400))
		@icons[@idx].do(repeat(seq))
		$scene.hud.set_help(@battler.actions[@idx])
		@icons[@idx].ox = @icons[@idx].width/2
		@icons[@idx].oy = @icons[@idx].height

		@texts[@idx].y -= 10
		@texts[@idx].do(go("y",10,250,:qio))
		@texts[@idx].do(go("opacity",255,250,:qio))

		#@texts[@idx].zoom_x -= 10
		@icons[@idx].zoom_x = 1.0
		@icons[@idx].zoom_y = 1.0
		@icons[@idx].do(seq(go("zoom_x",0.2,50,:qio),go("zoom_x",-0.2,50,:qio)))
		@icons[@idx].do(seq(go("zoom_y",0.2,50,:qio),go("zoom_y",-0.2,50,:qio)))

	end

	def update

		return if @battler.nil?

		# Left and right to change
		if $input.right? && @idx < @icons.count-1
			@idx += 1
			select
		end

		if $input.left? && @idx > 0
			@idx -= 1 			
			select
		end

		pos = $mouse.position
		pos[0] += 13
		pos[1] += 34
			@icons.each{ |i|
			if i.within?(pos[0],pos[1])
				break if @icons.index(i) == @idx
				@idx = @icons.index(i)
				select
			end
		}

	end

end"Ö
# Actor view, show portrait, hp etc

class CharView < SpriteGroup

	def initialize(vp,char,id)

		super()

		@battler = char

		@box = Box.new(vp)
		@box.skin = $cache.menu_common("skin-plain")
    	@box.wallpaper = $cache.menu_wallpaper("back2")
		@box.resize(153,135)
		add(@box)   

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_battle(char.id)
		add(@port,153-@port.width-10,135-@port.height-10)

		@shadow = Sprite.new(vp)
		@shadow.bitmap = $cache.menu_char("battlehud-shadow")
		add(@shadow,6,74)

		# @xform = Sprite.new(vp)
		# @xform.bitmap = $cache.menu_char("Transforms/frog") if rand(10) > 3
		# add(@xform,15,65)

		# Health
		#bars

		@hp_bar = Bar.new(vp,110,8)
		add(@hp_bar,11,118)

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200
		add(@hp_label,12,110)

		@hp_text = Label.new(vp)
		@hp_text.font = $fonts.hud_hp
		@hp_text.text = 23
		add(@hp_text,120,110)

		@mp_bar = Bar.new(vp,110,8)
		add(@mp_bar,11,100)

		@mp_label = Sprite.new(vp)
		@mp_label.bitmap = $cache.menu_char("label-mp")
		@mp_label.opacity = 200
		add(@mp_label,12,92)

	end

	def update

		@box.update
		@hp_bar.update
		@mp_bar.update

		@hp_text.text = @battler.hp
		@hp_bar.value = @battler.hp
		@hp_bar.max = @battler.maxhp

		# If a state, change background
		if @battler.state?('power')
			@box.wallpaper = $cache.menu_wallpaper("lightning")
		end

	end

end"Ç
class ItemCmd

	def initialize(vp)

		# Left side window
		@window = Box.new(vp,300,242)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	@window.move(14,66)

		# Left side list
		@list = List.new()
		@list.move(20,72)

		@list.per_page = 6
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 1

		@list.change = Proc.new{ |option| self.change(option) }

		@list.setup([])
		@list.refresh

		@box = Item_Box.new(vp)
		@box.item('covey')
		@box.move(326,100)
		@box.opacity = 0

		@list.opacity = 0
		@window.opacity = 0

	end

	def setup

		item_list = $party.battle_item_list
		@list.setup(item_list)
		change(item_list[0])

		open
	end

	def open
		$tweens.clear(@list)
		$tweens.clear(@window)
		$tweens.clear(@box)

		@list.opacity = 0
		@window.opacity = 0
		@box.opacity = 0

		@list.x = -132
		@list.do(go("x",150,250,:qio))
		@list.do(go("opacity",255,250,:qio))

		@window.x = -138
		@window.do(go("x",150,250,:qio))
		@window.do(go("opacity",255,250,:qio))

		@box.x = 326+150
		@box.do(go("x",-150,250,:qio))
		@box.do(go("opacity",255,250,:qio))
	end

	def close
		$tweens.clear(@list)
		$tweens.clear(@window)
		$tweens.clear(@box)

		@list.do(go("x",-150,250,:qio))
		@list.do(go("opacity",-255,250,:qio))

		@window.do(go("x",-150,250,:qio))
		@window.do(go("opacity",-255,250,:qio))

		@box.do(go("x",150,250,:qio))
		@box.do(go("opacity",-255,250,:qio))
	end

	def update
		@list.update
	end

	def change(option)
		@item = option
		@box.item(option)
		#@box.center(462,130+@list.page_idx*@list.item_height)
	end

	def get_item
		return @item
	end

end"»
class SkillCmd < ItemCmd

	def setup(battler)

		@battler = battler

		skill_list = @battler.skill_list

		log_info(skill_list)
		@box.type = :skill
		@list.type = :skill
		@list.setup(skill_list)
		change(skill_list[0])

		open
	end

	def get_skill
		return @item
	end

	def change(option)
		return if !@box
		@item = option
		@box.skill(option)
		#@box.center(462,130+@list.page_idx*@list.item_height)
	end

end"b
class TargetCmd

	attr_reader :active

	def initialize(vp)

		@vp = vp

		@arrow = Sprite.new(@vp)
		@arrow.bitmap = $cache.menu_common("target")
		@arrow.hide

		@targets_sy = nil
		@targets_sx = nil
		@targets = nil

		@active = nil

		@idx = 0

	end

	def setup(targets)

		@arrow.show

		@targets = targets

		# Sort targets by y pos
		# Maybe x sort for left and right?
		@targets_sy = targets.sort_by{ |t| t.ev.screen_y }
		@targets_sx = targets.sort_by{ |t| t.ev.screen_x }

		# Arrow pos
		@active = targets[0]
		point_at(targets[0])

	end

	def point_at(char)
		@arrow.center(char.ev.screen_x,char.ev.screen_y)
	end

	def close
		@arrow.hide
	end

	def update

		# Left and right to change
		if $input.right?


			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx += 1
			if idx >= @targets_sx.count
			  idx -=1
			end
			@active = @targets_sx[idx]

			point_at(@active)
			
		end

		if $input.left?
			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			end
			@active = @targets_sx[idx]

			point_at(@active)
		end



		# Left and right to change
		if $input.down?	
			
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx += 1
			if idx >= @targets_sy.count
			  idx -=1
			end
			@active = @targets_sy[idx]

			point_at(@active)
			
		end

		if $input.up?
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			end
			@active = @targets_sy[idx]

			point_at(@active)
		end

		pos = $mouse.position
		@targets.each{ |i|
			next if pos[0] < i.ev.screen_x - 20
			next if pos[0] > i.ev.screen_x + 20
			next if pos[1] < i.ev.screen_y - 64
			next if pos[1] > i.ev.screen_y
			@active = i
			point_at(@active)
		}

	end

end
" #==============================================================================
# Ui_Screen
#==============================================================================

class Ui_Screen

	attr_reader :message
  
	def initialize(vp)

		@vp = vp
		
		@message = Ui_Message.new(vp)

		@bar = Ui_Bar.new(vp)
		#@bar.hide
		
		@info = Ui_Info.new(vp)

		@popper = nil
		@grid = nil
		@item = nil

	end

	def update
		@message.update
		@bar.update
		#@info.update
		if @popper
			@popper.update 
			if $input.action? || $input.click?
				$tweens.clear(@popper)
				@popper.dispose
				@popper = nil
			end
		end

		if @grid
			@grid.update 
			if $input.action? || $input.click?
				# Record action and close
				$menu.grid_action = @grid.get_chosen

				$tweens.clear(@grid)
				@grid.dispose
				@grid = nil
				if @item
					$tweens.clear(@item)
					@item.dispose
					@item = nil
				end
			end
		end

		if @item
			@item.update 
			if $input.action? || $input.click?
				$tweens.clear(@item)
				@item.dispose
				@item = nil
			end
		end

	  # Check inputs
	  return if busy? or $map.interpreter.running?
      if $input.cancel? || $input.rclick?
      	open_main_menu
      end

	end

	def open_buy_item(i)
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move($player.screen_x-@item.width,$player.screen_y-64-@item.height-40)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height
		grid.add_button('Buy',"Buy",'misc/unknown')
		grid.add_button('Info',"Info",'misc/unknown')
		grid.add_button('Cancel',"Cancel",'misc/unknown')
	end

	def open_sell_item(i)
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move($player.screen_x-@item.width,$player.screen_y-64-@item.height-40)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height
		grid.add_button('Buy',"Buy",'misc/unknown')
		grid.add_button('Info',"Info",'misc/unknown')
		grid.add_button('Cancel',"Cancel",'misc/unknown')
	end

	def open_empty_item
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move($player.screen_x-@item.width,$player.screen_y-64-@item.height-40)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height
		grid.add_button('Buy',"Buy",'misc/unknown')
		grid.add_button('Info',"Info",'misc/unknown')
		grid.add_button('Cancel',"Cancel",'misc/unknown')
	end

	def open_popper()
		@popper = Ui_Popper.new(@vp)
		return @popper
	end

	def open_grid()
		@grid = Ui_Grid.new(@vp)
		return @grid
	end

    def busy?() 
    	return @message.busy? || @item || @popper || @grid
    end

end"é#==============================================================================
# Ui_Bar
#==============================================================================

class Ui_Bar < SpriteGroup

	def initialize(vp)
		super()

		@base = Sprite.new(vp)
		@base.bitmap = Bitmap.new(640,32)
		@base.bitmap.fill_rand
		add(@base)

		# Buttons
		cx = 4

		@quit = Button.new(vp)
		@quit.bitmap = $cache.icon("misc/quit")
		@quit.press = Proc.new{ log_info("QUIT BUTTON") }
		add(@quit,cx,4)

		cx += 24 + 4

		@char = Button.new(vp)
		@char.bitmap = $cache.icon("misc/char")
		add(@char,cx,4)

		cx += 24 + 4

		@save = Button.new(vp)
		@save.bitmap = $cache.icon("misc/keys")
		add(@save,cx,4)

		cx += 24 + 4

		@journal = Button.new(vp)
		@journal.bitmap = $cache.icon("misc/journal")
		add(@journal,cx,4)

		cx += 24 + 4

		@items = Button.new(vp)
		@items.bitmap = $cache.icon("misc/coins")
		add(@items,cx,4)

		cx += 24 + 4

		@settings = Button.new(vp)
		@settings.bitmap = $cache.icon("misc/settings")
		add(@settings,cx,4)

		cx += 24 + 4

		@help = Button.new(vp)
		@help.bitmap = $cache.icon("misc/unknown")
		add(@help,cx,4)

		move(0,480-32)

	end

	def update
		super()
	end

end"B(#==============================================================================
# ** Ui_Grid
#==============================================================================

class Ui_Grid

	attr_reader :idx

	attr_accessor :spacing, :cx, :cy

	def initialize(vp)

		@vp = vp

		@active = true

		@layout = :vertical

		@cx = 0
		@cy = 0

		@spacing = 5

		@fix_width = 0

		@boxes = []
		@contents = []
		@extra = []

     	@glow = Sprite.new(vp)
     	@glow.bitmap = Bitmap.new(100,100)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow"))
     	@glow.do(pingpong("opacity",-100,300,:quad_in_out))
     	@glow.z += 50

     	@idx = 0

     	@type = :slot
     	@char = 'boy'
     	
     	#@selected = "Journal"
     	#choose(@selected)

	end

	def enable
		@active = true
		choose(@selected)
	end

	def disable
		@active = false
		@glow.move(-1000,-1000)
	end

	def move(x,y)
		@cx = x
		@cy = y
	end

	def opacity=(o)

	end
	def opacity
		return 255
	end

	def x=(v)
		@cx = v
	end
	def x
		return @cx
	end

	def y=(v)
		@cy = v
	end
	def y
		return @cy
	end

	def dispose

		$tweens.clear(@glow)
		@glow.dispose
		@contents.each{ |i| i.dispose }
		@extra.each{ |i| i.dispose }
		@boxes.each{ |i| i.dispose }

	end

	def clear
		@contents.each{ |i| i.dispose }
		@extra.each{ |i| i.dispose }
		@boxes.each{ |i| i.dispose }
		@contents = []
		@boxes = []
		@extras = []

		@cx = 0
		@cy = 0

	end

	def add_active(id)

		char = $party.get(id)

		# Create new things
		btn = add_part_box(char.name,148,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("faces/#{id}")
     	#cont.gradient = true
     	cont.text = ' '
     	@contents.push(cont)

     	hp_bar = Bar.new(@vp,92,8)
		@extra.push(hp_bar)

		mp_bar = Bar.new(@vp,92,8)
		@extra.push(mp_bar)

     	# Position
     	cont.move(@cx+8,@cy+7)
     	hp_bar.move(@cx + 42,@cy+14)
     	mp_bar.move(@cx + 42,@cy+14+12)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @boxes.count % 2 == 0
  			@cy += btn.height + @spacing - 2
  			@cx -= btn.width + @spacing - 1
  		else
			@cx += btn.width + @spacing - 1
  		end

	end

	def add_reserve(id)

		char = $party.get(id)

		# Create new things
		btn = add_part_box(char.name,97,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("faces/#{id}")
     	#cont.gradient = true
     	cont.text = ' '
     	@contents.push(cont)

     	hp_bar = Bar.new(@vp,42,8)
		@extra.push(hp_bar)

		mp_bar = Bar.new(@vp,42,8)
		@extra.push(mp_bar)

     	# Position
     	cont.move(@cx+8,@cy+7)
     	hp_bar.move(@cx + 42,@cy+14)
     	mp_bar.move(@cx + 42,@cy+14+12)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
		@cx += btn.width + @spacing - 1

	end

	def add_button(name,text,icon)

		# Create new things
		btn = add_part_box(name,120,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx+10,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + @spacing
     	end

	end

	def add_wide(name,text,icon)

		# Create new things
		btn = add_part_box(name,300,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx+10,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + @spacing
     	end

	end

	def add_slot(slot,eq)

		log_info(slot)

		item = $data.items[eq]

		if item != nil
			
			text = item.name
			icon = item.icon
		else
			icon = "misc/unknown"
			text = 'Empty'
		end

		# Create new things
		btn = add_part_box(slot,300,61)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	stat = Label.new(@vp)
     	stat.font = $fonts.pop_type
     	#stat.shadow = $fonts.list_shadow
     	stat.icon = $cache.icon("stats/attack")
     	#stat.gradient = true
     	stat.text = "24 Strength"
     	@extra.push(stat)

     	cat = Label.new(@vp)
    	cat.fixed_width = 250
    	cat.font = $fonts.pop_type
    	cat.align = 0
    	cat.text = slot
    	@extra.push(cat)

     	# Position
     	cont.move(@cx+10,@cy+7)
     	stat.move(@cx+25,@cy+28)
     	cat.move(@cx+245,@cy+8)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + 4
     	end

	end

	def add_difficulty(diff)

		# Create new things
		btn = add_part_box(diff,500,116)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("misc/diff-#{diff}")
     	cont.gradient = true
     	cont.text = diff_name(diff)
     	@contents.push(cont)
     	cont.move(@cx+10,@cy+7)

     	stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/attack")
        stat.font = $fonts.pop_text
        stat.text = "Enemies do 25% less damage"
        @extra.push(stat)
        stat.move(@cx+22,@cy+34)

        stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/targets")
        stat.font = $fonts.pop_text
        stat.text = "Enemies respawn"
        @extra.push(stat)
        stat.move(@cx+22,@cy+57)

        stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/restore")
        stat.font = $fonts.pop_text
        stat.text = "Health is not restored when gaining levels"
        @extra.push(stat)
        stat.move(@cx+22,@cy+80)

     	# Position
     	
     	

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + 5
     	end

	end

	def add_party_mem(box,id)

		char = $party.get(id)

		name = "- Empty -"
		name = char.name if char
		name += " - Lvl #{char.level.to_s}" if char

		# Create new things
		btn = add_part_box(box,300,70)

		cont = Label.new(@vp)
	    cont.font = $fonts.list
	    cont.shadow = $fonts.list_shadow
	    cont.gradient = true
	    cont.text = name
	    @contents.push(cont)
	    cont.move(@cx+15,@cy+7)

		if char == nil



		else

	     	port = Sprite.new(@vp)
			port.bitmap = $cache.face_small(id)
			port.src_rect.height = port.height() - 14
			@extra.push(port)
			port.move(@cx+btn.width-port.width-9,@cy+62-port.src_rect.height)
			port.z += 50

			hp_bar = Bar.new(@vp,170,8)
			@extra.push(hp_bar)
			hp_bar.opacity = 200
			hp_bar.move(@cx+20,@cy+42)
			
	     	choose(@boxes[0].name) if @boxes.count == 1

	     end

     	# Next
		@cy += btn.height + @spacing + 3

	end

	def add_part_box(name,w,h)
		btn = Box.new(@vp,w,h)
     	btn.skin = $cache.menu_common("skin-plain")
     	btn.wallpaper = $cache.menu_wallpaper('diamonds')
     	#btn.wallpaper = $cache.menu_wallpaper(["blue",'green','orange','diamonds'].sample)
     	btn.name = name
     	@boxes.push(btn)
     	btn.move(@cx,@cy)
     	return btn
	end

	def diff_name(diff)
		case diff
			when 'easy'
				return "Bunny Protector - Easy Mode"
			when 'mid'
				return "Villain - Normal Mode"
			when 'hard'
				return "Super Villain - Expert Mode"
		end
	end

	def get_box(option)
		return @boxes.select{ |b| b.name == option }[0]
	end

	def update
		return if !@active
		return if @boxes.empty?

		if @boxes.count > 1 && $input.down?
			sx = @selected_box.x + @selected_box.width/2		
			sy = @selected_box.y + @selected_box.height
			search(sx,sy,1,3)
		end

		if @boxes.count > 1 && $input.up?
			sx = @selected_box.x + @selected_box.width/2		
			sy = @selected_box.y
			search(sx,sy,1,-3)
		end

		if @boxes.count > 1 && $input.right?		
			sx = @selected_box.x + @selected_box.width
			sy = @selected_box.y + @selected_box.height/2	
			search(sx,sy,3,1)
		end

		if @boxes.count > 1 && $input.left?
			sx = @selected_box.x
			sy = @selected_box.y + @selected_box.height/2
			search(sx,sy,-3,1)
		end


		pos = $mouse.position
		@boxes.each{ |b| 

			next if b == @selected_box
			next if pos[0] < b.x
		    next if pos[1] < b.y
		    next if pos[0] > b.x + b.width
		    next if pos[1] > b.y + b.height
			choose(b.name)
			break

		}

	end

	def search(sx,sy,x,y)

		cx = sx
		cy = sy

		# Start moving until find something
		while true

			cx += x
			cy += y

			@boxes.each{ |box|
				next if box == @selected_box 
				if box.window.within?(cx,cy)
					return choose(box.name)
				end
			}

			cy = 0 if cy > 480
			cx = 0 if cx > 640
			cy = 480 if cy < 0
			cx = 640 if cx < 0

		end

	end

	def open

		@glow.show
		@contents.each{ |i| i.show }
		@extra.each{ |i| i.show }
		@boxes.each{ |i| i.show }

	end

	def close

		@glow.hide
		@contents.each{ |i| i.hide }
		@extra.each{ |i| i.hide }
		@boxes.each{ |i| i.hide }

	end

	def choose(target)

		sys('select')

		@selected = target
		@selected_box = @boxes.find{ |b| b.name == target }

		# Find the icon if this is journal
		@idx = nil
		if !@boxes.select{ |b| b.name == target }.empty?

			idx = 0
			@boxes.each{ |b|
				break if b.name == target
				idx += 1
			}

			@idx = idx

		end

		glowon = @selected_box

		@glow.bitmap = Bitmap.new(glowon.width-12,glowon.height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow"))
		@glow.move(glowon.x+6,glowon.y+6)

	end

	def get_chosen
		return @selected
	end

end"C#==============================================================================
# Ui_Info
#==============================================================================

class Ui_Info < SpriteGroup

	def initialize(vp)
		super()

		# Map
		@map = Label.new(vp)
		@map.font = $fonts.pop_type
		@map.icon = $cache.icon("items/map")
		@map.text = $map.name
		add(@map,0,0)

		@gold = Label.new(vp)
		@gold.font = $fonts.pop_type
		@gold.icon = $cache.icon("misc/coins")
		@gold.text = $party.gold.to_s
		add(@gold,560,0)

		move(0,415)

		#refresh

	end

	def update
		super
		#refresh if @visible_gold != $party.gold || @visible_map != $map.name
	end

	def refresh
		@visible_gold = $party.gold
		@visible_map = $map.name

		@map.text = $visible_map
		@gold.text = $visible_gold.to_s

	end

end"J#==============================================================================
# Ui_Message
#==============================================================================

class Ui_Message

  # Consts
  MIN_WIDTH = 200
  MAX_WIDTH = 350
  TAB_WIDTH = 35

  VN_WIDTH = 520

  MIN_HEIGHT_FACE = 80

  SPACING = 7
  LINE_HEIGHT = 27
  PADDING_X = 21
  PADDING_Y = 16

  SPEED_1 = 9
  SPEED_2 = 7
  SPEED_3 = 5
  SPEED_4 = 3
  SPEED_5 = 2

  attr_reader :last_choice
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize(vp)

    @vp = vp

    # Create the pieces but do nothing besides
    @state = :idle

    # Hold on to the convo
    @text = ""

    @scratch = Bitmap.new(400,50)
    @scratch.font = $fonts.message

    @lines = []

    # Settings
    @color = nil

    # Text display
    @text_delay = SPEED_4
    @normal_speed = SPEED_4
    @wait_frames = 0
    @next_char = 0

    @cx = 0
    @cy = 0
    
    @line_idx = nil
    @word_idx = nil
    @char_idx = nil

    @width = 0
    @height = 0

    @mode = :speaker # speaker, system or vn
    @speaker = nil

    @vn_port = Sprite.new(vp)

    @sprites = SpriteGroup.new

    @box = Box.new(vp)
    @box.skin = $cache.menu_common("skin")
    @box.wallpaper = $cache.menu_wallpaper("diamonds")
    #@box.wallpaper = $cache.menu_wallpaper("fangder")
    @box.scroll(0.1,0.1)

    # Setup sprites    
    @textbox = Sprite.new(vp)
    @textbox.z += 50

    @lastchar = Sprite.new(vp)
    @lastchar.z += 50

    @namebox = Sprite.new(vp)
    @namebox.bitmap = Bitmap.new(220,40)
    @namebox.bitmap.hskin($cache.menu("Common/namebox"))

    @nametext = Sprite.new(vp)
    @nametext.bitmap = Bitmap.new(220,40)
    @nametext.bitmap.font = $fonts.namebox
    @nametext.bitmap.draw_text(0,0,220,40,"texter")

    #@next = Sprite.new(vp)
    #@next.bitmap = $cache.menu("Common/next")
    
    @face = Sprite.new(vp)
    @face.z += 10
    
    @tail = Sprite.new(vp)
    @tail.bitmap = $cache.menu("Common/tail")


    # Group system
    @sprites.add(@box)
    @sprites.add(@textbox)
    @sprites.add(@lastchar)

    @sprites.add(@namebox,20,-@namebox.height+16)
    @sprites.add(@nametext,40,-@namebox.height+19)

    #@sprites.add(@next)
    @sprites.add(@face)
   # @sprites.add(@tail)

    @sprites.opacity = 0

    @sparks = []

    # Draw to textbox
    @text_bmp = nil

    @grid = nil
    @choices = []
    @last_choice = ''

  end

  def wallpaper=(w)
    @box.wallpaper = $cache.menu_wallpaper(w)
    if w == 'fangder'
      @box.alpha = 255
    else
      @box.alpha = 230
    end
  end
  
  #--------------------------------------------------------------------------
  # Frame Update
  #--------------------------------------------------------------------------
  def update

    @grid.update if @grid

    if @mode == :message

      @speaker = plr if !@speaker

      # Put over speaker
      x = @speaker.screen_x - @width/2 - 10
      y = @speaker.screen_y - @height - 70

      # Hiding the tail?
      h = false

      # LIMIT TO BE ON SCREEN
      if x < 7
        x = 7 
        #h = true
      end
      if y < 46
        #y = 290
        #h = true
      end
      if x > 640-@width-10
        x = 640-@width-10
        #h = true
      end
      if y > 480-@height-10
        y = 480-@height-10
        h = true
      end
      # @tail.bitmap = $cache.menu("Common/tail2") if h == true
      # @tail.bitmap = $cache.menu("Common/tail") if h == false

      @sprites.move(x,y)

      x = @speaker.screen_x - 12# - @width/2
      y = @speaker.screen_y - 70# - @height

      @tail.move(x,y)

      

    end

    @box.update
    @sparks.each{ |s| s.update }
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end      
    
    # Skip to end of this text
    # if $input.action?
    #   @skip_all = true
    # end



    case @state

      when :closed
        #nothing

      when :opening
        @state = :texting if self.zoom_y == 1.0

      when :closing
        @state = :idle

      when :texting
        @next_char -= 1
        if @next_char <= 0
          #log_err "DOING"
          update_message
        end
        redraw

        if $input.action? || $input.click?
      
          @super_skipping = true
          while @state == :texting

            update_message           
          end
          @super_skipping = false
          redraw
          
        end
        
      when :waiting
        update_waiting

        # Choices in here too

      #when :pausing
      #  check_input_next
      when :choice
        check_input_choice
      when :done
        check_input_done
        
    end

    # skipping
    # while @state == :texting && $input.action?
    #   @next_char > 0 ? @next_char -= 1 : update_message
    # end

  end

  def add_choice(choice)
    @choices.push(choice)
  end

  #--------------------------------------------------------------------------
  # Show Convo
  #--------------------------------------------------------------------------
  def start(text, choices = nil)

    $tweens.clear(@sprites)

    @mode = :message

    # Reset
    @face.bitmap = nil
    #@vn_port.bitmap = nil
    @vn_port.do(to("opacity",0,-11))
    @speaker = nil
    @line_idx = 0
    @word_idx = -1
    @cx = PADDING_X
    @cy = PADDING_Y

    return log_err "Must specify speaker" if !text.include?(':')
    text_data = text.split(":")

    # Read data to get name and text
    speaker = text_data[0]
    @lines = split_text(text_data[1]) 

    # Figure things out from speaker
    speaker = this.name if speaker == 'this'
    speaker = this.name if speaker == 'This'
    name = speaker.gsub(/\A[\d_\W]+|[\d_\W]+\Z/, '') # Remove numbers


    # Check the mode
    if speaker.include?("vn-")
      speaker = speaker.sub("vn-",'')
      name = name.sub("vn-",'')
      @mode = :vn

      # Set vn face
      @vn_port.bitmap = $cache.face_vn(speaker)
      @vn_port.x = ($game.width - @vn_port.width)/2
      @vn_port.y = $game.height - @vn_port.height
      @vn_port.opacity = 0
      @vn_port.do(go("opacity",255,400,:quad_in_out))
      speaker = nil

    end

    # System message
    if speaker.split("-")[0] == 'sys'
      if speaker.split("-").count > 1
        @box.wallpaper = $cache.menu_wallpaper(speaker.split("-")[1])
      end
      speaker = nil
      name = ''
      @mode = :sys
      @tail.hide
    end
    
    # If in party, show as player and change player graphic
    if speaker != nil && $party.all.include?(speaker.split('-')[0]) && @mode == :message
      @speaker = $player
      $player.looklike(name.split('-')[0])
    elsif speaker != nil
      @speaker = gev(speaker.split("-")[0])
      @mode = :sys if @speaker == nil
    end

    # Force name to not have the number
    name.delete!('123456789')

    # Get face and name of player characters
    if $data.actors.has_key?(name.split('-')[0])
      @face.bitmap = $cache.face(name) if @mode == :message
      name = $data.actors[name.split('-')[0]].name
    end

    build_namebox(name.split("-")[0])

       

    # Textbox size
    @width = max_width + PADDING_X * 2
    @height = (@lines.count * LINE_HEIGHT) + PADDING_Y * 2

    # Position the face
    if @face.bitmap
      @width += @face.width 
      @height = MIN_HEIGHT_FACE  + PADDING_Y * 2
      fx = -10 + max_width + PADDING_X + PADDING_X
      fy = 7 + @height - @face.height - PADDING_Y
      @sprites.change(@face,fx,fy)
    end

    if @mode == :vn
      @width = VN_WIDTH
      @height = (3 * LINE_HEIGHT) + PADDING_Y * 2
    end

    # Prepare the sprites  
    @box.resize(@width,@height)
    @textbox.bitmap = Bitmap.new(@width,@height)
    @text_bmp = Bitmap.new(@width,@height)
    
    @text_bmp.font = $fonts.message
    @textbox.bitmap.font = $fonts.message

    # Point tale x at speaker and y under box
    # Would need to be put in update
    @sprites.change(@tail,@width/2-2,@height)
    #@sprites.change(@next,@width/2,@height-20)
    $tweens.clear(@sprites)
    @sprites.do(go("opacity",255,500,:quad_in_out))
    
    #@sprites.do(go("y",-25,500,:quad_in_out))

    # Start writing    
    @state = :texting

    # Position for system messages
    if @mode == :vn
      @sprites.move(($game.width-@width)/2,320)
    end

    if @mode == :sys
      @sprites.move(($game.width-@width)/2,220)
    end
        
  end

  def build_namebox(name)

      # Create the namebox
      @nametext.bitmap.clear
      @namebox.bitmap.clear

      return if name == ''
      return if name == nil

      size = $fonts.size(name,@nametext.bitmap.font)
      @namebox.bitmap = Bitmap.new(size.width+40,40)
      @namebox.bitmap.hskin($cache.menu("Common/namebox"))
      @nametext.bitmap.draw_gtext(0,0,220,35,name,1)

  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message

    skip_wait_test = false
    
    # if the current word is empty, get the next one and see if it fits
    if @word == nil || @char_idx > @word.length
      next_word
      skip_wait_test = true
    end
        
    # if not texting then don't go
    return unless @state == :texting
            
    # Add the next character to the final word
    @char_idx += 1

    # Play a lovely character sound
    sys('txt2',1.0) #if $settings.value('text_sound') 
    
    # Wait before drawing another character
    @next_char = @text_delay if !skip_wait_test

    # Show the behind char anim
        # Spawn spark
    

    txt = @word.delete('*^')[0..@char_idx-1]
    size = @scratch.text_size(txt)

    #return if size.width < 10
    
    x = @sprites.x + @cx+size.width
    y = @sprites.y + @cy

    return if @super_skipping #|| (@char_idx >= @word.length-1 && @char_idx > 0)

    sprk = Spark.new("message.28",x-4,y+16,@vp) # Faster with higher opacity perhaps
    #sprk.center()
    #sprk.blend_type = 1
    sprk.opacity = 30
    @sparks.push(sprk)
    
    # AUTO PAUSE AFTER SENTENCE HERE
    #(@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  def redraw

    @textbox.bitmap.clear    
    @textbox.bitmap.blt(0,0,@text_bmp,@text_bmp.rect)

    return if @word == nil

    @scratch.font.bold = @word.include?("*")
    @scratch.font.italic = @word.include?("^")

    @textbox.bitmap.font.bold = @word.include?("*")
    @textbox.bitmap.font.italic = @word.include?("^")

    #txt = @word[0..@char_idx-1]
    txt = @word.delete('*^')[0..@char_idx-1]
    txt2 = @word.delete('*^')[@char_idx..@char_idx]

    size = @scratch.text_size(txt)

    # SHADOW HERE FOR THE WORD IN PROGRESS

    @textbox.bitmap.draw_gtext(@cx,@cy,300,LINE_HEIGHT,txt)

    # Half draw the final
    return if @char_idx >= @word.length
    return

    # Offset the y here to animate
    #r = rand(4)
    r = 0
    op = 220 - @next_char * 50

    @textbox.bitmap.font = $fonts.message_shadow
    @textbox.bitmap.font.color.alpha = op
    @textbox.bitmap.draw_text(@cx+r+size.width+2,@cy+r+2,100,LINE_HEIGHT,txt2)

    @textbox.bitmap.font.color.alpha = 255


    @textbox.bitmap.font = $fonts.message
    @textbox.bitmap.font.color.alpha = op
    @textbox.bitmap.draw_gtext(@cx+r+size.width,@cy+r,100,LINE_HEIGHT,txt2)

    @textbox.bitmap.font.color.alpha = 255


    # Maybe last char so this can redraw fast, maybe don't even need


  end

  def redraw_last


  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @word = nil
    if @line_idx >= @lines.count
      # If choices, open them now
      if !@choices.empty?
        open_choices
      else
        @state = :done
        #@box.skin = $cache.menu_common("skin-gold")
      end
    else
      @word_idx = 0
      @cy += LINE_HEIGHT
      @cx = PADDING_X
    end
  end

    #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    # blit last word onto the main bmp
    if @word != nil

      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')

      txt = @word.delete('*^')[0..@char_idx]

      @text_bmp.font = $fonts.message_shadow
      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')
      @text_bmp.draw_text(@cx+2,@cy+2,300,LINE_HEIGHT,txt)

      @text_bmp.font = $fonts.message
      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')
      @text_bmp.draw_gtext(@cx,@cy,300,LINE_HEIGHT,txt)

      # Step cursor
      @cx += word_width(@word)

    end

    @word_idx += 1
    @char_idx = 0
    
    if @word_idx >= @lines[@line_idx].count
      next_line
      return if @line_idx >= @lines.count
    end

    @word = @lines[@line_idx][@word_idx]

    return if @word == nil

    # CHECK FOR COMMANDS
    if @word.include?('$')
      cmd = @word.split(".")
      wrd = cmd[0]

      # check for command words
      case wrd
      
        when "$n" # New line
          next_line
          
        when "$w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
                    
        when "$s"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = SPEED_1 if cmd[1] == '1'
            @text_delay = SPEED_2 if cmd[1] == '2'
            @text_delay = SPEED_3 if cmd[1] == '3'
            @text_delay = SPEED_4 if cmd[1] == '4'
            @text_delay = SPEED_5 if cmd[1] == '5'          
          end
                    
        when "$sfx" # play sound
          sfx(cmd[1])
          
        when "$m"
          
          case cmd[1]
            when 'stop'
              Audio.bgm_stop            
            when 'fade'
              Audio.bgm_fade(750)                   
            else
              Audio.bgm_play(cmd[1])            
          end
          
        when "$nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "$end"
          @state = :closing
          @show_next = false
          
      end
        
      @word = nil
      next_word if @state != :waiting        

    end

  end  

  def open_choices
    @state = :choice
    @grid = Ui_Grid.new(@vp)
    @grid.move(@box.x,@box.y+@box.height)
    @grid.add_button('a',@choices[0].split(": ")[1],'faces/rob')
    @grid.add_button('b',@choices[1].split(": ")[1],'faces/rob')
  end

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    # @wait_frames = 0 if @skip_all #|| Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if $input.action? || $input.click?
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @textbox.bitmap.clear
      @sprites.opacity = 0
      @box.skin = $cache.menu_common("skin")
      #@sprites.do(go("opacity",-255,100,:quad_in_out))
    end
  end

  #--------------------------------------------------------------------------
  # * Wait for input or choice
  #--------------------------------------------------------------------------
  def check_input_choice
    if $input.action?
      #sound(:text_next)
      #self.slide_zy(0.0)

      @last_choice = @choices[@grid.idx].split(":")[0]
      @choices = []

      @grid.dispose
      @grid = nil
      @state = :closing
      @textbox.bitmap.clear
      @sprites.opacity = 0
      @box.skin = $cache.menu_common("skin")
      #@sprites.do(go("opacity",-255,300,:quad_in_out))
    end
  end

  #--------------------------------------------------------------------------
  # Calculate size
  #--------------------------------------------------------------------------
  def word_width(word)
      return TAB_WIDTH if word == "$t"
      return 0 if word.include?("$")
      @scratch.font.bold = word.include?('*')
      @scratch.font.italic = word.include?('^')
      return @scratch.text_size(word.delete('*^')).width + SPACING
  end

  def max_width
    max = 0
    @lines.each{ |line|
      width = line.inject(0) { |t,w| t + word_width(w) }
      max = width if width > max
    }
    return max - SPACING
  end

  def split_text(text)

    # Split all text into lines
    # Then calc widths and that

    total_width = text.split(" ").inject(0) { |t, w| t + word_width(w) }

    # use total width to split into lines

    # If there is a forced newline, there will be no autosizing
    if text.include?("$n")
      return text.split("$n").map { |i| i = i.split(" ") }  
    end

    # If less than split width, just one line
    if total_width < MIN_WIDTH
      return [text.split(" ")]
    end

    # If width is less than max * 2, we are splitting at the first word after half point
    if total_width < MAX_WIDTH * 2 && false
      limit = total_width / 2
      cursor = 0
      lines = [[]]
      text.split(" ").each{ |word|
        lines[-1].push(word)
        cursor += word_width(word)
        if cursor >= limit
          lines.push([])
          cursor = 0
        end
      }
      return lines
    end

    # Else we are autosizing max width
    lines = [[]]
    limit = MAX_WIDTH
    cursor = 0
    text.split(" ").each{ |word|
      cursor += word_width(word)
      if cursor > limit
        cursor = 0
        lines.push([])
      end
      lines[-1].push(word)
    }
    return lines

  end

  #--------------------------------------------------------------------------
  # Misc
  #--------------------------------------------------------------------------
  def clear() end
  def busy?() return @state != :idle end

end

"


class Ui_Popper < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@vp = vp

		# Resize to whatever is needed
		@window = Box.new(vp,300,54)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	@window.scroll(0.2,0.2)
    	add(@window)

    	@before = Label.new(vp)
    	@before.font = $fonts.message
    	add(@before,16,10)

    	@after = Label.new(vp)
    	@after.font = $fonts.message
    	add(@after,106,10)

	end

	def center(x,y)
		move(x-@window.width/2,y+60)
	end

	def dispose

		self.sprites.each{ |s|
			s[0].dispose
		}

	end

	def update
		@window.update
	end

	def color=(c)
		@window.wallpaper = $cache.menu_wallpaper(c)
	end

	def setup(a,ia,b,ib)

		data = $data.items[id]

		@before.text = a
		@before.icon = ia
		
		@after.text = b
		@after.icon = ib


		tw = @before.width + @after.width

		@window.resize(tw+26,54)
		
		change(@after,@before.x + @before.width+10,10)

		center(320,230)

		# Launch sparks?
		#sprk = $scene.add_spark("redstar",420,300,@vp)
		#

		# Animate in
		self.opacity = 0
		self.do(go("opacity",255,250,:qio))
		self.do(seq(go("y",-15,100,:qio),go("y",40,300,:bounce_o)))


	end

end"­

class Ui_Shop < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@vp = vp

		# Left side window
		@window = Box.new(vp,300,242)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	add(@window,0,0)

		# Left side list
		@list = List.new()
		add(@list,6,6)

		@list.per_page = 9
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 35	

		@list.change = Proc.new{ |option| self.select(option) }
		
		data = []
		data.push('covey')
		data.push('covey')
		data.push('covey')

		@list.setup(data)

		@box = Item_Box.new(vp)
		@box.item('covey')
		add(@box,300,20)
		

		#@list.opacity = 0
		#@window.opacity = 0

		move(10,64)

@list.refresh
	end

	def dispose

		

	end

	def update
		@list.update
	end

	def setup()

		

	end

	def start_selling

	end

	def select(op)

	end


end"Û#==============================================================================
# ** Mnu_Base
#==============================================================================

class Mnu_Base

	attr_reader :left, :right, :other

	def initialize(vp)

		@closing = false

		@left = []
		@right = []
		@other = []

		@title = Page_Title.new(vp)
		@left.push(@title)

		@tabs = Page_Tabs.new(vp)
		@left.push(@tabs)

		@subtitle = Label.new(vp)
		@subtitle.move(116,74)
		@left.push(@subtitle)


		@menu = List_Common.new(vp)
		@menu.list.select = Proc.new{ |option| self.select(option) }
		@menu.list.cancel = Proc.new{ |option| self.cancel(option) }
		@menu.list.change = Proc.new{ |option| self.change(option) }
		@left.push(@menu)

		 @info = Info_Box.new(vp)
		 @left.push(@info)

		# Anything else is per page

	end

	def dispose
		(@left + @right + @other).each{ |i| i.dispose }
	end

	def update
		(@left + @right + @other).each{ |i| i.update }

		# If anim in done, change state
	end

	def close
		@closing = true
		@left.each{ |i|
			# Animate each thing sliding left and fading out
		}
	end

	def open
		# Hide everything, animate in
		(@left + @right + @other).each{ |i| i.opacity = 0 }
		@left.each{ |i| i.do(go("opacity",255,400,:qio))}
		@left.each{ |i| i.x -= 50; i.do(go("x",50,400,:qio))}
		@right.each{ |i| i.do(go("opacity",255,500,:qio))}
		@right.each{ |i| i.x += 50; i.do(go("x",-50,400,:qio))}
		@other.each{ |i| i.do(go("opacity",255,500,:qio))}
	end

	def cancel(option)
		@left.each{ |a| $tweens.clear(a) }
		@right.each{ |a| $tweens.clear(a) }
		@other.each{ |a| $tweens.clear(a) }
		close
	end

	def done?
		return @closing # && NO TWEENS GOING
	end

end"Z#==============================================================================
# ** Mnu_Char
#==============================================================================

class Mnu_Char < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change($menu.char)

		@subtitle.text = "Master of deception"

		#@tabs.push("all")
		#@tabs.push("potions")
		#@tabs.push("keys")

		@menu.dispose
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(15,115)
		@grid.add_wide("equip","Equip","misc/unknown")
		@grid.add_wide("skills","Skills","misc/unknown")
		@grid.add_wide("status","Status","misc/unknown")
		@grid.add_wide("profile","Profile","misc/unknown")
		self.left.push(@grid)


		@port = Port_Full.new(vp)
		self.right.push(@port)

	end

	def update
		super

		@grid.update

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close
		end
		
	end

	def change(option)
		
	end

	def select(option)	
		
	end

end"í
#==============================================================================
# ** Mnu_Equip
#==============================================================================

class Mnu_Equip < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Equip')

		@char = $party.get('boy')

		@subtitle.text = "Master of deception"

		#@tabs.push("all")
		#@tabs.push("potions")
		#@tabs.push("keys")

		@menu.opacity = 0
		@menu.move(15,180)
		#@menu.opacity = 0
		
		@menu.list.per_page = 7
		@menu.window.height -= 34
		@menu.list.active = false

		#@info.hide
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(15,115)
		 @char.slots.each{ |slot| 
		 	@grid.add_slot(slot,@char.equips[slot])
		 }
		#@grid.add_slot('staff',char.equips['staff'])
		self.left.push(@grid)


		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,290)
		@item_box.hide
		#self.right.push(@item_box)

		# Selected slot
		@slot = nil

	end

	def update
		super

		@menu.update if @menu.list.active
		@grid.update if !@menu.list.active

		# Get chosen grid option
		if $input.action? || $input.click?
			log_scr("GO")
			choose(@grid.get_chosen)
		end

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close
		end
		
	end

	# Grid
	def choose(option)

		@slot = option

		# Rebuild the grid
		@grid.clear
		@grid.move(15,115)
		@grid.add_slot(@slot,@char.equips[@slot])

		@grid.disable

		# Populate the list

		# Find gear for this slot
		items = $party.items.keys.select{ |i|
			$data.items[i].is_a?(GearData) && $data.items[i].slot == @slot
		}
		items.push(nil) if @char.equips[@slot] != nil
		@menu.list.setup(items)

		# Bring in the list
		@menu.opacity = 255
		@menu.move(15,180)

		@menu.list.active = true

		@item_box.show
		#change(items[0])

	end

	# Equip List
	def change(option)



		# Change the item box to show this
		if option != nil
			@item_box.item(option)
			@item_box.show
		else
			@item_box.hide
		end
		#@item_box.comparison(option,@char.equips[@slot])
		
	end

	def select(option)	

		# Replace the gear in the slot hahahhahah
		log_scr(@slot)
		log_scr(option)
		@char.equip(@slot,option)
		back_to_slots
		
	end

	def cancel(option)

		back_to_slots
	end

	def back_to_slots
		@menu.opacity = 0
		@menu.move(15,180)

		@menu.list.active = false

		@grid.enable
		@grid.clear
		@grid.move(15,115)
		 @char.slots.each{ |slot| 
		 	@grid.add_slot(slot,@char.equips[slot])
		 }

		 @grid.choose(@slot)

		 @item_box.hide

	end

end" #==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Items < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('items')
		@subtitle.text = "Various items of collection"

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.hide
		self.right.push(@item_box)

		# Party grid hahahha
		@grid = Ui_Grid.new(vp)
		@grid.move(@item_box.x,@item_box.y + @item_box.height + 3)
		$party.active.each{ |m|
			@grid.add_active(m)
		}
		@grid.cx = @item_box.x
		$party.reserve.each{ |m|
			@grid.add_reserve(m)
		}
		@grid.disable
		#@grid.hide
		self.right.push(@grid)

		grant_items

		@menu.setup_items('all')

	end

	def update
		super
		# Keep checking if item box changed
		
	end

	def change(option)
		#@item_box.show
		@item_box.item(option)
		@item_box.center(472,260)#+@menu.list.page_idx*@menu.list.row_height)
	end

	def select(option)	
		
	end

end"ü#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Journal < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('journal')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		log_scr("HUH")

		@menu.list.type = :quest

		data = $progress.quests

		@page = Right_Page.new(vp)
		self.right.push(@page)

		@menu.list.setup(data)

		

		#change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		#return

		@page.clear

		# Change page to show this quest
		#@info.title.text = option

		@page.title = $data.quests[option].name
		@page.description = $data.quests[option].description

		@page.add_reqs($data.quests[option].req)
		@page.add_zone($data.quests[option].location)

	end

	def select(option)	
		
	end


end"Â#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Load < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('load')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@menu.list.type = :quest

		data = $progress.quests

		@menu.list.setup(data)

		@page = Right_Page.new(vp)
		@right.push(@page)

		change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end

end"#==============================================================================
# ** Mnu_Main
#==============================================================================

class Mnu_Main # MAYBE SPRITEGROUP FOR EASY MOVING OF ALL

	def initialize(vp)

		@vp = vp

		@chars = []

		# Active Characters

		charbox = Char_Box_Large.new(vp,$party.active[0])
		charbox.box.name = "C.0"
		charbox.move(200,15)
		@chars.push(charbox)

		if $party.active.count > 1
			charbox = Char_Box_Large.new(vp,$party.active[1])
			charbox.box.name = "C.1"
			charbox.move(420,15)
			@chars.push(charbox)
		end

		if $party.active.count > 2
			charbox = Char_Box_Large.new(vp,$party.active[2])
			charbox.box.name = "C.2"
			charbox.move(200,198)
			@chars.push(charbox)
		end

		if $party.active.count > 3
			charbox = Char_Box_Large.new(vp,$party.active[3])
			charbox.box.name = "C.3"
			charbox.move(420,198)
			@chars.push(charbox)
		end

		# Reserve Characters

		if $party.reserve.count > 0
			charbox = Char_Box_Small.new(vp,$party.reserve[0])
			charbox.box.name = "R.0"
			charbox.move(200,381)
			@chars.push(charbox)
		end

		if $party.reserve.count > 1
			charbox = Char_Box_Small.new(vp,$party.reserve[1])
			charbox.box.name = "R.1"
			charbox.move(347,381)
			@chars.push(charbox)
		end

		if $party.reserve.count > 2
			charbox = Char_Box_Small.new(vp,$party.reserve[2])
			charbox.box.name = "R.2"
			charbox.move(492,381)
			@chars.push(charbox)
		end

		# Special Positioning
		if $party.active.count == 1
			@chars[0].move(310,140)
		end

		if $party.active.count == 2
			@chars[0].move(200,140)
			@chars[1].move(420,140)
		end


		@data = ['Journal','Items','Equip','Skills',
  	 		     'Party','Options','Quit','Load','Save']

		cy = 15

		@buttons = []
		@texts = []
		@icons = []

		@data.each{ |item|

			btn = Box.new(vp,170,45)
	     	btn.skin = $cache.menu_common("skin-plain")
	     	btn.wallpaper = $cache.menu_wallpaper("diamonds")
	     	btn.move(15,cy)
	     	btn.name = item
	     	@buttons.push(btn)

	     	text = Label.new(vp)
	     	text.font = $fonts.list
	     	text.shadow = $fonts.list_shadow
	     	text.gradient = true
	     	text.text = item
	     	text.move(94,cy+7)
	     	@texts.push(text)

	     	icon = Sprite.new(vp)
	     	icon.bitmap = $cache.menu("Icons/"+item)
	     	icon.move(-4+28,cy-12)
	     	#icon.src_rect = Rect.new(68,0,120,50)
	     	icon.z += 50
	     	@icons.push(icon)

	     	cy += 51

     	}

     	@glow = Sprite.new(vp)
     	@glow.bitmap = Bitmap.new(@buttons[0].width-12,@buttons[0].height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow"))
     	@glow.do(pingpong("opacity",-100,300,:quad_in_out))

     	@idx = 0
     	@sr = 0

     	@boxes = @buttons + @chars.map{ |c| c.box }
     	
     	@selected = "Journal"
     	@selected_box = nil
     	choose(@selected,false)

	end

	def dispose

		@chars.each{ |c| c.dispose } 

		@glow.dispose
		@icons.each{ |i| i.dispose }
		@texts.each{ |i| i.dispose }
		@buttons.each{ |i| i.dispose }

	end

	def update
		#@menu.update
		#@chars.each{ |c| c.update }

		if $input.action? || $input.click?
			select(@selected)
		end

		# Just remember selected I would suppose
		box = @selected_box
			
		if $input.right?		
			sx = box.x + box.width
			sy = box.y + box.height/2	
			search(sx,sy,3,1)
		end

		if $input.left?
			sx = box.x
			sy = box.y + box.height/2
			search(sx,sy,-3,1)
		end

		if $input.down?
			sx = box.x + box.width/2		
			sy = box.y + box.height
			search(sx,sy,1,3)
		end

		if $input.up?
			sx = box.x + box.width/2		
			sy = box.y
			search(sx,sy,1,-3)
		end

		pos = $mouse.position
     

		# Mousing
		@boxes.each{ |b| 

			next if b == @selected_box
			next if pos[0] < b.x
		    next if pos[1] < b.y
		    next if pos[0] > b.x + b.width
		    next if pos[1] > b.y + b.height
			choose(b.name)
			break

		}

	end

	def search(sx,sy,x,y)

		before = @selected

		cx = sx
		cy = sy

		# Start moving until find something
		while true

			cx += x
			cy += y

			@boxes.each{ |box|
				if box.window.within?(cx,cy)
					return choose(box.name)
				end
			}

			cy = 0 if cy > 480
			cx = 0 if cx > 640
			cy = 480 if cy < 0
			cx = 640 if cx < 0

		end

	end

	def open

		@chars.each{ |c| c.show } 

		@glow.show
		@icons.each{ |i| i.show }
		@texts.each{ |i| i.show }
		@buttons.each{ |i| i.show }
	end

	def close

		@chars.each{ |c| c.hide } 

		@glow.hide
		@icons.each{ |i| i.hide }
		@texts.each{ |i| i.hide }
		@buttons.each{ |i| i.hide }
	end

	def choose(target,dosound=true)

		sys('select') if dosound

		@selected = target

		@sr = 0


		idx2 = 0
		@icons.each{ |i|
			i.src_rect = Rect.new(36,0,120,50)
			i.y = 25+(idx2*51)-23
			$tweens.clear(i)
			idx2 += 1
		}


		# Find the icon if this is journal
		@idx = nil
		if !@buttons.select{ |b| b.name == target }.empty?

			idx = 0
			@buttons.each{ |b|
				break if b.name == target
				idx += 1
			}

			@idx = idx

			@icons[idx].do(go("y",-12,250,:quad_in_out))
			self.do(go("srcrecter",12,250,:quad_in_out))

		end

		@selected_box = @boxes.find{ |b| b.name == target }

		glowon = @selected_box

		@glow.bitmap = Bitmap.new(glowon.width-12,glowon.height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow"))
		@glow.move(glowon.x+6,glowon.y+6)

	end

	def srcrecter
		return @sr
	end

	def srcrecter=(y)
		if @idx == nil
			$tweens.clear(self)
			return
		end
		@sr = y
		@icons[@idx].src_rect = Rect.new(36,0,120,50+y)
	end

	def select(option)

		sys('action')

		case option
			when "Journal"
				$scene.open_sub(Mnu_Journal.new(@vp))
			when "Items"
				$scene.open_sub(Mnu_Items.new(@vp))
			when "Equip"
				$scene.open_sub(Mnu_Equip.new(@vp))
			when "Skills"
				$scene.open_sub(Mnu_Skills.new(@vp))
			when "Party"
				$scene.open_sub(Mnu_Party.new(@vp))
			when "Options"
				$scene.open_sub(Mnu_Options.new(@vp))
			when "Quit"
				$scene.open_sub(Mnu_Quit.new(@vp))
			when "Load"
				$scene.open_sub(Mnu_Load.new(@vp))
			when "Save"
				$scene.open_sub(Mnu_Save.new(@vp))
			when "Char"
				$scene.open_sub(Mnu_Char.new(@vp))
			else
				# C.1
				num = option.split(".")[1].to_i
				if option.include?("C")
					$menu.char = $party.active[num]
				else # Reserve
					$menu.char = $party.reserve[num]
				end
				$scene.open_sub(Mnu_Char.new(@vp))

		end

	end

	def done?
		return false
	end

end"
class Mnu_Options < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('options')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@menu.list.type = :quest

		data = $progress.quests

		@menu.list.setup(data)

		@page = Right_Page.new(vp)
		@right.push(@page)

		change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end

end"
class Mnu_Party < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('party')
		@subtitle.text = "Change up your party members"

		@menu.hide
		@menu.list.active = false

		@first = nil

		@active = Sprite.new(vp)
		@active.bitmap = $cache.menu_tab('all')
		@active.move(140,105)
		@left.push(@active)

		@reserve = Sprite.new(vp)
		@reserve.bitmap = $cache.menu_tab('all')
		@reserve.move(450,105)
		@right.push(@reserve)
		
		@grid = Ui_Grid.new(vp)
		@other.push(@grid)
		setup_grid

	end

	def setup_grid
		
		@grid.move(15,128)

		@grid.add_party_mem('a.0',$party.active[0])
		if $party.active.count > 1
			@grid.add_party_mem('a.1',$party.active[1])
		else
			@grid.add_party_mem('a.1',nil)
		end
		if $party.active.count > 2
			@grid.add_party_mem('a.2',$party.active[2])
		else
			@grid.add_party_mem('a.2',nil)
		end
		if $party.active.count > 3
			@grid.add_party_mem('a.3',$party.active[3])
		else
			@grid.add_party_mem('a.3',nil)
		end

		@grid.cx = 324
		@grid.cy = 128

		@grid.add_party_mem('r.0',$party.reserve[0])
		if $party.reserve.count > 1
			@grid.add_party_mem('r.1',$party.reserve[1])
		else
			@grid.add_party_mem('r.1',nil)
		end
		if $party.reserve.count > 2
			@grid.add_party_mem('r.2',$party.reserve[2])
		else
			@grid.add_party_mem('r.2',nil)
		end
		if $party.reserve.count > 3
			@grid.add_party_mem('r.3',$party.reserve[3])
		else
			@grid.add_party_mem('r.3',nil)
		end

	end

	def update
		super

		@grid.update

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close
		end

	end

	def choose(option)
		if @first == nil
			@first = option
			@grid.get_box(option).wallpaper = $cache.menu_wallpaper('blue')
		else
			$party.swap(@first,option)
			@first = nil			
			@grid.clear
			setup_grid
			@grid.choose(option)
		end
	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end

end"
class Mnu_Quit < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('quit')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@menu.list.type = :quest

		data = $progress.quests

		@menu.list.setup(data)

		@page = Right_Page.new(vp)
		@right.push(@page)

		change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end

end"À#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Save < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('save')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@menu.list.type = :quest

		data = $progress.quests

		@menu.list.setup(data)

		@page = Right_Page.new(vp)
		@right.push(@page)

		change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end
end"(#==============================================================================
# ** Mnu_Shop
#==============================================================================

class Mnu_Shop < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('shop-buy')

		@tabs.push("all")
		#@tabs.push("potions")
		#@tabs.push("keys")

		@tabs.tab_proc = Proc.new{ |tab| self.change_tab(tab) }

		@menu.list.setup($menu.shop)

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,250)
		self.right.push(@item_box)

		change_tab("Items")

	end

	def update
		super
		
	end

	def change(option)
		@info.title.text = option
		@item_box.item(option)
		#@item_box.center(462,130+@menu.list.page_idx*@menu.list.item_height)
	end

	def select(option)	
		
	end

	def change_tab(tab)
		return

		# Change list to certain items only
		list = []
		$menu.shop.each{ |item|
			list.push(item) if $data.items[item].category == tab
		}
		@menu.list.setup(list)

	end

end":#==============================================================================
# ** Mnu_Skills
#==============================================================================

class Mnu_Skills < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Skills')

		@subtitle.text = "Master of deception"

		@menu.list.type = :skill
		@menu.list.setup($party.get('boy').skill_list)

		@port = Port_Full.new(vp)
		self.right.push(@port)

	end

	def update
		super
		
	end

	def change(option)
		
	end

	def select(option)	
		
	end

end"Y

class Char_Box_Large < SpriteGroup

	attr_accessor :box

	def initialize(vp,char)

		super()

		@char = $party.get(char)

		@box = Box.new(vp,205,168)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("portback")
		add(@box)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_large(char)
		#@port.src_rect.width = 155
		add(@port,205-@port.width-9,168-@port.height-8)
		@port.z += 50

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient")
		@gradient.opacity = 160
		add(@gradient,9,100)
		@gradient.z += 50

		@name = Label.new(vp)
	    @name.font = $fonts.list
	    @name.shadow = $fonts.list_shadow
	    @name.gradient = true
	    @name.text = @char.name
	    add(@name,15,7)

		@level = Label.new(vp)
	    @level.font = $fonts.list
	    @level.shadow = $fonts.list_shadow
	    @level.gradient = true
	    @level.text = "15"
	    add(@level,20,27)


		# @mp_bar = Bar.new(vp,180,8)
		# add(@mp_bar,11,112)
		# @mp_bar.z += 50

		# @mp_label = Sprite.new(vp)
		# @mp_label.bitmap = $cache.menu_char("label-mp")
		# @mp_label.opacity = 200
		# add(@mp_label,12,104)
		# @mp_label.z += 50

		@hp_bar = Bar.new(vp,180,8)
		add(@hp_bar,11,130)
		@hp_bar.opacity = 180
		@hp_bar.z += 50

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200
		add(@hp_label,12,122)
		@hp_label.z += 50

		@xp_bar = Bar.new(vp,180,8)
		add(@xp_bar,11,148)
		@xp_bar.opacity = 180
		@xp_bar.z += 50

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-rp")
		@xp_label.opacity = 200
		add(@xp_label,12,140)
		@xp_label.z += 50



	end

	def dispose
		@box.dispose
		@gradient.dispose
		@port.dispose
	end

	def update
		@box.update
	end

	def choose()

	end

end"è

class Char_Box_Small < SpriteGroup

	attr_accessor :box

	def initialize(vp,char)

		super()

		@char = $party.get(char)

		@box = Box.new(vp,132,87)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("portback")
		add(@box)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_small(char)
		add(@port,123-@port.width,78-@port.height)
		@port.z += 50

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient-small")
		@gradient.opacity = 160
		add(@gradient,5,30)

		@name = Label.new(vp)
	    @name.font = $fonts.list
	    @name.shadow = $fonts.list_shadow
	    @name.gradient = true
	    @name.text = @char.name
	    add(@name,6,4)

		@level = Label.new(vp)
	    @level.font = $fonts.list
	    @level.shadow = $fonts.list_shadow
	    @level.gradient = true
	    @level.text = "15"
	    add(@level,20,27)

		@xp_bar = Bar.new(vp,106,8)
		add(@xp_bar,11,64)

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-rp")
		@xp_label.opacity = 200
		add(@xp_label,12,56)

	end

	def dispose
		@box.dispose
		#@gradient.dispose
		#@port.dispose
	end

	def update
		@box.update
	end

	def setup(char)

	end

end"þ
class Info_Box < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@window = Box.new(vp,300,60)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@gold = Label.new(vp)
    	@gold.font = $fonts.pop_type
    	@gold.icon = $cache.icon("misc/coins")
    	@gold.text = "250G"
    	add(@gold,12,8)

    	@zone = Label.new(vp)
    	@zone.font = $fonts.pop_type
    	@zone.icon = $cache.icon("misc/coins")
    	@zone.text = "Whisper Woods"
    	add(@zone,100,8)
    	
    	move(15,440)

	end

	def dispose
		@window.dispose
		@gold.dispose
		@zone.dispose
	end

	def update
		@window.update
	end

	def change


	end

end
")

class Item_Box < SpriteGroup

	attr_accessor :title
    attr_accessor :type

	def initialize(vp)
		super()		

        @vp = vp
        @type = :item

		# Resize to whatever is needed
		@window = Box.new(vp,300,120)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@title = Label.new(vp)
    	@title.fixed_width = 250
    	@title.icon = $cache.icon("items/map")
    	@title.font = $fonts.pop_ttl
    	@title.text = "Active Quests:"
    	add(@title,16,10)

    	@cat = Label.new(vp)
    	@cat.fixed_width = 250
    	@cat.font = $fonts.pop_type
    	@cat.align = 0
    	@cat.text = "POTION"
    	add(@cat,226,13)

    	@desc = Area.new(vp)
    	@desc.font = $fonts.pop_text
    	@desc.text = "Missing Descriptor"
    	add(@desc,16,42)

        @stats = []
        @cy = 42

    	
    	
    	move(0,0)

    	item('unknown')

	end

    def width
        return @window.width
    end

    def height
        return @window.height
    end


	def center(x,y)
		move(x-150,y-60)
	end

	def dispose

		self.sprites.each{ |s|
			s[0].dispose
		}

	end

	def update
		@window.update
	end

    def get_data(id)
        if @type == :item
          return $data.items[id]
        elsif @type == :skill
          return $data.skills[id]
        end
    end

    def base(data)

        log_scr(data)
        return if data == nil

        # Set values
        @title.text = data.name
        @desc.text = data.description

        @stats.each{ |s| 
            s.dispose
            delete(s)
            s.dispose 
        }
        @stats = []
        @cy = 42 + @desc.height 

    end

    def newsize
        @window.resize(300,64 + @desc.height + @stats.count*20)
    end

    def stat(icon,text)

        stat = Label.new(@vp)
        stat.fixed_width = 250
        stat.icon = $cache.icon("stats/#{icon}")
        stat.font = $fonts.pop_text
        stat.text = text
        @stats.push(stat)
        add(stat,36,@cy)
        @cy += 20

    end

	def item(id)

        data = get_data(id)       
        base(data)

        #return if data == nil
        stat("targets","Hit ALL")
		
		#@type.text = item.type

        newsize
        remove

	end

	def skill(id)

        data = get_data(id)       
        base(data)

        #if data.scope == 'all'
            stat("targets","Hit ALL")
        #end

        newsize
        remove

	end

    def gear(id)

    end

end"R
class List_Common < SpriteGroup

	attr_accessor :list, :window

	def initialize(vp)
		super()

		# Left side window
		@window = Box.new(vp,300,292)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	add(@window)
    	
		# Left side list
		@list = List.new()

		@list.per_page = 8
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 1
		add(@list,6,6)


		move(15,140)
		@list.refresh

	end

	def dispose
		@window.dispose
		@list.dispose
	end

	def update
		@list.update
	end

	def hide
		move(-1000,-1000)
	end

	# All the various data that can be shown
	def setup_items(category)
		items = $party.items.keys.select{ |i|
			$data.items[i].is_a?(UsableData) # &&
		}
		@list.setup(items)
	end

	def setup_gear(slot)

	end

end"
class List_Main < SpriteGroup

	attr_accessor :list

	def initialize(vp)
		super()

		# Left side window
		@window = Box.new(vp)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	@window.resize(178,362)
    	add(@window)

		# Left side list
		@list = List.new()
		@list.type = :misc

		# @list.item_width = 156
		# @list.item_height = 42
		#@list.item_space = 43

		@list.item_width = 166
		@list.item_height = 34
		@list.item_space = 35
		

		add(@list,6,6)

		data = []
		data.push(['Items',"items/map"])
		data.push(['Journal','items/map'])
		data.push(['Party','items/map'])
		data.push(['Equip','items/map'])
		data.push(['Skills','items/map'])
		data.push(['Profiles','items/map'])
		data.push(['Options','items/map'])
		data.push(['Quit','items/map'])
		data.push(['Load','items/map'])
		data.push(['Save','items/map'])

		@list.setup(data)

		move(10,490)
		@list.refresh

	end

	def dispose
		@window.dispose
		@list.dispose
	end

	def update
		@list.update
	end

end

def _db(*args)
	DataBox.new(args[0],args[1],args[2],args[3])
end"·#==============================================================================
# Tabs
#==============================================================================

# Horizontal list of sorts
# Image based only
# Drawn to single sprite

class Page_Tabs < Sprite

  SPACING = 5

  attr_accessor :tab_proc

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

  	#@parent = nil
    @names = []
  	@gfx = []
    @gfx_on = []

    @ranges = []

  	@idx = 0

    move(20,108)

  end

  def push(name)
    @names.push(name)
    @gfx.push($cache.menu_tab(name))
    @gfx_on.push($cache.menu_tab(name+"-on"))
    refresh
  end

  def refresh

    return if @gfx.empty?

    # Calc width
    width = @gfx.inject(0){ |t,b| t += b.width + SPACING } - SPACING
    height = @gfx[0].height#@gfx.max_by{ |b| b.height }

    self.bitmap = Bitmap.new(width,height)

    # Draw the tabs
    cx = 0
    idx = 0
    @gfx.each{ |b|
      src = b
      src = @gfx_on[idx] if idx == @idx
      self.bitmap.blt(cx,0,src,src.rect)
      cx += b.width + SPACING
      idx += 1
    }

  end

  def update

    return if @names.empty?

  	# Check inputs and that
  	if $input.right?
      @idx += 1
      @tab_proc.call(@tabs[@idx]) if @tab_proc
      refresh      
  	end

  	if $input.left? #&& @dynamo.done?
      @idx -= 1
      @tab_proc.call(@tabs[@idx]) if @tab_proc
      refresh  
  	end

    pos = $mouse.position

    # Check mouseover
    # @sprites.each_index{ |i|
      
    # }

  end

 end"I
class Page_Title < SpriteGroup

	def initialize(vp)
		super()

		@web = Sprite.new(vp)
		@web.bitmap = $cache.menu_common("webber")
		add(@web,-40,-50)

		@icon = Sprite.new(vp)
		@icon.bitmap = $cache.menu("Icons/journal")
		add(@icon,0,-5)

		@title = Sprite.new(vp)
		@title.bitmap = $cache.menu("Titles/journal")
		add(@title,100,20)

		move(0,0)

	end

	def dispose
		@sprites.each{ |s| s[0].dispose }
	end

	def change(page)
		@icon.bitmap = $cache.menu("Icons/"+page)
		@title.bitmap = $cache.menu("Titles/"+page)
	end

	def update

	end

end"#==============================================================================
# ** Part_Char
#==============================================================================

# Could auto choose the right char, but maybe just put as sprite
class Port_Full < Sprite

	def initialize(vp)
		super(vp)

		self.bitmap = $cache.face_menu("#{$menu.char}-w")
		self.x = 330
		#self.x -= 20

	end

end"a
class Right_Page < SpriteGroup

	def initialize(vp)
		super()
	
		# Right side journal
		@window = Box.new(vp,300,292)
    	@window.skin = $cache.menu_common("skin-dry")
    	@window.wallpaper = $cache.menu_wallpaper("journal_page_line")
    	#@window.color = Color.new(47,45,41)
    	add(@window,320,140)

    	# Quest Name
    	@page_title = Label.new(vp)
    	@page_title.fixed_width = 250
    	@page_title.font = $fonts.page_ttl
    	@page_title.text = "Board the Ferry"
    	add(@page_title,340,154)



    	# # SUBTEXTS!!!!!!!!!!

    	# cy = 180

    	# # ALWAYS DESCRIPTION

    	@txt_desc = Area.new(vp)
    	@txt_desc.fixed_width =  260
    	@txt_desc.font = $fonts.page_text
    	@txt_desc.text = "Rescue them guys in the briar woods"
    	add(@txt_desc,340,198)

    	# Subtitles ready for later
    	@sub_req = Sprite.new(vp)
    	@sub_req.bitmap = $cache.menu_page("tasks")
    	@sub_zone = Sprite.new(vp)
    	@sub_zone.bitmap = $cache.menu_page("location")

    	# Text sprites

        @txt_req1 = Label.new(vp)
        @txt_req1.font = $fonts.page_text

        @txt_req2 = Label.new(vp)
        @txt_req2.font = $fonts.page_text

        @txt_req3 = Label.new(vp)
        @txt_req3.font = $fonts.page_text

    	@txt_zone = Label.new(vp)
    	@txt_zone.font = $fonts.page_text

    	# cy += 30

    	move(0,0)

        #clear

    end

    def dispose
        # Clear the extras!
        @window.dispose
        @page_title.dispose
        @txt_desc.dispose
        @sub_req.dispose
        @txt_req1.dispose
        @txt_req2.dispose
        @txt_req3.dispose
        @sub_zone.dispose
        @txt_zone.dispose
    end

    def title=(text)
        @page_title.text = text
    end

    def description=(text)
        @txt_desc.text = text
        @cy = @txt_desc.y + @txt_desc.height
    end

    def clear

    	# Clear the extras!
    	@sub_req.hide
    	@txt_req1.hide
        @txt_req2.hide
        @txt_req3.hide
    	@sub_zone.hide
    	@txt_zone.hide

    end

    def add_reqs(reqs)
        @sub_req.show
        @sub_req.move(340,@cy)
        @cy += 22

        log_info(reqs)

        num = 1

        # Per req
        reqs.split(" | ").each{ |req|

            txt_req = @txt_req1 if num == 1
            txt_req = @txt_req2 if num == 2
            txt_req = @txt_req3 if num == 3

            dta = req.split("=>")
            if dta[0] == 'item'
                item = $data.items[dta[1]]
                txt_req.icon = $cache.icon(item.icon)
                name = item.name
                name += " x #{dta[2]}" if dta[2].to_i > 1
                txt_req.text = name
                txt_req.show
                txt_req.move(340,@cy)
                @cy += txt_req.height
            end

            num += 1
        }
    end

    def add_zone(zone)
    	@sub_zone.show
    	@sub_zone.move(340,@cy)
    	@cy += 22
    	@txt_zone.icon = $cache.icon("items/map")
    	@txt_zone.text = "Whisper Woods"
    	@txt_zone.show
    	@txt_zone.move(340,@cy)
    	@cy += @txt_zone.height
    end

end"³#==============================================================================
# ** Game_Battler (part 1)
#==============================================================================

# STATS

class Game_Battler
 
  attr_reader :id, :name, :level

  attr_reader :transform

  attr_accessor :action, :skill_id, :item_id
  attr_accessor :target
  attr_accessor :target_type, :target_idx
  attr_accessor :ev

  attr_reader :hp, :mp

  attr_reader :slots, :equips

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    @is_actor = true
    @transform = nil

    # Current values
    @hp = 0
    @mp = 0

    @restype = nil#data.resource

    # Enemy values and also bonus for player
    @stat_plus = {}
    @stat_mods = {}
   
    @xp = 0
    @level = 1

    @equips = {}

    @states = []
    @states_turn = {}

    @skills = []
    @skill_cooldown = {}

    # Skill selection
    @action = nil
    @skill_id = nil
    @item_id = nil

    @target = nil
    @target_type = nil # <-- Scope?
    @target_index = -1

    @ev = nil # Mid battle hold even number for easy access

    @form = nil # <- fox or frog or etc, maybe for battler? turn enemy to frog he shoot water at you? interesting

    recover_all

  end

  def is_actor?
    return @is_actor
  end

  def init_actor(id)

    @is_actor = true

    data = $data.actors[id]
    @id = id

    @looklike = id

    @name = data.name

    @slots = data.slots.split(" | ")

    # Prepare equipment slots
    @slots.each{ |s|
      @equips[s] = nil
    }
    
    @actions = data.actions.split(" | ")

    # Add actions as skills, maybe not now, only when checking
    #@actions.each{ |a| @skills.push(a) }

    # Prepare stat mods per character
    if data.mods != ""
      data.mods.split("\n").each{ |m|
        md = m.split("=>")
        @stat_mods[md[0]] = md[1].to_i
        log_info @stat_mods
      }
    end


  end

  def init_enemy(id)

    @is_actor = false

    data = $data.enemies[id]
    @id = id

    # Get stat plus per enemy
    if data.stats != ""
      data.stats.split("\n").each{ |m|
        md = m.split("=>")
        @stat_plus[md[0]] = md[1].to_i
      }
    end

  end
  
  def is_actor?
    return @is_actor
  end

  def actions
    if !@transform
      return @actions
    else
      return $data.actors[@transform].actions.split(" | ")
    end
  end

  #--------------------------------------------------------------------------
  # * Transform into something
  #--------------------------------------------------------------------------
  
  def transform(into)

    @transform = into
    log_scr("TRANSFORM NOW")

    ev.character_name = "Player/#{@id}-snake"
    ev.direction = 4

  end

  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    @mp = maxmp
   # for i in @states.clone
   #   remove_state(i)
   # end
  end

  
  def damage(amount)
    @hp -= amount
    @hp = 0 if @hp < 0
  end

  def heal(amount)

  end



  # perhamps cut these things
  def down?
    @hp == 0 
  end
  def attackable?
    return !down?
  end


end
"À
class Game_Battler

  #--------------------------------------------------------------------------
  # * Stat Calcs
  #--------------------------------------------------------------------------

  def maxhp
    val = stat('hp')
    return val
  end

  def maxmp
    stat('mp')
  end

  def str
  	stat('str')
  end

  def def
    stat('def')
  end

  #--------------------------------------------------------------------------
  # * Secondary Calculated Stats
  #--------------------------------------------------------------------------
  def eva
    stat('eva')
  end

  def crit
    stat('crit')
  end

  def miss
    stat('miss')
  end

  #--------------------------------------------------------------------------
  # * Stat values
  #--------------------------------------------------------------------------
 
  def stat(stat)
    val = 0
    val += stat_base(stat) # Player base stat from level
    val *= stat_base_mod(stat) # Modify per actor
    val += stat_plus(stat) # Enemy stat or player bonus stat
    val += stat_from_equip(stat) 
    val *= stat_mod_from_equip(stat) 
    val += stat_from_states(stat)   
    val *= stat_mod_from_states(stat)   
    val *= stat_mod_from_difficulty(stat) 
    return val
  end

  def stat_base(stat)
    return 0 if !is_actor?
    $data.numbers["#{stat}-base"].value + ($data.numbers["#{stat}-per"].value * (@level-1))
  end

  def stat_base_mod(stat)
    @stat_mods[stat] || 1.0
  end

  def stat_plus(stat)
    @stat_plus[stat] || 0
  end  

  def stat_from_equip(stat)
    total = 0
    @equips.values.each{ |e|
      
    }
    return total
  end

  def stat_mod_from_equip(stat)
    return 1.0
  end

  def stat_from_states(stat)
    total = 0
    @states.each{ |e|
      
    }
    return total
  end

  def stat_mod_from_states(stat)
    return 1.0
  end

  # MAYBE
  def stat_mod_from_difficulty(stat)
    return 1.0
  end

end"(
class Game_Battler


  #--------------------------------------------------------------------------
  # * States
  #--------------------------------------------------------------------------

  def state?(state_id)
    return @states.include?(state_id)
  end

  def add_state(state_id)
    @states.push(state_id)
  end

  def remove_state(id)
    @states.delete(id)
  end

  #--------------------------------------------------------------------------
  # * Get Restriction
  #--------------------------------------------------------------------------
  def restriction
    restriction_max = 0
    # Get maximum restriction from currently added states
    for i in @states
      if $data_states[i].restriction >= restriction_max
        restriction_max = $data_states[i].restriction
      end
    end
    return restriction_max
  end

  #--------------------------------------------------------------------------
  # â Has Restriction
  #   Determines if battler has a special restriction
  #--------------------------------------------------------------------------
  def has_restriction?(restriction)
    for i in @states
      if $data_states[i].restriction == restriction
        return true
      end
    end
    
    return false
  end

  #--------------------------------------------------------------------------
  # * Determine [Slip Damage] States
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Remove Battle States (called up during end of battle)
  #--------------------------------------------------------------------------
  def remove_states_battle
    for i in @states.clone
      if $data_states[i].battle_only
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Natural Removal of States (called up each turn)
  #--------------------------------------------------------------------------
  def remove_states_auto
    for i in @states_turn.keys.clone
      if @states_turn[i] > 0
        @states_turn[i] -= 1
      elsif rand(100) < $data_states[i].auto_release_prob
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * State Removed by Shock (called up each time physical damage occurs)
  #--------------------------------------------------------------------------
  def remove_states_shock
    for i in @states.clone
      if rand(100) < $data_states[i].shock_release_prob
        remove_state(i)
      end
    end
  end

 end"ãclass Game_Battler

  def learn(skill)
  	@skills.push(skill)
  end

  def skill_list
    return @skills
  end


  def skills_for(action)

    return @skills.select{ |s| 
      #log_info s
      $data.skills[s].id == action || 
      $data.skills[s].book == action
    }
  end

  def choose_action
  	@action = 'attack'
    @skill_id = 'attack'
    @target = $party.actor_by_id('boy')
  end  

  #--------------------------------------------------------------------------
  # * Determine Usable Skills
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    # If there's not enough SP, the skill cannot be used.
    if $data.skills[skill_id].sp_cost > self.sp
      return false
    end
    
    # If silent, only physical skills can be used
    if $data_skills[skill_id].atk_f == 0 and self.has_restriction?(1)
      return false
    end

    return true
  end

end"
class Game_Battler

	def equip(slot,new_equip)

		if @equips[slot] != nil # Remove existing
			$party.add_item(@equips[slot])
			@equips[slot] = nil
		end

		if new_equip != nil
			$party.lose_item(new_equip)
			@equips[slot] = new_equip
		end

	end

	def equip_list
		list = []
		@slots.each{ |s|
			list.push(@equips[s])
		}
		log_info(list)
		return list
	end

end"
class Game_Battler

  #--------------------------------------------------------------------------
  # * XP Calcs
  #--------------------------------------------------------------------------
  def exp_percent
    
  end
  
  def next_exp 
     
  end


end"	
class Attack_Result

	attr_accessor :target
	
	attr_accessor :damage
	attr_accessor :critical

	attr_accessor :state_add
	attr_accessor :state_remove

	attr_accessor :transform

end

class Attack_Round

	attr_accessor :anim_a
	attr_accessor :anim_b

	attr_accessor :skill

end

class Attack_Plan

	def initialize

		@attacks = []

	end

	def add(attack)
		@attacks.push(attack)
	end

	def next_attack
		return @attacks.shift
	end

	def done?
		return @attacks.empty?
	end

end"Ðª#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  
  attr_reader   :x                        # map x-coordinate (logical)
  attr_reader   :y                        # map y-coordinate (logical)
  attr_reader   :real_x                   # map x-coordinate (real * 128) # For precision
  attr_reader   :real_y                   # map y-coordinate (real * 128)
  
  
  # Graphics

  attr_accessor   :character_name           # character file name

  attr_accessor   :opacity                  # opacity level
  
  
  attr_accessor :direction                # direction
  attr_accessor :showdir

  attr_accessor :force_pattern # For random pattern feature

  attr_accessor   :pattern                  # pattern
  attr_reader   :move_route_forcing       # forced move route flag
  attr_reader   :through                  # through
  attr_accessor :animation_id             # animation ID
  attr_accessor :transparent              # transparent flag
  attr_accessor :ignore_movement          # ignore movement when finding path
  attr_accessor :step_anime               # stop animation
  
  attr_accessor :fxtrail

  attr_accessor :cool_jumps, :spin_jumps, :flat_jumps
  
  # Custom
  attr_accessor :off_x, :off_y
  
   
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @character_name = ""
    

    @direction = 2
    @showdir = 4
    @lockdir = 0

    @force_pattern = nil

    @move_angle = 0

    @prev_terrain = 0


    @off_x = 0
    @off_y = 0

    @cool_jumps = false
    @spin_jumps = false
    @flat_jumps = false

    @fxtrail = nil

    @pattern = 0

    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0

    @move_type = 0
    @move_speed = 3
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0

    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0 #how long has paused for between steps

    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
    @ignore_movement = false

    @opacity = 255
  end

  # For offsets > 32, snap the position and remove offset
  def snap_offset
    @y += @off_y / 32
    @x += @off_x / 32
    @real_x = @x * 128
    @real_y = @y * 128
    @off_y = @off_y % 32
    @off_x = @off_x % 32
  end

  #--------------------------------------------------------------------------
  # * Determine if Moving
  #--------------------------------------------------------------------------
  def moving?
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # * Determine if Jumping
  #--------------------------------------------------------------------------
  def jumping?
    @showdir = [2,4,6,8].sample if @jump_count > 0 && @spin_jumps
    return @jump_count > 0
  end

  #--------------------------------------------------------------------------
  # * Straighten Position
  #--------------------------------------------------------------------------
  def straighten
    # If moving animation or stop animation is ON
    if @walk_anime or @step_anime
      # Set pattern to 0
      @pattern = 0
    end
    # Clear animation count
    @anime_count = 0
    # Clear prelock direction
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # * Force Move Route
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # Save original move route
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end

    # Change move route
    @move_route = move_route
    @move_route_index = 0
    # Set forced move route flag
    @move_route_forcing = true
    # Clear prelock direction
    @prelock_direction = 0
    # Clear wait count
    @wait_count = 0
    # Move cutsom
    move_type_custom
    
  end

    def at?(x,y)
    return self.x == x && self.y == y
  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d) #d0 = jump

    #return true if self != $player

    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)

    return false if self != $player && $player.at?(new_x,new_y)
       
    # If coordinates are outside of map
    return false unless $map.valid?(new_x, new_y)
    return true if @through
    
    # To new tile and from new tile
    return false unless $map.passable?(x, y, d, self)
    return false  unless $map.passable?(new_x, new_y, 10 - d,self)

    # end
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Determine if Can Fight 
  #--------------------------------------------------------------------------
  def canfight?()

    d = 2 if @x == $player.x and @y == $player.y - 1
    d = 8 if @x == $player.x and @y == $player.y + 1
    d = 4 if @y == $player.y and @x == $player.x + 1
    d = 6 if @y == $player.y and @x == $player.x - 1
    
    return passable?(x,y,d)

  end

  #--------------------------------------------------------------------------
  # * Lock
  #--------------------------------------------------------------------------
  def lock
    return if @locked
    @prelock_direction = @direction
    turn_toward_player
    @locked = true
  end

  #--------------------------------------------------------------------------
  # * Determine if Locked
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end

  #--------------------------------------------------------------------------
  # * Unlock
  #--------------------------------------------------------------------------
  def unlock
    return if !@locked

    # Clear locked flag
    @locked = false
    # If direction is not fixed
    unless @direction_fix
      # If prelock direction is saved
      if @prelock_direction != 0
        # Restore prelock direction
        @direction = @prelock_direction
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x 
    @y = y 
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end

  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    # Get screen coordinates from real coordinates and map display position
    return  @off_x + (@real_x - $scene.map.display_x + 3) / 4 + 16
  end

  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    # Get screen coordinates from real coordinates and map display position
    y = (@real_y - $scene.map.display_y + 3) / 4 + 32
    # Make y-coordinate smaller via jump count
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    if @flat_jumps
      return @off_y + y - (@jump_peak * @jump_peak - n * n) / 6
    else
      return @off_y + y - (@jump_peak * @jump_peak - n * n) / 2
    end
  end
  #--------------------------------------------------------------------------
  # * Get Screen Z-Coordinates
  #     height : character height
  #--------------------------------------------------------------------------
  def screen_z(height = 0)

    return 0 if @below
    return 999 if @above

    # Get screen coordinates from real coordinates and map display position
    z = (@real_y - $scene.map.display_y + 3) / 4 + 32

    # If height exceeds 32, then add 31
    return z #+ ((height > 32) ? 31 : 0)


  end

  #--------------------------------------------------------------------------
  # * Get Thicket Depth
  #--------------------------------------------------------------------------
  def bush_depth
    return 0 if @always_on_top
    return 0 if jumping?
    dx = ((@x * 128) - @real_x).abs
    #log_info(dx) if dx > 0
    return 12 if $scene.map.bush?(@x, @y) && dx < 24
    return 0
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #--------------------------------------------------------------------------
  def terrain_tag() return $scene.map.terrain_tag(@x, @y) end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update(mini=false)

    # mini is just for player to make sure anim finishes

    # Update facing dir
    @lockdir -= 1
    if @lockdir <= 0
      @showdir = @direction
    end

    return if mini && !jumping? # Force jumps to finish


    # Mouse pathfinding
    run_path if @runpath == true    
    
    # Branch with jumping, moving, and stopping
    if jumping?
      update_jump
    elsif moving?
      update_move
      if !moving?
        @move_angle = 0
      end
    else
      update_stop
    end

    # If animation count exceeds maximum value
    # * Maximum value is move speed * 1 taken from basic value 18
    if @anime_count > 18 - @move_speed * 2
      # If stop animation is OFF when stopping
      if not @step_anime and @stop_count > 0
        # Return to original pattern
        @pattern = @original_pattern
      # If stop animation is ON when moving
      else
        # Update pattern
        @pattern = (@pattern + 1) % 4
      end
      # Clear animation count
      @anime_count = 0
    end


    # If waiting
    if @wait_count > 0
      # Reduce wait count
      @wait_count -= 1
      return
    end


    # If move route is forced
    if @move_route_forcing
      # Custom move
      move_type_custom
      return
    end
    # When waiting for event execution or locked
    if @starting or lock?
      # Not moving by self
      return
    end

    # If stop count exceeds a certain value (computed from move frequency)
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # Branch by move type
      case @move_type
        when 1  # Random
          move_type_random
        when 2  # Approach
          move_type_toward_player
        when 3  # Custom
          move_type_custom
      end
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (jump)
  #--------------------------------------------------------------------------
  def update_jump
    # Reduce jump count by 1
    @jump_count -= 1
    @jump_count += 0.5 if @cool_jumps
    # Calculate new coordinates
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)

    # Run in air for cool jumps
    if @cool_jumps && !@spin_jumps

      # If move animation is ON
      if @walk_anime
        # Increase animation count by 1.5
        @anime_count += 3
      # If move animation is OFF, and stop animation is ON
      elsif @step_anime
        # Increase animation count by 1
        @anime_count += 2
      end

    end

  end

  #--------------------------------------------------------------------------
  # * Update frame (move)
  #--------------------------------------------------------------------------
  def update_move

    #if moving?

    #end

    
    

    # Convert map coordinates from map move speed into move distance
    distance = 2 ** @move_speed 

    #LADDER
    if terrain_tag == 3

      # turn to get on ladder
      if @direction == 2 #&& @prev_terrain != 3
        @showdir = 4
        @direction = 8
        @lockdir = 4
     else
        @direction = 8
        #@showdir = 8
      end
      @move_angle += 0.2
      # Convert map coordinates from map move speed into move distance
      distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs

      #sfx("step") if (2.4-@move_angle).abs < 0.2 && (@prev_terrain == 4 || @prev_terrain == 3)
      #sfx("step") if (4.8 - @move_angle).abs < 0.21

    elsif terrain_tag == 5 && @prev_terrain == 3
      #@showdir = 8
      #@direction = 8

      @move_angle += 0.2

      if @move_angle < 3.14
        @showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs
      else
        #if @lockdir > 0
          @direction = 2
          @showdir = 4
          @lockdir = 2
       # end
        distance = 2 ** @move_speed 
      end

      #sfx("step") if @move_angle == 2.4 && @prev_terrain != 3


    elsif terrain_tag == 2 # Stairs

      #@showdir = 8
      #@direction = 8

      @move_angle += 0.15

      #if @move_angle < 3.14
        #@showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 2.0 ** @move_speed * (Math.sin(@move_angle)).abs
      #end

      #Audio.se_play("Audio/SE/step.ogg") if @move_angle == 2.4 && @prev_terrain != 3


    else
      @move_angle = 0
    end

    # If logical coordinates are further down than real coordinates
    if @y * 128 > @real_y
      @real_y = [@real_y + distance, @y * 128].min
    end
    # If logical coordinates are more to the left than real coordinates
    if @x * 128 < @real_x
      @real_x = [@real_x - distance, @x * 128].max
    end
    # If logical coordinates are more to the right than real coordinates
    if @x * 128 > @real_x
      @real_x = [@real_x + distance, @x * 128].min
    end
    # If logical coordinates are further up than real coordinates
    if @y * 128 < @real_y
      @real_y = [@real_y - distance, @y * 128].max
    end

    # If move animation is ON
    if @walk_anime
      # Increase animation count by 1.5
      @anime_count += 1.5
    # If move animation is OFF, and stop animation is ON
    elsif @step_anime
      # Increase animation count by 1
      @anime_count += 1
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (stop)
  #--------------------------------------------------------------------------
  def update_stop

    @prev_terrain = terrain_tag if @prev_terrain != terrain_tag

    # If stop animation is ON
    if @step_anime
      # Increase animation count by 1
      @anime_count += 1
    # If stop animation is OFF, but current pattern is different from original
    elsif @pattern != @original_pattern
      # Increase animation count by 1.5
      @anime_count += 1.5
    end
    # When waiting for event execution, or not locked
    # * If lock deals with event execution coming to a halt
    unless @starting or lock?
      @stop_count += 1
    end
  end
  
  #--------------------------------------------------------------------------
  # * Move Type : Random
  #--------------------------------------------------------------------------
  def move_type_random
    # Branch by random numbers 0-5
    case rand(6)
      when 0..3  # Random
        move_random
      when 4  # 1 step forward
        move_forward
      when 5  # Temporary stop
        @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # Get difference in player coordinates
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end

    # What if they follow more aggressively on harder difficulty?
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_toward_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end
  end

  #--------------------------------------------------------------------------
  # * Move Type : Custom
  #--------------------------------------------------------------------------
  def move_type_custom
    # Interrupt if not stopping
    return if jumping? or moving?

    # Loop until finally arriving at move command list
    while @move_route_index < @move_route.list.size

      # Acquiring move command
      command = @move_route.list[@move_route_index]

      # If command code is 0 (last part of list)
      if command.code == 0

        # Restart
        @move_route_index = 0 if @move_route.repeat

        # If [repeat action] option is OFF
        if !@move_route.repeat
          # If move route is forcing
          if @move_route_forcing

            # Release forced move route
            @move_route_forcing = false

            # Restore original move route
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # Clear stop count
          @stop_count = 0
        end
        return
      end

      # COL 1

      # During move command (from move down to jump)
      if command.code <= 14
        # Branch by command code
        case command.code
          when 1; move_down
          when 2  # Move left
            move_left
          when 3  # Move right
            move_right
          when 4  # Move up
            move_up
          when 5  # Move lower left
            move_lower_left
          when 6  # Move lower right
            move_lower_right
          when 7  # Move upper left
            move_upper_left
          when 8  # Move upper right
            move_upper_right
          when 9  # Move at random
            move_random
          when 10  # Move toward player
            move_toward_player
          when 11  # Move away from player
            move_away_from_player
          when 12  # 1 step forward
            move_forward
          when 13  # 1 step backward
            move_backward
          when 14  # Jump
            jump(command.parameters[0], command.parameters[1])
        end
        # If movement failure occurs when [Ignore if can't move] option is OFF
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end

      # If waiting
      if command.code == 15
        # Set wait count
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end

      # COL 2

      # If direction change command
      if command.code >= 16 and command.code <= 26
        # Branch by command code
        case command.code
        when 16  # Turn down
          turn_down
        when 17  # Turn left
          turn_left
        when 18  # Turn right
          turn_right
        when 19  # Turn up
          turn_up
        when 20  # Turn 90Â° right
          turn_right_90
        when 21  # Turn 90Â° left
          turn_left_90
        when 22  # Turn 180Â°
          turn_180
        when 23  # Turn 90Â° right or left
          turn_right_or_left_90
        when 24  # Turn at Random
          turn_random
        when 25  # Turn toward player
          turn_toward_player
        when 26  # Turn away from player
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end

      # COL 3

      # If other command
      if command.code >= 27
        # Branch by command code
        case command.code
        
        when 29  # Change speed
          @move_speed = command.parameters[0]
        when 30  # Change freq
          @move_frequency = command.parameters[0]
        when 31  # Move animation ON
          @walk_anime = true
        when 32  # Move animation OFF
          @walk_anime = false
        when 33  # Stop animation ON
          @step_anime = true
        when 34  # Stop animation OFF
          @step_anime = false
        when 35  # Direction fix ON
          @direction_fix = true
        when 36  # Direction fix OFF
          @direction_fix = false
        when 37  # Through ON
          @through = true
        when 38  # Through OFF
          @through = false
        when 39  # Always on top ON
          @always_on_top = true
        when 40  # Always on top OFF
          @always_on_top = false
        when 41  # Change Graphic
          @character_name = command.parameters[0]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # Change Opacity
          @opacity = command.parameters[0]
        when 43  # Change Blending
          @blend_type = command.parameters[0]
        when 44  # Play SE
          $game_system.se_play(command.parameters[0])
        when 45  # Script
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end


    end


  end

  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    # Clear stop count
    @stop_count = 0
  end



    #--------------------------------------------------------------------------
  # * Move Down
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)


    @move_angle = 0

    # Turn down
    if turn_enabled
      turn_down
    end
    # If passable
    if passable?(@x, @y, 2)

      # Turn down
      turn_down
      # Update coordinates
      @y += 1
      # Increase steps
      increase_steps
      # If impassable
      $audio.queue('step',10,0.15) if terrain_tag == 3 || terrain_tag == 5
      $audio.queue('step',24,0.15) if terrain_tag == 3

       #$audio.queue('walk',4,0.5) if self == $player
       $audio.queue('walk',12,0.4) if self == $player && terrain_tag != 3
       $audio.queue('walk',12,0.6) if self == $player && terrain_tag == 2
    else
      # Determine if touch event is triggered IF ENEMY ONLY
      check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Left
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)

@move_angle = 0

    # Turn left
    if turn_enabled
      # If facing right, turn down for just second
      turn_left
    end
    # If passable
    if passable?(@x, @y, 4)
      # Turn left
      turn_left
      # Update coordinates
      @x -= 1
      # Increase steps
      increase_steps
    # If impassable
    $audio.queue('walk',12,0.4) if self == $player && terrain_tag != 3
    $audio.queue('walk',12,0.6) if self == $player && terrain_tag == 2
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Right
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)

    @move_angle = 0

    # Turn right
    if turn_enabled
      turn_right
    end
    # If passable
    if passable?(@x, @y, 6)
      # Turn right
      turn_right
      # Update coordinates
      @x += 1
      # Increase steps
      increase_steps
    # If impassable
    $audio.queue('walk',12,0.4) if self == $player && terrain_tag != 3
    $audio.queue('walk',12,0.6) if self == $player && terrain_tag == 2
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move up
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)

    @move_angle = 0

    # Turn up
    if turn_enabled
      turn_up
    end
    # If passable
    if passable?(@x, @y, 8)
      # Turn up
      turn_up
      # Update coordinates
      pt = terrain_tag
      @y -= 1
      # Increase steps
      increase_steps
    # If impassable
      $audio.queue('step',10,0.15) if terrain_tag == 3 && pt == 3
      $audio.queue('step',24,0.15) if terrain_tag == 4
      $audio.queue('step',24,0.15) if terrain_tag == 3

      $audio.queue('walk',12,0.4) if self == $player && terrain_tag != 3
      $audio.queue('walk',12,0.6) if self == $player && terrain_tag == 2
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Left
  #--------------------------------------------------------------------------
  def move_lower_left
    # If no direction fix
    unless @direction_fix
      # Face down is facing right or up
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # When a down to left or a left to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # Update coordinates
      @x -= 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Right
  #--------------------------------------------------------------------------
  def move_lower_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face down if facing up
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # When a down to right or a right to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # Update coordinates
      @x += 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Left
  #--------------------------------------------------------------------------
  def move_upper_left
    # If no direction fix
    unless @direction_fix
      # Face left if facing right, and face up if facing down
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # When an up to left or a left to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # Update coordinates
      @x -= 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Right
  #--------------------------------------------------------------------------
  def move_upper_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face up if facing down
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # When an up to right or a right to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # Update coordinates
      @x += 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move at Random
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # Move down
      move_down(false)
    when 1  # Move left
      move_left(false)
    when 2  # Move right
      move_right(false)
    when 3  # Move up
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * Move toward Player
  #--------------------------------------------------------------------------
  def move_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Move away from Player
  #--------------------------------------------------------------------------
  def move_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move away from player, prioritize left and right directions
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # If vertical distance is longer
    else
      # Move away from player, prioritize up and down directions
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Forward
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Backward
  #--------------------------------------------------------------------------
  def move_backward
    # Remember direction fix situation
    last_direction_fix = @direction_fix
    # Force directino fix
    @direction_fix = true
    # Branch by direction
    case @direction
    when 2  # Down
      move_up(false)
    when 4  # Left
      move_right(false)
    when 6  # Right
      move_left(false)
    when 8  # Up
      move_down(false)
    end
    # Return direction fix situation back to normal
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # * Jump
  #     x_plus : x-coordinate plus value
  #     y_plus : y-coordinate plus value
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # If plus value is not (0,0)
    if x_plus != 0 or y_plus != 0
      # If horizontal distnace is longer
      if x_plus.abs > y_plus.abs
        # Change direction to left or right
        x_plus < 0 ? turn_left : turn_right
      # If vertical distance is longer, or equal
      else
        # Change direction to up or down
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # Calculate new coordinates
    new_x = @x + x_plus
    new_y = @y + y_plus
    # If plus value is (0,0) or jump destination is passable
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # Straighten position
      straighten
      # Update coordinates
      @x = new_x
      @y = new_y
      # Calculate distance
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # Set jump count
      @jump_peak = 10 + distance - @move_speed 
      @jump_peak += distance if @cool_jumps
      @jump_count = @jump_peak * 2
      # Clear stop count
      @stop_count = 0
    end
  end

  #--------------------------------------------------------------------------
  # * Turns
  #--------------------------------------------------------------------------
  def turn_down() 
    return if @direction_fix 
    return if terrain_tag == 3 #on ladder
    return if terrain_tag == 4 #&& @previous_terrain == 3
    if @direction == 8
        @showdir=4
        @direction = 2
        @lockdir = 6
      else
        @direction = 2 
      end  


  end


  def turn_left() 
    return if @direction_fix 
      if @direction == 6
        @showdir=2
        @direction =4
        @lockdir = 7
      else
        @direction = 4 unless @direction_fix 
      end
    
  end

  def turn_right() 
    return if @direction_fix 
    if @direction == 4
        @showdir=2
        @direction = 6
        @lockdir = 7
    else
      @direction = 6 unless @direction_fix 
    end
  end



  def turn_up() 
    return if @direction_fix 
    if @direction == 2
        @showdir=6
        @direction = 8
        @lockdir = 6
      else
        @direction = 8 unless @direction_fix 
      end  

  end
  
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Left
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 180Â°
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right or Left
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # * Turn at Random
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Towards Player
  #--------------------------------------------------------------------------
  def turn_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Away from Player
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left away from player
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down away from player
      sy > 0 ? turn_down : turn_up
    end
  end

  #--------------------------------------------------------------------------
  # * Turn Towards Event
  #--------------------------------------------------------------------------
  def turn_toward_event(event_id)
    # Get difference in player coordinates
    evt = $map.events[event_id]
    return if evt == nil
    sx = @x - evt.x
    sy = @y - evt.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end

  def turn_toward_pos(x,y)

    sx = @x - x
    sy = @y - y

    # If coordinates are equal
    return if sx == 0 and sy == 0

    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end
  #   #--------------------------------------------------------------------------
#   # * Frame Update (run_path)
#   #--------------------------------------------------------------------------
  def run_path

    return if moving?

    step = @map[@x,@y]
    if step == 1 # AT TARGET POS
      @map = nil
      @runpath = false
      return
    end
      
    # maybe cut the step != 0, would be broken if there

    dir = rand(2)
    case dir
    when 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_up if @map[@x,@y-1] == step - 1 and step != 0
    when 1
      move_up if @map[@x,@y-1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
    end
  end

  #--------------------------------------------------------------------------
  # * Find Path
  #--------------------------------------------------------------------------
  def find_path(x,y)
    sx, sy = @x, @y
    @tx, @ty = x, y
    tx, ty = x,y
    result = setup_map(sx,sy,tx,ty)
    @runpath = result[0]
    @map = result[1]
    @map[sx,sy] = result[2] if result[2] != nil
  end
  #--------------------------------------------------------------------------
  # * Clear Path
  #--------------------------------------------------------------------------
  def clear_path
    @map = nil
    @runpath = false
  end
  #--------------------------------------------------------------------------
  # * Setup Map
  #--------------------------------------------------------------------------
  def setup_map(sx,sy,tx,ty) #tx and ty in params for external call

    map = Table.new($map.width, $map.height)

    update_counter = 0
    map[tx,ty] = 1
    old_positions = [[tx, ty]]
    new_positions = []

    depth = 2

    depth.upto(100){ |step|
      while !old_positions.empty?

        x,y = old_positions.shift

        #log_sys([x,y])

        if x == sx and y == sy
          #log_scr("WINWINWINW")
          return [true, map, step-1] 
        end

        if map[x,y + 1] == 0 and passable?(x, y, 2) 
          #log_err "IN"
          map[x,y + 1] = step
          new_positions.push([x,y + 1])
        end

        if map[x - 1,y] == 0 and passable?(x, y, 4) 
          map[x - 1,y] = step
          new_positions.push([x - 1,y])
        end

        if map[x + 1,y] == 0 and passable?(x, y, 6) 
          map[x + 1,y] = step
          new_positions.push([x + 1,y])
        end

        if map[x,y - 1] == 0 and passable?(x, y, 8) 
          map[x,y - 1] = step
          new_positions.push([x,y - 1])
        end

      end

      old_positions = new_positions
      new_positions = []

      #log_info (old_positions)
    }
      
    log_err "No Path Found"
    return [false, nil, nil]     

  end


end
"í8#==============================================================================
# ** Game_Event
#==============================================================================

class Game_Event < Game_Character

  attr_reader   :trigger   
  attr_reader   :list          
  attr_reader   :starting  
  
  attr_reader   :name
  attr_reader   :event
  attr_reader   :icon

  attr_accessor :random

  attr_reader :above
  attr_reader :below

  attr_reader :page_idx

  attr_reader :deleted, :disabled, :erased
      

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------

  def initialize(event)
    super()

    @event = event
    @id = event.id

    # Hold a random number to be used with @r1
    @random = 0 
    
    @erased = false
    @disabled = $state.disable?(@id)
    @deleted = $state.delete?(@id)

    @starting = false
    @through = true
    @above = false
    @below = false

    @width = 1
    @height = 1

    @page = nil
    @page_idx = -1

    # Name breakdown
    name = @event.name

    clone_ev = nil
    
    # Clone map clone
    if name.include?('::')
      clone = name.delete('::')
      name = $data.clones[clone].name
      clone_ev = $data.clones[clone]
    elsif name.include?(':')
      clone = name.delete(':')
      clone_ev = $scene.map.event_by_name(clone).event
      name = clone_ev.name
    end

    if name == '' || name == '#'
      @icon = nil
      @name = 'nil'
    else
      data = name.split('#').first.split('.')
      if data.size > 1
        @icon = data[0].strip
        @name = data[1].strip
      else
        @icon = @name = data[0].strip
      end
    end   
    
    # Set pages from clone or event
    if clone_ev
      @pages = clone_ev.pages
    else
      @pages = @event.pages 
    end

    # Restore saved location if relevant
    if $state.loc?(@id)
      loc = $state.getloc(@id)
      moveto(loc[0],loc[1])
    else
      moveto(@event.x, @event.y)
    end
    
    refresh
  end

  #--------------------------------------------------------------------------
  # * Clear Starting Flag
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end

  def icon
    return nil if @erased || @disabled || @deleted
    return @icon
  end

  def collide?(x,y)
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine if Over Trigger
  #    is this event under player
  #--------------------------------------------------------------------------
  def over_trigger?
    # If not through situation with character as graphic
    if @character_name != "" and not @through
      # Starting determinant is face
      return false
    end
    # If this position on the map is impassable
    unless $map.passable?(@x, @y, 0)
      # Starting determinant is face
      return false
    end
    # Starting determinant is same position
    return true
  end

  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  def start  
    return if @erased || @deleted || @disabled
    return if !@list || @list.size < 1
    refresh
    @starting = true    

  end

  def stop

    $player.looklike($party.leader)
    
    # Enable the second state if there is one
    state(@id,"second_#{@page_idx}") if !is_second?(@page)

  end

  def find_page
    return nil if @erased || @deleted
    page = @pages.count-1
    while page >= 0
      return page if conditions_met?(page)
      page -= 1
    end
  end

  def conditions_met?(idx)
        #return false if page == 0

        page = @pages[idx]
      
        # DANHAX - check super conditions
        page.list.each{ |line|
      
          if line.code == 108
            comment = line.parameters[0]
            if comment[0] == '?'[0]
              data = comment.split(' ')
              if !condition_applies?(data,idx)
                return false
              end
            end
          end        
        }  

        return true
  end

  # Can also be called by script
  def condition_applies?(cond,idx)
      # cond is [code,data1.....]

    case cond[0]

      # Second
      when '?second'
        return false if !conditions_met?(idx-1)
        return false if !state?(@id,"second_#{idx-1}")
       

      # Flag
      when '?flag'
          return false if !flag?(cond[1])
              
      # Progress
      when '?before'
        return false if !$progress.before?(cond[1])
      when '?progress'
        return false if !$progress.progress?(cond[1])
      when '?after'
        return false if !$progress.beyond?(cond[1])

      # States
      when '?state'
        if cond.count > 2
          return false if !$state.state?(gid(cond[1]),cond[2])
        else
          return false if !$state.state?(@id,cond[1])
        end

      # Active Quest
      when '?active'
        return false if !$progress.active?(cond[1])
      when '?inactive'
        return false if $progress.active?(cond[1])
      when '?complete'
        return false if !$progress.complete?(cond[1])
      when '?incomplete'
        return false if $progress.complete?(cond[1])
      when '?quest'
        return false if !$progress.quest?(cond[1])

      # Party member check
      when '?boyle', '?boy'
        return false if !$party.has_member?('boy')
      when '?ingrid', '?ing'
        return false if !$party.has_member?('ing')
      when '?myst', '?mys'
        return false if !$party.has_member?('mys')
      when '?robin', '?rob'
        return false if !$party.has_member?('rob')
      when '?hiberu', '?hib'
        return false if !$party.has_member?('hib')
      when '?rowen', '?row'
        return false if !$party.has_member?('row')
      when '?phye', '?phy'
        return false if !$party.has_member?('phy')

      # Inventory
      when '?gold'
        return false if !$party.has_gold?(cond[1].to_i)

      when '?item'
        cond[2] = 1 if cond.count < 3
        return false if !($party.item_number(cond[1]) >= cond[2].to_i)



    end

    return true

  end

  def label_applies?(label)

    case label.split(":")[0]
      
      when '@first'
        return false if state?(me,"second_#{this.page_idx}")
      when '@second'
        return false if !state?(me,"second_#{this.page_idx}")

      # Char in party
      when '@boy'
        return false if $party.leader != 'boy'      
      when '@ing'
        return false if $party.leader != 'ing'
      when '@mys'
        return false if $party.leader != 'mys'
      when '@rob'
        return false if $party.leader != 'rob'
      when '@hib'
        return false if $party.leader != 'hib'
      when '@row'
        return false if $party.leader != 'row'
      when '@phy'
        return false if $party.leader != 'phy'

      # Choices
      when '@a', '@b', '@c', '@d'
        return false if label.split(":")[0] != $scene.hud.message.last_choice

      # Randoms
      when '@r1'
        return false if @random != 1
      when '@r2'
        return false if @random != 2
      when '@r3'
        return false if @random != 3
      when '@r4'
        return false if @random != 4
      when '@r5'
        return false if @random != 5
      when '@r6'
        return false if @random != 6
      when '@r7'
        return false if @random != 7


    end

    return true

  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    @page_idx = find_page
    new_page = @pages[@page_idx] if @page_idx != nil
    setup_page(new_page) if new_page != @page
  end

  def is_second?(page)

    return if page == nil

    # DANHAX - check super conditions
    page.list.each{ |line|
  
      if line.code == 108
        comment = line.parameters[0]
        if comment[0] == '?'[0]
          data = comment.split(' ')
          return true if data[0] == '?second'
        end
      end        
    }  

    return false

  end  
  
  def setup_page(new_page)

    # Set @page as current event page
    @page = new_page
    if @page
      setup_page_settings
      read_comment_data
    else
      clear_page_settings
    end

    # Clear starting flag
    clear_starting
    
    # Auto event start determinant
    check_event_trigger_auto

  end
  

  def clear_page_settings
      @character_name = ""
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
  end

  def setup_page_settings
    
    # Set each instance variable
    @character_name = @page.graphic.character_name
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    #XP - VX @opacity = @page.graphic.opacity
    #XP - VX @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil

    # Do things based on the name
    if @character_name == "!!!"
      @through = true
      @trigger = 1 if @trigger == 0
      if @pattern == 0 && @direction == 2
        @icon = 'T'
      end
    end

    # Change enemy gfx
    if @character_name == "!!!Monster"
      @character_name = "Monsters/#{$battle.enemy_types[@pattern]}"
      @trigger = 2
    end

    if @character_name == "Common"
      @direction_fix = true
    end

  end
  
  def read_comment_data
    comment_data = []

    @list.each{ |line|
      next if line.code != 108
      if line.parameters[0].include?('#')
        comment_data.push(line.parameters[0].split(" "))
      end
    }

    comment_data.each{ |data|
      case data[0]

        when '#above'
          @above = true
        when '#below'
          @below = true

        when '#opacity'
          self.opacity = data[1].to_i
        when '#hide'
          self.opacity = 0

        when '#width'
          @width = data[1].to_i
        when '#height'
          @height = data[1].to_i
        when '#gfx'

          if @character_name == "!!Prop"
            @character_name = "Props/"+data[1]
          end

          if @character_name.include?("NPC")
            @character_name = "NPCs/"+@character_name.delete("NPC-")+"/"+data[1]
          end

        when "#prop"
          @character_name = "Props/#{data[1]}"

        when "#animal"
          @character_name = "Animals/#{data[1]}"

        when "#object"
          @character_name = "Objects/#{data[1]}"

        when "#door"
          @character_name = "Doors/#{data[1]}"

        when "#icon"
          @character_name = "Icons/#{data[1]}"

        when '#rand-pattern'
          @force_pattern = rand(3)

        when '#rand-dir'
          @direction = [2,4,6].sample

        when '#ox'
          @off_x = data[1].to_i
        when '#oy'
          @off_y = data[1].to_i

        when '#moblin'
          data.push(1) if data.count < 2
          $scene.add_moblin(self,data[1].to_i)

        when '#disable'
          disable

        when '#fxtrail'
          @fxtrail = data[1]

      end
    }
    

  end

  #--------------------------------------------------------------------------
  # * Automatic Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # # If trigger is [touch from event] and consistent with player coordinates
    # if @trigger == 2 and @x == $player.x and @y == $player.y
    #   # If starting determinant other than jumping is same position event
    #   if not jumping? and over_trigger?
    #     start
    #   end
    # end

    # If trigger is [parallel process]
    if @trigger == 4
      @interpreter = Interpreter.new
      @interpreter.setup(@list, @event.id)
    end


    # If trigger is [auto run]
    if @trigger == 3 || @event.name == 'AUTORUN'
      start
    end
  end


  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?
      
    if $player.at?(x,y) and [1,2].include?(@trigger)
      start_battle
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # Automatic event starting determinant
    check_event_trigger_auto if @starting == false

    # If parallel process is valid
    if @interpreter != nil
      @interpreter.update
    end

  end
    
  #--------------------------------------------------------------------------
  # * Save Position
  #--------------------------------------------------------------------------
  def saveloc
    $state.loc!(@event.id)
  end

  #--------------------------------------------------------------------------
  # * Temporarily Erase
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    self.opacity = 0
    refresh
  end

  def disable
    @disabled = true
    $state.disable(@id)
    refresh
  end

  def enable
    @disabled = false
    $state.enable(@id)
    refresh
  end

  def delete
    @deleted = true
    $state.delete(@id)
    self.opacity = 0
    refresh
  end

end"a[#==============================================================================
# ** Interpreter
#==============================================================================

class Interpreter

  attr_accessor :common_event_id

  attr_accessor :wait_count

  attr_accessor :event_id
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #     main  : main flag
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main

    @common_event_id = 0
    
    # Depth goes up to level 100
    if depth > 100
      print("Common event call has exceeded maximum limit.")
      exit
    end
    
    # Clear inner situation of interpreter
    clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Reset
  #   Remove any queued items 
  #--------------------------------------------------------------------------
  def reset
    @list = nil
  end
  
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # map ID when starting up
    @event_id = 0                     # event ID
    @message_waiting = false          # waiting for message to end
    @move_route_waiting = false       # waiting for move completion
    @wait_count = 0                   # wait count
    @child_interpreter = nil          # child interpreter
    @branch = {}                      # branch data
  end

  #--------------------------------------------------------------------------
  # * Event Setup
  #     list     : list of event commands
  #     event_id : event ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    
    # Clear inner situation of interpreter
    clear
    
    # Remember map ID
    @map_id = $map.id
    
    # Remember event ID
    @event_id = event_id
    
    # Remember list of event commands
    @list = list
    
    # Initialize index
    @index = 0
    
    # Clear branch data hash
    @branch.clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Current event (as event, not id)
  #--------------------------------------------------------------------------
  def event
    return $map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Running
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  
  #--------------------------------------------------------------------------
  # * Starting Event Setup
  #--------------------------------------------------------------------------
  def setup_starting_event
    
    # Refresh map if necessary
    if $map.need_refresh
      $map.refresh
    end
    
    # If common event call is reserved
    if @common_event_id > 0
      
      # Set up event
      setup($data.commons[@common_event_id].list, 0)
      
      # Release reservation
      @common_event_id = 0
      
      return
      
    end
    
    # Loop (map events)
    $map.starting_events.each{ |e| 

        # If not auto run
        #if e.trigger < 3
          
          e.clear_starting
          e.lock          
       # end
        
        # Set up event

        # Make sure autoruns don't run a second time if disabled
        return if e.disabled || e.deleted || e.erased

        setup(e.list, e.id) 
        
        return      
    }
    
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    
    # Initialize loop count
    @loop_count = 0
    
    # Loop
    loop do
      
      # Add 1 to loop count
      @loop_count += 1
      
      # If 100 event commands ran
      if @loop_count > 100
        # Call Graphics.update for freeze prevention
        Graphics.update
        @loop_count = 0
      end
      
      # If map is different than event startup time
      if $map.id != @map_id
        # Change event ID to 0
        @event_id = 0
      end
      
      # If a child interpreter exists, run it then check if done
      if @child_interpreter != nil
        @child_interpreter.update
        @child_interpreter = nil if !@child_interpreter.running?  
        return if @child_interpreter != nil        
      end
      
      # If waiting for message to end
      return if @message_waiting

      # Misc hud busy
      return if $scene.is_a?(Scene_Menu)
      return if $scene.is_a?(Scene_Battle)
      return if $scene.busy?

      # If waiting for move to end
      if @move_route_waiting

        # If player is forcing move route
        if $player.move_route_forcing
          return
        end
        
        # Loop (map events)
        for event in $map.events.values
          
          # If this event is forcing move route
          if event.move_route_forcing
            return
          end
          
        end
        
        # Clear move end waiting flag
        @move_route_waiting = false
        
      end
      
      # If waiting
      if @wait_count > 0
        # Decrease wait count
        @wait_count -= 1
        return
      end

      # If list of event commands is empty
      if @list == nil
        
        # If main map event
        if @main
          # Set up starting event
          setup_starting_event
        end
        
        # If nothing was set up
        if @list == nil
          return
        end
        
      end
      
      # If return value is false when trying to execute event command
      if execute_command == false
        return
      end
      
      # Advance index
      @index += 1
      
    end
  end

    #--------------------------------------------------------------------------
  # * Event Command Execution
  #--------------------------------------------------------------------------
  def execute_command
   
    # If last to arrive for list of event commands
    if @index >= @list.size - 1
      command_end
      return true
    end

    # Make event command parameters available for reference via @parameters
    @parameters = @list[@index].parameters

    # Check if this is a label marker
    # If it is check if applies, if so keep going,
    # Otherwise skip to next label
    if @list[@index].code == 108 && @parameters[0].include?('@')

      # Keep going until a label passes or end of events
      while true

        # No more commands, end it
        if @index >= @list.size - 1
          command_end
          return true
        end

        if @list[@index].code == 108
          break if this.label_applies?(@list[@index].parameters[0])
        end

        @index += 1

      end

    end

    # Branch by command code
    return true if @list[@index].code == 108
    return true if @list[@index].code == 509
    send("command_"+@list[@index].code.to_s)
    
  end
  #--------------------------------------------------------------------------
  # * End Event
  #--------------------------------------------------------------------------
  def command_end

    # Fix for going into battle mid event
    # Cut this or something, change all maps here to $scene.map?
    if $map.events[@event_id] == nil
      @list = nil
      return
    end

    # Clear list of event commands
    @list = nil
    # If main map event and event ID are valid
    if @main and @event_id > 0
      # Unlock event
      $map.events[@event_id].unlock
    end

    # Tell the even that it is stopping so it can mark second
    $map.events[@event_id].stop 

  end

  #--------------------------------------------------------------------------
  # * Command Skip
  #--------------------------------------------------------------------------
  def command_skip
    # Get indent
    indent = @list[@index].indent
    # Loop
    loop do
      # If next event command is at the same level as indent
      if @list[@index+1].indent == indent
        # Continue
        return true
      end
      # Advance index
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # * Get Character
  #     parameter : parameter
  #--------------------------------------------------------------------------
  def get_character(parameter)
    # Branch by parameter
    case parameter
    when -1  # player
      return $player
    when 0  # this event
      events = $map.events
      return events == nil ? nil : events[@event_id]
    else  # specific event
      events = $map.events
      return events == nil ? nil : events[parameter]
    end
  end

  #--------------------------------------------------------------------------
  # * Calculate Operated Value
  #     operation    : operation
  #     operand_type : operand type (0: invariable 1: variable)
  #     operand      : operand (number or variable ID)
  #--------------------------------------------------------------------------
  def operate_value(operation, operand_type, operand)
    # Get operand
    if operand_type == 0
      value = operand
    else
      value = $game_variables[operand]
    end
    # Reverse sign of integer if operation is [decrease]
    if operation == 1
      value = -value
    end
    # Return value
    return value
  end


    def next_event_code
    @list[@index+1].code
  end

    #--------------------------------------------------------------------------
  # * Show Text
  #--------------------------------------------------------------------------
  def command_101

    message = []
    message.push(@list[@index].parameters[0])
    while next_event_code == 401
      @index += 1
      message.push(@list[@index].parameters[0])
    end

    message = message.join(' ')

    # If there is a choice next, add it
    while next_event_code == 101 && @list[@index+1].parameters[0].include?("@")
      @index+=1
      $scene.hud.message.add_choice(@list[@index].parameters[0])
    end

    $scene.hud.message.start(message)

    # If vn mode
    
    #$scene.hud.message.start_vn(message)
    
    # Return mouse to default cursor
    #$mouse.set_cursor('Default')
    
    # Continue
    return true

  end

  #--------------------------------------------------------------------------
  # * Wait
  #--------------------------------------------------------------------------
  def command_106
    @wait_count = @parameters[0]
    return true
  end

  #--------------------------------------------------------------------------
  # * Conditional Branch
  #--------------------------------------------------------------------------
  def command_111
    
    result = eval(@parameters[1])
    return true if result
  
    # Skip it
    @branch[@list[@index].indent] = result
    return command_skip
  
  end
  #--------------------------------------------------------------------------
  # * Else
  #--------------------------------------------------------------------------
  def command_411
    # If determinant results are false
    if @branch[@list[@index].indent] == false
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the conditions: command skip
    return command_skip
  end
 
  #--------------------------------------------------------------------------
  # * Exit Event Processing
  #--------------------------------------------------------------------------
  def command_115
    command_end
    return true
  end

  def command_117
    # Get common event
    common_event = $data.commons[@parameters[0]]
    # If common event is valid
    if common_event != nil
      # Make child interpreter
      @child_interpreter = Interpreter.new(@depth + 1)
      @child_interpreter.setup(common_event.list, @event_id)
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Label
  #--------------------------------------------------------------------------
  def command_118
    return true
  end

  #--------------------------------------------------------------------------
  # * Jump to Label
  #--------------------------------------------------------------------------
  def command_119
    # Get label name
    label_name = @parameters[0]
    # Initialize temporary variables
    temp_index = 0
    # Loop
    loop do

      # If a fitting label was not found
      return true if temp_index >= @list.size-1

      # If this event command is a designated label name
      if @list[temp_index].code == 118 and
         @list[temp_index].parameters[0] == label_name
        # Update index
        @index = temp_index
        # Continue
        return true
      end
      # Advance index
      temp_index += 1
    end
  end

  #--------------------------------------------------------------------------
  # * Transfer Player
  #--------------------------------------------------------------------------
  def command_201

    # If transferring player, showing message, or processing transition
    return false if $player.transferring || $scene.busy?
    
    # If appointment method is [direct appointment]
    $player.queue_xfer(@parameters[1],@parameters[2],@parameters[3],@parameters[4])
    
    # Advance index
    @index += 1

    # If fade is set <---- CUT
    # if @parameters[5] == 0
    #   # Prepare for transition
    #   Graphics.freeze
    #   # Set transition processing flag
    #   $game_temp.transition_processing = true
    #   $game_temp.transition_name = ""
    # end

    # End
    return false
  end

  #--------------------------------------------------------------------------
  # * Set Event Location
  #--------------------------------------------------------------------------
  def command_202

    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # If appointment method is [direct appointment]
    if @parameters[1] == 0
      # Set character position
      character.moveto(@parameters[2], @parameters[3])
    # If appointment method is [appoint with variables]
    elsif @parameters[1] == 1
      # Set character position
      character.moveto($game_variables[@parameters[2]],
        $game_variables[@parameters[3]])
    # If appointment method is [exchange with another event]
    else
      old_x = character.x
      old_y = character.y
      character2 = get_character(@parameters[2])
      if character2 != nil
        character.moveto(character2.x, character2.y)
        character2.moveto(old_x, old_y)
      end
    end
    # Set character direction
    case @parameters[4]
      when 8  # up
        character.turn_up
      when 6  # right
        character.turn_right
      when 2  # down
        character.turn_down
      when 4  # left
        character.turn_left
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Map Settings
  #--------------------------------------------------------------------------
  def command_204
    case @parameters[0]
    when 0  # panorama
      $game_map.panorama_name = @parameters[1]
      $game_map.panorama_hue = @parameters[2]
    when 1  # fog
      $game_map.fog_name = @parameters[1]
      $game_map.fog_hue = @parameters[2]
      $game_map.fog_opacity = @parameters[3]
      $game_map.fog_blend_type = @parameters[4]
      $game_map.fog_zoom = @parameters[5]
      $game_map.fog_sx = @parameters[6]
      $game_map.fog_sy = @parameters[7]
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Fog Opacity
  #--------------------------------------------------------------------------
  def command_206
    # Start opacity level change
    $game_map.start_fog_opacity_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Show Animation
  #--------------------------------------------------------------------------
  def command_207
    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # Set animation ID
    character.animation_id = @parameters[1]
    # Continue
    return true

  end
  #--------------------------------------------------------------------------
  # * Change Transparent Flag
  #--------------------------------------------------------------------------
  def command_208
    $game_player.transparent = (@parameters[0] == 0)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Move Route
  #--------------------------------------------------------------------------
  def command_209
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    return true if character == nil

    # Force move route - pushes on top of auto movers
    character.force_move_route(@parameters[1])
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Wait for Move's Completion
  #--------------------------------------------------------------------------
  def command_210
    @move_route_waiting = true
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Change Screen Color Tone
  #--------------------------------------------------------------------------
  def command_223
    $game_screen.start_tone_change(@parameters[0], @parameters[1] * 2)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Weather Effects
  #--------------------------------------------------------------------------
  def command_236
    # Set Weather Effects
    $game_screen.weather(@parameters[0], @parameters[1], @parameters[2])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Play BGM
  #--------------------------------------------------------------------------
  def command_241
    # Play BGM
    $game_system.bgm_play(@parameters[0])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Fade Out BGM
  #--------------------------------------------------------------------------
  def command_242
    # Fade out BGM
    $game_system.bgm_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play BGS
  #--------------------------------------------------------------------------
  def command_245
    # Play BGS
    $game_system.bgs_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Fade Out BGS
  #--------------------------------------------------------------------------
  def command_246
    # Fade out BGS
    $game_system.bgs_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Memorize BGM/BGS
  #--------------------------------------------------------------------------
  def command_247
    # Memorize BGM/BGS
    $game_system.bgm_memorize
    $game_system.bgs_memorize
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Restore BGM/BGS
  #--------------------------------------------------------------------------
  def command_248
    # Restore BGM/BGS
    $game_system.bgm_restore
    $game_system.bgs_restore
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play ME
  #--------------------------------------------------------------------------
  def command_249
    # Play ME
    $game_system.me_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play SE
  #--------------------------------------------------------------------------
  def command_250
    $audio.play_se(@parameters[0])
    return true
  end
  #--------------------------------------------------------------------------
  # * Stop SE
  #--------------------------------------------------------------------------
  def command_251
    # Stop SE
    Audio.se_stop
    # Continue
    return true
  end


  #--------------------------------------------------------------------------
  # * Shop Processing
  #--------------------------------------------------------------------------
  def command_302

    # Set shop calling flag
    $game_temp.shop_calling = true
    # Set goods list on new item
    $game_temp.shop_goods = [@parameters]
    # Loop
    loop do
      # Advance index
      @index += 1
      # If next event command has shop on second line or after
      if @list[@index].code == 605
        # Add goods list to new item
        $game_temp.shop_goods.push(@list[@index].parameters)
      # If event command does not have shop on second line or after
      else
        # End
        return false
      end
    end
  end


    #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    # Set first line to script
    script = @list[@index].parameters[0] + "\n"
    # Loop
    loop do
      # If next event command is second line of script or after
      if @list[@index + 1].code == 655
        # Add second line or after to script
        script += @list[@index + 1].parameters[0] + "\n"
      # If event command is not second line or after
      else
        # Abort loop
        break
      end
      # Advance index
      @index += 1
    end
    
    # Evaluation
    result = eval(script)

    return true

  rescue Exception => e

    line = e.message.split(":")[1].to_i      
    log_scr e.inspect.split(":in `")[0]
    log_scr e.inspect.split(":in `")[1]

    lc = 0
      script.split("\n").each{ |s|
        if lc == line
          s = "---> "+s
        end
        log_scr s
        lc+=1
      }

    # Continue
    return true
     
  end

end
"³)#==============================================================================
# ** Game_Map
#==============================================================================

class Game_Map

  # Keep the zone? 
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :tileset  
  
  # Camera offsets
  attr_accessor :cam_ox, :cam_oy


  attr_accessor :need_refresh             # refresh request flag

  attr_reader   :map_name                 # name of the map

  attr_reader :interpreter

  attr_reader :id

  # Try to cut this
  attr_reader :events

  attr_reader :map

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @interpreter = Interpreter.new(0,true)

    @cam_target = $player
    @cam_xy = [0,0]
    @cam_snap = false
    @cam_ox = 0
    @cam_oy = 0#-16
    @cam_speed = 'mid'

    #self.do(pingpong("cam_ox",50,70,:quad_in_out))
    #self.do(pingpong("cam_oy",-70,350,:quad_in_out))

    @namecache = {}
  end

  def cam_speed
    case @cam_speed
      when 'slow'
        return 10
      when 'mid'
        return 20
      when 'fast'
        return 30
    end
    return 50
  end

  def name
    return @map_name
  end
  
  #--------------------------------------------------------------------------
  # * Setup
  #     map_id : map ID
  #--------------------------------------------------------------------------
  def setup(id)
    
    # Put map ID in @map_id memory
    @id = id
    @namecache = {} # reset each map
    
    # Load map from file and set @map
    @map = load_data(sprintf("Data/Map%03d.rxdata", @id))
    @map_name = $data.mapinfos[id].name 
        
    # Hold onto the tileset
    @tileset = $data.tilesets[@map.tileset_id]        
    @passages = @tileset.passages 
    
    # Initialize displayed coordinates
    @display_x = 0
    @display_y = 0
    @target = $player
    
    @need_refresh = false
    

        # Disregard if battle map? or use battle zone?
    # Or various battle zones?

    # What is the zone
    autoplay = false
    newzone = get_zone(@id)
    newzone = "@" + newzone.split("@")[1]
    if newzone != @zone.id

      @zone = $data.zones[newzone]

      log_info "Changing Zone: #{newzone}"


      if @zone.id == "@clear"
        $audio.bgm_stop
        $audio.bgs_stop
        autoplay = true
      elsif @zone.id == "@nil" || @zone == nil
        # Don't change anything
        # Load the map music if you like
        autoplay = true
      else

        
        $audio.change_mode(@zone.reverb)

        # Init tints and that
        $scene.change_weather(@zone.weather)
        $scene.change_fog(@zone.fog)
        $scene.change_tint(@zone.tint)
        $scene.change_panoramas(@zone.panoramas)

        # Prep enemies for this zone
        $battle.change_enemies(@zone.enemies)

      end

    end
    
    # If a null or clear zone
    if autoplay
      $audio.bgm_play(@map.bgm) if @map.autoplay_bgm
      $audio.bgs_play(@map.bgs) if @map.autoplay_bgs
    end

        # Set map event data
    @events = {}
    @map.events.keys.each{ |i|
      @events[i] = Game_Event.new(@map.events[i])
    }

  end

  def setup_audio

    # Fadeout previous
    

    # Play music from the zone
    $audio.music(@zone.music)
    $audio.atmosphere(@zone.atmosphere)

  end

  def dispose

  end
  
  def display_x
    return @display_x + (@cam_ox*4)
  end

  def display_y
    return @display_y + (@cam_oy*4)
  end

  #--------------------------------------------------------------------------
  # * Get Tileset ID
  #--------------------------------------------------------------------------
  def tileset_id() return @map.tileset_id end
  def width() return @map.width end
  def height() return @map.height end
  def data() return @map.data end

  #--------------------------------------------------------------------------
  # * Camera
  #--------------------------------------------------------------------------
  def camera_to(ev,spd=0.15)
    @cam_target = ev
    @cam_snap = false
    @cam_speed = spd
  end

  def camera_xy(x,y,spd=0.15)
    @cam_xy = [x,y]
    @cam_target = nil
    @cam_snap = false
    @cam_speed = spd
  end

  def camera_snap
    @cam_snap = true
  end

  def refresh
    @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    update_camera

    @interpreter.update
    return if $scene.is_a?(Scene_Menu)

    # Anti lag here
    @events.values.each{ |e| e.update }

    # Refresh map if necessary
    if @need_refresh
      @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

    # Mouse update
    # Check what's under, change cursor etc etc, maybe not every frame? only if moving?
    update_mouse

    

  end

  def update_mouse

    # Mouse position
    mx, my = *$mouse.grid

    # What event is there
    if event_at(mx,my) != nil

      ev = event_at(mx,my)
      case ev.icon

        when 'S'
          $mouse.change_cursor('Speak')
        when 'I'
          $mouse.change_cursor('Inspect')
        when 'T'
          $mouse.change_cursor('Transfer')
        else
          $mouse.change_cursor('Default')

      end

    else
      if $map.passable?(mx,my,$player.direction)
        $mouse.change_cursor('Default')
      else
        $mouse.change_cursor('Battle')
      end
    end

  end

  def update_camera

    if @cam_target != nil
      @target_x = @cam_target.real_x- (128 * 9.5)
      @target_y = @cam_target.real_y- (128 * 7)
    else
      @target_x = @cam_xy[0] * 64
      @target_y = @cam_xy[1] * 64
    end

    # if @target_x != @display_x
    #   @display_x += [(@target_x-@display_x) * 0.15,cam_speed].min
    # end

    # if @target_y != @display_y
    #   @display_y += [(@target_y-@display_y) * 0.15,cam_speed].min
    # end

    # calc dx and dx
    dx = @target_x - @display_x
    dy = @target_y - @display_y

    dist = dx+dy

    # calc ratio
    if (dx - dy).abs < 5
      r = 0.5
    else
      if dy == 0
        r = 1
      else
        r = dx/dy
      end
    end

    # Limit
    dist *= 0.15
    dist = 40 if dist > 40

    # move by speed
    sx = dist * r 
    sy = dist * (1-r)

    @display_x += sx
    @display_y += sy


    if (dx) < 5 && (dx) < 5
      #@cam_snap = true
      @display_x = @target_x
      @display_y = @target_y
    end

    # if @cam_snap
       @display_x = @target_x
       @display_y = @target_y
    # end


    # Limit cam to screen
    @display_x = 0 if @display_x < 0
    @display_y = 0 if @display_y < 0

    w = ($map.width * 32) - $game.width
    h = ($map.height * 32) - $game.height

    #@display_x = w if @display_x > w
    #@display_y = w if @display_y > h

  end
  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil)

    return false unless valid?(x, y)

    # Change direction (0,2,4,6,8,10) to obstacle bit (0,1,2,4,8,0)
    bit = (1 << (d / 2 - 1)) & 0x0f

    # Loop in all events
    events.values.each{ |e| 
      if e != self_event and e.at?(x,y)
         return false if !(e.through || e.above || e.below)
      end
    }

    # Loop searches in order from top of layer
    [2, 1, 0].each{ |i|

      tile_id = data[x, y, i]

      # If obstacle bit is set
      return false if @passages[tile_id] & bit != 0
        
      # If obstacle bit is set in all directions
      return false if @passages[tile_id] & 0x0f == 0x0f
        
      # If priorities other than that are 0
      return true if @tileset.priorities[tile_id] == 0

    }

    # passable
    return true

  end

  #--------------------------------------------------------------------------
  # * Determine Thicket
  #--------------------------------------------------------------------------
  def bush?(x, y) return false
   ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x40 == 0x40 }.empty? end
  def counter?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x80 == 0x80 }.empty? end
  def terrain_tag(x, y)

    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return 0
        elsif tile_id > 0   # @terrain_tags[tile_id] > 0
          return @tileset.terrain_tags[tile_id]
        end
      end
    end
    return 0
  
  end

  #--------------------------------------------------------------------------
  # * Event At
  #--------------------------------------------------------------------------
  def valid?(x, y) x >= 0 and x < width and y >= 0 and y < height end
  def event_at(x, y) @events.values.find{ |e| e.at?(x,y) } end
  def events_at(x, y) @events.values.select{ |e| e.at?(x,y) } end
  def lowest_event_at(x, y) nil end #events_at(x,y).min_by{ |e| e.y } end
  

  def starting_events() @events.values.select{ |e| e.starting } end

  def event_by_name(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.name == name }
    @namecache[name] = ev
    return ev
  end

  def event_by_evname(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.event.name == name }
    @namecache[name] = ev
    return ev
  end

  #--------------------------------------------------------------------------
  # Find the zone name for this map
  #--------------------------------------------------------------------------
  def get_zone(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return map_zone_or_nil(id)
  end

  # Return zone name, parent map or @nil if top map
  def map_zone_or_nil(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return '@nil' if $data.mapinfos[id].parent_id == 0
    return map_zone_or_nil($data.mapinfos[id].parent_id)
  end

end"Ë
class Moblin

	def initialize(ev,delay)

		@ev = ev
		@delay = delay
		@next = 1

	end

	def update

		@next -= 1
		if @next <= 0

			@next = @delay
			@ev.start

		end

	end

end"(#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. Its functions include event starting
#  determinants and map scrolling. Refer to "$game_player" for the one
#  instance of this class.
#==============================================================================

class Game_Player < Game_Character

  attr_accessor :transferring      # player place movement flag
  attr_accessor :trans_type 

  def initialize
    super
    looklike("boy")
    @transferring = false
    @xfer_data = nil
    @trans_type = :cross
    @static = false
  end

  def transfer(map,x,y,dir)
    @transferring = true
    @xfer_data = [map,x,y,dir]
  end

  def transfer_to(map,target,after=nil)
    @transferring = true
    @xfer_data = [map,target,after]
  end

  def name
    return "Player"
  end

  def looklike(char)
    self.character_name = "Player/#{char}"
  end

  def static
    @static = true
  end

  #--------------------------------------------------------------------------
  # * Passable Determinants
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    if DEBUG and Input.press?(Input::CTRL)
      return true
    end
    super
  end

  #--------------------------------------------------------------------------
  # * Same Position Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.collide?(@x,@y) and triggers.include?(event.trigger)
      #if event.x == @x and event.y == @y and triggers.include?(event.trigger)
        # If starting determinant is same position event (other than jumping)
        if not event.jumping? and event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Front Envent Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end

    # Calculate front event coordinates
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(new_x,new_y) &&
         triggers.include?(event.trigger) and event.list.size > 1


        # If starting determinant is front event (other than jumping)
        if !event.jumping? and !event.over_trigger?
          event.start
          result = true
        end
      end
    end
    # If fitting event is not found

    # COUNTER CHECK

    if result == false

      # If front tile is a counter
      if $map.counter?(new_x, new_y)
        # Calculate 1 tile inside coordinates
        new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
        new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
        # All event loops
        for event in $map.events.values
          # If event coordinates and triggers are consistent
          if event.x == new_x and event.y == new_y and
             triggers.include?(event.trigger) and event.list.size > 1
            # If starting determinant is front event (other than jumping)
            if not event.jumping? and not event.over_trigger?
              event.start
              result = true
            end
          end
        end
      end
    end

    return result
  end

  #--------------------------------------------------------------------------
  # * Touch Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?
      
    result = false

    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(x,y) and [1,2].include?(event.trigger)
        # If starting determinant is front event (other than jumping)
        if not event.jumping? and not event.over_trigger?
          if event.trigger == 2
            start_battle
            return true
          else
            event.start
            result = true
          end
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    return if @static

    return super if @move_route_forcing
    return super(true) if ($scene.busy?) || $debug.busy? # Still finish turn anim
    return super(true) if $map.interpreter.running? # Still finish turn anim
    

    transfer_player if @transferring 

    # Unless Interpretter Running, Forcing a Route or Message Showing

    if $input.click?

        # Gets Mouse X & Y
        mx, my = *$mouse.grid

        $scene.add_spark('click',$mouse.x+($map.display_x/4)+3,$mouse.y+($map.display_y/4)+5)
        $audio.sys('walkto',0.7)
        
        
        # Turn Character in direction
        #turn_toward_pos(mx,my)
        
        # Run Pathfinding
        @event_at_path = $map.event_at(mx, my)
        @event_at_path = nil if @event_at_path && @event_at_path.through
        if @event_at_path == nil
          find_path(mx, my)
          #@eventarray = @runpath ? $map.events_at(mx, my) : nil
        else

          dx = @x - @event_at_path.x
          dy = @y - @event_at_path.y

          if dx.abs > dy.abs
            if dx > 0
              find_path(@event_at_path.x+1, @event_at_path.y)
              @turn_after_path = 'l'
            else
              find_path(@event_at_path.x-1, @event_at_path.y)
              @turn_after_path = 'r'
            end
          else
            if dy > 0
              find_path(@event_at_path.x, @event_at_path.y+1)
              @turn_after_path = 'u'
            else
              find_path(@event_at_path.x, @event_at_path.y-1)
              @turn_after_path = 'd'
            end
          end

        end
                
      end
    
    if @move_route_forcing == true
      clear_path
      @event_at_path = nil
    end

    # Clear path if any direction keys pressed
    clear_path if $input.dir4 != 0
    
    # Remember whether or not moving in local variables
    last_moving = moving?
    # If moving, event running, move route forcing, and message window
    # display are all not occurring
    unless moving? || $map.interpreter.running? || @move_route_forcing
      case $input.dir4
        when 2; move_down
        when 4; move_left
        when 6; move_right
        when 8; move_up
      end
    end

    # Remember coordinates in local variables
    last_real_x = @real_x
    last_real_y = @real_y

    super
   
    # If not moving
    unless moving?
      
      # If player was moving last time
      if last_moving
        # Event determinant is via touch of same position event
        result = check_event_trigger_here([1,2])
      end

      # If C button was pressed
      if $input.action?
        # Same position and front event determinant
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
      end

      unless @runpath == true
        if @event_at_path != nil
          case @turn_after_path
            when 'd'
              @direction = 2
            when 'l'
              @direction = 4
            when 'r'
              @direction = 6
            when 'u'
              @direction = 8
          end
          @event_at_path.start
          @event_at_path = nil
        end
      end

    end

  end

  #--------------------------------------------------------------------------
  # * Teleport the Player
  #--------------------------------------------------------------------------
  def transfer_player

    Graphics.freeze
   
    @transferring = false
    $player.clear_path

    # Map to teleport to 
    if $map.id != @xfer_data[0]
      $map.setup(@xfer_data[0])      
    end

      ev = gev(@xfer_data[1])
      if @xfer_data[2] != nil
        case @xfer_data[2]
          when 'd'
            @direction = 2
          when 'l'
            @direction = 4
          when 'r'
            @direction = 6
          when 'u'
            @direction = 8
        end
      end
      dx = 0
      dy = 0
      dx = 1 if @direction == 6
      dx = -1 if @direction == 4
      dy = 1 if @direction == 2
      dy = -1 if @direction == 8
      $player.moveto(ev.x+dx,ev.y+dy)
      #$player.direction = @xfer_data[3]

      $player.straighten  

      $game.update

      # If next zone is different, start fading?
      $audio.fadeout

      

      case @trans_type

        when :cross
          Graphics.transition(16)

        when :cave
          $scene.overlay.opacity = 255
          Graphics.transition(45,'Graphics/Transitions/cave') 
          Graphics.freeze
          $scene.overlay.opacity = 0
          Graphics.transition(45,'Graphics/Transitions/cave_inv')   

        when :fade
          $scene.overlay.opacity = 255
          Graphics.transition(45) 
          Graphics.freeze
          $scene.overlay.opacity = 0
          Graphics.transition(45)    

      end



      # Now do the zone etc
      $map.setup_audio

    #end

    # AUTO SAVING

    # autosave your game (but not on the ending map)
   # if !ENDING_MAPS.include?($game_map.map_id)
   #   save = Scene_Save.new(1)
   #   save.autosave      
   # end
    
  end

end
"
class Game_Battle

  attr_accessor :map, :weather

  attr_reader :enemies
  attr_reader :enemy_types
  attr_reader :enemy_list

	def initialize
    @enemy_types = []
    @enemy_list = []
		@enemies = []
    @props = []
    @actor_index = 0

    @map = 26 #65 #26
	end

  # Enemies for this zone from zone data
  def change_enemies(enemies)
    @enemy_types = enemies.split("\n")
  end

  def add(enemy)
    battler = Game_Battler.new
    battler.init_enemy(enemy)
    @enemy_list.push(enemy)
    @enemies.push(battler)
  end

  def start
    $game.push_scene(Scene_Battle.new)
  end

  def victory?
    return @enemies.select{ |e| !e.down? }.empty?
  end


  def build_attack_queue

    return ($party.active_battlers + @enemies).shuffle

  end

  def build_attack_plan(attacker)

    plan = Attack_Plan.new

    skill = $data.skills[attacker.skill_id]
    hits = calc_hits(skill)

    hits.times{ |t|

      round = Attack_Round.new
      round.anim_a = skill.anim_a
      round.anim_b = skill.anim_b
      round.skill = skill

      plan.add(round)
    }

    # Add followup attacks


    # Use up the item or mana for the skill used
    # Put it in the attack plan probably


    return plan

  end

  # Happens at the time of using the skill
  # Uses states applied etc realtime
  def build_attack_results(attacker,skill)

    results = []

    # Attack already has skill selected, and targets if scope requires
    targets = build_target_list(attacker,skill)

    # Calculate damage per target i suppose
    targets.each{ |t|

      result = Attack_Result.new

      result.target = t
      # Check damage effects

      dmg_base = 0
      dmg_mod = 0

      skill.effects.split("\n").each{ |effect|
        data = effect.split("=>")      
        case data[0]
          when 'dmg-base'
            dmg_base = data[1].to_i
          when 'dmg-mod'
            dmg_mod = data[1].to_f
          when 'state-add'
            result.state_add = data[1]
          when 'state-remove'
            result.state_remove = data[1]
          when 'transform'
            result.transform = data[1]
        end
      }

      # Build final damage
      result.damage = dmg_base + (attacker.str * dmg_mod)

      results.push(result)

    }

    return results    

  end

  def possible_targets(attacker)

    skill = $data.skills[attacker.skill_id]

    if skill.scope == 'one'
      return $battle.enemies
    elsif skill.scope == 'ally'
      return $party.active_battlers
    end

  end

  def build_target_list(attacker,skill)

    # Get scope, prepare targets, return list
    case skill.scope

      when 'one', 'ally', 'down'

        # Will be in attacker, already chosen
        targets = [attacker.target]

        # If the target is not attackable, do somethingelse
        # TODO TODO
        return targets

      when 'rand' # Single random target

        if attacker.is_actor?
          return [@enemies.select{ |b| b.attackable? }.sample]
        else
          return [$party.active.select{ |b| b.attackable? }.sample]
        end

      when 'two'

        # Random 2
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }.sample(2)
        else
          return $party.active.select{ |b| b.attackable? }.sample(2)
        end

      when 'three'

        # Random 3
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }.sample(3)
        else
          return $party.active.select{ |b| b.attackable? }.sample(3)
        end

      when 'all'

        # All enemy
        if attacker.is_actor?
          return @enemies.select{ |b| b.attackable? }
        else
          return $party.active.select{ |b| b.attackable? }
        end

      when 'party'

        # All allies
        if attacker.is_actor?
          return $party.active.select{ |b| b.attackable? }
        else          
          return @enemies.select{ |b| b.attackable? }
        end

      when 'self'

        return [attacker]

    end

    return []

  end

  def calc_hits(skill)
    hits = skill.hits
    if hits.include?("-")
      data = hits.split("-")
      low = data[0].to_i
      high = data[0].to_i
      return low + rand(hi-low)
    else
      return skill.hits.to_i
    end
  end



  def get_targetable(attacker)

    case $data.skills(attack.skill_id).scope

      when 'one'

      when 'ally'

      when 'down'

    end

  end

  
end"
# Menu state
# Hold cursor positions, current character etc etc etc

class MenuState

	attr_accessor :char
	attr_accessor :shop
	attr_accessor :grid_action # <- menu selection

	#attr_accessor :category
	#attr_accessor :tab

	def initialize
		@char = 'boy'
		@shop = []
	end

	def shop_init
		@shop = []
	end

	def shop_add(item)
		@shop.push(item)
	end

end"3 #==============================================================================
# ** Game_Party
#==============================================================================

class Game_Party

  attr_accessor :active                  # actors
  attr_accessor :reserve                  # reserve party

  attr_reader   :gold                     # amount of gold

  attr_accessor :all_actors

  attr_reader :leader

  attr_reader :items

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    $party = self

    # Create all actors    
    @actors = {}
    $data.actors.each{ |k,v| 
      battler = Game_Battler.new
      battler.init_actor(k)
      @actors[k] = battler 
    }    

    # Create actor array
    @active = []
    @reserve = []

    # Initialize amount of gold
    @gold = 0

    # Create amount in possession hash for items, weapons, and armor
    @items = {}
    @weapons = {}
    @armors = {}    

    # Hardcode Party Data
    init_party

  end

  #--------------------------------------------------------------------------
  # * Getting Maximum Level
  #--------------------------------------------------------------------------
  def max_level
    return @actors.max_by(&:level).level
  end

  def get(a)
    return actor_by_id(a)
  end

  def actor_by_id(actor)
    return @actors[actor]
  end

  def actor_by_index(idx)
    return @actors[@active[idx]]
  end

  def active_battlers
    return @active.map{ |a| @actors[a] }
  end

  #--------------------------------------------------------------------------
  # * Add an Actor
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def set_active(actor)

    # if @active.size < 4 and not @actors.include?(actor)
      
      @active.push(actor)

    # end
   # if !@active.include?(actor)
   #    @reserve.push(actor)
   #  end

  end

  def set_reserve(actor)
    @reserve.push(actor)
  end

  def back_to_pavillion(actor)
    @actors.delete(actor)
    @reserve.delete(actor)
  end


  def swap(a,b)
    return if a == b

    first = nil
    dta = a.split('.')
    if dta[0] == 'a'
      first = @active[dta[1].to_i]
    else
      first = @reserve[dta[1].to_i]
    end

    second = nil
    dta2 = b.split('.')
    if dta2[0] == 'a'
      second = @active[dta2[1].to_i]
    else
      second = @reserve[dta2[1].to_i]
    end

    # Put second in first
    if dta[0] == 'a'
      @active[dta[1].to_i] = second
    else
      @reserve[dta[1].to_i] = second
    end

    # Put first in second
    if dta2[0] == 'a'
      @active[dta2[1].to_i] = first
    else
      @reserve[dta2[1].to_i] = first
    end

    @active.compact!
    @reserve.compact!

  end


  def all
    return @active + @reserve
  end


  #--------------------------------------------------------------------------
  # * Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def add_item(id,n=1) 
    @items.has_key?(id) ? @items[id] += n : @items[id] = n
    @items.delete(id) if @items[id] <= 0 
    $map.need_refresh = true if $map
  end

  def lose_item(id,n=1) add_item(id,-n) end
  
  def item_number(id) return @items.has_key?(id) ? @items[id] : 0 end
  def has_item?(id) item_number(id) > 0 end


  def add_gold(n)
    @gold += n
    @gold = 0 if @gold < 0
    $map.need_refresh = true
  end

  def item_list
    items = []
    @items.each{ |k,v|
      items.push(k) if v > 0
    }
    return items
  end

  def battle_item_list
    return ['covey','cheese','mir-wood']
  end


  #--------------------------------------------------------------------------
  # * Determine Everyone is Dead
  #--------------------------------------------------------------------------
  def defeated?
    return @active.select{ |a| !@actors[a].down? }.empty?
  end

  #--------------------------------------------------------------------------
  # * Slip Damage Check (for map)
  #--------------------------------------------------------------------------
  def check_map_slip_damage
    for actor in @active + @reserve
      if actor.hp > 0 and actor.slip_damage?
        actor.hp -= [actor.maxhp / 100, 1].max
        if actor.hp == 0
          $audio.play_se($data_system.actor_collapse_se)
        end
        $map.world.start_flash(Color.new(255,0,0,128), 4)
        $temp.gameover = $party.all_dead?
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # â check if actor is in party
  #--------------------------------------------------------------------------  
  def has_member?(guy)
    return (@active + @reserve).include?(guy)
  end

  #--------------------------------------------------------------------------
  # â check if all actors are 'normal' state
  #--------------------------------------------------------------------------  
  def all_normal
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        if (actor.states & ([1] + BAD_STATES)).size > 0 # non-shield status inflicted
          return false
        end
      end
    end
    
    return true
  end

  #--------------------------------------------------------------------------
  # â remove inflictions
  #--------------------------------------------------------------------------  
  def remove_inflictions()
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        for state in BAD_STATES
          actor.remove_state(state, true)
        end
      end
    end
  end

  #--------------------------------------------------------------------------
  # â Actor Lineup
  #   Provides a list of party members
  #-------------------------------------------------------------------------- 
  def actor_lineup()
    @lineup = []
    for i in 1..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil and !@lineup.include?(actor) && $game_player.is_present(actor.id)
        @lineup.push(actor)
      end
    end
  end


  #--------------------------------------------------------------------------
  # â Initialize Party Data
  #--------------------------------------------------------------------------

  def init_party

    @leader = 'boy'

    # -----------------------------------
    # Initial Party Members
    # -----------------------------------

    set_active("boy")
    set_active("ing")
    set_active("mys")
    set_active("rob")
    set_reserve("hib")
    set_reserve("row")
    set_reserve("phy")   
  
    # ----------------------------------
    # Initial Gear

    # Boyle
    @actors['boy'].equip('staff','boy-staff')
    @actors['boy'].equip('mid','boy-arm-s')

    # Ingrid
    @actors['ing'].equip('wand','ing-wep-s')
    @actors['ing'].equip('athame','ing-athame-s')
    @actors['ing'].equip('light','ing-arm-s')

    # Myst
    @actors['mys'].equip('claw1','mys-wep-s')
    @actors['mys'].equip('claw2','mys-wep-s')
    @actors['mys'].equip('light','mys-arm-s')

    # Robin
    @actors['rob'].equip('sword','rob-wep-s')
    @actors['rob'].equip('heavy','rob-arm-s')

    # Hiberu
    @actors['hib'].equip('book','hib-wep-s')
    @actors['hib'].equip('mid','hib-arm-s')
    # Give accessory

    # Rowen
    @actors['row'].equip('dagger','row-wep-s')
    @actors['row'].equip('light','row-arm-s')
    # Give extra gadget

    # Phye
    @actors['phy'].equip('staff','phy-sword')
    @actors['phy'].equip('heavy','phy-arm-s')
    # Give him helm


    # Initial skills per actor
    @actors["boy"].learn('fireburn')
    @actors["boy"].learn('flames')

    @actors["ing"].learn('xform-snake')

    item('boy-arm-s','s')
    item('hib-arm-s','s')

    

  end























        
end"5class Progress

	attr_accessor :quests, :complete

	def initialize
		@quests = []
		@complete = []
		@progress = 0
	end


	def add_quest(q)
		@quests.push(q)
		$map.need_refresh = true
		log_info("Quest Added: #{q}")
	end

	def end_quest(q)
		@quests.delete(q)
		@complete.push(q)
		$map.need_refresh = true
		log_info("Quest Ended: #{q}")
	end

	def quest_active?(q)
		return @quests.include?(q)
	end

	def quest_complete?(q)
		return @complete.include?(q)
	end

	def progress(pro)
		@progress= $data.progress[pro]
		$map.need_refresh = true
		log_info("Progress Set: #{pro}")
	end

	def get_progress
		return @progress
	end

	def progress?(progress)
	    return false if !$data.progress.include?(progress)
		return @progress >= $data.progress[progress]
	end

	def beyond?(progress)
		return false if !$data.progress.include?(progress)
		return @progress > $data.progress[progress]
	end

	def before?(progress)
		return false if !$data.progress.include?(progress)
		return @progress < $data.progress[progress]
	end

end"class State

	def initialize

		@flags = []
		@vars = {}

		# Event modifiers
		@states = {} # Event states
		@locs = {}
		@deleted = []
		@disabled = []

		# Menu indexes?

	end

	def flag(f)
		@flags.push(f) if !@flags.include?(f)
		$map.need_refresh = true
	end

	def unflag(f)
		@flags.delete(f)
		$map.need_refresh = true
	end

	def flag?(f)
		return @flags.include?(f)
	end

	def var(v,a)
		if @vars.has_key?(v)
			@vars[v] += a
		else
			@vars[v] = a
		end
		$map.need_refresh = true
	end

	def unvar(v,a)
		if @vars.has_key?(v)
			@vars[v] -= a
		else
			@vars[v] = -a
		end
		$map.need_refresh = true
	end

	def var?(v,t)
		return false if !@vars.has_key?(v)
		return @vars[v] >= t
	end

	def state(e,s)
		@states[[$map.id,e,s]] = true
		$map.need_refresh = true
	end

	def unstate(e,s)
		@states[[$map.id,e,s]] = false
		$map.need_refresh = true
	end

	def state?(e,s)
		return false if !@states.has_key?([$map.id,e,s])
		return @states[[$map.id,e,s]]
	end

	def loc(e)
		@locs[[$map.id,e]] = [e.x,e.y]
	end
	def nloc(e)

	end

	def loc?(e)
		return @locs.has_key?([$map.id,e])			
	end

	def getloc(e)
		return @locs[[$map.id,e]]
	end



	def delete(e)
		@deleted.push([$map.id,e])
	end

	def delete?(e)
		return @deleted.include?([$map.id,e])
	end

	def disable(e)
		@disabled.push([$map.id,e])
	end

	def disable?(e)
		return @disabled.include?([$map.id,e])
	end

	def enable(e)
		@disabled.delete([$map.id,e])
	end

end
"±#==============================================================================
# ** Scene_Base
#==============================================================================

class Scene_Base

  attr_reader :map, :player

  attr_reader :panorama, :tilemap
  attr_reader :weather, :fog, :overlay

  attr_reader :hud

  attr_reader :debug

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    $scene = self

    # Prep model
    @map = Game_Map.new
    @player = Game_Player.new

    # Make viewports - Also in the scene
    @vp_under = Viewport.new(0,0,$game.width,$game.height)
    @vp_under.z = 0
    @vp_main = Viewport.new(0,0,$game.width,$game.height)   
    @vp_main.z = 1000
    @vp_weather = Viewport.new(0,0,$game.width,$game.height)
    @vp_weather.z = 1999
    @vp_over = Viewport.new(0,0,$game.width,$game.height)
    @vp_over.z = 2000
    @vp_ui = Viewport.new(0,0,$game.width,$game.height)
    @vp_ui.z = 3000
   
    # Make tilemap
    @panoramas = []
    @tilemap = MapWrap.new(@vp_main)
    
    @characters = []  
    @sparks = []
    @pops = []

    # weather in map data
    @weather = nil#Weather.new(@vp_over)
    @fog = Plane.new(@vp_over)

    # Put this where?
    @overlay = Sprite.new(@vp_over)
    @overlay.bitmap = Bitmap.new($game.width,$game.height)
    @overlay.bitmap.fill(Color.new(0,0,0))
    @overlay.opacity = 0
    @overlay.z = 999
    
    # UI
    @hud = nil # Define in sub
            
  end
  
  def terminate

    # Dispose of things
    @panoramas.each{ |s| s.dispose }
    @tilemap.dispose
    @characters.each{ |s| s.dispose }
    @sparks.each{ |s| s.dispose }
    @pops.each{ |s| s.dispose }
    @weather.dispose if @eather
    @fog.dispose
    @overlay.dispose
    @hud.dispose
    
    # Dispose of viewports
    @vp_under.dispose
    @vp_main.dispose   
    @vp_over.dispose
    @vp_ui.dispose

    #@map.dispose
    #@player.dispose

  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update

    return if $scene.is_a?(Scene_Menu)

    # Model update
    @map.update      
    return if $scene.is_a?(Scene_Menu)
    @player.update

    # Elements update
    @panoramas.each{ |p| p.update } # With animated position
    @tilemap.ox = @map.display_x / 4
    @tilemap.oy = @map.display_y / 4
    @tilemap.update
    @characters.each{ |s| s.update }
    @sparks.each{ |s| 
      # Mouse click needs to follow, others do not
      # Maybe just do all
      s.ox = @map.display_x/4
      s.oy = @map.display_y/4
      s.update 
    }
    @pops.each{ |s| 
      #s.ox = @map.display_x/4
      #s.oy = @map.display_y/4
      s.update 
    }
    @weather.update if @weather
    #@fog.update
    #@overlay.update
    @hud.update

    # Try to delete anything
    @sparks.delete_if{ |s| s.done? }
    @pops.delete_if{ |s| s.done? }

    # Could delete erased characters here

    @vp_weather.ox = $map.display_x / 4
    @vp_weather.oy = $map.display_y / 4


    # Rebuild the map
    reload_map if @map.id != @tilemap.map_id
    
  end

  def reload_map
    
    @tilemap.refresh(@map)

    @characters.each{ |s| s.dispose }
    @characters = []

    @map.events.keys.sort.each{ |i|
      sprite = Sprite_Character.new(@vp_main, @map.events[i])
      @characters.push(sprite)
    }

    @characters.push(Sprite_Character.new(@vp_main, @player))

  end

  def change_tint(tint)

  end

  def change_weather(weather)
    @weather.dispose if @weather
    case weather
      when 'dark-dots'
        @weather = Weather_DarkDots.new(@vp_weather)
    end
  end

  def change_fog(fog)

  end

  def change_panoramas(panos)

    @panoramas.each{ |p| p.dispose }
    @panoramas.clear

   

    data = panos.split("\n")

    data.each{ |pano|

       panorama = Panorama.new(@vp_under)

      # Any extra data
      dta = pano.split(" | ")

      if dta.count > 1
        dta.each_index{ |i|
          next if i == 0
          d = dta[i].split("=>")

          case d[0]
            when 'ax'; panorama.att_x = d[1].to_f
            when 'ay'; panorama.att_y = d[1].to_f
            when 'sx'; panorama.spd_x = d[1].to_f
            when 'sy'; panorama.spd_y = d[1].to_f
            when 'ox'; panorama.start_x = d[1].to_f
            when 'oy'; panorama.start_y = d[1].to_f
            when 'px'; panorama.pad_x = d[1].to_f
            when 'py'; panorama.pad_y = d[1].to_f
            when 'r'; panorama.repeat = d[1].to_b

          end

        }
      end

      
      #pano.z = -1000
      panorama.bitmap = $cache.panorama(dta[0])
      @panoramas.push(panorama)

    }

  end

  def add_spark(fx,x,y,vp=@vp_main) # might want custom vp

    sprk = Spark.new(fx,x,y,@vp_main)
    @sparks.push(sprk)
    return sprk

  end

  def add_icon(ic,x,y,ein,eout)

    ico = Pop.new(ein,eout,@vp_over)
    ico.icon = ic
    ico.move(x,y)
    @pops.push(ico) # Could combine these with spark

  end

  def add_num(nm,x,y,ein,eout)

    ico = Pop.new(ein,eout,@vp_over)
    ico.number = nm
    ico.move(x,y)
    @pops.push(ico) # Could combine these with spark

  end

  def pop_dmg(target,amount)
    #ev = gev(target)
    pop = Popper.new(@vp_over)
    pop.value = amount #- amount/10
    pop.x = target.screen_x-200-20
    pop.y = target.screen_y-40-12+45
    @pops.push(pop)

    pop.opacity = 1
    pop.do(go("value",amount,700,:quad_in_out))
    pop.do(sequence(go("opacity",254,500),go("opacity",0,1500),go("opacity",-255,500)))
    pop.do(sequence(go("y",-30,500,:quad_in_out),go("y",-20,1500),go("y",-30,500,:quad_in_out)))


  end

end
"#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Battle < Scene_Base

  attr_accessor :phase

  def initialize
    super

    Graphics.freeze

    @phase = :intro_init
    @wait_frames = 0
    @active_battler = nil

    @map.setup($battle.map)
    @tilemap.refresh(@map)

    # Could put the scrolling into battle in with this
    # Char screenx comes from this, perhaps $scene.map
   
    @player.moveto(0,0)
    @player.static
    @map.camera_to(@player)
    #@map.camera_xy(5,15)
    #@map.cam_oy = 150
    #@map.do(go("cam_oy",-250,2500,:quad_in_out))    


    # Create Hud Elements
    @hud = BattleHud.new(@vp_ui)
    @actor_cmd = ActorCmd.new(@vp_ui)
    @skill_cmd = SkillCmd.new(@vp_ui)
    @item_cmd = ItemCmd.new(@vp_ui)
    @target_cmd = TargetCmd.new(@vp_ui)

    #$map = @map
    #$player = @player

    # Find battler events
    [0,1,2,3].each{ |i| 
      ev = @map.event_by_evname("A.#{i}")
      next if ev == nil
      act = $party.actor_by_index(i).id
      ev.character_name = "Player/#{act}-idle"
      ev.pattern = rand(4)
      #ev.direction = 2
      ev.step_anime = true
      if $party.active.count > i
        $party.actor_by_index(i).ev = ev
      end
    }
    [0,1,2,3,4].each{ |i| 
      ev = @map.event_by_evname("E.#{i}") 
      next if ev == nil
      if $battle.enemies.count > i
        $battle.enemies[i].ev = ev
        ev.character_name = "Monsters/#{$battle.enemy_list[i]}"
      end
    }

    # And the minion
    #@minion = @map.event_by_evname("MINION")
    #@minion.character_name = 'Player/minion-rat'
    #hide(@minion)


    reload_map

    sys('battlestart')
    #music("rivals",0.6)
        
    Graphics.transition(20,'Graphics/Transitions/trans') 
            
  end
  
  def terminate
    super  
  end

  def busy?
    return false
  end

  def wait(w)
    @wait_frames += w
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------

  def update

    super

    # Draw phase
    #@dbg_phase.bitmap.fill(Color.new(0,0,0))
    #@dbg_phase.bitmap.draw_text(10,0,150,30,@phase.to_s,0)

    update_phase

  end

  def update_phase

    $debug.track(self,"phase")

    # Wait count here
    if @wait_frames > 0
      @wait_frames -= 1
      return
    end

    case @phase

      # Introduction Phase
      when :intro_init
        phase_intro_init

      # Actor Phase
      when :actor_init
        phase_actor_init
      when :actor_action
        phase_actor_action
      when :actor_skill
        phase_actor_skill
      when :actor_item
        phase_actor_item
      when :actor_strategize
        phase_actor_strategize
      when :actor_target
        phase_actor_target
      when :actor_next
        phase_actor_next

      # Battle phase
      when :main_init
        phase_main_init
      when :main_prep
        phase_main_prep
      when :main_start
        phase_main_start
      when :main_attack
        phase_main_attack
      when :main_defend
        phase_main_defend
      when :main_transform
        phase_main_transform
      when :main_hit
        phase_main_hit
      when :main_crit
        phase_main_crit
      when :main_state
        phase_main_state
      when :main_fall
        phase_main_fall
      when :main_next
        phase_main_next
      when :main_end
        phase_main_end

      # Victory Phase
      when :victory_init
        phase_victory_init

    end

  end

end"[
class Scene_Battle

  def phase_intro_init
    @phase = :actor_init
  end

end"

class Scene_Battle

  #==============================================================================
  # ** actor_init
  #==============================================================================

  def phase_actor_init
    @actor_idx = -1  
    @phase = :actor_next
  end

  #==============================================================================
  # ** actor_action
  #==============================================================================

  def phase_actor_action

    @actor_cmd.update

    if $input.cancel? || $input.rclick?
      if @actor_idx != 0
        @actor_idx -= 1
        @active_battler = $party.actor_by_index(@actor_idx)
        @actor_cmd.setup(@active_battler)
      end
    end

    # Player command inputs section
    if $input.action? || $input.click?

      action = @actor_cmd.get_action
      @active_battler.action = action
      @actor_cmd.close

      case action 

        when "items"

          @item_cmd.setup
          @phase = :actor_item

        when "skills", "spells", "witchery", "team", "transform", "demon", "dream"

          @skill_cmd.setup(@active_battler)
          @phase = :actor_skill

        else

          @active_battler.skill_id = action
          @phase = :actor_strategize

      end

    end 

  end

  #==============================================================================
  # ** actor_skill
  #==============================================================================

  def phase_actor_skill

    @skill_cmd.update

    if $input.cancel? || $input.rclick?
      @actor_idx -= 1
      @phase = :actor_next
      @skill_cmd.close
    end

    if $input.action? || $input.click?
      @skill_cmd.close
      @active_battler.skill_id = @skill_cmd.get_skill
      @phase = :actor_strategize
    end

  end

  #==============================================================================
  # ** actor_item
  #==============================================================================

  def phase_actor_item

    @item_cmd.update

    if $input.cancel? || $input.rclick?
      @actor_idx -= 1
      @phase = :actor_next
      @item_cmd.close
    end

    if $input.action? || $input.click?
      @item_cmd.close
      @active_battler.item_id = @item_cmd.get_item
      @phase = :actor_strategize
    end

  end

  #==============================================================================
  # ** actor_strategize
  #==============================================================================

  def phase_actor_strategize

    # Get the skill or item

    # If single, targetable?
    if ["one","ally"].include?($data.skills[@active_battler.skill_id].scope)
      targets = $battle.possible_targets(@active_battler)
      @target_cmd.setup(targets)
      @phase = :actor_target      
    else
      @phase = :actor_next
    end

  end

  #==============================================================================
  # ** actor_target
  #==============================================================================

  def phase_actor_target

    @target_cmd.update

    if $input.cancel? || $input.rclick?
      @target_cmd.close
      @actor_idx -= 1
      @phase = :actor_next
    end

    if $input.action? || $input.click?
      @active_battler.target = @target_cmd.active
      @target_cmd.close
      @phase = :actor_next
    end

  end  

  #==============================================================================
  # ** actor_next
  #==============================================================================

  def phase_actor_next

    @actor_idx += 1
    if @actor_idx >= $party.active.count
      @phase = :main_init
    else
      @active_battler = $party.actor_by_index(@actor_idx)
      @actor_cmd.setup(@active_battler)
      @phase = :actor_action 
    end
    
  end

end"ü
class Scene_Battle

  def phase_main_init
   	
    # Choose enemy actions
    $battle.enemies.each{ |e|
    	e.choose_action
    }

    # Determine order of attacks
    @battle_queue = $battle.build_attack_queue
    
    # certain attacks always go first, robin's team move with phye for example

	  @active_battler = @battle_queue.shift
	  @phase = :main_prep

  end

  # Prepare attack of next guy to attack, next_actor called before this
  def phase_main_prep

  	# Calculate results now, then play out the anims
  	@attack_plan = $battle.build_attack_plan(@active_battler)

    @attack_round = @attack_plan.next_attack

  	@phase = :main_start

  end

  # Start a round of the attack
  def phase_main_start

    # Calculate damage here and now
    @attack_results = $battle.build_attack_results(@active_battler,@attack_round.skill)

    # Attack anim if there is one
    @phase = :main_attack
    wait(20)

  end

  # Show anim on attacker
  def phase_main_attack

    @attack_results.each{ |result|

      if @attack_round.anim_a
        # Show the hit animation
        x = result.target.ev.screen_x
        y = result.target.ev.screen_y - 32
        add_spark(@attack_round.anim_a,x,y)
      end

    }

    @phase = :main_defend
    wait(20)

  end

  # Show anim on defender
  def phase_main_defend

    @attack_results.each{ |result|

      if @attack_round.anim_b
        # Show the hit animation
        x = result.target.ev.screen_x
        y = result.target.ev.screen_y - 32
        add_spark(@attack_round.anim_b,x,y)
      end

    }

  	# Onto the next
  	@phase = :main_transform
    # Some anims might have a pause before hit
    # Might use the sound delay on the anim
    #wait(20) 

  end

  def phase_main_transform

    @attack_results.each{ |result|      
      if result.transform
        result.target.transform(result.transform)
      end
    }

    # Onto the next
    @phase = :main_hit

  end

  def phase_main_hit

    # Show the damage of @attack-result on each guy hit
    # There might not even be damage but
    # Better figure damage pops
    @attack_results.each{ |result|

        result.target.damage(result.damage)
        pop_num(result.target.ev,result.damage)

    }

    # Onto the next
    @phase = :main_crit
    wait(1)

  end

  def phase_main_crit

    # Onto the next

    @phase = :main_state
    wait(1)

  end

  def phase_main_state

    @attack_results.each{ |result|

      if result.state_add
        result.target.add_state(result.state_add)
        log_sys(result.state_add)
      end

    }

    @phase = :main_fall
    wait(30) # Might wait if a state was aded

  end

  def phase_main_fall

    # Anybody defeated should leave now
    @attack_results.each{ |result|

      if result.target.down?
        sys('fall')
        fade(result.target.ev)
        wait(60)
      end


    }


    # Onto the next
    @phase = :main_next


  end

  def phase_main_next

    # If one side has been defeated, that's it
    if $party.defeated?
      # Fade out show defeat screen etc
      $game.push_scene(Scene_GameOver.new)
      @phase = :LOSE
      return
    end

    if $battle.victory?
      @phase = :victory_init
      return
    end

  	# If a multi stage, go back to attack
    if !@attack_plan.done?

      # End multi stage attacks early if user is incapable of attack

      @active_attack = @attack_plan.next_attack
      @phase = :main_start
      return
    end

  	# Onto the next battler
	  if !@battle_queue.empty?
		
  		# Good place to check for end of battle also
	 	  @active_battler = @battle_queue.shift
	   	@phase = :main_prep
      return

    end

    # Attack phase done, finalize
    @phase = :main_end    

	end

  # NOT CURRENTLY ACTIVATED
  def phase_main_end
    
    # Remove states and that before next turn starts

    # Go to next turn, actor select
    @phase = :actor_init

  end

end
"]
class Scene_Battle

  def phase_victory_init

  	$game.pop_scene

  end


end"ß#==============================================================================
# ** Scene_GameOver
#==============================================================================

class Scene_GameOver

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    $scene = self

    # Make viewports - Also in the scene
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 3999

    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = $cache.menu_background("game-over")
               
  end
  
  def terminate


  end

  def update

  end

end
"+#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Map < Scene_Base

   def initialize
    super

    @moblins = []

    # Setup
    @map.setup($data.system.start_map_id)
    @map.setup_audio
    @player.moveto($data.system.start_x, $data.system.start_y)

    @map.camera_to(@player)

    $map = @map
    $player = @player

    @hud = Ui_Screen.new(@vp_ui)    
            
  end
  
  def terminate
    super

  end

  def busy?
    return @hud.busy?
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update
    super

    @moblins.each{ |i| i.update } if !busy?
    
  end

  def add_moblin(ev,delay)
    ev = gev(ev) if !ev.is_a?(Game_Event)
    @moblins.push(Moblin.new(ev,delay))
  end

end
"S#==============================================================================
# ** Scene_Menu
#==============================================================================

class Scene_Menu
  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    Graphics.freeze

    # Vp
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 3500

    # Background
    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = $cache.menu_background("sample")
    #@bg.do(repeat(sequence(go("x",-50,7000),go("x",50,7000))))

    # Choose background by location

    # The current menu
    case $game.menu_page
      when "Main"; @menu = Mnu_Main.new(@vp)
      when "Shop"; @menu = Mnu_Shop.new(@vp)
    end
    @sub = nil

    Graphics.transition(20,'Graphics/Transitions/trans')     

  end
  
  def terminate

    @menu.dispose if @menu != nil
    @sub.dispose if @sub != nil
    @bg.dispose

    @vp.dispose

  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    if @sub == nil || @sub.done?
      @menu.update
    else
      @sub.update
    end

    if @sub != nil && @sub.done? # CLOSE SELF
      @sub.dispose
      @sub = nil
      @menu.open
    end

    if ($input.cancel? || $input.rclick?) || (@sub == nil && @menu.done?)
      sys('cancel')
      $tweens.clear_all
      $game.pop_scene
    end
    
  end

  def open_sub(menu)
    @menu.close
    @sub = menu
    @sub.open
  end

  # def close_sub
  #   @sub.close
  #   @sub.dispose
  #   @menu.open
  # end

  def close_all

  end


end" " "ÂCmodule Seal

  #LIB_DIR = "System/"
  class SealAPI < Win32API
    STRCPY_S = Win32API.new('msvcrt', 'strcpy_s', 'pll', 'i')

    def initialize(func, arg_types, return_type = 'i', *args)
      @return_string = return_type == 'p'
      library = File.join(defined?(LIB_DIR) ? LIB_DIR : '.', 'seal')
      super(library, "seal_#{func}", arg_types, return_type, *args)
    end

    def [](*args)
      result = call(*args)
      if @return_string and result.is_a? Integer
        # String pointer is returned to Ruby as an integer even though we
        # specified 'p' as the return value - possibly a bug in Ruby 1.9.3's
        # Win32API implementation. Work around it.
        message_buffer = ' ' * 128
        STRCPY_S.call(message_buffer, message_buffer.size, result)
        return message_buffer.strip
      end
      result
    end unless method_defined? :[]
  end

  module Helper
    GET_ERR_MSG = SealAPI.new('get_err_msg', 'i', 'p')

    class << self
      def define_enum(mod, constants, start_value = 0)
        constants.each_with_index do |constant, index|
          mod.const_set(constant, start_value + index)
        end
      end

      # Returns a destructor for a native Seal object. This is most likely
      # called in the initializer method, but we cannot define the proc handler
      # there because that will capture the binding of the implicit `self` (due
      # to the nature of closure), which makes the object that `self` refers to
      # unrecyclable.
      def free(obj, destroyer)
        lambda { |object_id| destroyer[obj] }
      end
    end

  private
    def check_error(error_code)
      raise SealError, GET_ERR_MSG[error_code], caller.shift if error_code != 0
      nil
    end

    def input_audio(media, filename, format, inputter)
      check_error(inputter[media, filename, format])
    end

    def set_obj_int(obj, int, setter)
      check_error(setter[obj, int])
      int
    end

    def get_obj_int(obj, getter)
      buffer = '    '
      check_error(getter[obj, buffer])
      buffer.unpack('i')[0]
    end

    def set_obj_char(obj, bool, setter)
      set_obj_int(obj, bool ? 1 : 0, setter)
    end

    def get_obj_char(obj, getter)
      buffer = ' '
      check_error(getter[obj, buffer])
      buffer.unpack('c')[0] != 0
    end

    # Win32API does not support float argument type, need to pass as integer.
    def set_obj_float(obj, float, setter)
      check_error(setter[obj, [float].pack('f').unpack('i')[0]])
      float
    end

    def get_obj_float(obj, getter)
      float_buffer = '    '
      check_error(getter[obj, float_buffer])
      float_buffer.unpack('f')[0]
    end
  end

  VERSION = SealAPI.new('get_version', 'v', 'p')[]

  class << self
    include Helper

    STARTUP = SealAPI.new('startup', 'p')
    CLEANUP = SealAPI.new('cleanup', 'v', 'v')
    GET_PER_SRC_EFFECT_LIMIT = SealAPI.new('get_per_src_effect_limit', 'v')

    def startup(device = nil)
      check_error(STARTUP[device ? device : 0])
    end

    def cleanup
      CLEANUP[]
    end

    def per_source_effect_limit
      GET_PER_SRC_EFFECT_LIMIT[]
    end
  end

  module Format
    Helper.define_enum(self, [
      :UNKNOWN,
      :WAV,
      :OV,
      :MPG
    ])
  end

  class SealError < Exception
  end

  class Buffer
    include Helper

    INIT = SealAPI.new('init_buf', 'p')
    DESTROY = SealAPI.new('destroy_buf', 'p')
    LOAD = SealAPI.new('load2buf', 'ppi')
    GET_SIZE = SealAPI.new('get_buf_size', 'pp')
    GET_FREQ = SealAPI.new('get_buf_freq', 'pp')
    GET_BPS = SealAPI.new('get_buf_bps', 'pp')
    GET_NCHANNELS = SealAPI.new('get_buf_nchannels', 'pp')

    def initialize(filename, format = Format::UNKNOWN)
      @buffer = '    '
      check_error(INIT[@buffer])
      input_audio(@buffer, filename, format, LOAD)
      ObjectSpace.define_finalizer(self, Helper.free(@buffer, DESTROY))
      self
    end

    def load(filename, format = Format::UNKNOWN)
      input_audio(@buffer, filename, format, LOAD)
      self
    end

    def size
      get_obj_int(@buffer, GET_SIZE)
    end

    def frequency
      get_obj_int(@buffer, GET_FREQ)
    end

    def bit_depth
      get_obj_int(@buffer, GET_BPS)
    end

    def channel_count
      get_obj_int(@buffer, GET_NCHANNELS)
    end
  end

  class Stream
    include Helper

    OPEN = SealAPI.new('open_stream', 'ppi')
    CLOSE = SealAPI.new('close_stream', 'p')
    REWIND = SealAPI.new('rewind_stream', 'p')

    class << self
      alias open new
    end

    def initialize(filename, format = Format::UNKNOWN)
      @stream = '    ' * 5
      input_audio(@stream, filename, format, OPEN)
      ObjectSpace.define_finalizer(self, Helper.free(@stream, CLOSE))
      self
    end

    def frequency
      field(4)
    end

    def bit_depth
      field(2)
    end

    def channel_count
      field(3)
    end

    def rewind
      check_error(REWIND[@stream])
    end

    def close
      check_error(CLOSE[@stream])
    end

  private
    def field(index)
      @stream[index * 4, 4].unpack('i')[0]
    end
  end

  class Reverb
    include Helper

    INIT = SealAPI.new('init_rvb', 'p')
    DESTROY = SealAPI.new('destroy_rvb', 'p')
    LOAD = SealAPI.new('load_rvb', 'pi')
    SET_DENSITY = SealAPI.new('set_rvb_density', 'pi')
    SET_DIFFUSION = SealAPI.new('set_rvb_diffusion', 'pi')
    SET_GAIN = SealAPI.new('set_rvb_gain', 'pi')
    SET_HFGAIN = SealAPI.new('set_rvb_hfgain', 'pi')
    SET_DECAY_TIME = SealAPI.new('set_rvb_decay_time', 'pi')
    SET_HFDECAY_RATIO = SealAPI.new('set_rvb_hfdecay_ratio', 'pi')
    SET_REFLECTIONS_GAIN = SealAPI.new('set_rvb_reflections_gain', 'pi')
    SET_REFLECTIONS_DELAY = SealAPI.new('set_rvb_reflections_delay', 'pi')
    SET_LATE_GAIN = SealAPI.new('set_rvb_late_gain', 'pi')
    SET_LATE_DELAY = SealAPI.new('set_rvb_late_delay', 'pi')
    SET_AIR_ABSORBTION_HFGAIN =
      SealAPI.new('set_rvb_air_absorbtion_hfgain', 'pi')
    SET_ROOM_ROLLOFF_FACTOR = SealAPI.new('set_rvb_room_rolloff_factor', 'pi')
    SET_HFDECAY_LIMITED = SealAPI.new('set_rvb_hfdecay_limited', 'pi')
    GET_DENSITY = SealAPI.new('get_rvb_density', 'pp')
    GET_DIFFUSION = SealAPI.new('get_rvb_diffusion', 'pp')
    GET_GAIN = SealAPI.new('get_rvb_gain', 'pp')
    GET_HFGAIN = SealAPI.new('get_rvb_hfgain', 'pp')
    GET_DECAY_TIME = SealAPI.new('get_rvb_decay_time', 'pp')
    GET_HFDECAY_RATIO = SealAPI.new('get_rvb_hfdecay_ratio', 'pp')
    GET_REFLECTIONS_GAIN = SealAPI.new('get_rvb_reflections_gain', 'pp')
    GET_REFLECTIONS_DELAY = SealAPI.new('get_rvb_reflections_delay', 'pp')
    GET_LATE_GAIN = SealAPI.new('get_rvb_late_gain', 'pp')
    GET_LATE_DELAY = SealAPI.new('get_rvb_late_delay', 'pp')
    GET_AIR_ABSORBTION_HFGAIN =
      SealAPI.new('get_rvb_air_absorbtion_hfgain', 'pp')
    GET_ROOM_ROLLOFF_FACTOR = SealAPI.new('get_rvb_room_rolloff_factor', 'pp')
    IS_HFDECAY_LIMITED = SealAPI.new('is_rvb_hfdecay_limited', 'pp')

    def initialize(preset = nil)
      @effect = '    '
      check_error(INIT[@effect])
      load(preset) if preset
      ObjectSpace.define_finalizer(self, Helper.free(@effect, DESTROY))
      self
    end

    def load(preset)
      check_error(LOAD[@effect, preset])
    end

    def density=(density)
      set_obj_float(@effect, density, SET_DENSITY)
    end

    def diffusion=(diffusion)
      set_obj_float(@effect, diffusion, SET_DIFFUSION)
    end

    def gain=(gain)
      set_obj_float(@effect, gain, SET_GAIN)
    end

    def hfgain=(hfgain)
      set_obj_float(@effect, hfgain, SET_HFGAIN)
    end

    def decay_time=(decay_time)
      set_obj_float(@effect, decay_time, SET_DECAY_TIME)
    end

    def hfdecay_ratio=(hfdecay_ratio)
      set_obj_float(@effect, hfdecay_ratio, SET_HFDECAY_RATIO)
    end

    def reflections_gain=(reflections_gain)
      set_obj_float(@effect, reflections_gain, SET_REFLECTIONS_GAIN)
    end

    def reflections_delay=(reflections_delay)
      set_obj_float(@effect, reflections_delay, SET_REFLECTIONS_DELAY)
    end

    def late_gain=(late_gain)
      set_obj_float(@effect, late_gain, SET_LATE_GAIN)
    end

    def late_delay=(late_delay)
      set_obj_float(@effect, late_delay, SET_LATE_DELAY)
    end

    def air_absorbtion_hfgain=(air_absorbtion_hfgain)
      set_obj_float(@effect, air_absorbtion_hfgain, SET_AIR_ABSORBTION_HFGAIN)
    end

    def room_rolloff_factor=(room_rolloff_factor)
      set_obj_float(@effect, room_rolloff_factor, SET_ROOM_ROLLOFF_FACTOR)
    end

    def hfdecay_limited=(hfdecay_limited)
      set_obj_char(@effect, hfdecay_limited, SET_HFDECAY_LIMITED)
    end

    def density
      get_obj_float(@effect, GET_DENSITY)
    end

    def diffusion
      get_obj_float(@effect, GET_DIFFUSION)
    end

    def gain
      get_obj_float(@effect, GET_GAIN)
    end

    def hfgain
      get_obj_float(@effect, GET_HFGAIN)
    end

    def decay_time
      get_obj_float(@effect, GET_DECAY_TIME)
    end

    def hfdecay_ratio
      get_obj_float(@effect, GET_HFDECAY_RATIO)
    end

    def reflections_gain
      get_obj_float(@effect, GET_REFLECTIONS_GAIN)
    end

    def reflections_delay
      get_obj_float(@effect, GET_REFLECTIONS_DELAY)
    end

    def late_gain
      get_obj_float(@effect, GET_LATE_GAIN)
    end

    def late_delay
      get_obj_float(@effect, GET_LATE_DELAY)
    end

    def air_absorbtion_hfgain
      get_obj_float(@effect, GET_AIR_ABSORBTION_HFGAIN)
    end

    def room_rolloff_factor
      get_obj_float(@effect, GET_ROOM_ROLLOFF_FACTOR)
    end

    def hfdecay_limited
      get_obj_char(@effect, IS_HFDECAY_LIMITED)
    end

    alias hfdecay_limited? hfdecay_limited

    module Preset
      Helper.define_enum(self, [
        :GENERIC,
        :PADDEDCELL,
        :ROOM,
        :BATHROOM,
        :LIVINGROOM,
        :STONEROOM,
        :AUDITORIUM,
        :CONCERTHALL,
        :CAVE,
        :ARENA,
        :HANGAR,
        :CARPETEDHALLWAY,
        :HALLWAY,
        :STONECORRIDOR,
        :ALLEY,
        :FOREST,
        :CITY,
        :MOUNTAINS,
        :QUARRY,
        :PLAIN,
        :PARKINGLOT,
        :SEWERPIPE,
        :UNDERWATER,
        :DRUGGED,
        :DIZZY,
        :PSYCHOTIC
      ])
    end
  end

  class Source
    include Helper

    INIT = SealAPI.new('init_src', 'p')
    DESTROY = SealAPI.new('destroy_src', 'p')
    PLAY = SealAPI.new('play_src', 'p')
    STOP = SealAPI.new('stop_src', 'p')
    REWIND = SealAPI.new('rewind_src', 'p')
    PAUSE = SealAPI.new('pause_src', 'p')
    DETACH = SealAPI.new('detach_src_audio', 'p')
    MOVE = SealAPI.new('move_src', 'p')
    SET_BUF = SealAPI.new('set_src_buf', 'pp')
    SET_STREAM = SealAPI.new('set_src_stream', 'pp')
    FEED_EFS = SealAPI.new('feed_efs', 'ppi')
    UPDATE = SealAPI.new('update_src', 'p')
    SET_POS = SealAPI.new('set_src_pos', 'piii')
    SET_VEL = SealAPI.new('set_src_vel', 'piii')
    SET_GAIN = SealAPI.new('set_src_gain', 'pi')
    SET_PITCH = SealAPI.new('set_src_pitch', 'pi')
    SET_AUTO = SealAPI.new('set_src_auto', 'pi')
    SET_RELATIVE = SealAPI.new('set_src_relative', 'pi')
    SET_LOOPING = SealAPI.new('set_src_looping', 'pi')
    SET_QUEUE_SIZE = SealAPI.new('set_src_queue_size', 'pi')
    SET_CHUNK_SIZE = SealAPI.new('set_src_chunk_size', 'pi')
    GET_POS = SealAPI.new('get_src_pos', 'pppp')
    GET_VEL = SealAPI.new('get_src_vel', 'pppp')
    GET_GAIN = SealAPI.new('get_src_gain', 'pp')
    GET_PITCH = SealAPI.new('get_src_pitch', 'pp')
    GET_AUTO = SealAPI.new('is_src_auto', 'pp')
    GET_RELATIVE = SealAPI.new('is_src_relative', 'pp')
    GET_LOOPING = SealAPI.new('is_src_looping', 'pp')
    GET_QUEUE_SIZE = SealAPI.new('get_src_queue_size', 'pp')
    GET_CHUNK_SIZE = SealAPI.new('get_src_chunk_size', 'pp')
    GET_TYPE = SealAPI.new('get_src_type', 'pp')
    GET_STATE = SealAPI.new('get_src_state', 'pp')

    def initialize
      @source = '    ' * 5
      check_error(INIT[@source])
      ObjectSpace.define_finalizer(self, Helper.free(@source, DESTROY))
      self
    end

    def play
      operate(PLAY)
    end

    def stop
      operate(STOP)
    end

    def rewind
      operate(REWIND)
    end

    def pause
      operate(PAUSE)
    end

    def move
      operate(MOVE)
    end

    def buffer=(buffer)
      set_audio(:@buffer, buffer, SET_BUF)
    end

    def stream=(stream)
      set_audio(:@stream, stream, SET_STREAM)
    end

    attr_reader :buffer, :stream

    def feed(effect_slot, index)
      native_efs_obj = effect_slot.instance_variable_get(:@effect_slot)
      check_error(FEED_EFS[@source, native_efs_obj, index])
      self
    end

    def update
      operate(UPDATE)
    end

    def position=(position)
      set_3float(position, SET_POS)
    end

    def velocity=(velocity)
      set_3float(velocity, SET_VEL)
    end

    def gain=(gain)
      return if gain < 0
      set_obj_float(@source, gain, SET_GAIN)
    end

    def pitch=(pitch)
      set_obj_float(@source, pitch, SET_PITCH)
    end

    def auto=(auto)
      set_obj_char(@source, auto, SET_AUTO)
    end

    def queue_size=(queue_size)
      set_obj_int(@source, queue_size, SET_QUEUE_SIZE)
    end

    def chunk_size=(chunk_size)
      set_obj_int(@source, chunk_size, SET_CHUNK_SIZE)
    end

    def relative=(relative)
      set_obj_char(@source, relative, SET_RELATIVE)
    end

    def looping=(looping)
      set_obj_char(@source, looping, SET_LOOPING)
    end

    def position
      get_3float(GET_POS)
    end

    def velocity
      get_3float(GET_VEL)
    end

    def gain
      get_obj_float(@source, GET_GAIN)
    end

    def pitch
      get_obj_float(@source, GET_PITCH)
    end

    def auto
      get_obj_char(@source, GET_AUTO)
    end

    def relative
      get_obj_char(@source, GET_RELATIVE)
    end

    def looping
      get_obj_char(@source, GET_LOOPING)
    end

    alias auto? auto
    alias relative? relative
    alias looping? looping

    def queue_size
      get_obj_int(@source, GET_QUEUE_SIZE)
    end

    def chunk_size
      get_obj_int(@source, GET_CHUNK_SIZE)
    end

    def type
      case get_obj_int(@source, GET_TYPE)
      when Type::STATIC
        Type::STATIC
      when Type::STREAMING
        Type::STREAMING
      else
        Type::UNDETERMINED
      end
    end

    def state
      case get_obj_int(@source, GET_STATE)
      when State::PLAYING
        State::PLAYING
      when State::PAUSED
        State::PAUSED
      when State::STOPPED
        State::STOPPED
      else
        State::INITIAL
      end
    end

    def playing?
      return state == State::PLAYING
    end

  private
    def operate(operation)
      check_error(operation[@source])
      self
    end

    def set_audio(var, audio, setter)
      if audio.nil?
        operate(DETACH)
      else
        check_error(setter[@source, audio.instance_variable_get(var)])
      end
      instance_variable_set(var, audio)
      audio
    end

    def set_3float(float_tuple, setter)
      integer_tuple = float_tuple.pack('f*').unpack('i*')
      check_error(setter[@source, *integer_tuple])
      float_tuple
    end

    def get_3float(getter)
      float_tuple_buffers = Array.new(3) { '    ' }
      check_error(getter[@source, *float_tuple_buffers])
      float_tuple_buffers.join.unpack('f*')
    end

    module State
      Helper.define_enum(self, [
        :INITIAL,
        :PLAYING,
        :PAUSED,
        :STOPPED
      ])
    end

    module Type
      Helper.define_enum(self, [
        :UNDETERMINED,
        :STATIC,
        :STREAMING
      ])
    end
  end

  class EffectSlot
    include Helper

    INIT = SealAPI.new('init_efs', 'p')
    DESTROY = SealAPI.new('destroy_efs', 'p')
    SET_EFFECT = SealAPI.new('set_efs_effect', 'pp')
    SET_GAIN = SealAPI.new('set_efs_gain', 'pi')
    SET_AUTO = SealAPI.new('set_efs_auto', 'pi')
    GET_GAIN = SealAPI.new('get_efs_gain', 'pp')
    GET_AUTO = SealAPI.new('is_efs_auto', 'pp')

    def initialize(effect = nil)
      @effect_slot = '    '
      check_error(INIT[@effect_slot])
      self.effect = effect if effect
      ObjectSpace.define_finalizer(self, Helper.free(@effect_slot, DESTROY))
      self
    end

    def effect=(effect)
      native_effect_obj = effect ? effect.instance_variable_get(:@effect) : 0
      check_error(SET_EFFECT[@effect_slot, native_effect_obj])
      @effect = effect
      effect
    end

    attr_reader :effect

    def gain=(gain)
      set_obj_float(@effect_slot, gain, SET_GAIN)
    end

    def gain
      get_obj_float(@effect_slot, GET_GAIN)
    end

    def auto=(auto)
      set_obj_char(@effect_slot, auto, SET_AUTO)
    end

    def auto
      get_obj_char(@effect_slot, GET_AUTO)
    end

    alias auto? auto
  end
end"ß#==============================================================================
# ** Audio Manager
#==============================================================================

class AudioManager


  def initialize

    begin
      Seal.startup
    rescue
      retry
    end

    @music = Seal::Source.new
    @music_in = Seal::Source.new

    @atmosphere = Seal::Source.new
    @atmostphere_in = Seal::Source.new

    # Fade targets
    @music_target = 1.0
    @music_in_target = 1.0
    @atmosphere_target = 1.0
    @atmosphere_in_target = 1.0

    # Looping, fade by distance
    @environmental = [] 

    # System Effects
    @sys = []

    # Sound effects with reverb
    @sfx = []

    # Queue of sfx to play [[file,delay,vol]]
    @queue = [] 

    @mode = :normal
    @effect = nil

    @sfx_vol = 1.0 # Set by mode

    #change_mode(:cave)
    
  end

  def dispose

    # Destroy all the sources

    Seal.cleanup
  end

  def fadeout
    @music_target = 0.0
    @atmosphere_target = 0.0
  end

  def env(file,pos)
    @environmental.each{ |snd|
      if snd.file == file
        snd.addpos(pos)
        return
      end
    }
    @environmental.push(EnviroSource.new(file,pos))
  end

  def music(file,vol=1.0)
    if file == nil || file == ''
      @music.stop
      return
    end
    @music.gain = vol
    @music.stream = Seal::Stream.open("Audio/Music/#{file}.ogg")
    @music.play
  end

  def atmosphere(file)
    return
    @atmosphere_target = 0.3
    if file == nil  || file == ''
      @atmosphere.stop
      return
    end
    #@atmosphere.gain = 0.3
    @atmosphere.stream = Seal::Stream.open("Audio/Atmosphere/#{file}.ogg")
    @atmosphere.play
  end

  def sys(file,vol=1.0)
    return

    #log_scr(@sys.count)

    # Check through sources, if empty, use, if none, add
    @sys.each{ |src|
      if !src.playing?
        src.buffer = Seal::Buffer.new("Audio/Sys/#{file}.ogg")
        src.play
        return
      end
    }

    # Add new
    src = Seal::Source.new
    buf = Seal::Buffer.new("Audio/Sys/#{file}.ogg")
    src.gain = vol
    src.buffer = buf
    src.play
    @sys.push(src)

  end

  def sfx(file,vol=1.0)
    return

    #log_scr(@sfx.count)

    # Check through sources, if empty, use, if none, add
    @sfx.each{ |src|
      if !src.playing?
        src.buffer = Seal::Buffer.new("Audio/Sounds/#{file}.ogg")
        
        src.play
        return
      end
    }

    # Add new
    src = Seal::Source.new
    buf = Seal::Buffer.new("Audio/Sounds/#{file}.ogg")
    src.buffer = buf
    src.gain = vol
    src.feed(@effect, 0) if @effect != nil
    src.play
    @sfx.push(src)

  end

  def queue(file,delay,vol=1.0)
    @queue.push([file,delay,vol])
  end

  def dip(src)

    # Dip the music while the src plays then fade up

  end


  # send_blank to force start music
  def play_bgm(bgm)
    @bgm = bgm
    Audio.bgm_play("Audio/BGM/" + bgm)
  end



  def pause
    @music.pause
  end

  def unpause
    @music.play
  end

  # Change mode between maps so clear sources also
  def change_mode(mode)

    @mode = mode
    preset = nil

    # Create new effect and volume modifier
    case mode
      when 'normal', ''
        preset = nil
        @effect = nil
        

      when 'cave'
        preset = Seal::Reverb::Preset::CAVE
        
    end

    # Prepare the effect to be added to each newly created source
    if preset != nil
      @effect = Seal::EffectSlot.new(Seal::Reverb.new(preset))
    end

    #@sfx.each{ |s| s.dispose }
    @sfx = []

   
  end

  def update

    if @atmosphere_target != @atmosphere.gain
      if @atmosphere_target > @atmosphere.gain
        @atmosphere.gain -= 0.05
      else
        @atmosphere.gain += 0.05
      end
    end

    @environmental.each{ |e| e.update }

    # Play sfx on delay
    @queue.each{ |i|

      i[1] -= 1
      if i[1] <= 0
        sfx(i[0],i[2])
      end

    }

    @queue.delete_if{ |i| i[1] <= 0 }

  end

end

class EnviroSource < Seal::Source

  attr_reader :file

  def initialize(sound,pos)
    super()

    @file = sound

    @positions = [pos]
    self.buffer = Seal::Buffer.new("Audio/Sounds/#{sound}.ogg")
    self.looping = true
    self.play

    @short = 96 * 4 # *4 to convert to REAL coords
    @long = 320 * 4

  end

  def addpos(pos)

    @positions.push(pos)

  end

  def update

    # Use player pos for now
    px = $player.real_x
    py = $player.real_y

    # Find closest point
    src = nil
    mn = 999999999
    @positions.each{ |p| 
      dist = ((px-p[0]) * (px-p[0])) +
             ((py-p[1]) * (py-p[1]))
      if dist < mn
        mn = dist
        src = p
      end
    }

    # Use distance to figure volume
    dist = ((px-src[0]) * (px-src[0])) +
           ((py-src[1]) * (py-src[1]))

    dist = Math.sqrt(dist)

    # If under min, full volume
    if dist < @short
      self.gain = 1.0
      return
    end

    # If over max, off
    if dist > @long
      self.gain = 0.0
      return
    end

    # Scale
    self.gain = 1.0 - (dist - @short).to_f / (@long-@short).to_f


  end

end" 
class CacheManager

    def initialize
        @cache = {}
    end

    def get(filename) load("",filename) end

    def animation(filename) load("Animations/", filename) end

    def autotile(filename) load("Autotiles/", filename) end
    def tileset(filename) load("Tilesets/", filename) end
    def character(filename) load("Characters/", filename) end

    
    def panorama(filename) load("Panoramas/", filename) end
    def fog(filename) load("Fogs/", filename, hue) end
    def particle(filename) load("Particles/", filename) end


    # Menu
    def menu(filename) load("Menus/", filename) end
    def menu_common(filename) load("Menus/Common/", filename) end
    def menu_wallpaper(filename) load("Menus/Wallpapers/", filename) end
    def menu_background(filename) load("Menus/Backgrounds/", filename) end
    def menu_tab(filename) load("Menus/Tabs/", filename) end
    def menu_char(filename) load("Menus/Char/", filename) end
    def menu_page(filename) load("Menus/Page/", filename) end

    def cursor(filename) load("Cursors/", filename) end
    def icon(filename) load("Icons/", filename) end
    def numbers(filename) load("Numbers/", filename) end

    # Faces
    def face(filename) load("Faces/Message/", filename) end
    def face_vn(filename) load("Faces/Vn/", filename) end
    def face_small(filename) load("Faces/Small/", filename) end
    def face_large(filename) load("Faces/Large/", filename) end
    def face_menu(filename) load("Faces/Menu/", filename) end
    def face_battle(filename) load("Faces/Battle/", filename) end
    


    def tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end


    def load(folder_name, filename, hue = 0)
      path = "Graphics/"+folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          begin
            @cache[path] = Bitmap.new(path)
          rescue
            log_err("MISSING GRAPHICS: #{path}")
            @cache[path] = Bitmap.new(32, 32)
          end  
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def clear
      @cache = {}
      GC.start
    end

  end"#==============================================================================
# ** Data Manager
#==============================================================================

class DataManager

  # JsonData
	attr_reader :items
  attr_reader :shop
  attr_reader :gear

  attr_reader :actors
  attr_reader :enemies
  attr_reader :skills
  attr_reader :states

  attr_reader :progress
  attr_reader :quests
  attr_reader :zones

  attr_reader :anims

  attr_reader :numbers

  # Clone events
  attr_reader :clones

  # RxData
  attr_reader :commons
  attr_reader :tilesets
  attr_reader :system
  attr_reader :mapinfos

	def initialize

    # Create an icon list
    create_icon_list if DEBUG

    # Load up json data
    usable = load_json("items",UsableData)
    usable.each{ |k,i| i.tab = "usable"}
    keys = load_json("keyitems",KeyItemData)
    keys.each{ |k,i| i.tab = "keys"}
    shop = load_json("shop",ShopData)
    shop.each{ |k,i| i.tab = "shop"}
    gear = load_json("gear",GearData)
    gear.each{ |k,i| i.tab = "gear"}

    @items = usable.merge(keys).merge(shop).merge(gear)

    @actors = load_json("actors",ActorData)
    @enemies = load_json("enemies",EnemyData)
    
    @skills = load_json("skills",SkillData)
    @states = load_json("states",StateData)
    
    @progress = load_json("progress",ProgressData)
    @quests = load_json("quests",QuestData)
    @zones = load_json("zones",ZoneData)

    @anims = load_json("anims",AnimData)

    @numbers = load_json("numbers",NumberData)

    @clones = load_clones

		# Convert to json
    @commons = load_data("Data/CommonEvents.rxdata")
    @tilesets = load_data("Data/Tilesets.rxdata")
    @system = load_data("Data/System.rxdata")
    @mapinfos = load_data("Data/MapInfos.rxdata")

	end

  def create_icon_list

    list = Dir.glob('Graphics/Icons/**/*').select{ |e| File.file? e }
    list.each_index { |i|
      list[i] = list[i].gsub("Graphics/Icons/","")
      list[i] = list[i].gsub(".png","")
    }

    File.open('Editor/icons.json', 'w') { |file|
      file.puts("[")
      list.each{ |l| file.puts("\""+l+"\",") }
      file.puts("\"\"")
      file.puts("]")
    }

  end

  def load_clones

    clones = {}
    map = load_data("Data/Map001.rxdata")

    map.events.each{ |k,ev|
      dta = ev.name.split('#').first.split('.')
      if dta.count > 1
        name = dta[1].rstrip
      else
        name = dta[0].rstrip
      end
      clones[name] = ev
    }

    return clones

  end

  def load_json(file,type)

    # Load from rxdata if not debug
    if !DEBUG
      return load_data("Data/Json/#{file}.rxdata")
    end

    # Clear out garbage files
    process_data_files(file)

    # If there is no data file, make blank
    if !FileTest.exist?("Editor/json/#{file}.json")
      log_sys "Missing data file: #{file}.json"
      return {}
    end

    # Load up the data
    json_data = File.read("Editor/json/#{file}.json")
    json_data = json_data.gsub(/[:]/, '=>')
    json_data = eval(json_data)

  
    # Create datas
    data = {}
    json_data.each{ |v|
      item = type.new
      v.each{ |var,val|
        
        # Ignore modified field
        next if var == 'modified'

        # Attempt to convert val to int or float
        if val.numeric?
          if val.include?(".")
            val = val.to_f
          else
            val = val.to_i
          end
        end

        item.instance_variable_set("@#{var}", val)
      }
      data[item.id] = item
      
    }

    # Export to rxdata for later
    # Disabled for now to not crowd up github commits
    #save_data(data,"Data/Json/#{file}.rxdata")

    return data

  end

  def process_data_files(file)

    # RIGHT, START AT 50 DOWN TO NOTHING! WHEN FOUND REPLACE THE BASE
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        # Found it! Delete the base and rename this one
        File.delete("Editor/json/#{file}.json")
        File.rename("Editor/json/#{file}(#{idx}).json","Editor/json/#{file}.json")
        break
      end
      idx -= 1
    end

    # Delete any with brackets
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        File.delete("Editor/json/#{file}(#{idx}).json")
      end      
      idx -= 1
    end

  end

 end"Å#==============================================================================
# ** Debug
#==============================================================================

def log_err(msg) $debug.log(msg,'ERROR') end
def log_scr(msg) $debug.log(msg,'SCRIPT') end
def log_info(msg) $debug.log(msg,'INFO') end
def log_sys(msg) $debug.log(msg,'SYSTEM') end
def log_ev(msg) $debug.log(msg,'EVENT') end

class DebugManager

	OSD_OPACITY = 230

	INFO_COLOR = Color.new(220,171,1,OSD_OPACITY)
	SCRIPT_COLOR = Color.new(128,0,64,OSD_OPACITY)
	ERROR_COLOR = Color.new(202,0,0,OSD_OPACITY)
	SYSTEM_COLOR = Color.new(128,0,128,OSD_OPACITY)
	EVENT_COLOR = Color.new(0,128,128,OSD_OPACITY)

	attr_reader :last_color

	def initialize		
		return if !DEBUG

		$DEBUG = true

		# Prepare log file
		@path = $appdata + "\\log.txt"
		File.open(@path, 'w') { |file| }	

		
		# Prepare on screen log
		@viewport = Viewport.new(0,0,640,480)
		@viewport.z = 5000
		
		@console = DebugConsole.new(@viewport)

		@menu = DebugMenu.new(@viewport)

		@track = Sprite.new(@viewport)
	    @track.bitmap = Bitmap.new(150,30)

		@last_color = INFO_COLOR

	end	

	def update
		return if !DEBUG

		@console.update if !@menu.active?
		@menu.update if !@console.active?

		# If tracking, do it
		if @track_obj
			@track.bitmap.fill(Color.new(0,0,0))
			@track.bitmap.font = $fonts.debug_min
   	 		@track.bitmap.draw_text(10,0,150,30,@track_obj.send(@track_val).to_s,0)
   	    end

	end

	def track(obj,val)

		@track_obj = obj
		@track_val = val

	end

	def log(msg,type='LOG')
	    return if !DEBUG

	    msg = "NIL" if msg == nil
	    if msg.is_a?(Array)
	    	msg = "Array: "+msg.join(", ")
	    end
	    if msg.is_a?(Hash)

	    end
		out = type + "\t" + msg.to_s
		File.open(@path, 'a') { |file| file.puts(out) }

		out = msg.to_s
		color = nil

		case type
			when 'INFO'; color = INFO_COLOR
			when 'SCRIPT'; color = SCRIPT_COLOR
			when 'ERROR'; color = ERROR_COLOR
			when 'SYSTEM'; color = SYSTEM_COLOR
			when 'EVENT'; color = EVENT_COLOR
		end

		@console.log([out,color])

		@last_color = color

	end

	def busy?
		return @console.active? || @menu.active?
	end
end"Ó#==============================================================================
# ** Save File Manager
#==============================================================================

# 99 save files
class FileManager
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def any_save_files?
    !Dir.glob('Av4-*.save').empty?
  end
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def file_exists?(which)
    file = 'Av4-'+which+'.save'
    File.exist?($appPath + file)
  end
  
  #--------------------------------------------------------------------------
  # * Create Filename
  #--------------------------------------------------------------------------
  def make_filename()
    file = "Av4-"+$settings.value('active')+".dean"
    return $appdata + file
  end

  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  def save_game
    File.open(make_filename(), "wb") { |file|
      header = make_save_header  
      body = make_save_contents
      Marshal.dump(header, file)
      Marshal.dump(body, file)
      @last_savefile_index = index
    }
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Execute Load (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_game
    File.open(make_filename(), "rb") do |file|
      Marshal.load(file)
      extract_save_contents(Marshal.load(file))
      reload_map_if_updated
      @index = index
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Load Save Header (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_header
    File.open(make_filename(), "rb") do |file|
      return Marshal.load(file)
    end
    return nil
  end
  
  #--------------------------------------------------------------------------
  # * Delete Save File
  #--------------------------------------------------------------------------
  def delete_save_file()
    File.delete(make_filename()) rescue nil
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Header
  #--------------------------------------------------------------------------
  def make_save_header
    header = {}
    header[:progress] = 140
    #header[:characters] = $game_party.characters_for_savefile
    #header[:playtime_s] = $game_system.playtime_s
    header
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Contents
  #--------------------------------------------------------------------------
  def make_save_contents
    contents = {}
    contents[:state]       = $state
    contents[:progress]         = $progress
    contents[:party]      = $party
    contents[:battle]     = $battle

    contents[:map]        = $map
    contents[:player]        = $player
    contents
  end
  
  #--------------------------------------------------------------------------
  # * Extract Save Contents
  #--------------------------------------------------------------------------
  def extract_save_contents(contents)
    $journal       = contents[:journal]
    $flags         = contents[:flags]
    $switches      = contents[:switches]
    $variables     = contents[:variables]
    $states        = contents[:states]
    $harvey        = contents[:harvey]
  end
  
  #--------------------------------------------------------------------------
  # * Get Update Date of Save File
  #--------------------------------------------------------------------------
  def savefile_time_stamp()
    File.mtime(make_filename()) rescue Time.at(0)
  end
  
  #--------------------------------------------------------------------------
  # * Get File Index with Latest Update Date
  #--------------------------------------------------------------------------
  def latest_savefile_index
    savefile_max.times.max_by {|i| savefile_time_stamp(i) }
  end
  
end
"H
class FontManager

	attr_reader :debug, :debug_min, :debug_ttl
	attr_reader :message, :message_shadow, :namebox

	attr_reader :list, :list_shadow

	attr_reader :pop_ttl, :pop_text, :pop_type

	attr_reader :page_ttl, :page_sub, :page_text

	attr_reader :hud_hp

	attr_reader :mini, :mini_b


	def initialize

		@scratch = Bitmap.new(600,50)


		# Debug Fonts

		@debug = Font.new
	    @debug.name = "Consolas"
	    @debug.size = 22

	    @debug_min = Font.new
	    @debug_min.name = "Consolas"
	    @debug_min.size = 20

	    @debug_ttl = Font.new
	    @debug_ttl.name = "Consolas"
	    @debug_ttl.size = 28


	    # List

	    @list = Font.new
    	@list.name = "Verdana"
    	@list.size = 20 #was 26
    	@list.color = Color.new(245,223,200)

    	@list_shadow = Font.new
    	@list_shadow.name = "Verdana"
    	@list_shadow.size = 20 #was 26
    	@list_shadow.color = Color.new(0,0,0,90)


		# Message box

		@message = Font.new
	    @message.name = "Georgia"
	    @message.size = 24 #30 good for big text
	    #@message.gradient = true
	    @message.color = Color.new(245,223,200)

	    @message_shadow = Font.new
	    @message_shadow.name = "Georgia"
	    @message_shadow.size = 24
	    @message_shadow.color = Color.new(0,0,0,90)

	    @namebox = Font.new
	    @namebox.name = "Bitter"
	    @namebox.size = 30
	    @namebox.italic = true
	    @namebox.gradient = true


	    # Menus
	    
	    @pop_ttl = Font.new
	    @pop_ttl.name = "Verdana"
	    @pop_ttl.size = 22
	    @pop_ttl.color = Color.new(245,223,200)

	    @pop_text = Font.new
	    @pop_text.name = "Verdana"
	    @pop_text.size = 18
	    #@pop_text.italic = true
	    @pop_text.color = Color.new(245,223,200)

	   	@pop_type = Font.new
	    @pop_type.name = "Verdana"
	    @pop_type.size = 16
	    @pop_type.color = Color.new(245,223,200)


	    # Page 

	    @page_ttl = Font.new
		@page_ttl.name = "Georgia"
	    @page_ttl.size = 28
	    #@page_ttl.bold = true
	    @page_ttl.color = Color.new(44,44,44)

	   	@page_sub = Font.new
		@page_sub.name = "Bitter"
	    @page_sub.size = 20
	    #@page_ttl.bold = true
	    @page_sub.color = Color.new(99,99,99)

	   	@page_text = Font.new
		@page_text.name = "Georgia"
	    @page_text.size = 20
	    @page_text.color = Color.new(44,44,44)


		# Misc

		@hud_hp = Font.new
		@hud_hp.name = "Bitter"
	    @hud_hp.size = 20
	    @hud_hp.color = Color.new(99,99,99)

	    @mini = Font.new
	    @mini.name = "Verdana"
	    @mini.size = 12
	    @mini.bold = true
	    @mini.color = Color.new(255,255,255)

	    @mini_b = Font.new
	    @mini_b.name = "Verdana"
	    @mini_b.size = 12
	    @mini_b.bold = true
	    @mini_b.color = Color.new(0,0,0)


	end

	def size(text,font)
		@scratch.font = font
		return @scratch.text_size(text)
	end

end"#==============================================================================
# ** Game Manager
#==============================================================================

class GameManager

  attr_reader :width, :height
  attr_accessor :menu_page

	def initialize

    $game = self

    # Setup font
    Font.default_size = 22
    Font.default_name = "Consolas"

    if ACE_MODE
      Font.default_outline = false
      Font.default_shadow = true
    end

    Graphics.frame_rate = 60
    #resize(853,480)
    resize(640,480)

    @scenes = []
    @queue = nil

    # Game State Objects
    $progress = Progress.new
    $state = State.new
    $party = Game_Party.new
    $menu = MenuState.new
    $battle = Game_Battle.new    

    # Make scene object (title screen)
    if DEBUG && $settings.debug_skip_title
      push_scene(Scene_Map.new)    
    else
      push_scene(Scene_Splash.new)
    end

  end

  def resize(w,h)
    @width = w
    @height = h
    if ACE_MODE
      Graphics.resize_screen(w,h)
    end
    #set_rez(w,h)
  end

  def push_scene(scene)
    $scene = scene
    @scenes.unshift(scene)
  end

  def pop_scene
    #Graphics.freeze
    $tweens.clear_all
    @scenes.shift.terminate
    $scene = @scenes[0]
  end

  def quit?
    return false
  end

  def update

    $audio.update
    $keyboard.update
    $mouse.update
    $debug.update
    $tweens.update
    Graphics.update
    Input.update
    @scenes[0].update

    if @queue
      push_scene(@queue)
      @queue = nil
    end

  end

  def flip_window
    showm = Win32API.new('user32', 'keybd_event', %w(l l l l), '')
    showm.call(18,0,0,0)
    showm.call(13,0,0,0)
    showm.call(13,0,2,0)
    showm.call(18,0,2,0)
  end

end"ñ#============================================================================== 
# ** Input
#==============================================================================

class InputManager

	def dir4
		return 2 if $keyboard.state?(VK_DOWN)
		return 4 if $keyboard.state?(VK_LEFT)
		return 6 if $keyboard.state?(VK_RIGHT)
		return 8 if $keyboard.state?(VK_UP)
		return 0
	end

	def action?
		return $keyboard.press?(VK_ENTER) ||
			   $keyboard.press?(VK_SPACE) 
	end

	def click?
		return $keyboard.press?(VK_LBUTTON)
	end

	def cancel?
		return $keyboard.press?(VK_ESC) || $keyboard.press?(VK_NUM0)
	end

	def rclick?
		return $keyboard.press?(VK_RBUTTON)
	end

	def left?
		return $keyboard.press?(VK_LEFT)
	end

	def right?
		return $keyboard.press?(VK_RIGHT)
	end

	def up?
		return $keyboard.press?(VK_UP)
	end

	def down?
		return $keyboard.press?(VK_DOWN)
	end

	def shortcut?(s)

	end

	def shift?
		return $keyboard.state?(VK_SHIFT)
	end

end"n#==============================================================================
# ** Keyboard Manager
#==============================================================================


VK_LBUTTON = 1
VK_RBUTTON = 2

VK_BS = 8
VK_TAB = 9
VK_ENTER = 13
VK_SHIFT = 16
VK_ESC = 27
VK_NUM0 = 96

VK_SPACE = 32
VK_TILDE = 192

VK_LEFT = 37
VK_UP = 38
VK_RIGHT = 39
VK_DOWN = 40

class KeyboardManager

	KeyState = Win32API.new("user32","GetKeyState",['i'],'i')
	
	def initialize
		@keys_held = {}
	end

	def state?(key)
		check = KeyState.call(key) #& 0x80 == 128
		return !(check == 1 || check == 0)
	end

	def press?(key)
	  if !@keys_held.has_key?(key) && state?(key)
	  	@keys_held[key] = Graphics.frame_count
	  	return true
	  else
	  	return false
	  end
	end 

  def hold?(key)
    return true if press?(key)
    if @keys_held.has_key?(key)
      if (Graphics.frame_count - @keys_held[key]) % 8 == 7
        return true
      end
    end
    return false
  end 

  def down?(key)
    return state?(key)
  end

  def up?(key)
    return !state?(key)
  end

	def update
		@keys_held.delete_if { |k,v| !state?(k)}
	end

	  # http://www.mods.com.au/budapi_docs/Virtual%20Key%20Codes.htm

  def to_char(key)

    shift = $input.shift?

    case key

      when 32; " "
      when 48; shift ? ')' : '0'
      when 49; shift ? '!' : '1'
      when 50; shift ? '@' : '2'
      when 51; shift ? '#' : '3'
      when 52; shift ? '$' : '4'
      when 53; shift ? '%' : '5'
      when 54; shift ? '^' : '6'
      when 55; shift ? '&' : '7'
      when 56; shift ? '*' : '8'
      when 57; shift ? '(' : '9'

      when 65..90; shift ? key.chr.upcase : key.chr.downcase

      when 186; shift ? ':' : ';' 
      when 187; shift ? '+' : '=' 
      when 188; shift ? '<' : ',' 
      when 189; shift ? '_' : '-' 
      when 190; shift ? '>' : '.' 
      when 191; shift ? '?' : '/' 
      
      when 219; shift ? '{' : '[' 
      when 220; shift ? '|' : '\\'
      when 221; shift ? '}' : ']' 
      when 222; shift ? '"' : '\''

      else; ''

    end

  end

end",#============================================================================== 
# ** Modules.Mouse Input (7.0)              By Near Fantastica & SephirothSpawn
#==============================================================================

class MouseManager

  #--------------------------------------------------------------------------
  # * API Declaration
  #--------------------------------------------------------------------------
  Cursor_Pos = Win32API.new('user32', 'GetCursorPos', 'p', 'i')
  ShowCursor = Win32API.new('user32', 'ShowCursor', 'i', 'l')
  Scr2cli = Win32API.new('user32', 'ScreenToClient', %w(l p), 'i')
  Findwindow = Win32API.new('user32', 'FindWindowA',%w(p p),'l')

  def initialize
    @pos = [0,0]
    @hwnd = Findwindow.call(nil, "Aveyond")
    @sprite = Sprite.new()
    @sprite.z = 6000
    @sprite.ox = 4
    change_cursor("Default")
  end

  def x() @pos[0] end
  def y() @pos[1] end
  
  def position() @pos; end
  def grid() 
    x = (@pos[0] + $map.display_x / 4) / 32
    y = (@pos[1] + 14 + $map.display_y / 4) / 32
    return [x.to_i,y.to_i]
  end
  def on_screen?() !(@pos[0] < 0 || @pos[1] < 0 || @pos[0] >= 640 || @pos[1] >= 480); end
        
  #--------------------------------------------------------------------------
  # * Update Mouse Position
  #--------------------------------------------------------------------------
  def update
    
    # Update Position
    pos = [0,0].pack('ll')
    Cursor_Pos.call(pos)
    Scr2cli.call(@hwnd, pos) 
    @pos = pos.unpack('ll')

    # Update sprite pos
    @sprite.x = @pos[0]
    @sprite.y = @pos[1]

    ShowCursor.call(0)#on_screen?.to_i) # on_screen && mouse_mode
    
  end

  def change_cursor(c)
    @sprite.bitmap = $cache.cursor(c)
  end

end

#==============================================================================
# ** Sprite_Mouse
#==============================================================================

class Sprite_Mouse < Sprite

  #--------------------------------------------------------------------------
  # ** Frame Update : Update Event Cursors
  #--------------------------------------------------------------------------
  def update_event_cursors
    
    # If Nil Grid Position
    if Mouse.grid.nil? 
      # Set Default Cursor
      set_bitmap(MouseCursor::Default_Cursor)
      return
    end
    
    # Gets Mouse Position
    x, y = *Mouse.grid
    
    # Gets Mouse Position
    mx, my = *Mouse.position    
    
    # Gets Mouse Event
    event = $game_map.lowest_event_at(x, y)
    
    # If Non-Nil Event or not over map HUD
    unless event.nil? || my >= 448
      # If Not Erased or Nil List
      if event.list != nil && event.erased == false && event.list[0].code == 108
        # Get the cursor to show
        icon = nil
        event.list[0].parameters.to_s.downcase.gsub!(/icon (.*)/) do
          icon = $1.to_s
        end
        
        if !((icon == "talk") || 
           (icon == "touch") || 
           (icon == "fight") || 
           (icon == "examine") || 
           (icon == "point") ||
           (icon == "exit"))
           icon = MouseCursor::Default_Cursor
        end        
        xNPCname = nil 
        if event.list.size > 1 && event.list[1].code == 108
          text = event.list[1].parameters.to_s
          text.gsub!(/[Nn][Aa][Mm][Ee] (.*)/) do
            xNPCname = $1.to_s
          end
        end
        set_bitmap(icon, xNPCname)  
        #self.x = self.x - self.bitmap.width + 24 if self.x + self.bitmap.width > 640
        if event.name != "BOTTOM" # and ["Arrow2", "Arrow4"].include?(icon)
          self.y -= 8
        end
        return
      end
      return
    end
    
    # Set Default Cursor
    set_bitmap(MouseCursor::Default_Cursor)
    
  end
end
"&#==============================================================================
# ** Game_Settings
#==============================================================================

class SettingsManager

  attr_accessor :music
  attr_accessor :sound
  attr_accessor :window
  attr_accessor :effects
  attr_accessor :mouse

  attr_accessor :debug_skip_title
  attr_accessor :debug_draw_fps
  attr_accessor :debug_draw_names
  attr_accessor :debug_draw_sprites # Draw rect under sprites
  

  # In settings
  attr_accessor :last_file_index          # last save file no.

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize

    # Defaults
    @music = false
    @sound = true
    @window = false
    @effects = false
    @mouse = false

    # Debug options - keys 1-9
    @debug_skip_title = true
    @debug_draw_fps = true
    @debug_draw_names = false
    @debug_draw_sprites = false
        
    # Load from settings file real quick   
    File.open($appdata+'\settings.txt', "r").each do |line|
      dta = line.split(" ")
      val = dta[1]
      if val.to_i.to_s == val
        val = val.to_i
      elsif val.to_f.to_s == val
        val = val.to_f
      elsif val == "true"
        val = true
      elsif val == "false"
        val = false
      end
      self.instance_variable_set(dta[0],val)
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Get/Set Settings
  #--------------------------------------------------------------------------
  def save() 
    File.open($appdata+'\settings.txt', 'w') { |file|  
      # Write some stats      
      self.instance_variables.each{ |var|
        next if !DEBUG && var.to_s.include?("debug")
        file.puts(var.to_s+" "+self.instance_variable_get(var).to_s)
      }
    }
  end

  def conclude
    @window = Win32API.new('Utils', "IsFullScreen", ["V"], "I").call
  end

end"Õ
class SteamManager

	def initialize
		# Sync with steam

		#dll, func, send, rec

		# Steam test
		log_info "STARTING STEAM"
    	log_info Win32API.new('System/steamstub', "OpenSteam", "I", "I").call(364270)
		log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	
    	log_info Win32API.new('System/steamstub', "GetSteamAchievement", "P", "I").call("START_GAME")
log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	log_info Win32API.new('System/steamstub', "SetSteamAchievement", "P", "I").call("START_GAME")
log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	log_info Win32API.new('System/steamstub', "GetSteamAchievement", "P", "I").call("START_GAME")
    	log_info Win32API.new('System/steamstub', "ReadSteam", "[]", "I").call
    	#stats =  Win32API.new('System/steam_api', "SteamUserStats", ["V"], "P").call     	

	end


	def unlock(ach)

	end

	def card(crd)

	end

end"#==============================================================================
# ** Nano Manager
#==============================================================================

class TweenManager

	def initialize
		@tweens = []
		@last = Time.now
	end

	def update

		# calc delta
		delta = ((Time.now - @last) * 1000).to_i
		@last = Time.now

		@tweens.delete_if{ |n| (n.is_a?(SpriteGroup) && n.disposed?) || (n.is_a?(Sprite) && n.disposed?) || n == nil || n.done? }
		
	    @tweens.each{ |n| n.update(delta) }

	end

	def register(tween)
		@tweens.push(tween)
	end

	def clear(object)
		@tweens.delete_if{ |n| n.parent == object } 
	end

	def resolve(object)
		@tweens.each{ |n| n.update(5000) if n.parent == object }
		clear(object)
	end

	def clear_all
		@tweens.clear
	end

	def done?(object)
		return @tweens.select{ |n| n.parent == object }.empty?
	end

end"øclass Bitmap

	def fill(color)
		self.fill_rect(0,0,self.width,self.height,color)
	end

	def fill_rand
		self.fill_rect(0,0,self.width,self.height,Color.new(rand(255),rand(255),rand(255)))
	end

	# xp windowskin style
	def windowskin(skin)
		src = $cache.windowskin(skin)
		dest = rect.dup
		dest.x += 3
		dest.y += 3
		dest.width -= 6
		dest.height -= 6
		stretch_blt(dest,src,Rect.new(0,0,128,128),210)

		w = 16
		h = 16
		sx = 128
		sy = 0

		o = 255

		# CORNERS
	    blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
	    blt(width-w,0,src,Rect.new(sx+48,sy,w,h),o) # top right
	    blt(0,height-h,src,Rect.new(sx,sy+48,w,h),o) # bottom left
	    blt(width-w,height-h,src,Rect.new(sx+48,sy+48,w,h),o) # bottom right
	    
	    #dest_rect, bmp, src_rect

	   #  # Middle
	   #stretch_blt(Rect.new(w,h,width-16,height-16),src,Rect.new(sx+16,0,w,h),o)

	   #  # left side
	   stretch_blt(Rect.new(0,h,w,height-32),src,Rect.new(sx,h+16,w,h),o)

	   #  # Right
	     stretch_blt(Rect.new(width-w,h,w,height-32),src,Rect.new(sx+48,h,w,h),o)

	   #  #top
	   stretch_blt(Rect.new(w,0,width-32,h),src,Rect.new(sx+16,0,w,h),o)

	   # #bottom
	   stretch_blt(Rect.new(w,height-h,width-32,h),src,Rect.new(sx+16,h+32,w,h),o)


	end

	def borderskin(src)

		# 32px corners, 64px edges

		w = 32
		h = 32

		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(96,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,96,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(96,96,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-64),src,Rect.new(0,h+16,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-64),src,Rect.new(96,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-64,32),src,Rect.new(32,0,64,32))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-64,32),src,Rect.new(32,96,64,32))

	end

	def skin(src)
		
		w = src.width/3
		h = src.height/3


		# Inside
		dest = Rect.new(w,h,width-w,height-h)
		srect = Rect.new(w,h,w,h)
		stretch_blt(dest,src,srect)
    	
		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(w*2,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,h*2,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(w*2,h*2,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-h),src,Rect.new(0,w,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-h),src,Rect.new(w*2,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-w,h),src,Rect.new(w,0,w,h))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-w,h),src,Rect.new(w,h*2,w,h))




	end

	def vskin(src)
		size = src.height/3
    	blt(0,0,src,Rect.new(0,0,src.width,size)) # top left
    	blt(0,height-size,src,Rect.new(0,size*2,src.width,size)) # bottom right    
    	stretch_blt(Rect.new(0,size,size,height-size),src,Rect.new(0,size,src.width,size))
	end

	def hskin(src)
		size = src.width/3
    	blt(0,0,src,Rect.new(0,0,size,src.height)) #left
    	blt(width-size,0,src,Rect.new(size*2,0,size,src.height)) # bottom right    
    	stretch_blt(Rect.new(size,0,width-size*2,src.height),src,Rect.new(size,0,size,src.height))
	end

end
"
class UsableData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :price
	attr_reader :action
	attr_reader :icon
	attr_reader :battle
	attr_accessor :tab
end

class KeyItemData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :chapter
	attr_accessor :tab
end

class ShopData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :value
	attr_accessor :tab
end

class GearData
	attr_reader :id
	attr_reader :name
	attr_reader :slot
	attr_reader :geartype
	attr_reader :description
	attr_reader :stats
	attr_reader :mods
	attr_reader :icon
	attr_reader :source
	attr_accessor :tab
end

class SkillData
	attr_reader :id
	attr_reader :name
	attr_reader :book
	attr_reader :description
	attr_reader :icon
	attr_reader :cost
	attr_reader :hits
	attr_reader :scope
	attr_reader :anim_a
	attr_reader :anim_b
	attr_reader :stats
	attr_reader :effects
end

class StateData
	attr_reader :id
	attr_reader :name
	attr_reader :stats
	attr_reader :mods
end

class ActorData
	attr_reader :id
	attr_reader :name
	attr_reader :profile
	attr_reader :actions
	attr_reader :resource
	attr_reader :slots
	attr_reader :mods
end

class EnemyData
	attr_reader :id
	attr_reader :name
	attr_reader :actions
	attr_reader :stats
	attr_reader :loot
end

class ZoneData
	attr_reader :id
	attr_reader :music
	attr_reader :atmosphere
	attr_reader :reverb
	attr_reader :tint
	attr_reader :weather
	attr_reader :fog
	attr_reader :panoramas
	attr_reader :enemies
end

class ProgressData
	attr_reader :category
	attr_reader :id
	attr_reader :value
end

class QuestData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :location
	attr_reader :req
	attr_reader :reward
	attr_reader :type
end

class AnimData
	attr_reader :id
	attr_reader :frames
	attr_reader :delay
	attr_reader :fadeout
	attr_reader :order
	attr_reader :blend
	attr_reader :opacity
	attr_reader :sound
end

class NumberData
	attr_reader :id
	attr_reader :value
	attr_reader :notes
end

"r#==============================================================================
# ** Gradient Font Color
#------------------------------------------------------------------------------
#   Original code by poccil
#   Rewritten by Dargor, 2008
#   05/07/08
#   Version 1.0
#------------------------------------------------------------------------------
#   VERSION HISTORY:
#    - 1.0 (05/07/08), Initial release
#------------------------------------------------------------------------------
#   INSTRUCTIONS:
#    - Paste this above main
#    - Edit the font's gradient parameters in a window like that:
#            self.contents.font.gradient = true/false
#            self.contents.font.gradient_color1 = color
#            self.contents.font.gradient_color2 = color
#            self.contents.font.gradient_mode = mode
#                  Modes: (0 : Vertical, 1: Horizontal, 2: Diagonal)
#    - By default, the gradient effect is on. You can turn it off by
#       setting the @gradient flag in the Font class to false. (*line 47)
#------------------------------------------------------------------------------
#   NOTES:
#       This script is compatible with both XP and VX
#==============================================================================
 
#==============================================================================
# ** Font
#==============================================================================
 
class Font
  
  attr_accessor :gradient
  attr_accessor :gradient_color1
  attr_accessor :gradient_color2
  
end
 
#==============================================================================
# ** Bitmap
#==============================================================================
 
class Bitmap

  #--------------------------------------------------------------------------
  # * Draw Text
  #--------------------------------------------------------------------------
  def draw_gtext(x,y,width,height,text,type=0)

      #return draw_text(*args) if !self.font.gradient

      # colors
      case type
        when 0
          c1 = Color.new(215,193,170)
        when 1
          c1 = Color.new(189,186,105)
      end      

      c2 = Color.new(255,255,255)
        
      # Align left only
      align = 0


      original_color = self.font.color
      alpha = original_color.alpha.to_f if alpha.nil?
      # Create temporary text bitmap
      text1=Bitmap.new(width, height)
      text2=Bitmap.new(width, height)
      text1.font.size = self.font.size
      text1.font.name = self.font.name
      text1.font.italic = self.font.italic
      text1.font.bold = self.font.bold
      text1.font.color = c1 #self.font.gradient_color2
      text_height = text1.text_size(text).height
      text_width = text1.text_size(text).width
      return if text_width < 1 or text_height < 1

      # Temporary remove the gradient effect
      text1.draw_text(0, 0, width, height, text, align)

      # What in the world .....
         text_position = (height / 2) - (text_height / 2)
         for i in 0...height
            if i < text_position
               opacity = 0
            elsif i > text_position + text_height
               opacity = 255
            else
               ratio = ((i - text_position) * 1.0 / text_height)
               ratio -=(0.5 - ratio) * 0.5
               #ratio += 0.2
               opacity = ratio * 255.0
               opacity = 255.0 if opacity > 255.0
               opacity = 0.0 if opacity < 0.0
            end
            text2.blt(0, i, text1, Rect.new(0,i,width,1), opacity)
         end


      # Draw gradient text
      self.font.color = c2 #self.font.gradient_color1
      self.font.color.alpha = alpha
      # Temporary remove the gradient effect
      self.font.gradient = false
      draw_text(x,y,width,height,text)
      # Temporary remove the gradient effect
      self.font.gradient = true
      self.font.color = original_color
      self.font.color.alpha = 255#alpha
      self.blt(x, y, text2, text2.rect, alpha)
      # Dispose gradient text bitmap
      text1.dispose
      text2.dispose

  end

end"È
class Group

	def initialize(args)

		@events = args

	end

	def method_missing(m,*args)

		@events.each{ |ev|
			if ev.is_a?(String)
				argstring = " '#{ev}',"
			else
				argstring = " #{ev},"
			end

			args.each{ |a|
				if a.is_a?(String)
					argstring+=(" '"+a+"',")
				else
					argstring+=(" "+a+",")
				end
			}
			eval(m.to_s[1..-1]+argstring.chop)
		}

	end

end

def grp(*args)
	return Group.new(args)
end"~# if !ACE_MODE
#   class Font
#     attr_accessor :outline, :shadow
#   end
# end


# module RPG
#   class Tileset
#     def initialize
#       @id = 0
#       @name = ""
#       @tileset_name = ""
#       @autotile_names = [""]*7
#       @panorama_name = ""
#       @panorama_hue = 0
#       @fog_name = ""
#       @fog_hue = 0
#       @fog_opacity = 64
#       @fog_blend_type = 0
#       @fog_zoom = 200
#       @fog_sx = 0
#       @fog_sy = 0
#       @battleback_name = ""
#       @passages = Table.new(384)
#       @priorities = Table.new(384)
#       @priorities[0] = 5
#       @terrain_tags = Table.new(384)
#     end
#     attr_accessor :id
#     attr_accessor :name
#     attr_accessor :tileset_name
#     attr_accessor :autotile_names
#     attr_accessor :panorama_name
#     attr_accessor :panorama_hue
#     attr_accessor :fog_name
#     attr_accessor :fog_hue
#     attr_accessor :fog_opacity
#     attr_accessor :fog_blend_type
#     attr_accessor :fog_zoom
#     attr_accessor :fog_sx
#     attr_accessor :fog_sy
#     attr_accessor :battleback_name
#     attr_accessor :passages
#     attr_accessor :priorities
#     attr_accessor :terrain_tags
#   end
# end

# module RPG
#   class System
#     def initialize
#       @magic_number = 0
#       @party_members = [1]
#       @elements = [nil, ""]
#       @switches = [nil, ""]
#       @variables = [nil, ""]
#       @windowskin_name = ""
#       @title_name = ""
#       @gameover_name = ""
#       @battle_transition = ""
#       @title_bgm = RPG::AudioFile.new
#       @battle_bgm = RPG::AudioFile.new
#       @battle_end_me = RPG::AudioFile.new
#       @gameover_me = RPG::AudioFile.new
#       @cursor_se = RPG::AudioFile.new("", 80)
#       @decision_se = RPG::AudioFile.new("", 80)
#       @cancel_se = RPG::AudioFile.new("", 80)
#       @buzzer_se = RPG::AudioFile.new("", 80)
#       @equip_se = RPG::AudioFile.new("", 80)
#       @shop_se = RPG::AudioFile.new("", 80)
#       @save_se = RPG::AudioFile.new("", 80)
#       @load_se = RPG::AudioFile.new("", 80)
#       @battle_start_se = RPG::AudioFile.new("", 80)
#       @escape_se = RPG::AudioFile.new("", 80)
#       @actor_collapse_se = RPG::AudioFile.new("", 80)
#       @enemy_collapse_se = RPG::AudioFile.new("", 80)
#       @words = RPG::System::Words.new
#       @test_battlers = []
#       @test_troop_id = 1
#       @start_map_id = 1
#       @start_x = 0
#       @start_y = 0
#       @battleback_name = ""
#       @battler_name = ""
#       @battler_hue = 0
#       @edit_map_id = 1
#     end
#     attr_accessor :magic_number
#     attr_accessor :party_members
#     attr_accessor :elements
#     attr_accessor :switches
#     attr_accessor :variables
#     attr_accessor :windowskin_name
#     attr_accessor :title_name
#     attr_accessor :gameover_name
#     attr_accessor :battle_transition
#     attr_accessor :title_bgm
#     attr_accessor :battle_bgm
#     attr_accessor :battle_end_me
#     attr_accessor :gameover_me
#     attr_accessor :cursor_se
#     attr_accessor :decision_se
#     attr_accessor :cancel_se
#     attr_accessor :buzzer_se
#     attr_accessor :equip_se
#     attr_accessor :shop_se
#     attr_accessor :save_se
#     attr_accessor :load_se
#     attr_accessor :battle_start_se
#     attr_accessor :escape_se
#     attr_accessor :actor_collapse_se
#     attr_accessor :enemy_collapse_se
#     attr_accessor :words
#     attr_accessor :test_battlers
#     attr_accessor :test_troop_id
#     attr_accessor :start_map_id
#     attr_accessor :start_x
#     attr_accessor :start_y
#     attr_accessor :battleback_name
#     attr_accessor :battler_name
#     attr_accessor :battler_hue
#     attr_accessor :edit_map_id
#   end
# end

# module RPG
#   class System
#     class Words
#       def initialize
#         @gold = ""
#         @hp = ""
#         @sp = ""
#         @str = ""
#         @dex = ""
#         @agi = ""
#         @int = ""
#         @atk = ""
#         @pdef = ""
#         @mdef = ""
#         @weapon = ""
#         @armor1 = ""
#         @armor2 = ""
#         @armor3 = ""
#         @armor4 = ""
#         @attack = ""
#         @skill = ""
#         @guard = ""
#         @item = ""
#         @equip = ""
#       end
#       attr_accessor :gold
#       attr_accessor :hp
#       attr_accessor :sp
#       attr_accessor :str
#       attr_accessor :dex
#       attr_accessor :agi
#       attr_accessor :int
#       attr_accessor :atk
#       attr_accessor :pdef
#       attr_accessor :mdef
#       attr_accessor :weapon
#       attr_accessor :armor1
#       attr_accessor :armor2
#       attr_accessor :armor3
#       attr_accessor :armor4
#       attr_accessor :attack
#       attr_accessor :skill
#       attr_accessor :guard
#       attr_accessor :item
#       attr_accessor :equip
#     end
#   end
# end

# module RPG
#   class System
#     class TestBattler
#       def initialize
#         @actor_id = 1
#         @level = 1
#         @weapon_id = 0
#         @armor1_id = 0
#         @armor2_id = 0
#         @armor3_id = 0
#         @armor4_id = 0
#       end
#       attr_accessor :actor_id
#       attr_accessor :level
#       attr_accessor :weapon_id
#       attr_accessor :armor1_id
#       attr_accessor :armor2_id
#       attr_accessor :armor3_id
#       attr_accessor :armor4_id
#     end
#   end
# end


"4 class Array
 	def count
 		return length
 	end
 	def sample
      self[rand(length)]
  end
  def shuffle
    return self.sort_by { rand }
  end
 end

 class String
  def is_integer?
    self.to_i.to_s == self
  end
  def numeric?
    return true if self =~ /\A\d+\Z/
    true if Float(self) rescue false
  end
  def to_b
    return self == "true"
  end
end

class FalseClass; def to_i; 0 end end
class TrueClass; def to_i; 1 end end


class Fixnum
	def odd?
		return self % 2 == 1
	end
  def include?(a)
    false
  end
end

"# Extensions to sprite class

class Sprite

	def hide
		self.visible = false
	end

	def show
		self.visible = true
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def center(x,y)
		self.x = x - width/2
		self.y = y - height/2
	end

	def width
		return self.bitmap.width
	end

	def height 
		return self.bitmap.height
	end

	def within?(x,y)
		return false if x < self.x
		return false if y < self.y
		return false if x > self.x + width
		return false if y > self.y + height
		return true
	end

end"Ò#==============================================================================
# ** Console
#==============================================================================

class DebugConsole

	INPUT_COLOR = Color.new(30,30,30,210)

	MAX_LOGS = 11


	def initialize(vp)

		# Prepare log
		@history = []
		@console_text = ""
		@console_sprite = Sprite.new(vp)
		@console_sprite.move(0,410)
		refresh_console

		# Showing previous
		@logs = []
		@osd_sprite = Sprite.new(vp)

		hide

	end

	def update

		# If console not showing
		if !active?
			show if $keyboard.press?(VK_TAB) 
		end

		# Hide console if press TILDE
		hide if active? && $keyboard.press?(VK_TAB)
		hide if active? && $keyboard.press?(VK_ESC)

		if !active?
			if $keyboard.state?(VK_BS)
				@osd_sprite.show
			else
				@osd_sprite.hide
			end
		end

		return if !active?

		# Show last
		if $keyboard.press?(VK_DOWN)
			@console_text = @history.empty? ? "" : @history.pop
			refresh_console
		end
									
		# Check console input
		console_chars.each{ |c|
			if $keyboard.press?(c)
				@console_text += $keyboard.to_char(c)
				refresh_console
			end
		}

		# Check inputs now
		if $keyboard.press?(VK_ENTER)
			begin
				eval(@console_text)
			rescue Exception => e
			 	log_scr(e.class.to_s+" --- '" + @console_text + "'")		      
		    end
		    @history.push(@console_text)
			@console_text = ""
			refresh_console
		end

		if $keyboard.hold?(VK_BS)
			@console_text.chop!
			refresh_console
		end

	end

	def hide
		@console_sprite.hide
		@osd_sprite.hide
	end

	def show
		@console_sprite.show
		@osd_sprite.show
	end

	def active?
		return @console_sprite.visible
	end

	def refresh_console
		@console_sprite.bitmap = Bitmap.new(640,60)

		@console_sprite.bitmap.fill_rect(0,0,640,30,INPUT_COLOR)
		@console_sprite.bitmap.draw_text(8,0,640,30,"-> "+@console_text) # Make gfx.width

		if !@history.empty?
			@console_sprite.bitmap.fill_rect(0,30,640,30,Color.new(0,0,0,120))
			@console_sprite.bitmap.draw_text(8,30,640,30,"   "+@history[-1]) # Make gfx.width
		end	

	end

	def refresh_osd

		@osd_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		cx = 0
		cy = 6

		@osd_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@osd_sprite.bitmap.font.size = 28
		@osd_sprite.bitmap.draw_text(cx+8,cy,640,50,"::LOG HISTORY::")

		cy += 60

		@osd_sprite.bitmap.font.size = 22

		@logs.each{ |log|

			out = log[0]
			color = log[1]

			size = @osd_sprite.bitmap.text_size(out)
			@osd_sprite.bitmap.fill_rect(cx,cy,size.width+20,size.height+6,color)
			@osd_sprite.bitmap.draw_text(cx+8,cy+3,600,size.height,out)

			cy += 32

		}

	end

	def log(msg)

		@logs.push(msg)
		@logs.shift while @logs.count > MAX_LOGS
		refresh_osd

	end

	def console_chars
		chars = (48..57).to_a
		chars += (65..90).to_a
		chars += (186..222).to_a
		chars += [32]
		return chars
	end

end"Cmodule Graphics
 
  @fps, @fps_tmp = 0, []
 
  class << self
    
    attr_reader :fps
    
    alias fps_update update unless method_defined?(:fps_update)
    def update

      if !$settings.debug_draw_fps
      	fps_sprite.hide
      	back_sprite.hide
      	fps_update
      	return
      else
		fps_sprite.show
      	back_sprite.show
      end

	  t = Time.now
	  fps_update
	  @fps_tmp[frame_count % frame_rate] = Time.now != t
	  @fps = 0
	  frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
	  fps_sprite.src_rect.y = @fps * 30

	  if @old_color != $debug.last_color
	  	back_sprite.bitmap.fill($debug.last_color)
	  	@old_color = $debug.last_color
	  end

    end
    
    def fps_sprite
	  if !@fps_sprite or @fps_sprite.disposed?
	    @fps_sprite = Sprite.new
	    @fps_sprite.z = 9999
	    @fps_sprite.x = $game.width-45
	    @fps_sprite.y = 16
	    @fps_sprite.bitmap = Bitmap.new(30, 30*62)
	    @fps_sprite.bitmap.font.size = 28
	    @fps_sprite.bitmap.font.name = "Consolas"
	    @fps_sprite.bitmap.font.color.set(255, 255, 255)
	    61.times {|i| @fps_sprite.bitmap.draw_text(-2, i*30, 36, 30, "% 3d"%i)}
	    @fps_sprite.bitmap.draw_text(-2, 61*30, 36, 30, "++")
	    @fps_sprite.src_rect.height = 30
	  end
	  return @fps_sprite
    end

    def back_sprite
	  if !@back_sprite or @back_sprite.disposed?
	    @back_sprite = Sprite.new
	    @back_sprite.z = 9997
	    @back_sprite.x = $game.width-40
	    @back_sprite.y = 16
	    @back_sprite.bitmap = Bitmap.new(30, 30)
	  end
	  return @back_sprite
    end
    
  end
end"7#==============================================================================
# ** Actions
#==============================================================================

class DebugMenu

	def initialize(vp)

		@actions = []
		@idx = 0

		@mnu_sprite = Sprite.new(vp)
		@idx_sprite = Sprite.new(vp)
		@text_sprite = Sprite.new(vp)
		@text_sprite.z += 10

		@idx_sprite.y = 10

		@menu_title = "DEBUG MENU"

		@esc = Proc.new{ hide }

		@cursor_pos = {}

		page(:main)

		hide

	end

	def page(newpage)

		@cursor_pos[@page] = @idx

		clear

		@page = newpage

		case newpage
			when :main

				add(">> General Settings",Proc.new{ page(:settings) })
				add(">> Debug Settings",Proc.new{ page(:debug) })
				
				add("-- Progress: #{$progress.get_progress}",nil) if !$progress.nil?

				@esc = Proc.new{ hide }

			when :settings

				@menu_title = "GENERAL SETTINGS"

				add(":: Toggle Fullscreen",Proc.new{ $game.flip_window })

				@esc = Proc.new{ page(:main) }

			when :debug

				@menu_title = "DEBUG SETTINGS"

				add(":: Toggle skip title - "+$settings.debug_skip_title.to_s.upcase,Proc.new{ $settings.debug_skip_title ^= true })
				add(":: Toggle draw fps - "+$settings.debug_draw_fps.to_s.upcase,Proc.new{ $settings.debug_draw_fps ^= true })
				add(":: Toggle draw names - "+$settings.debug_draw_names.to_s.upcase,Proc.new{ $settings.debug_draw_names ^= true })

				@esc = Proc.new{ page(:main) }

		end
		refresh
	end


	def clear
		#@idx = 0
		@actions.clear
		refresh
	end

	def add(text,proc)
		@actions.push([text,proc])
	end

	def update

		if $keyboard.press?(VK_TILDE)
			active? ? @esc.call : show
		end

		if $keyboard.press?(VK_ESC)
			@esc.call if active?
		end

		return if !active?

		if $keyboard.press?(VK_ENTER)
			@actions[@idx][1].call if @actions[@idx][1] != nil
			page(@page)
		end
		
		if $keyboard.press?(VK_DOWN)
			@idx += 1 if @idx != @actions.count - 1
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		if $keyboard.press?(VK_UP)
			@idx -= 1 if @idx != 0
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		@idx_sprite.y = 66 + (@idx * 34)
		

		#refresh

	end

	def refresh


		@idx = @cursor_pos.has_key?(@page) ? @cursor_pos[@page] : 0

		@mnu_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)
		@text_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		@idx_sprite.bitmap = Bitmap.new(400,30)
		@idx_sprite.bitmap.fill(Color.new(40,110,170,240))

		cx = 0
		cy = 6

		@mnu_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@text_sprite.bitmap.font.size = 28
		@text_sprite.bitmap.draw_text(cx+8,cy,640,50,"::"+@menu_title+"::")

		cy += 60

		@text_sprite.bitmap.font.size = 22

		@actions.each_index{ |i|

			out = @actions[i][0]
			color = Color.new(30,30,30,210)

			size = @mnu_sprite.bitmap.text_size(out)
			@mnu_sprite.bitmap.fill_rect(cx,cy,400,30,color)
			@text_sprite.bitmap.draw_text(cx+8,cy+0,600,size.height+6,out)

			cy += 34

		}

	end


	def show
		page(:main)
		@mnu_sprite.show
		@idx_sprite.show
		@text_sprite.show
	end

	def hide
		@mnu_sprite.hide
		@idx_sprite.hide
		@text_sprite.hide
	end

	def active?
		@mnu_sprite.visible
	end

end


"Ú#==============================================================================
# ** SpellCheck
#==============================================================================

def execute_spellcheck
    
    data = {} # map name, dialogues?
    
    # Each map
    $data_maps.each{ |k,v| 
    
      map_id = k
      map_name = v.name
      
      event_list = load_data(sprintf("Data/Map%03d.rvdata2",map_id)).events
      next if event_list.empty?
      
      events = {}
      
      # Do for each event
      event_list.each{ |k,v|
      
        ev_id = k
        ev_name = v.name
        
        dialogues = []
        
        # Do for each page
        v.pages.each{ |page|
        
        @cmd_idx = 0        
        while page.list[@cmd_idx] do

            # Do something according to command          
            case page.list[@cmd_idx].code
            
              when 101; # Short text
                
                text = ""
                while page.list[@cmd_idx+1].code == 401       # Text data
                  @cmd_idx += 1
                  text += page.list[@cmd_idx].parameters[0]
                  text += ' '      
                end
                dialogues.push(text)
                
              when 105; # Long text
            
                while page.list[@cmd_idx+1].code == 405
                  @cmd_idx += 1
                  line = page.list[@cmd_idx].parameters[0]
                  if line[0] == "@"
                    dialogues[dialogues.size-1] += " " + line
                  else
                    dialogues.push(line)
                  end
                end
            
            end
              
            @cmd_idx += 1  
          
          end # page        
        
        }

        # any dialogues? save it
        if !dialogues.empty?
          #p dialogues
          events[[ev_id,ev_name]] = dialogues
        end
        
      }

      # Add to overall
      if !events.empty?
        data[[map_id,map_name]] = events
      end
      
      #p name
      #p event_list.size
      
      
      #break
      
      
    }
    
    # Output to file
    # Create a new file and write to it  
    File.open('spellcheck.txt', 'w') do |file|  

      # Write some stats
      file.puts("Total Maps: "+$data_maps.size.to_s)
      file.puts("Maps with dialogue: "+data.size.to_s)

      # Word counts
      words = 0
      data.values.each{ |map|
        map.values.each{ |ev|
          ev.each{ |line|
            words += line.split(" ").size
          }
        }
      }
      file.puts("Word Count: "+words.to_s)

      file.puts("\n")
      file.puts("\n")

      # Each Map
      data.each{ |mk,mv|

        # Map name
        file.puts("Map "+mk[0].to_s+": "+mk[1])
        file.puts("----------------------------------------")
        file.puts("\n")

        # Contents
        mv.each{ |ek,ev|

          # Event name
          file.puts("Event "+ek[0].to_s+": "+ek[1])

          # Event contents
          ev.each{ |line|
            file.puts(line)
          }

          file.puts("\n")

        }
        file.puts("\n")
      }

    end  

    
  end"O# Fullscreen++ v2.2 for VX and VXace by Zeus81
# Free for non commercial and commercial use
# Licence : http://creativecommons.org/licenses/by-sa/3.0/
# Contact : zeusex81@gmail.com
# (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
# (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
 
 if ACE_MODE


class << Graphics
  Disable_VX_Fullscreen = false
 
  CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
  GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
  GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
  GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
  GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
  FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
  FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
  ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
  SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
  SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
  SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
  ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
  SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
  UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
  GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
  WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
  CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
  DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
 
  unless method_defined?(:zeus_fullscreen_update)
    HWND     = FindWindow.call('RGSS Player', 0)
    BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
    alias zeus_fullscreen_resize_screen resize_screen
    alias zeus_fullscreen_update        update
  end
private
  def initialize_fullscreen_rects
    @borders_size    ||= borders_size
    @fullscreen_rect ||= screen_rect
    @workarea_rect   ||= workarea_rect
  end
  def borders_size
    GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
    GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
    wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
    Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
  end
  def screen_rect
    Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
  end
  def workarea_rect
    SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
    rect = rect.unpack('l4')
    Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
  end
  def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
  def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
  def hide_back()    ShowWindow.call(BackHWND, 0)              end
  def show_back
    ShowWindow.call(BackHWND, 3)
    UpdateWindow.call(BackHWND)
    dc    = GetDC.call(BackHWND)
    rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
    brush = CreateSolidBrush.call(0)
    FillRect.call(dc, rect, brush)
    ReleaseDC.call(BackHWND, dc)
    DeleteObject.call(brush)
  end
  def resize_window(w, h)
    if @fullscreen
      x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
    else
      w += @borders_size.width
      h += @borders_size.height
      x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
      y = @workarea_rect.y + (@workarea_rect.height - h) / 2
      z = -2
    end
    SetWindowPos.call(HWND, z, x, y, w, h, 0)
  end
  def release_alt
    inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
    SendInput.call(3, inputs, 28)
  end
public
  def load_fullscreen_settings
    buffer = [].pack('x256')
    section = 'Fullscreen++'
    filename = './Game.ini'
    get_option = Proc.new do |key, default_value|
      l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
      buffer[0, l]
    end
    @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
    @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
    @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
    toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
    fullscreen? ? fullscreen_mode : windowed_mode
  end
  def save_fullscreen_settings
    section = 'Fullscreen++'
    filename = './Game.ini'
    set_option = Proc.new do |key, value|
      WritePrivateProfileString.call(section, key, value.to_s, filename)
    end
    set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
    set_option.call('FullscreenRatio', @fullscreen_ratio)
    set_option.call('WindowedRatio'  , @windowed_ratio)
  end
  def fullscreen?
    @fullscreen or vx_fullscreen?
  end
  def vx_fullscreen?
    rect = screen_rect
    rect.width == 640 and rect.height == 480
  end
  def toggle_fullscreen
    fullscreen? ? windowed_mode : fullscreen_mode
  end
  def toggle_vx_fullscreen
    windowed_mode if @fullscreen and !vx_fullscreen?
    inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
    SendInput.call(4, inputs, 28)
    zeus_fullscreen_update
    self.ratio += 0 # refresh window size
  end
  def vx_fullscreen_mode
    return if vx_fullscreen?
    toggle_vx_fullscreen
  end
  def fullscreen_mode
    return if vx_fullscreen?
    initialize_fullscreen_rects
    show_back
    hide_borders
    @fullscreen = true
    self.ratio += 0 # refresh window size
  end
  def windowed_mode
    toggle_vx_fullscreen if vx_fullscreen?
    initialize_fullscreen_rects
    hide_back
    show_borders
    @fullscreen = false
    self.ratio += 0 # refresh window size
  end
  def toggle_ratio
    return if vx_fullscreen?
    self.ratio += 1
  end
  def ratio
    return 1 if vx_fullscreen?
    @fullscreen ? @fullscreen_ratio : @windowed_ratio
  end
  def ratio=(r)
    return if vx_fullscreen?
    initialize_fullscreen_rects
    r = 0 if r < 0
    if @fullscreen
      @fullscreen_ratio = r
      w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
    else
      @windowed_ratio = r
      w_max = @workarea_rect.width  - @borders_size.width
      h_max = @workarea_rect.height - @borders_size.height
    end
    if r == 0
      w, h = w_max, w_max * height / width
      h, w = h_max, h_max * width / height if h > h_max
    else
      w, h = width * r, height * r
      return self.ratio = 0 if w > w_max or h > h_max
    end
    resize_window(w, h)
    save_fullscreen_settings
  end
  def update
    release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
    zeus_fullscreen_update
    toggle_fullscreen if Input.trigger?(Input::F5)
    toggle_ratio      if Input.trigger?(Input::F6)
  end
  def resize_screen(width, height)
    zeus_fullscreen_resize_screen(width, height)
    self.ratio += 0 # refresh window size
  end
end
Graphics.load_fullscreen_settings


end"ê# if ACE_MODE
  
#   def set_rez(width,height)

#     eval "

#     # Do not edit
#     wt, ht = width.divmod(32), height.divmod(32)
#     #wt.last + ht.last == 0 || fail('Incorrect width or height')
#     wh = -> w, h, off = 0 { [w + off, h + off].pack('l2').scan /.{4}/ }
#     w, h = wh.(width, height)
#     ww, hh = wh.(width, height, 32)
#     www, hhh = wh.(wt.first.succ, ht.first.succ)
#     base = 0x10000000  # fixed?
#     mod = -> adr, val { DL::CPtr.new(base + adr)[0, val.size] = val }
#     mod.(0x195F, \"\x90\" * 5)  # ???   
#     mod.(0x19A4, h)
#     mod.(0x19A9, w)
#     mod.(0x1A56, h)
#     mod.(0x1A5B, w)
#     mod.(0x20F6, w)
#     mod.(0x20FF, w)
#     mod.(0x2106, h)
#     mod.(0x210F, h)
#     # speed up y?
#     #mod.(0x1C5E3, h)
#     #mod.(0x1C5E8, w)
#     zero = [0].pack ?l
#     mod.(0x1C5E3, zero)
#     mod.(0x1C5E8, zero)
#     mod.(0x1F477, h)
#     mod.(0x1F47C, w)
#     mod.(0x211FF, hh)
#     mod.(0x21204, ww)
#     mod.(0x21D7D, hhh[0])
#     mod.(0x21E01, www[0])
#     mod.(0x10DEA8, h)
#     mod.(0x10DEAD, w)
#     mod.(0x10DEDF, h)
#     mod.(0x10DEF0, w)
#     mod.(0x10DF14, h)
#     mod.(0x10DF18, w)
#     mod.(0x10DF48, h)
#     mod.(0x10DF4C, w)
#     mod.(0x10E6A7, w)
#     mod.(0x10E6C3, h)
#     mod.(0x10EEA9, w)
#     mod.(0x10EEB9, h)
#     Graphics.resize_screen width, height
#     GC.start"

#   end

# else

#   def set_rez(x,y)
#     log_err "Can't resize in XP mode"
#   end

# end"^#=============================================================================
# * Snapshot script from screenshot.dll, Modified from GAMEGUY's SCRIPT
#=============================================================================
module Snapshot
  def self.snap
    snp = Win32API.new('screenshot.dll', 'Screenshot', %w(l l l l p l l), '')
    window = Win32API.new('user32', 'FindWindowA', %w(p p), 'l')
    ini = (Win32API.new 'kernel32', 'GetPrivateProfileStringA', %w(p p p p l p), 
      'l')
    game_name = '\0' * 256
    ini.call('Game', 'Title', '', game_name, 255, '.\Game.ini')
    game_name.delete!('\0')
    win = window.call('RGSS Player', game_name)
    count = 0
    
    file_name = "Graphics/Pictures/temp_screenshot#{rand(30)}.png"


    log_info 'works to here'

    snp.call(0, 0, 640, 480, file_name, win, 2)
  end
end"A
# Moved to System/_seal for now to run before AudioManager"1# # Zeus Video Player v2.3 for XP, VX and VXace by Zeus81
# # Free for commercial use
# # Licence : http://creativecommons.org/licenses/by/4.0/
# # Contact : zeusex81@gmail.com
# #
# # How to Use :
# #   Graphics.play_movie( filename, cancellable, fit_to_screen )
# #   - filename = path of the video file.
# #   - cancellable = true if you want to allow the player to stop the video
# #                   by pressing Enter or Escape, false otherwise.
# #                   This option can be omitted and default value is true.
# #   - fit_to_screen = true if you want the video to be stretched to fit the screen in
# #                     case it doesn't match, false if you just want it to be centered.
# #                     If you're using scripts like Fullscreen++ true is recommended.
# #                     This option can be omitted and default value is true.
# #   ex : Graphics.play_movie( "Movies/prout.avi", true, true )
# #   or   Graphics.play_movie( "Movies/prout.avi" )
# #
# # Codec choice :
# #   I haven't tested all of them but I guess wmv9 (standard) would be a good choice.
# #   You can find a list of codecs installed by default on windows here :
# #   http://support.microsoft.com/kb/899113
# #
# # Background Image :
# #   You can choose the background image of the player (in case your video doesn't fill all the space).
# #   It will automatically load the image named "ZeusVideoPlayer" if found in Pictures folder (the extension doesn't matter).
# #   If not found it will be black.
# #
# # Known bugs :
# #  - With some video codecs stretching to fit screen doesn't work in fullscreen mode.
# #  - When switching fullscreen mode during playback the display can freeze.
# #  - Sometimes the display doesn't render when playing a video for the second time.
# #  - Weird behaviour in fullscreen mode.
# #
# # ZVP_OldAviMode :
# #   Just bellow you can enable this mode by setting the variable to true.
# #   Advantages :
# #     - More stable, no known bugs.
# #   Drawbacks :
# #     - It can only play avi files.
# #     - You must use vfw codecs for video, and windows defaults vfw codecs are very limited.
# #       Exhaustive list : MS RLE, MS Video 1, Cinepak, iyuv. And they all sucks.
# #       Any other codec will require to be installed on user side to ensure that it's supported.
# #       But if it's not a problem then you can find very nice vfw codecs on the internet, eg x264vfw.
# #     - You must use acm codecs for audio.
# #       Windows defaults : mp3, pcm.
# #       You can also find better codecs like aac acm.
 
# module Graphics
#   ZVP_OldAviMode = false
# end
 
# $imported ||= {}
# $imported[:Zeus_Video_Player] = __FILE__
 
# def xp?() false end ; 
# def vx?() false end ; 
# def vxace?() false end
  
# RUBY_VERSION == '1.8.1' ? defined?(Hangup) ?
# def xp?() true  end : def vx?() true  end : def vxace?() true  end
 
# #Cache = RPG::Cache if xp?
 
# class String
#   alias getbyte  []
#   alias setbyte  []=
#   alias bytesize size
# end unless vxace?
 
# module Zeus
#   module Encode # 1.1
#     MultiByteToWideChar = Win32API.new('kernel32', 'MultiByteToWideChar', 'iipipi'  , 'i')
#     WideCharToMultiByte = Win32API.new('kernel32', 'WideCharToMultiByte', 'iipipipp', 'i')
#     CodePages = {
#       'ANSI'=>0, 'OEM'=>1, 'MAC'=>2, 'THREAD_ANSI'=>3, 'SYMBOL'=>42,
#       'WINDOWS874'=>874, 'SHIFT_JIS'=>932, 'BIG5'=>950, 'WINDOWS1250'=>1250,
#       'WINDOWS1251'=>1251, 'WINDOWS1252'=>1252, 'WINDOWS1253'=>1253,
#       'WINDOWS1254'=>1254, 'WINDOWS1255'=>1255, 'WINDOWS1256'=>1256,
#       'WINDOWS1257'=>1257, 'WINDOWS1258'=>1258, 'US_ASCII'=>20127,
#       'ISO8859_1'=>28591, 'ISO8859_2'=>28592, 'ISO8859_3'=>28593,
#       'ISO8859_4'=>28594, 'ISO8859_5'=>28595, 'ISO8859_6'=>28596,
#       'ISO8859_7'=>28597, 'ISO8859_8'=>28598, 'ISO8859_9'=>28599,
#       'ISO8859_13'=>28603, 'ISO8859_15'=>28605, 'ISO8859_8I'=>38598,
#       'ISO2022_JP'=>50220, 'ISO2022_KR'=>50225, 'ISO2022_CN'=>50227,
#       'EUC_JP'=>51932, 'EUC_CN'=>51936, 'EUC_KR'=>51949, 'GB2312'=>52936,
#       'UTF7'=>65000, 'UTF8'=>65001, 'UTF16'=>-1
#     }
#     def self.encode(str, from, to, dchar=nil, dflag=nil)
#       if from != -1
#         l = MultiByteToWideChar.call(from, 0, str, str.bytesize, nil, 0)
#         utf16 = [].pack('x') * (l*2)
#         MultiByteToWideChar.call(from, 0, str, str.bytesize, utf16, l)
#       else utf16 = str
#       end
#       if to != -1
#         l = WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, nil, 0, dchar, dflag)
#         str = [].pack('x') * l
#         WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, str, l, dchar, dflag)
#       else str = utf16
#       end
#       case to
#       when 20127; str.force_encoding('US-ASCII')
#       when 65001; str.force_encoding('UTF-8')
#       when    -1; str.force_encoding('UTF-16LE')
#       end if vxace?
#       str
#     rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
#     end
#     def self.method_missing(method, str, *options)
#       from, to = *method.to_s.upcase.split('_TO_', 2).map! {|s| CodePages[s]}
#       super unless from and to
#       encode(str, from, to, *options)
#     rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
#     end
#   end
# end
 
# module Graphics
#   DefWindowProc       = Win32API.new('user32', 'DefWindowProc'      , 'iiii', 'i')
#   DestroyWindow       = Win32API.new('user32', 'DestroyWindow'      , 'i'   , 'i')
#   EnableWindow        = Win32API.new('user32', 'EnableWindow'       , 'ii'  , 'i')
#   FindWindow          = Win32API.new('user32', 'FindWindow'         , 'pp'  , 'i')
#   GetClientRect       = Win32API.new('user32', 'GetClientRect'      , 'ip'  , 'i')
#   GetForegroundWindow = Win32API.new('user32', 'GetForegroundWindow', ''    , 'i')
#   GetMessage          = Win32API.new('user32', 'GetMessage'         , 'piii', 'i')
#   GetWindowLong       = Win32API.new('user32', 'GetWindowLong'      , 'ii'  , 'i')
#   PostMessage         = Win32API.new('user32', 'PostMessage'        , 'iiii', 'i')
#   RedrawWindow        = Win32API.new('user32', 'RedrawWindow'       , 'ipii', 'i')
#   SetWindowLong       = Win32API.new('user32', 'SetWindowLong'      , 'iii' , 'i')
#   MciGetErrorString   = Win32API.new('winmm' , 'mciGetErrorStringW' , 'ipi' , 'i')
#   MciSendString       = Win32API.new('winmm' , 'mciSendStringW'     , 'ppii', 'i')
#   class << self
#     def hwnd() @hwnd ||= FindWindow.call('RGSS Player', nil) end
#     def play_movie(filename, cancellable = true, fit_to_screen = true)
#       @zvp ||= {:buffer => [].pack('x') * 256}
#       @zvp[:filename] = Dir["#{filename}.*"][0] || filename
#       @zvp[:cancellable] = cancellable
#       @zvp[:fit_to_screen] = fit_to_screen
#       return unless open_video_player
#       back_sprite = Sprite.new
#       back_sprite.z = 0x7FFF_FFFF
#       begin
#         cached = true
#         back_sprite.bitmap = $cache.picture('ZeusVideoPlayer')
#         back_sprite.zoom_x = width  / back_sprite.bitmap.width.to_f
#         back_sprite.zoom_y = height / back_sprite.bitmap.height.to_f
#       rescue
#         cached = false
#         back_sprite.bitmap = Bitmap.new(1, 1)
#         back_sprite.bitmap.set_pixel(0, 0, Color.new(0,0,0))
#         back_sprite.zoom_x = width
#         back_sprite.zoom_y = height
#       end
#       frame_reset
#       update
#       update_video_player
#       back_sprite.bitmap.dispose unless cached
#       back_sprite.dispose
#     ensure
#       close_video_player
#     end
#     def width()  640 end unless method_defined?(:width)
#     def height() 480 end unless method_defined?(:height)
#   private
#     def mci(command)
#       error = mci_silent(command)
#       return true if error == 0
#       MciGetErrorString.call(error, @zvp[:buffer], @zvp[:buffer].bytesize/2)
#       print(mci_result, "\nCommand : ", command)
#       return false
#     end
#     def mci_silent(command)
#       command = Zeus::Encode.utf8_to_utf16("#{command}\0")
#       MciSendString.call(command, @zvp[:buffer], @zvp[:buffer].bytesize/2, hwnd)
#     end
#     def mci_result
#       str = Zeus::Encode.utf16_to_utf8(@zvp[:buffer])
#       str[0, str.index("\0")]
#     end
#     def open_video_player(position=0)
#       if ZVP_OldAviMode
#         return false unless mci("open \"#{@zvp[:filename]}\" type AVIVideo alias ZeusVideoPlayer")
#         return false unless mci("window ZeusVideoPlayer handle #{hwnd}")
#         return false unless mci("play ZeusVideoPlayer from #{position} notify")
#       else
#         return false unless mci("open \"#{@zvp[:filename]}\" type MPEGVideo style Child parent #{hwnd} alias ZeusVideoPlayer")
#         return false unless mci("play ZeusVideoPlayer from #{position} notify")
#         return false unless mci('status ZeusVideoPlayer window handle')
#         @zvp[:hwnd] = mci_result.to_i
#         EnableWindow.call(@zvp[:hwnd], 0)
#         style = GetWindowLong.call(hwnd, -16) #GWL_STYLE
#         SetWindowLong.call(hwnd, -16, style | 0x02000000) #WS_CLIPCHILDREN
#       end
#       return true
#     end
#     def close_video_player
#       if !ZVP_OldAviMode and @zvp[:hwnd]
#         DestroyWindow.call(@zvp[:hwnd])
#         @zvp[:hwnd] = nil
#       end
#       mci_silent('stop ZeusVideoPlayer')
#       mci_silent('close ZeusVideoPlayer')
#     end
#     def resize_video_player
#       if mci_silent('where ZeusVideoPlayer source') == 0
#         x, y, w, h = *mci_result.split(' ', 4).map! {|s| s.to_i}
#         GetClientRect.call(hwnd, @zvp[:buffer])
#         client_w, client_h = *@zvp[:buffer].unpack('x8L2')
#         if @zvp[:fit_to_screen]
#           ratio = w / h.to_f
#           w, h = client_w, (client_w / ratio).round
#           h, w = client_h, (client_h * ratio).round if h > client_h
#         end
#         x, y = (client_w-w)/2, (client_h-h)/2
#         window = ZVP_OldAviMode ? 'destination' : 'window'
#         mci_silent("put ZeusVideoPlayer #{window} at #{x} #{y} #{w} #{h}")
#       end
#       RedrawWindow.call(@zvp[:hwnd] || hwnd, nil, 0, 0)
#     end
#     def update_video_player
#       focus = false
#       loop do
#         GetMessage.call(@zvp[:buffer], 0, 0, 0)
#         DefWindowProc.call(*msg = @zvp[:buffer].unpack('L4'))
#         if focus != (GetForegroundWindow.call == hwnd)
#           focus = !focus
#           mci_silent("#{focus ? 'resume' : 'pause'} ZeusVideoPlayer")
#           resize_video_player
#         end
#         next unless focus
#         Input.update
#         # if Input.trigger?(Input::B) or Input.trigger?(Input::C)
#           mci_silent('stop ZeusVideoPlayer') if @zvp[:cancellable]
#         elsif Input.trigger?(Input::F5) or Input.trigger?(Input::F6)
#           if $imported[:Zeus_Fullscreen] and !vx_fullscreen?
#             update
#             resize_video_player
#           end
#         end
#         case msg[1]
#         when 0x0012 #WM_QUIT
#           exit
#         when 0x0100 #WM_KEYDOWN
#           next if msg[3][30] == 1
#           case msg[2]
#           when 0x70, 0x7B #VK_F1, VK_F12
#             focus = false
#             mci_silent('pause ZeusVideoPlayer')
#             PostMessage.call(*msg)
#             update
#           end
#         when 0x0104 #WM_SYSKEYDOWN
#           next if msg[2] != 0x0D or msg[3][30] == 1
#           next if $imported[:Zeus_Fullscreen] and Disable_VX_Fullscreen
#           if ZVP_OldAviMode
#             PostMessage.call(*msg)
#             update
#             resize_video_player
#           else
#             next if mci_silent('status ZeusVideoPlayer position') != 0
#             position = mci_result.to_i
#             close_video_player
#             PostMessage.call(*msg)
#             update
#             break unless open_video_player(position)
#             resize_video_player
#           end
#         else
#           mci_silent('status ZeusVideoPlayer length')
#           length = mci_result.to_i
#           mci_silent('status ZeusVideoPlayer position')
#           break if mci_result.to_i >= length
#           mci_silent('status ZeusVideoPlayer mode')
#           break if mci_result == 'stopped'
#         end
#       end
#     end
#     if xp?
#       alias anti_hangup_update_video_player update_video_player
#       def update_video_player
#         anti_hangup_update_video_player
#       rescue Hangup
#         retry
#       end
#     end
#   end
# end">
# Copyright (c) 2013 DamiÃ¡n Silvani

# MIT License

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# https://github.com/munshkr/easing-ruby

  # Added function
  def easing(t,b,c,d,e)

  	t = t.to_f; b = b.to_f; c = c.to_f; d = d.to_f

  	case e
  		when :linear; linear_tween(t,b,c,d)

  		when :quad_in, :quad_i, :qi; ease_in_quad(t,b,c,d)
  		when :quad_out, :quad_o, :qo; ease_out_quad(t,b,c,d)
  		when :quad_in_out, :quad_io, :qio; ease_in_out_quad(t,b,c,d)

  		when :cubic_in, :cubic_i; ease_in_cubic(t,b,c,d)
  		when :cubic_out, :cubic_o; ease_out_cubic(t,b,c,d)
  		when :cubic_in_out, :cubic_io; ease_in_out_cubic(t,b,c,d)

  		when :quart_in, :quart_i; ease_in_quart(t,b,c,d)
  		when :quart_out, :quart_o; ease_out_quart(t,b,c,d)
  		when :quart_in_out, :quart_io; ease_in_out_quart(t,b,c,d)

  		when :quint_in, :quint_i; ease_in_quint(t,b,c,d)
  		when :quint_out, :quint_i; ease_out_quint(t,b,c,d)
  		when :quint_in_out, :quint_io; ease_in_out_quint(t,b,c,d)

  		when :sine_in, :sine_i; ease_in_sine(t,b,c,d)
  		when :sine_out, :sine_o; ease_out_sine(t,b,c,d)
  		when :sine_in_out, :sine_io; ease_in_out_sine(t,b,c,d)

  		when :expo_in, :expo_i; ease_in_expo(t,b,c,d)
  		when :expo_out, :expo_o; ease_out_expo(t,b,c,d)
  		when :expo_in_out, :expo_io; ease_in_out_expo(t,b,c,d)

  		when :circ_in, :circ_i; ease_in_circ(t,b,c,d)
  		when :circ_out, :circ_o; ease_out_circ(t,b,c,d)
  		when :circ_in_out, :circ_io; ease_in_out_circ(t,b,c,d)

      when :bounce_in, :bounce_i; ease_in_bounce(t,b,c,d)
      when :bounce_out, :bounce_o; ease_out_bounce(t,b,c,d)
      when :bounce_in_out, :bounce_io; ease_in_out_bounce(t,b,c,d)

  	end

  end

  def linear_tween(t, b, c, d)
    c * t / d + b
  end

  def ease_in_quad(t, b, c, d)
    return c*(t/=d)*t + b;
  end

  def ease_out_quad(t, b, c, d)
    return -c *(t/=d)*(t-2) + b;
  end

  def ease_in_out_quad(t, b, c, d)
    t /= d / 2
    return c / 2*t*t + b if (t < 1)
    t -= 1
    return -c/2 * (t*(t-2) - 1) + b
  end

  def ease_in_cubic(t, b, c, d)
    return c*(t/=d)*t*t + b
  end

  def ease_out_cubic(t, b, c, d)
    return c*((t=t/d-1)*t*t + 1) + b
  end

  def ease_in_out_cubic(t, b, c, d)
    return c/2*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t + 2) + b
  end

  def ease_in_quart(t, b, c, d)
    return c*(t/=d)*t*t*t + b
  end

  def ease_out_quart(t, b, c, d)
    return -c * ((t=t/d-1)*t*t*t - 1) + b
  end

  def ease_in_out_quart(t, b, c, d)
    return c/2*t*t*t*t + b if ((t/=d/2) < 1)
    return -c/2 * ((t-=2)*t*t*t - 2) + b
  end

  def ease_in_quint(t, b, c, d)
    return c*(t/=d)*t*t*t*t + b
  end

  def ease_out_quint(t, b, c, d)
    return c*((t=t/d-1)*t*t*t*t + 1) + b
  end

  def ease_in_out_quint(t, b, c, d)
    return c/2*t*t*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t*t*t + 2) + b
  end

  def ease_in_sine(t, b, c, d)
    return -c * Math.cos(t/d * (Math::PI/2)) + c + b
  end

  def ease_out_sine(t, b, c, d)
    return c * Math.sin(t/d * (Math::PI/2)) + b
  end

  def ease_in_out_sine(t, b, c, d)
    return -c/2 * (Math.cos(Math::PI*t/d) - 1) + b
  end

  def ease_in_expo(t, b, c, d)
    return (t==0) ? b : c * (2 ** (10 * (t/d - 1))) + b
  end

  def ease_out_expo(t, b, c, d)
    return (t==d) ? b+c : c * (-2**(-10 * t/d) + 1) + b
  end

  def ease_in_out_expo(t, b, c, d)
    return b if t == 0
    return b + c if t == d
    return (c/2) * 2**(10 * (t-1)) + b if ((t /= d/2) < 1)
    return (c/2) * (-2**(-10 * t-=1) + 2) + b
  end

  def ease_in_circ(t, b, c, d)
    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b
  end

  def ease_out_circ(t, b, c, d)
    return c * Math.sqrt(1 - (t=t/d-1)*t) + b
  end

  def ease_in_out_circ(t, b, c, d)
    return -c/2 * (Math.sqrt(1 - t*t) - 1) + b if ((t/=d/2) < 1)
    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b
  end

  # Added
  def ease_in_bounce(t,b,c,d)
  	return c - ease_out_bounce(d-t,0,c,d) + b
  end

  def ease_out_bounce(t,b,c,d)
  	t /= d
  	if ( (t) < (1 / 2.75))
  		return c * (7.5625 * t * t) + b
  	elsif (t < (2 / 2.75))
  		t -= (1.5 / 2.75)
  		return c * (7.5625 * (t) * t + 0.75) + b
  	elsif (t < (2.5 / 2.75))
  		t -= (2.25 / 2.75)
  		return c * (7.5625 * (t) * t + 0.9375) + b
  	else
  		t -= (2.625 / 2.75)
  		return c * (7.5625 * (t) * t + 0.984375) + b
  	end
  end

  def ease_in_out_bounce(t,b,c,d)
  	if (t < d / 2)
  		return ease_in_bounce(t * 2, 0, c, d) * 0.5 + b;
  	else
  		return ease_out_bounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  	end
  end"class Object
	def do(tween)
		# Register
		tween.set_parent(self)
		$tweens.register(tween)
		tween.start
	end

	# These don't work for some reason
	def go(var,amount,dur,ease=:linear)
		self.do(TimedTween.new(var,amount,dur,ease))
	end

	def to(var,target,speed=nil)
		self.do(TargetTween.new(var,target,speed))
	end

	def done?
		return $tweens.done?(self)
	end
end"J
def sequence(*args)
	return SequenceTween.new(*args)
end

def seq(*args)
	return SequenceTween.new(*args)
end

def repeat(a,times=-1)
	return LoopTween.new(a,times)
end

def parallel(*args)
	return ParallelTween.new(args)
end

def para(*args)
	return ParallelTween.new(args)
end

def pingpong(var,amount,duration,ease=:linear)
	return PingPongTween.new(var,amount,duration,ease)
end

def set(var,value)
	return SetTween.new(var,value)
end

def delay(duration)
	return DelayTween.new(duration)
end

def call(script)
	return CallTween.new(script)
end

def go(var,amount,dur,ease=:linear)
	return TimedTween.new(var,amount,dur,ease)
end

def to(var,target,speed=nil)
	return TargetTween.new(var,target,speed)
end

def proc(prc,delay=0)
	return ProcTween.new(prc,delay)
end


#==============================================================================
# ** Tweens
#==============================================================================

class Tween

	attr_reader :parent

	def initialize
		@parent = nil
	end

	def set_parent(parent)
		@parent = parent
	end

	def disposed?
		return @parent.disposed? if !@parent.nil?
		return false
	end

	def start
	end

end

class SetTween < Tween

	def initialize(var,value)
		@var = var
		@value = value
	end

	def done?
		return true
	end

	def start
		@parent.send(@var+"=",@value)
	end

	def copy
		return SetTween(@var,@value)
	end

end

class CallTween < Tween

	def initialize(script)
		@script = script
	end

	def done?
		return true
	end

	def start
		eval(@script)
	end

	def copy
		return CallTween(@script)
	end

end

class ProcTween < Tween

	def initialize(proc,delay)
		@proc = proc
		@delay = delay
	end

	def done?
		return @delay <= 0
	end

	def update(delta)
		@delay -= delta
		@proc.call() if done?
	end

end

class DelayTween < Tween

	def initialize(duration)
		@elapsed = 0
		@duration = duration
	end

	def done?
		return @elapsed >= @duration
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
	end

end

# Timed Tween
class TimedTween < Tween

	attr_accessor :elapsed, :duration, :ease

	def initialize(var,amount,duration,ease=:linear)
		@elapsed = 0
		@duration = duration
		@ease = ease
		@var = var
		@amount = amount
	end

	def done?
		return @elapsed >= @duration
	end

	def start
		@initial = @parent.send(@var)
	end

	def update(delta)

		# Error with list with setting x, for now it doesn't slide
		return if @parent.is_a?(Sprite) && @parent.disposed?


		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
		var = easing(elapsed, @initial, @amount, @duration, @ease)
		@parent.send(@var+"=",var)
	end

	def reverse
		nano = TimedTween.new(@var,-@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

	def copy
		nano = TimedTween.new(@var,@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

end

class TargetTween < Tween

	attr_accessor :initial, :target, :speed

	def initialize(var,target,speed=nil) # speed default to 10% distance
		@target = target
		@var = var
		@speed = speed
	end

	def done?
		return @target == @parent.send(@var)
	end

	def start
		@initial = @parent.send(@var)
		@dist = @target - @initial
		@speed = @dist.to_f/10 if @speed == nil
	end

	def update(delta)
		val = @parent.send(@var)
		if (@target-val).abs < @speed.abs
			val = @target
		else
			val += @speed
		end		
		@parent.send(@var+"=",val)
	end

	def reverse

	end

	def copy
		nano = TargetTween.new(@var,@target,@speed)
		nano.set_parent(@parent)
		return nano
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class PingPongTween < TimedTween

	def done?
		# Never ending nano
		return false
	end

	def update(delta)
		super(delta)
		if @elapsed == @duration
			@initial = @parent.send(@var)
			@elapsed = 0
			@amount= -@amount
		end
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class LoopTween < Tween

	def initialize(child,times=-1)
		#super
		@initial = child.copy
		@child = child
		@times = times
	end

	def done?
		return @child.done? && @times == 0
	end

	def set_parent(parent)
		super(parent)
		@initial.set_parent(parent) if @initial
		@child.set_parent(parent)
	end

	def start
		@child.start
	end

	def update(delta)
		@child.update(delta)
		if @child.done?
			@times -= 1
			if @times != 0
				@child = @initial
				@initial = @child.copy
				@child.set_parent(@parent)
				#log_append 'start child'
				@child.start
			end
		end
	end

	def reverse

	end

	def copy
		return LoopTween.new(@child.copy, @times)
	end

end

class SequenceTween < Tween

	def initialize(*args)
		@sequence = args
	end

	def push(nano)
		@sequence.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@sequence.each{ |n| n.set_parent(parent)}
	end

	def done?
		return @sequence.empty?
	end

	def clear
		@sequence.clear
	end

	def start
		start_instants
	end

	def start_instants
		return if @sequence.empty?
		#log_append @sequence.first
		@sequence.first.start
		while !@sequence.empty? && @sequence.first.done?
			@sequence.shift#.dispose
			@sequence.first.start if !@sequence.empty?
		end
	end

	def update(delta)
		return if @sequence.empty?
		@sequence.first.update(delta)
		if @sequence.first.done?
			@sequence.shift#.dispose
			start_instants
		end
	end

	def count
		return @sequence.count
	end

	def reverse
		nano = SequenceTween.new()
		@sequence.reverse.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

	def copy
		nano = SequenceTween.new()
		@sequence.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end

class ParallelTween < Tween

	def initialize(*args)
		@nanos = args
	end

	def push(nano)
		@nanos.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@nanos.each{ |n| n.set_parent(parent)}
	end

	def done?
		@nanos.each{ |n|
			return false if !n.done?
		}
		return true
	end

	def start
		@nanos.each{ |n| 
			n.start
		}
	end

	def update(delta)
		@nanos.each{ |n| 
			n.update(delta)
		}
	end

	def reverse

	end

	def copy
		nano = ParallelTween.new()
		@nanos.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end