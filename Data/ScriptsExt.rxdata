[="ÿ	#==============================================================================
# ** Game
#==============================================================================

APPFOLDER = "Aveyond 4"

# Get rid of this
# ----------------------------

  # Font used in windows 
  $fontface = "Arial" 
  $fontface2 = "Tahoma"
  
  # Font size used
  $fontsize = 22
  $fontsize2 = 18
  $fontsize3 = 20
  $fontsize4 = 15
  $fontsize5 = 26 
  
  # Initilize leader
  $leader = 0  

  def aveyond4

      # User Data folder
      Win32API.new('Utils', "AVSetEnv", ["V"], "I").call          
      $appdata = ENV['AV_APPDATA'] + "\\" + APPFOLDER
      Dir.mkdir($appdata) if !File.exists?($appdata) 

      $debug = DebugManager.new
      $DEBUG = true

      $audio = AudioManager.new

      # Install font here?
      $keyboard = KeyboardManager.new
      $mouse = MouseManager.new

      $data = DataManager.new
      $nanos = NanoManager.new

      $settings = SettingsManager.new
      $files = FileManager.new

      $game = GameManager.new

      # Call main method as long as $scene is effective      
      $game.update until $game.quit?
      
      # Set the windowed mode for next time
      $settings.conclude
      
  rescue ScriptError => e

    line = e.message.split(":")[1].to_i      
    log_err e.inspect
    log_err "------------------"
    
    e.backtrace.each{ |location|
      line_num = location.split(":")[1]
      script_name = location.split(":")[0].split("/").last
      method = location.split(":")[2]
      next if method == nil
      loc_err = "Line " + line_num + ", in "+script_name+ ", "+method.to_s
      loc_err = "Game Start" if script_name.include?("{0128")
      log_err("#{loc_err}")
    }     
    
  rescue StandardError => e
      
    line = e.message.split(":")[1].to_i      
    log_err e.inspect
    log_err "------------------"
    
    e.backtrace.each{ |location|
      line_num = location.split(":")[1]
      script_name = location.split(":")[0].split("/").last

      if location.include?("Section")
        section = location[/(?#Section)(\d)*(:)/]
        section_err = section[0, section.length - 1]
        script_name = $RGSS_SCRIPTS[section_err.to_i][1]
      end

      method = location.split(":")[2]
      next if method == nil
      loc_err = "Line " + line_num + ", in "+script_name+ ", "+method.to_s
      loc_err = "Game Start" if script_name.include?("{0128")
      log_err("#{loc_err}")
    } 
    
  end


"P

def condition_applies?(cond)
      # cond is [code,data1.....]

    case cond[0]

      # Flag
      when '?flag'
          return false if !flag?(cond[1])
              
        # Progress
      when '?progress'
        return false if !progress?(cond[1])

      # Active Quest
      when '?active'
        return false if !on_quest?(cond[1])
         when '?quest'
        return false if !on_quest?(cond[1])  
              
        # Item Check
      when '?item'
        return false if !$game_party.has_item?(cond[1].to_i)

    end

    return true

  end"ª'#==============================================================================
# ** Interpreter (part 1)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #     main  : main flag
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main
    
    # Depth goes up to level 100
    if depth > 100
      print("Common event call has exceeded maximum limit.")
      exit
    end
    
    # Clear inner situation of interpreter
    clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Reset
  #   Remove any queued items 
  #--------------------------------------------------------------------------
  def reset
    @list = nil
  end
  
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # map ID when starting up
    @event_id = 0                     # event ID
    @message_waiting = false          # waiting for message to end
    @move_route_waiting = false       # waiting for move completion
    @wait_count = 0                   # wait count
    @child_interpreter = nil          # child interpreter
    @branch = {}                      # branch data
  end
  
  #--------------------------------------------------------------------------
  # * Event Setup
  #     list     : list of event commands
  #     event_id : event ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    
    # Clear inner situation of interpreter
    clear
    
    # Remember map ID
    @map_id = $map.map_id
    
    # Remember event ID
    @event_id = event_id
    
    # Remember list of event commands
    @list = list
    
    # Initialize index
    @index = 0
    
    # Clear branch data hash
    @branch.clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Current event (as event, not id)
  #--------------------------------------------------------------------------
  def event
    return $map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Running
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  
  #--------------------------------------------------------------------------
  # * Starting Event Setup
  #--------------------------------------------------------------------------
  def setup_starting_event
    
    # Refresh map if necessary
    if $map.need_refresh
      $map.refresh
    end
    
    # If common event call is reserved
    if $temp.common_event_id > 0
      
      # Set up event
      setup($data.commons[$temp.common_event_id].list, 0)
      
      # Release reservation
      $temp.common_event_id = 0
      
      return
      
    end
    
    # Loop (map events)
    for event in $map.events.values
      
      # If running event is found
      if event.starting
        
        # If not auto run
        if event.trigger < 3
          
          # Clear starting flag
          event.clear_starting
          
          # Lock
          event.lock
          
        end
        
        # Set up event
        setup(event.list, event.id)
        
        return
        
      end
      
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    
    # Initialize loop count
    @loop_count = 0
    
    # Loop
    loop do
      
      # Add 1 to loop count
      @loop_count += 1
      
      # If 100 event commands ran
      if @loop_count > 100
        # Call Graphics.update for freeze prevention
        Graphics.update
        @loop_count = 0
      end
      
      # If map is different than event startup time
      if $map.map_id != @map_id
        # Change event ID to 0
        @event_id = 0
      end
      
      # If a child interpreter exists
      if @child_interpreter != nil
        
        # Update child interpreter
        @child_interpreter.update
        
        # If child interpreter is finished running
        unless @child_interpreter.running?
          # Delete child interpreter
          @child_interpreter = nil          
        end
        
        # If child interpreter still exists
        if @child_interpreter != nil
          return
        end
        
      end
      
      # If waiting for message to end
      if @message_waiting
        return
      end
      
      # If waiting for move to end
      if @move_route_waiting

        # If player is forcing move route
        if $player.move_route_forcing
          return
        end
        
        # Loop (map events)
        for event in $map.events.values
          
          # If this event is forcing move route
          if event.move_route_forcing
            return
          end
          
        end
        
        # Clear move end waiting flag
        @move_route_waiting = false
        
      end
      
      # If waiting
      if @wait_count > 0
        # Decrease wait count
        @wait_count -= 1
        return
      end

      # If list of event commands is empty
      if @list == nil
        
        # If main map event
        if @main
          # Set up starting event
          setup_starting_event
        end
        
        # If nothing was set up
        if @list == nil
          return
        end
        
      end
      
      # If return value is false when trying to execute event command
      if execute_command == false
        return
      end
      
      # Advance index
      @index += 1
      
    end
  end

  #--------------------------------------------------------------------------
  # * Setup Choices
  #--------------------------------------------------------------------------
  def setup_choices(parameters)
    
    # Set choice item count to choice_max
    $game_temp.choice_max = parameters[0].size
    
    # Set choice to message_text
    for text in parameters[0]
      $game_temp.message_text += text + "\n"
    end
    
    # Set cancel processing
    $game_temp.choice_cancel_type = parameters[1]
    
    # Set callback
    current_indent = @list[@index].indent
    $game_temp.choice_proc = Proc.new { |n| @branch[current_indent] = n }
    
  end

  #--------------------------------------------------------------------------
  # * Actor Iterator (consider all party members)
  #     parameter : if 1 or more, ID; if 0, all
  #--------------------------------------------------------------------------
  def iterate_actor(parameter)
    
    # If entire party
    if parameter == 0
      
      # Loop for entire party
      #for actor in $game_party.actors
        
        # Evaluate block
        #yield actor
                
      #end
      
      # Shaz - do this to all actors in the party, including reserve
      for i in 0..10
        actor = $game_actors[i]
        yield actor if actor != nil && $player.is_present(actor.id)
      end
      
    # If single actor
    else
      
      # Get actor
      actor = $game_actors[parameter]
      
      # Evaluate block
      yield actor if actor != nil
      
    end
  end
  
  #--------------------------------------------------------------------------
  # * Enemy Iterator (consider all troop members)
  #     parameter : If 0 or above, index; if -1, all
  #--------------------------------------------------------------------------
  def iterate_enemy(parameter)
    
    # If entire troop
    if parameter == -1
      
      # Loop for entire troop
      for enemy in $game_troop.enemies
        
        # Evaluate block
        yield enemy
        
      end
      
    # If single enemy
    else
      
      # Get enemy
      enemy = $game_troop.enemies[parameter]
      
      # Evaluate block
      yield enemy if enemy != nil
      
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Battler Iterator (consider entire troop and entire party)
  #     parameter1 : If 0, enemy; if 1, actor
  #     parameter2 : If 0 or above, index; if -1, all
  #--------------------------------------------------------------------------
  def iterate_battler(parameter1, parameter2)
    
    # If enemy
    if parameter1 == 0
      
      # Call enemy iterator
      iterate_enemy(parameter2) do |enemy|
        yield enemy
      end
      
    # If actor
    else
      
      # If entire party
      if parameter2 == -1
        
        # Loop for entire party
        #for actor in $game_party.actors
          
          # Evaluate block
          #yield actor
          
        #end

        # Shaz - do this to all actors in the party, including reserve
        for i in 0..10
          actor = $game_actors[i]
          yield actor if actor != nil && $player.is_present(actor.id)
        end
        
      # If single actor (N exposed)
      else
        
        # Get actor
        actor = $game_party.actors[parameter2]
        
        # Evaluate block
        yield actor if actor != nil
        
      end
      
    end
  end
end
"š##==============================================================================
# ** Interpreter (part 2)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # * Event Command Execution
  #--------------------------------------------------------------------------
  def execute_command
    
    # If last to arrive for list of event commands
    if @index >= @list.size - 1
      # End event
      command_end
      # Continue
      return true
    end
    
    # NEW
    # Make event command parameters available for reference via @parameters
    if !(@list[@index].code == 102 and $game_temp.skip_next_choices > 0) 
      @parameters = @list[@index].parameters.clone
      if @list[@index].code == 402
        @parameters[0] += @offset
      end
    end  
    # END NEW

    # Make event command parameters available for reference via @parameters
    #@parameters = @list[@index].parameters
    
    # Branch by command code
    case @list[@index].code
    when 101  # Show Text
      return command_101
    when 102  # Show Choices
      return command_102
    when 402  # When [**]
      return command_402
    when 403  # When Cancel
      return command_403
    when 103  # Input Number
      return command_103
    when 104  # Change Text Options
      return command_104
    when 105  # Button Input Processing
      return command_105
    when 106  # Wait
      return command_106
    when 111  # Conditional Branch
      return command_111
    when 411  # Else
      return command_411
    when 112  # Loop
      return command_112
    when 413  # Repeat Above
      return command_413
    when 113  # Break Loop
      return command_113
    when 115  # Exit Event Processing
      return command_115
    when 116  # Erase Event
      return command_116
    when 117  # Call Common Event
      return command_117
    when 118  # Label
      return command_118
    when 119  # Jump to Label
      return command_119
    when 121  # Control Switches
      return command_121
    when 122  # Control Variables
      return command_122
    when 123  # Control Self Switch
      return command_123
    when 124  # Control Timer
      return command_124
    when 125  # Change Gold
      return command_125
    when 126  # Change Items
      return command_126
    when 127  # Change Weapons
      return command_127
    when 128  # Change Armor
      return command_128
    when 129  # Change Party Member
      return command_129
    when 131  # Change Windowskin
      return command_131
    when 132  # Change Battle BGM
      return command_132
    when 133  # Change Battle End ME
      return command_133
    when 134  # Change Save Access
      return command_134
    when 135  # Change Menu Access
      return command_135
    when 136  # Change Encounter
      return command_136
    when 201  # Transfer Player
      return command_201
    when 202  # Set Event Location
      return command_202
    when 203  # Scroll Map
      return command_203
    when 204  # Change Map Settings
      return command_204
    when 205  # Change Fog Color Tone
      return command_205
    when 206  # Change Fog Opacity
      return command_206
    when 207  # Show Animation
      return command_207
    when 208  # Change Transparent Flag
      return command_208
    when 209  # Set Move Route
      return command_209
    when 210  # Wait for Move's Completion
      return command_210
    when 221  # Prepare for Transition
      return command_221
    when 222  # Execute Transition
      return command_222
    when 223  # Change Screen Color Tone
      return command_223
    when 224  # Screen Flash
      return command_224
    when 225  # Screen Shake
      return command_225
    when 231  # Show Picture
      return command_231
    when 232  # Move Picture
      return command_232
    when 233  # Rotate Picture
      return command_233
    when 234  # Change Picture Color Tone
      return command_234
    when 235  # Erase Picture
      return command_235
    when 236  # Set Weather Effects
      return command_236
    when 241  # Play BGM
      return command_241
    when 242  # Fade Out BGM
      return command_242
    when 245  # Play BGS
      return command_245
    when 246  # Fade Out BGS
      return command_246
    when 247  # Memorize BGM/BGS
      return command_247
    when 248  # Restore BGM/BGS
      return command_248
    when 249  # Play ME
      return command_249
    when 250  # Play SE
      return command_250
    when 251  # Stop SE
      return command_251
    when 301  # Battle Processing
      return command_301
    when 601  # If Win
      return command_601
    when 602  # If Escape
      return command_602
    when 603  # If Lose
      return command_603
    when 302  # Shop Processing
      return command_302
    when 303  # Name Input Processing
      return command_303
    when 311  # Change HP
      return command_311
    when 312  # Change SP
      return command_312
    when 313  # Change State
      return command_313
    when 314  # Recover All
      return command_314
    when 315  # Change EXP
      return command_315
    when 316  # Change Level
      return command_316
    when 317  # Change Parameters
      return command_317
    when 318  # Change Skills
      return command_318
    when 319  # Change Equipment
      return command_319
    when 320  # Change Actor Name
      return command_320
    when 321  # Change Actor Class
      return command_321
    when 322  # Change Actor Graphic
      return command_322
    when 331  # Change Enemy HP
      return command_331
    when 332  # Change Enemy SP
      return command_332
    when 333  # Change Enemy State
      return command_333
    when 334  # Enemy Recover All
      return command_334
    when 335  # Enemy Appearance
      return command_335
    when 336  # Enemy Transform
      return command_336
    when 337  # Show Battle Animation
      return command_337
    when 338  # Deal Damage
      return command_338
    when 339  # Force Action
      return command_339
    when 340  # Abort Battle
      return command_340
    when 351  # Call Menu Screen
      return command_351
    when 352  # Call Save Screen
      return command_352
    when 353  # Game Over
      return command_353
    when 354  # Return to Title Screen
      return command_354
    when 355  # Script
      return command_355
    else      # Other
      return true
    end
  end
  #--------------------------------------------------------------------------
  # * End Event
  #--------------------------------------------------------------------------
  def command_end
    # Clear list of event commands
    @list = nil
    # If main map event and event ID are valid
    if @main and @event_id > 0
      # Unlock event
      $map.events[@event_id].unlock
    end
  end
  #--------------------------------------------------------------------------
  # * Command Skip
  #--------------------------------------------------------------------------
  def command_skip
    # Get indent
    indent = @list[@index].indent
    # Loop
    loop do
      # If next event command is at the same level as indent
      if @list[@index+1].indent == indent
        # Continue
        return true
      end
      # Advance index
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # * Get Character
  #     parameter : parameter
  #--------------------------------------------------------------------------
  def get_character(parameter)
    # Branch by parameter
    case parameter
    when -1  # player
      return $player
    when 0  # this event
      events = $map.events
      return events == nil ? nil : events[@event_id]
    else  # specific event
      events = $map.events
      return events == nil ? nil : events[parameter]
    end
  end
  #--------------------------------------------------------------------------
  # * Calculate Operated Value
  #     operation    : operation
  #     operand_type : operand type (0: invariable 1: variable)
  #     operand      : operand (number or variable ID)
  #--------------------------------------------------------------------------
  def operate_value(operation, operand_type, operand)
    # Get operand
    if operand_type == 0
      value = operand
    else
      value = $game_variables[operand]
    end
    # Reverse sign of integer if operation is [decrease]
    if operation == 1
      value = -value
    end
    # Return value
    return value
  end
end
"«*#==============================================================================
# ** Interpreter (part 3)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter

  def next_event_code
    @list[@index+1].code
  end

  #--------------------------------------------------------------------------
  # * Show Text
  #--------------------------------------------------------------------------
  def command_101

    message = []
    message.push(@list[@index].parameters[0])
    while next_event_code == 401
      @index += 1
      message.push(@list[@index].parameters[0])
    end

    message = message.join(' ')

    # If there is a choice next, add it
    if next_event_code == 102
      @index+=1
      while next_event_code == 402

      end
    end

    $hud.message.start(message)
    
    # Return mouse to default cursor
    #$mouse_sprite.set_bitmap(MouseCursor::Default_Cursor)
    
    # Continue
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Setup Choices
  #--------------------------------------------------------------------------
  def setup_choices(parameters)
    params = parameters.clone
    @offset = 0
    i = @index
    curr = 1
    while curr < $game_temp.num_choices
      i += 1
      if @list[i].code == 102
        params[0] += @list[i].parameters[0]
        if @list[i].parameters[1] == 5
          @cancel_flag = true
        else
          @cancel_flag = false
        end
        params[1] = @list[i].parameters[1] + (curr * 4)
        curr += 1
      end
    end
    
    # Set choice item count to choice_max
    $game_temp.choice_max = params[0].size
    # Set choice to message_text
    $game_temp.choices = params[0]
    # Set cancel processing
    $game_temp.choice_cancel_type = params[1]
    
    if $game_temp.num_choices != 1
      $game_temp.skip_next_choices = $game_temp.num_choices - 1
      $game_temp.num_choices = 1
    end
    
    # Set callback
    current_indent = @list[@index].indent
    $game_temp.choice_proc = Proc.new { |n| @branch[current_indent] = n }
  end

  #--------------------------------------------------------------------------
  # * When [**]
  #--------------------------------------------------------------------------
  def command_402
    # If fitting choices are selected
    if @branch[@list[@index].indent] == @parameters[0]
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the condition: command skip
    return command_skip
  end

  #--------------------------------------------------------------------------
  # * Wait
  #--------------------------------------------------------------------------
  def command_106
    # Set wait count
    @wait_count = @parameters[0] * 2
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Conditional Branch
  #--------------------------------------------------------------------------
  def command_111
    # Initialize local variable: result
    result = false
    case @parameters[0]
    when 0  # switch
      result = ($game_switches[@parameters[1]] == (@parameters[2] == 0))
    when 1  # variable
      value1 = $game_variables[@parameters[1]]
      if @parameters[2] == 0
        value2 = @parameters[3]
      else
        value2 = $game_variables[@parameters[3]]
      end
      case @parameters[4]
      when 0  # value1 is equal to value2
        result = (value1 == value2)
      when 1  # value1 is greater than or equal to value2
        result = (value1 >= value2)
      when 2  # value1 is less than or equal to value2
        result = (value1 <= value2)
      when 3  # value1 is greater than value2
        result = (value1 > value2)
      when 4  # value1 is less than value2
        result = (value1 < value2)
      when 5  # value1 is not equal to value2
        result = (value1 != value2)
      end
    when 2  # self switch
      if @event_id > 0
        key = [$map.map_id, @event_id, @parameters[1]]
        if @parameters[2] == 0
          result = ($game_self_switches[key] == true)
        else
          result = ($game_self_switches[key] != true)
        end
      end
    when 3  # timer
      if $game_system.timer_working
        sec = $game_system.timer / Graphics.frame_rate
        if @parameters[2] == 0
          result = (sec >= @parameters[1])
        else
          result = (sec <= @parameters[1])
        end
      end
    when 4  # actor
      actor = $game_actors[@parameters[1]]
      if actor != nil
        case @parameters[2]
        when 0  # in party
          result = ($game_party.actors.include?(actor))
        when 1  # name
          result = (actor.name == @parameters[3])
        when 2  # skill
          result = (actor.skill_learn?(@parameters[3]))
        when 3  # weapon
          result = (actor.weapon_id == @parameters[3])
        when 4  # armor
          result = (actor.armor1_id == @parameters[3] or
                    actor.armor2_id == @parameters[3] or
                    actor.armor3_id == @parameters[3] or
                    actor.armor4_id == @parameters[3])
        when 5  # state
          result = (actor.state?(@parameters[3]))
        end
      end
    when 5  # enemy
      enemy = $game_troop.enemies[@parameters[1]]
      if enemy != nil
        case @parameters[2]
        when 0  # appear
          result = (enemy.exist?)
        when 1  # state
          result = (enemy.state?(@parameters[3]))
        end
      end
    when 6  # character
      character = get_character(@parameters[1])
      if character != nil
        result = (character.direction == @parameters[2])
      end
    when 7  # gold
      if @parameters[2] == 0
        result = ($game_party.gold >= @parameters[1])
      else
        result = ($game_party.gold <= @parameters[1])
      end
    when 8  # item
      result = ($game_party.item_number(@parameters[1]) > 0)
    when 9  # weapon
      result = ($game_party.weapon_number(@parameters[1]) > 0)
    when 10  # armor
      result = ($game_party.armor_number(@parameters[1]) > 0)
    when 11  # button
      result = (Input.press?(@parameters[1]))
    when 12  # script
      result = eval(@parameters[1])
    end
    # Store determinant results in hash
    @branch[@list[@index].indent] = result
    # If determinant results are true
    if @branch[@list[@index].indent] == true
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the conditions: command skip
    return command_skip
  end
  #--------------------------------------------------------------------------
  # * Else
  #--------------------------------------------------------------------------
  def command_411
    # If determinant results are false
    if @branch[@list[@index].indent] == false
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the conditions: command skip
    return command_skip
  end
  #--------------------------------------------------------------------------
  # * Loop
  #--------------------------------------------------------------------------
  def command_112
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Repeat Above
  #--------------------------------------------------------------------------
  def command_413
    # Get indent
    indent = @list[@index].indent
    # Loop
    loop do
      # Return index
      @index -= 1
      # If this event command is the same level as indent
      if @list[@index].indent == indent
        # Continue
        return true
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Break Loop
  #--------------------------------------------------------------------------
  def command_113
    # Get indent
    indent = @list[@index].indent
    # Copy index to temporary variables
    temp_index = @index
    # Loop
    loop do
      # Advance index
      temp_index += 1
      # If a fitting loop was not found
      if temp_index >= @list.size-1
        # Continue
        return true
      end
      # If this event command is [repeat above] and indent is shallow
      if @list[temp_index].code == 413 and @list[temp_index].indent < indent
        # Update index
        @index = temp_index
        # Continue
        return true
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Exit Event Processing
  #--------------------------------------------------------------------------
  def command_115
    # End event
    command_end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Call Common Event
  #--------------------------------------------------------------------------
  def command_117
    # Get common event
    common_event = $data.commons[@parameters[0]]
    # If common event is valid
    if common_event != nil
      # Make child interpreter
      @child_interpreter = Interpreter.new(@depth + 1)
      @child_interpreter.setup(common_event.list, @event_id)
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Label
  #--------------------------------------------------------------------------
  def command_118
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Jump to Label
  #--------------------------------------------------------------------------
  def command_119
    # Get label name
    label_name = @parameters[0]
    # Initialize temporary variables
    temp_index = 0
    # Loop
    loop do
      # If a fitting label was not found
      if temp_index >= @list.size-1
        # Continue
        return true
      end
      # If this event command is a designated label name
      if @list[temp_index].code == 118 and
         @list[temp_index].parameters[0] == label_name
        # Update index
        @index = temp_index
        # Continue
        return true
      end
      # Advance index
      temp_index += 1
    end
  end

end"*#==============================================================================
# ** Interpreter (part 4)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  
  #--------------------------------------------------------------------------
  # * Change Gold
  #--------------------------------------------------------------------------
  def command_125
    # Get value to operate
    value = operate_value(@parameters[0], @parameters[1], @parameters[2])
    # Increase / decrease amount of gold
    $game_party.gain_gold(value)
    
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Items
  #--------------------------------------------------------------------------
  def command_126
    # Get value to operate
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Increase / decrease items
    $game_party.gain_item(@parameters[0], value)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Weapons
  #--------------------------------------------------------------------------
  def command_127
    # Get value to operate
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Increase / decrease weapons
    $game_party.gain_weapon(@parameters[0], value)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Armor
  #--------------------------------------------------------------------------
  def command_128
    # Get value to operate
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Increase / decrease armor
    $game_party.gain_armor(@parameters[0], value)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Windowskin
  #--------------------------------------------------------------------------
  def command_131
    # Change windowskin file name
    $game_system.windowskin_name = @parameters[0]
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Battle BGM
  #--------------------------------------------------------------------------
  def command_132
    # Change battle BGM
    $game_system.battle_bgm = @parameters[0]
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Battle End ME
  #--------------------------------------------------------------------------
  def command_133
    # Change battle end ME
    $game_system.battle_end_me = @parameters[0]
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Save Access
  #--------------------------------------------------------------------------
  def command_134
    # Change save access flag
    $game_system.save_disabled = (@parameters[0] == 0)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Menu Access
  #--------------------------------------------------------------------------
  def command_135
    # Change menu access flag
    $game_system.menu_disabled = (@parameters[0] == 0)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Encounter
  #--------------------------------------------------------------------------
  def command_136
    # Change encounter flag
    $game_system.encounter_disabled = (@parameters[0] == 0)
    # Make encounter count
    $game_player.make_encounter_count
    # Continue
    return true
  end
end
"õ:#==============================================================================
# ** Interpreter (part 5)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # * Transfer Player
  #--------------------------------------------------------------------------
  def command_201
    # If in battle
    if $game_temp.in_battle
      # Continue
      return true
    end
    # If transferring player, showing message, or processing transition
    if $game_temp.player_transferring or
       $game_temp.message_window_showing or
       $game_temp.transition_processing
      # End
      return false
    end
    # Set transferring player flag
    $game_temp.player_transferring = true
    # If appointment method is [direct appointment]
    if @parameters[0] == 0
      # Set player move destination
      $game_temp.player_new_map_id = @parameters[1]
      $game_temp.player_new_x = @parameters[2]
      $game_temp.player_new_y = @parameters[3]
      $game_temp.player_new_direction = @parameters[4]
    # If appointment method is [appoint with variables]
    else
      # Set player move destination
      $game_temp.player_new_map_id = $game_variables[@parameters[1]]
      $game_temp.player_new_x = $game_variables[@parameters[2]]
      $game_temp.player_new_y = $game_variables[@parameters[3]]
      $game_temp.player_new_direction = @parameters[4]
    end
    # Advance index
    @index += 1
    # If fade is set
    if @parameters[5] == 0
      # Prepare for transition
      Graphics.freeze
      # Set transition processing flag
      $game_temp.transition_processing = true
      $game_temp.transition_name = ""
    end
    # End
    return false
  end
  #--------------------------------------------------------------------------
  # * Set Event Location
  #--------------------------------------------------------------------------
  def command_202
    # If in battle
    if $game_temp.in_battle
      # Continue
      return true
    end
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    if character == nil
      # Continue
      return true
    end
    # If appointment method is [direct appointment]
    if @parameters[1] == 0
      # Set character position
      character.moveto(@parameters[2], @parameters[3])
    # If appointment method is [appoint with variables]
    elsif @parameters[1] == 1
      # Set character position
      character.moveto($game_variables[@parameters[2]],
        $game_variables[@parameters[3]])
    # If appointment method is [exchange with another event]
    else
      old_x = character.x
      old_y = character.y
      character2 = get_character(@parameters[2])
      if character2 != nil
        character.moveto(character2.x, character2.y)
        character2.moveto(old_x, old_y)
      end
    end
    # Set character direction
    case @parameters[4]
    when 8  # up
      character.turn_up
    when 6  # right
      character.turn_right
    when 2  # down
      character.turn_down
    when 4  # left
      character.turn_left
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Scroll Map
  #--------------------------------------------------------------------------
  def command_203
    # If in battle
    # if $game_temp.in_battle
    #   # Continue
    #   return true
    # end
    # If already scrolling
    if $map.scrolling?
      # End
      return false
    end
    # Start scroll
    $map.start_scroll(@parameters[0], @parameters[1], @parameters[2])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Map Settings
  #--------------------------------------------------------------------------
  def command_204
    case @parameters[0]
    when 0  # panorama
      $game_map.panorama_name = @parameters[1]
      $game_map.panorama_hue = @parameters[2]
    when 1  # fog
      $game_map.fog_name = @parameters[1]
      $game_map.fog_hue = @parameters[2]
      $game_map.fog_opacity = @parameters[3]
      $game_map.fog_blend_type = @parameters[4]
      $game_map.fog_zoom = @parameters[5]
      $game_map.fog_sx = @parameters[6]
      $game_map.fog_sy = @parameters[7]
    when 2  # battleback
      $game_map.battleback_name = @parameters[1]
      $game_temp.battleback_name = @parameters[1]
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Fog Color Tone
  #--------------------------------------------------------------------------
  def command_205
    # Start color tone change
    $game_map.start_fog_tone_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Fog Opacity
  #--------------------------------------------------------------------------
  def command_206
    # Start opacity level change
    $game_map.start_fog_opacity_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Show Animation
  #--------------------------------------------------------------------------
  def command_207
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    if character == nil
      # Continue
      return true
    end
    # Set animation ID
    character.animation_id = @parameters[1]
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Transparent Flag
  #--------------------------------------------------------------------------
  def command_208
    # Change player transparent flag
    $game_player.transparent = (@parameters[0] == 0)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Set Move Route
  #--------------------------------------------------------------------------
  def command_209
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    if character == nil
      # Continue
      return true
    end
    # Force move route
    character.force_move_route(@parameters[1])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Wait for Move's Completion
  #--------------------------------------------------------------------------
  def command_210
    # If not in battle
    unless $game_temp.in_battle
      # Set move route completion waiting flag
      @move_route_waiting = true
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Prepare for Transition
  #--------------------------------------------------------------------------
  def command_221
    # If showing message window
    if $game_temp.message_window_showing
      # End
      return false
    end
    # Prepare for transition
    Graphics.freeze
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Execute Transition
  #--------------------------------------------------------------------------
  def command_222
    # If transition processing flag is already set
    if $game_temp.transition_processing
      # End
      return false
    end
    # Set transition processing flag
    $game_temp.transition_processing = true
    $game_temp.transition_name = @parameters[0]
    # Advance index
    @index += 1
    # End
    return false
  end
  #--------------------------------------------------------------------------
  # * Change Screen Color Tone
  #--------------------------------------------------------------------------
  def command_223
    # Start changing color tone
    $game_screen.start_tone_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Screen Flash
  #--------------------------------------------------------------------------
  def command_224
    # Start flash
    $game_screen.start_flash(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Screen Shake
  #--------------------------------------------------------------------------
  def command_225
    # Start shake
    $game_screen.start_shake(@parameters[0], @parameters[1],
      @parameters[2] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Show Picture
  #--------------------------------------------------------------------------
  def command_231
    # Get picture number
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # If appointment method is [direct appointment]
    if @parameters[3] == 0
      x = @parameters[4]
      y = @parameters[5]
    # If appointment method is [appoint with variables]
    else
      x = $game_variables[@parameters[4]]
      y = $game_variables[@parameters[5]]
    end
    # Show picture
    $game_screen.pictures[number].show(@parameters[1], @parameters[2],
      x, y, @parameters[6], @parameters[7], @parameters[8], @parameters[9])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Move Picture
  #--------------------------------------------------------------------------
  def command_232
    # Get picture number
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # If appointment method is [direct appointment]
    if @parameters[3] == 0
      x = @parameters[4]
      y = @parameters[5]
    # If appointment method is [appoint with variables]
    else
      x = $game_variables[@parameters[4]]
      y = $game_variables[@parameters[5]]
    end
    # Move picture
    $game_screen.pictures[number].move(@parameters[1] * 2, @parameters[2],
      x, y, @parameters[6], @parameters[7], @parameters[8], @parameters[9])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Rotate Picture
  #--------------------------------------------------------------------------
  def command_233
    # Get picture number
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # Set rotation speed
    $game_screen.pictures[number].rotate(@parameters[1])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Picture Color Tone
  #--------------------------------------------------------------------------
  def command_234
    # Get picture number
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # Start changing color tone
    $game_screen.pictures[number].start_tone_change(@parameters[1],
      @parameters[2] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Erase Picture
  #--------------------------------------------------------------------------
  def command_235
    # Get picture number
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # Erase picture
    $game_screen.pictures[number].erase
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Set Weather Effects
  #--------------------------------------------------------------------------
  def command_236
    # Set Weather Effects
    $game_screen.weather(@parameters[0], @parameters[1], @parameters[2])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play BGM
  #--------------------------------------------------------------------------
  def command_241
    # Play BGM
    $game_system.bgm_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Fade Out BGM
  #--------------------------------------------------------------------------
  def command_242
    # Fade out BGM
    $game_system.bgm_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play BGS
  #--------------------------------------------------------------------------
  def command_245
    # Play BGS
    $game_system.bgs_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Fade Out BGS
  #--------------------------------------------------------------------------
  def command_246
    # Fade out BGS
    $game_system.bgs_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Memorize BGM/BGS
  #--------------------------------------------------------------------------
  def command_247
    # Memorize BGM/BGS
    $game_system.bgm_memorize
    $game_system.bgs_memorize
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Restore BGM/BGS
  #--------------------------------------------------------------------------
  def command_248
    # Restore BGM/BGS
    $game_system.bgm_restore
    $game_system.bgs_restore
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play ME
  #--------------------------------------------------------------------------
  def command_249
    # Play ME
    $game_system.me_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play SE
  #--------------------------------------------------------------------------
  def command_250
    $audio.play_se(@parameters[0])
    return true
  end
  #--------------------------------------------------------------------------
  # * Stop SE
  #--------------------------------------------------------------------------
  def command_251
    # Stop SE
    Audio.se_stop
    # Continue
    return true
  end
end
"##==============================================================================
# ** Interpreter (part 6)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # * Battle Processing
  #--------------------------------------------------------------------------
  def command_301
    # If not invalid troops
    if $data_troops[@parameters[0]] != nil
      # Shaz: set battle group in case of flee (green warp egg)
      if $game_map.events[@event_id] != nil &&
        $game_map.events[@event_id].name.index(/[Mm][Nn][Ss][Tt][Rr][Gg][Rr][Pp](.+)/) != nil
        $game_temp.battle_group = $1.to_s
      else
        $game_temp.battle_group = " "
      end
      
      # Set battle abort flag
      $game_temp.battle_abort = true
      # Set battle calling flag
      $game_temp.battle_calling = true
      $game_temp.battle_troop_id = @parameters[0]
      $game_temp.battle_can_escape = @parameters[1]
      $game_temp.battle_can_lose = @parameters[2]
      # Set callback
      current_indent = @list[@index].indent
      $game_temp.battle_proc = Proc.new { |n| @branch[current_indent] = n }

    end
    # Advance index
    @index += 1
    # End
    return false
  end
  #--------------------------------------------------------------------------
  # * If Win
  #--------------------------------------------------------------------------
  def command_601
    # When battle results = win
    if @branch[@list[@index].indent] == 0
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet conditions: command skip
    return command_skip
  end
  #--------------------------------------------------------------------------
  # * If Escape
  #--------------------------------------------------------------------------
  def command_602
    # If battle results = escape
    if @branch[@list[@index].indent] == 1
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet conditions: command skip
    return command_skip
  end
  #--------------------------------------------------------------------------
  # * If Lose
  #--------------------------------------------------------------------------
  def command_603
    # If battle results = lose
    if @branch[@list[@index].indent] == 2
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet conditions: command skip
    return command_skip
  end
  #--------------------------------------------------------------------------
  # * Shop Processing
  #--------------------------------------------------------------------------
  def command_302
    # Set battle abort flag
    $game_temp.battle_abort = true
    # Set shop calling flag
    $game_temp.shop_calling = true
    # Set goods list on new item
    $game_temp.shop_goods = [@parameters]
    # Loop
    loop do
      # Advance index
      @index += 1
      # If next event command has shop on second line or after
      if @list[@index].code == 605
        # Add goods list to new item
        $game_temp.shop_goods.push(@list[@index].parameters)
      # If event command does not have shop on second line or after
      else
        # End
        return false
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Change HP
  #--------------------------------------------------------------------------
  def command_311
    # Get operate value
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # If HP are not 0
      if actor.hp > 0
        # Change HP (if death is not permitted, make HP 1)
        if @parameters[4] == false and actor.hp + value <= 0
          actor.hp = 1
        else
          actor.hp += value
        end
      end
    end
    # Determine game over
    $game_temp.gameover = $game_party.all_dead?
    
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change SP
  #--------------------------------------------------------------------------
  def command_312
    # Get operate value
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # Change actor SP
      actor.sp += value
    end
    
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change State
  #--------------------------------------------------------------------------
  def command_313
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # Change state
      if @parameters[1] == 0
        actor.add_state(@parameters[2])
      else
        actor.remove_state(@parameters[2])
      end
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def command_314
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # Recover all for actor
      actor.recover_all
    end
    
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change EXP
  #--------------------------------------------------------------------------
  def command_315
    # Get operate value
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # Change actor EXP
      actor.exp += value
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Level
  #--------------------------------------------------------------------------
  def command_316
    # Get operate value
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # Process with iterator
    iterate_actor(@parameters[0]) do |actor|
      # Change actor level
      actor.level += value
    end
    
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Skills
  #--------------------------------------------------------------------------
  def command_318
    # Get actor
    actor = $game_actors[@parameters[0]]
    # Change skill
    if actor != nil
      if @parameters[1] == 0
        actor.learn_skill(@parameters[2])
      else
        actor.forget_skill(@parameters[2])
      end
    end
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Change Equipment
  #--------------------------------------------------------------------------
  def command_319
    # Get actor
    actor = $game_actors[@parameters[0]]
    # Change Equipment
    if actor != nil
      actor.equip(@parameters[1], @parameters[2])
    end
    # Continue
    return true
  end

end
"£#==============================================================================
# ** Interpreter (part 7)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    # Set first line to script
    script = @list[@index].parameters[0] + "\n"
    # Loop
    loop do
      # If next event command is second line of script or after
      if @list[@index + 1].code == 655
        # Add second line or after to script
        script += @list[@index + 1].parameters[0] + "\n"
      # If event command is not second line or after
      else
        # Abort loop
        break
      end
      # Advance index
      @index += 1
    end
    
    # Evaluation
    result = eval(script)

    # Continue
    return true
     
  end
end
" #==============================================================================
# ** Audio Manager
#==============================================================================

class AudioManager

  def initialize
  	@bgm = nil
  	@bgs = nil
  end

  # send_blank to force start music
  def play_bgm(bgm)
    @bgm = bgm
    return if !$settings.music
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def play_bgs(bgs)
	@bgm = bgm
	return if !$settings.music
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def stop_bgm
    Audio.bgm_stop
  end

  def stop_bgs
    Audio.bgs_stop
  end

  def fadeout_bgm(time)
    @bgm = nil
    Audio.bgm_fade(time * 1000)
  end
  
  def fadeout_bgs(time)
    @bgs = nil
    Audio.bgs_fade(time * 1000)
  end

  def play_me(me)
  	return if !$settings.music
    Audio.me_play("Audio/ME/" + me.name, me.volume, me.pitch)
  end

  def play_se(se)
    return if !$settings.sound
    Audio.se_play("Audio/SE/" + se.name, se.volume, se.pitch)
  end

  #--------------------------------------------------------------------------
  # * Turn on music
  #--------------------------------------------------------------------------
  def enable_music
    Audio.bgm_play("Audio/BGM/" + @bgm.name, @bgm.volume, @bgm.pitch)
    Audio.bgs_play("Audio/BGS/" + @bgs.name, @bgs.volume, @bgs.pitch)
  end     
  
  #--------------------------------------------------------------------------
  # * Turn off music
  #--------------------------------------------------------------------------
  def disable_music
      stop_bgm
      stop_bgs
  end     

end"‹	
 module RPG
  module Cache

    def self.animation(filename, hue)
      self.load_bitmap("Graphics/Animations/", filename, hue)
    end
    def self.autotile(filename)
      self.load_bitmap("Graphics/Autotiles/", filename)
    end
    def self.character(filename, hue)
      self.load_bitmap("Graphics/Characters/", filename, hue)
    end
    def self.cursor(filename)
      self.load_bitmap("Graphics/Cursors/", filename)
    end
    def self.face(filename)
      self.load_bitmap("Graphics/Faces/", filename)
    end
    def self.fog(filename, hue)
      self.load_bitmap("Graphics/Fogs/", filename, hue)
    end
    def self.icon(filename)
      self.load_bitmap("Graphics/Icons/", filename)
    end
    def self.menu(filename)
      self.load_bitmap("Graphics/Menus/", filename)
    end
    def self.panorama(filename, hue)
      self.load_bitmap("Graphics/Panoramas/", filename, hue)
    end
    def self.picture(filename)
      self.load_bitmap("Graphics/Pictures/", filename)
    end
    def self.tileset(filename)
      self.load_bitmap("Graphics/Tilesets/", filename)
    end
    def self.title(filename)
      self.load_bitmap("Graphics/Titles/", filename)
    end
    def self.windowskin(filename)
      self.load_bitmap("Graphics/Windowskins/", filename)
    end
    def self.tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end

    @cache = {}
    def self.load_bitmap(folder_name, filename, hue = 0)
      path = folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          @cache[path] = Bitmap.new(path)
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def self.clear
      @cache = {}
      GC.start
    end
  end
  
end" #==============================================================================
# ** Data Manager
#==============================================================================

class DataManager

  # JsonData
	attr_reader :items
  attr_reader :weapons
  attr_reader :armors

  attr_reader :actors
  attr_reader :enemies
  attr_reader :skills
  attr_reader :states

  attr_reader :progress
  attr_reader :quests
  attr_reader :zones

  # Clone events
  attr_reader :clones

  # RxData
  attr_reader :commons
  attr_reader :tilesets
  attr_reader :system
  attr_reader :mapinfos

	def initialize

    # Create an icon list
    create_icon_list if DEBUG

    # Load up json data
    
    @items = load_json("items",ItemData)
    @weapons = load_json("weapons",WeaponData)
    @armors = load_json("armors",ArmorData)

    @actors = load_json("actors",ActorData)
    @enemies = load_json("enemies",EnemyData)
    @skills = load_json("skills",SkillData)
    @states = load_json("states",StateData)
    
    @progress = load_json("progress",ProgressData)
    @quests = load_json("quests",QuestData)
    @zones = load_json("zones",ZoneData)

    @clones = load_clones
    @funcs = load_funcs

		# Convert to json
    @commons = load_data("Data/CommonEvents.rxdata")
    @tilesets = load_data("Data/Tilesets.rxdata")
    @system = load_data("Data/System.rxdata")
    @mapinfos = load_data("Data/MapInfos.rxdata")

	end

  def create_icon_list

    list = Dir.glob('Graphics/Icons/**/*').select{ |e| File.file? e }
    list.each_index { |i|
      list[i] = list[i].gsub("Graphics/Icons/","")
      list[i] = list[i].gsub(".png","")
    }

    File.open('Editor/icons.json', 'w') { |file|
      file.puts("[")
      list.each{ |l| file.puts("\""+l+"\",") }
      file.puts("\"\"")
      file.puts("]")
    }

  end

  def load_clones

    clones = {}
    map = load_data("Data/Map001.rxdata")

    map.events.each{ |k,ev|
      clones[ev.name.split("#")[0].rstrip!] = ev.pages
    }

    return clones

  end

  def load_funcs

    funcs = {}
    map = load_data("Data/Map002.rxdata")

    map.events.each{ |k,ev|
      
      ev.pages.each{ |p|
        name = ''
        p.list.each{ |cmd|
          if cmd.code == 108 && cmd.parameters[0].include?("%")
            name = cmd.parameters[0]
          end
        }
        next if !name
        funcs[name] = p.list
      }
      
    }

    return funcs

  end

  def load_json(file,type)

    # Load from rxdata if not debug
    if !DEBUG
      return load_data("Data/Json/#{file}.rxdata")
    end

    # Clear out garbage files
    process_data_files(file)

    # If there is no data file, make blank
    if !FileTest.exist?("Editor/json/#{file}.json")
      log_sys "Missing data file: #{file}.json"
      return {}
    end

    # Load up the data
    json_data = File.read("Editor/json/#{file}.json")
    json_data = json_data.gsub(/[:]/, '=>')
    json_data = eval(json_data)

  
    # Create datas
    data = {}
    json_data.each{ |v|
      item = type.new
      v.each{ |var,val|
        # Attempt to convert val to int or float

        item.instance_variable_set("@#{var}", val)
      }
      data[item.id] = item
      
    }

    # Export to rxdata for later
    save_data(data,"Data/Json/#{file}.rxdata")

    return data

  end

  def process_data_files(file)

    # RIGHT, START AT 50 DOWN TO NOTHING! WHEN FOUND REPLACE THE BASE
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        # Found it! Delete the base and rename this one
        File.delete("Editor/json/#{file}.json")
        File.rename("Editor/json/#{file}(#{idx}).json","Editor/json/#{file}.json")
        break
      end
      idx -= 1
    end

    # Delete any with brackets
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        File.delete("Editor/json/#{file}(#{idx}).json")
      end      
      idx -= 1
    end

  end

 end"#==============================================================================
# ** Debug
#==============================================================================

def log_err(msg) $debug.log(msg,'ERROR') end
def log_scr(msg) $debug.log(msg,'SCRIPT') end
def log_info(msg) $debug.log(msg,'INFO') end
def log_sys(msg) $debug.log(msg,'SYSTEM') end
def log_ev(msg) $debug.log(msg,'EVENT') end

class DebugManager

	DEBUG_TIME = 240

	INFO_COLOR = Color.new(220,171,1,120)
	SCRIPT_COLOR = Color.new(128,0,64,120)
	ERROR_COLOR = Color.new(202,0,0,120)
	SYSTEM_COLOR = Color.new(128,0,128,120)
	EVENT_COLOR = Color.new(0,128,128,120)

	INPUT_COLOR = Color.new(0,0,0,160)

	def initialize		
		return if !DEBUG

		# Prepare log file
		@path = $appdata + "\\log.txt"
		File.open(@path, 'w') { |file| }	
		
		# Prepare on screen log
		@viewport = Viewport.new(0,0,640,480)
		@viewport.z = 9999
		
		@sprites = []
		@timer = 120

		# Prepare log
		@previous_text = ""
		@console_text = ""
		@console_sprite = Sprite.new(@viewport)
		@console_sprite.move(20,400)
		@console_sprite.hide
		refresh_console

	end
	

	def update

		if Input.press?(Input::B)
			@timer = 0
		end

		# Fade away sprites
		@timer -= 1
		if !@sprites.empty? && @timer < 20
			@sprites.each{ |s| s.opacity = @timer * 12.6 }
		end
		if @timer <= 0
			@sprites.each{ |s| s.dispose }.clear
		end		

		# Debug keys
		debug_keys

		# If console not showing
		if !@console_sprite.visible
			$keyboard.press?(192) ? @console_sprite.show : return
		end

		# Hide console
		return @console_sprite.hide if $keyboard.press?(192)


		if $keyboard.press?(18)
			@console_text = @previous_text
			refresh_console
		end
									
		# Check console input
		console_chars.each{ |c|
			if $keyboard.hold?(c)
				@console_text += $keyboard.to_char(c)
				refresh_console
			end
		}

		# Check inputs now
		if Input.trigger?(Input::C)
			begin
				eval(@console_text)
			rescue Exception => e
			 	log_scr("Console FAIL: "+e.class.to_s+" --- '" + @console_text + "'")		      
		    end
		    @previous_text = @console_text
			@console_text = ""
			refresh_console
		end

		if $keyboard.press?(8)
			@console_text.chop!
			refresh_console
		end

	end

	def debug_keys

		if $keyboard.press?(48)
			log_info "1 - Toggle Superspeed"
			log_info "2 - Do something else"
		end

	end

	def refresh_console
		@console_sprite.bitmap = Bitmap.new(600,30)
		@console_sprite.bitmap.font.size = 22
		@console_sprite.bitmap.font.bold = true
		@console_sprite.bitmap.fill(INPUT_COLOR)
		@console_sprite.bitmap.draw_text(8,0,600,24,@console_text)
	end

	def console_chars
		chars = (48..57).to_a
		chars += (65..90).to_a
		chars += (186..222).to_a
		chars += [32]
		return chars
	end

	def log(msg,type='LOG')
	    return if !DEBUG

	    msg = "NIL" if msg == nil
	    if msg.is_a?(Array)
	    	msg = "Array: "+msg.join(", ")
	    end
	    if msg.is_a?(Hash)

	    end
		out = type + "\t" + msg.to_s
		File.open(@path, 'a') { |file| file.puts(out) }

		out = msg.to_s
		color = nil

		case type
			when 'INFO'; color = INFO_COLOR
			when 'SCRIPT'; color = SCRIPT_COLOR
			when 'ERROR'; color = ERROR_COLOR
			when 'SYSTEM'; color = SYSTEM_COLOR
			when 'EVENT'; color = EVENT_COLOR
		end

		# Create the sprite
		spr = Sprite.new(@viewport)
		spr.bitmap = Bitmap.new(600,24)
		spr.bitmap.font.size = 18
		spr.bitmap.font.bold = true
		w = spr.bitmap.text_size(out).width
		spr.bitmap.fill_rect(0,0,w+20,spr.bitmap.height,color)
		spr.bitmap.draw_text(8,0,600,24,out)

		# Position
		spr.x = 5
		spr.y = 5 + 28 * @sprites.count
		@sprites.push(spr)

		# Reset log display
		@timer = DEBUG_TIME
		@sprites.each{ |s| s.opacity = 255 }

	end

end"á#==============================================================================
# ** Save File Manager
#==============================================================================

# 99 save files
class FileManager
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def any_save_files?
    !Dir.glob('Av4-*.save').empty?
  end
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def file_exists?(which)
    file = 'Av4-'+which+'.save'
    File.exist?($appPath + file)
  end
  
  #--------------------------------------------------------------------------
  # * Create Filename
  #--------------------------------------------------------------------------
  def make_filename()
    file = "Av4-"+$settings.value('active')+".dean"
    return $appdata + file
  end

  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  def save_game
    File.open(make_filename(), "wb") { |file|
      header = make_save_header  
      body = make_save_contents
      Marshal.dump(header, file)
      Marshal.dump(body, file)
      @last_savefile_index = index
    }
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Execute Load (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_game
    File.open(make_filename(), "rb") do |file|
      Marshal.load(file)
      extract_save_contents(Marshal.load(file))
      reload_map_if_updated
      @index = index
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Load Save Header (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_header
    File.open(make_filename(), "rb") do |file|
      return Marshal.load(file)
    end
    return nil
  end
  
  #--------------------------------------------------------------------------
  # * Delete Save File
  #--------------------------------------------------------------------------
  def delete_save_file()
    File.delete(make_filename()) rescue nil
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Header
  #--------------------------------------------------------------------------
  def make_save_header
    header = {}
    header[:progress] = 140
    #header[:characters] = $game_party.characters_for_savefile
    #header[:playtime_s] = $game_system.playtime_s
    header
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Contents
  #--------------------------------------------------------------------------
  def make_save_contents
    contents = {}
    contents[:journal]       = $journal
    contents[:flags]         = $flags
    contents[:switches]      = $switches
    contents[:variables]     = $variables
    contents[:states]        = $states
    contents[:harvey]        = $harvey
    contents
  end
  
  #--------------------------------------------------------------------------
  # * Extract Save Contents
  #--------------------------------------------------------------------------
  def extract_save_contents(contents)
    $journal       = contents[:journal]
    $flags         = contents[:flags]
    $switches      = contents[:switches]
    $variables     = contents[:variables]
    $states        = contents[:states]
    $harvey        = contents[:harvey]
  end
  
  #--------------------------------------------------------------------------
  # * Get Update Date of Save File
  #--------------------------------------------------------------------------
  def savefile_time_stamp()
    File.mtime(make_filename()) rescue Time.at(0)
  end
  
  #--------------------------------------------------------------------------
  # * Get File Index with Latest Update Date
  #--------------------------------------------------------------------------
  def latest_savefile_index
    savefile_max.times.max_by {|i| savefile_time_stamp(i) }
  end
  
end
"%#==============================================================================
# ** Game Manager
#==============================================================================

class GameManager

	def initialize

      # Make scene object (title screen)
      if DEBUG && $settings.debug_skip_title
        quick_start
      else
        $scene = Scene_Splash.new    
      end

     end

     def quick_start

      # Game State Objects
      $temp = Game_Temp.new
      $progress = Av::Progress.new
      $state = Av::State.new

      $player        = Game_Player.new
      $party = Game_Party.new

      # Model

      
      $map           = Game_Map.new
      $map.setup($data.system.start_map_id)

      # Set up initial map position
      
      $player.moveto($data.system.start_x, $data.system.start_y)
      $player.refresh
      $map.autoplay
      $map.update

      $hud = Game_Hud.new

      # Switch to map screen
      $scene = Scene_Map.new

    end


     def quit?
      return false
    end


     def update

          $keyboard.update
          $mouse.update
          $debug.update
          $hud.update
          Graphics.update
          Input.update
          $scene.update

     end


  def flip_window
    
    # Check for keyboard events
    $showm = Win32API.new 'user32', 'keybd_event', %w(l l l l), ''
    
    if false
      $showm.call(18,0,0,0)
      $showm.call(13,0,0,0)
      $showm.call(13,0,2,0)
      $showm.call(18,0,2,0)
    end

  end

  


end" "t#==============================================================================
# ** Keyboard Manager
#==============================================================================

class KeyboardManager

	KeyState = Win32API.new("user32","GetKeyState",['i'],'i')
	
	def initialize
		@keys = {}
	end

	def state?(key)
		check = KeyState.call(key) #& 0x80 == 128
		return !(check == 1 || check == 0)
	end

	def press?(key)
	  if !@keys.has_key?(key) && state?(key)
	  	@keys[key] = Graphics.frame_count
	  	return true
	  else
	  	return false
	  end
	end 

  def hold?(key)
    return true if press?(key)
    if @keys.has_key?(key)
      if (Graphics.frame_count - @keys[key]) % 8 == 7
        return true
      end
    end
    return false
  end 

  def down?(key)
    return state?(key)
  end

  def up?(key)
    return !state?(key)
  end

	def update
		@keys.delete_if { |k,v| !state?(k)}
	end

	  # http://www.mods.com.au/budapi_docs/Virtual%20Key%20Codes.htm

  def to_char(key)

    shift = Input.press?(Input::SHIFT)

    case key

      when 32; " "
      when 48; shift ? ')' : '0'
      when 49; shift ? '!' : '1'
      when 50; shift ? '@' : '2'
      when 51; shift ? '#' : '3'
      when 52; shift ? '$' : '4'
      when 53; shift ? '%' : '5'
      when 54; shift ? '^' : '6'
      when 55; shift ? '&' : '7'
      when 56; shift ? '*' : '8'
      when 57; shift ? '(' : '9'

      when 65..90; key.chr.downcase

      when 186; shift ? ':' : ';' 
      when 187; shift ? '+' : '=' 
      when 188; shift ? '<' : ',' 
      when 189; shift ? '_' : '-' 
      when 190; shift ? '>' : '.' 
      when 191; shift ? '?' : '/' 
      
      when 219; shift ? '{' : '[' 
      when 220; shift ? '|' : '\\'
      when 221; shift ? '}' : ']' 
      when 222; shift ? '"' : '\''

      else; ''

    end

  end

end"Û#============================================================================== 
# ** Modules.Mouse Input (7.0)              By Near Fantastica & SephirothSpawn
#==============================================================================

class MouseManager

  #--------------------------------------------------------------------------
  # * API Declaration
  #--------------------------------------------------------------------------
  Cursor_Pos    = Win32API.new('user32',    'GetCursorPos',     'p',     'i')
  ShowCursor    = Win32API.new('user32',    'ShowCursor',       'i',     'l')
  Scr2cli       = Win32API.new('user32',    'ScreenToClient',   %w(l p), 'i')
  Findwindow    = Win32API.new('user32',    'FindWindowA',      %w(p p), 'l')

  def initialize
    @pos = [0,0]
    @hwnd = Findwindow.call(nil, "Aveyond") if @hwnd.nil?
  end
  
  def position() @pos; end
  def grid() @pos.map{ |i| i = (i + $map.display_x / 4) / 32 } end
  def on_screen?() !(@pos[0] < 0 || @pos[1] < 0 || @pos[0] >= 640 || @pos[1] >= 480); end
        
  #--------------------------------------------------------------------------
  # * Update Mouse Position
  #--------------------------------------------------------------------------
  def update
    
    # Update Position
    pos = [0,0].pack('ll')
    Cursor_Pos.call(pos)
    Scr2cli.call(@hwnd, pos) 
    @pos = pos.unpack('ll')

    #ShowCursor.call(on_screen?.to_i) # on_screen && mouse_mode
    
  end

end"È#==============================================================================
# ** Nano Manager
#==============================================================================

class NanoManager

	def initialize
		@nanos = []
		@last = Time.now
	end

	def update

		# calc delta
		delta = ((Time.now - @last) * 1000).to_i
		@last = Time.now

		@nanos.delete_if{ |n| n == nil || n.done? }
	    @nanos.each{ |n| n.update(delta) }

	end

	def register(nano)
		@nanos.push(nano)
	end

	def clear(object)
		@nanos.delete_if{ |n| n.parent == object } 
	end

	def clear_all
		@nanos.clear
	end

	def done?(object)
		return @nanos.select{ |n| n.parent == object }.empty?
	end

end"}#==============================================================================
# ** Game_Settings
#==============================================================================

class SettingsManager

  attr_accessor :music
  attr_accessor :sound
  attr_accessor :window
  attr_accessor :effects
  attr_accessor :mouse

  attr_accessor :debug_skip_title
  attr_accessor :debug_fps
  

  # In settings
  attr_accessor :last_file_index          # last save file no.

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize

    # Defaults
    @music = false
    @sound = true
    @window = false
    @effects = false
    @mouse = false

    # Debug options - keys 1-9
    @debug_skip_title = true
    @debug_show_fps = 40
        
    # Load from settings file real quick   
    File.open($appdata+'\settings.txt', "r").each do |line|
      dta = line.split(" ")
      val = dta[1]
      if val.to_i.to_s == val
        val = val.to_i
      elsif val.to_f.to_s == val
        val = val.to_f
      elsif val == "true"
        val = true
      elsif val == "false"
        val = false
      end
      self.instance_variable_set(dta[0],val)
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Get/Set Settings
  #--------------------------------------------------------------------------
  def save() 
    File.open($appdata+'\settings.txt', 'w') { |file|  
      # Write some stats      
      self.instance_variables.each{ |var|
        next if !DEBUG && var.to_s.include?("debug")
        file.puts(var.to_s+" "+self.instance_variable_get(var).to_s)
      }
    }
  end

  def conclude
    @window = Win32API.new('Utils', "IsFullScreen", ["V"], "I").call
  end

end"»
class ItemData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class WeaponData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class ArmorData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class SkillData

end

class StateData

end

class ActorData
	attr_reader :id
	attr_reader :name
	attr_reader :profile
	attr_reader :weapons
	attr_reader :armor
	attr_reader :statratings
end

class EnemyData

end

class ZoneData
	attr_reader :bgm
	attr_reader :bgs
end

class ProgressData
	attr_reader :category
	attr_reader :id
	attr_reader :value
end

class QuestData
	attr_reader :id
end
"q#==============================================================================
# ** MouseCursor
#==============================================================================

module MouseCursor
    Default_Cursor = 'default'
    Event_Cursor   = 'touch'
    Actor_Cursor   = 'default'
    Enemy_Cursor   = 'fight'
    Item_Cursor    = true
    Skill_Cursor   = true
    Dummy = Bitmap.new(32, 32)
end

#==============================================================================
# ** Sprite_Mouse
#==============================================================================

class Sprite_Mouse < Sprite
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    super
    self.z = 10100
    self.ox = 4
    update
  end
  #--------------------------------------------------------------------------
  # ** Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    
    # Update Visibility
    self.visible = $scene != nil
    
    # If Visible
    if self.visible
      
      # If Non-nil Mouse Position
      if Mouse.position != nil
        
        # Gets Mouse Position
        mx, my = *Mouse.position
        
        # Update POsition
        self.x = mx unless mx.nil?
        self.y = my unless my.nil? # (@_NPCname == nil ? my : my - 25) unless my.nil?        
        
      end
      
      # If Scene changes or Mouse is Triggered
      if @scene != $scene.class || Mouse.trigger?
        
        # Update Scene Instance
        @scene = $scene.class
        
        # Update Bitmap
        set_bitmap(MouseCursor::Default_Cursor)
      end
      
    end
    
  end
  #--------------------------------------------------------------------------
  # ** Set Bitmap
  #--------------------------------------------------------------------------
  def set_bitmap(cursor, xNPCname = nil)
    
    # show fancy cursor only if custom mouse on
    if $game_mouse
             
      # If Cursor Info matches
      if (@_cursor == cursor) && (@_NPCname == xNPCname)
        return
      end
      
      # Reset Cursor Info
      @_cursor      = cursor
      @_NPCname     = xNPCname
      
      # Gets Dummy
      dummy = MouseCursor::Dummy
      
      # Gets Item Cursor Bitmap
      item_cursor = cursor.nil? ? MouseCursor::Default_Cursor : cursor
      
      # Start Cursor Bitmap
      bitmap = RPG::Cache.icon("icon-" + item_cursor) if item_cursor != ''

      # Show NPC name
      if @_NPCname != nil
        # Get name width
        w = dummy.text_size(@_NPCname).width
        h = dummy.font.size
        b = RPG::Cache.icon("icon-" + item_cursor)
        # Create New Bitmap
        bitmap = Bitmap.new((bitmap.nil? ? w : 40 + w), [b.height, h + 2].max)
        bitmap.font.size = dummy.font.size
        # Draw Icon
        #if self.x + bitmap.width > 640
        #  textx = bitmap.width - w - b.width # - 10
        #  bitmap.blt(bitmap.width - b.width, 0, b, b.rect)
        #else
          textx = b.width + 10
          bitmap.blt(0, 0, b, b.rect)
        #end
        #bitmap.blt(12 - b.width / 2, 49 - b.height, b, b.rect)
        #bitmap.blt(0, 0, b, b.rect)
        # Draw NPC Name
        #x = item_cursor == '' ? 0 : 32
        bitmap.font.color = Color.new(0, 0, 0, 255) # black
        bitmap.draw_text(textx - 1, 0, w, h, @_NPCname) # 0
        bitmap.draw_text(textx + 1, 0, w, h, @_NPCname) # 0 
        bitmap.draw_text(textx, -1, w, h, @_NPCname) # -1
        bitmap.draw_text(textx, 1, w, h, @_NPCname) # 1
        bitmap.font.color = Color.new(255, 255, 255, 255) # white
        bitmap.draw_text(textx, 0, w, h, @_NPCname)
      end    

      # Set Bitmap
      self.bitmap = bitmap
      
    elsif self.bitmap
      @_cursor = nil
      self.bitmap = nil
      
    end
    
  end
  #--------------------------------------------------------------------------
  # ** Frame Update : Update Event Cursors
  #--------------------------------------------------------------------------
  def update_event_cursors
    
    # If Nil Grid Position
    if Mouse.grid.nil? 
      # Set Default Cursor
      set_bitmap(MouseCursor::Default_Cursor)
      return
    end
    
    # Gets Mouse Position
    x, y = *Mouse.grid
    
    # Gets Mouse Position
    mx, my = *Mouse.position    
    
    # Gets Mouse Event
    event = $game_map.lowest_event_at(x, y)
    
    # If Non-Nil Event or not over map HUD
    unless event.nil? || my >= 448
      # If Not Erased or Nil List
      if event.list != nil && event.erased == false && event.list[0].code == 108
        # Get the cursor to show
        icon = nil
        event.list[0].parameters.to_s.downcase.gsub!(/icon (.*)/) do
          icon = $1.to_s
        end
        
        if !((icon == "talk") || 
           (icon == "touch") || 
           (icon == "fight") || 
           (icon == "examine") || 
           (icon == "point") ||
           (icon == "exit"))
           icon = MouseCursor::Default_Cursor
        end        
        xNPCname = nil 
        if event.list.size > 1 && event.list[1].code == 108
          text = event.list[1].parameters.to_s
          text.gsub!(/[Nn][Aa][Mm][Ee] (.*)/) do
            xNPCname = $1.to_s
          end
        end
        set_bitmap(icon, xNPCname)  
        #self.x = self.x - self.bitmap.width + 24 if self.x + self.bitmap.width > 640
        if event.name != "BOTTOM" # and ["Arrow2", "Arrow4"].include?(icon)
          self.y -= 8
        end
        return
      end
      return
    end
    
    # Set Default Cursor
    set_bitmap(MouseCursor::Default_Cursor)
    
  end
end


  $mouse_sprite = Sprite_Mouse.new
  $mouse_sprite.visible = true
"ß2#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  attr_reader   :x                        # map x-coordinate (logical)
  attr_reader   :y                        # map y-coordinate (logical)
  attr_reader   :real_x                   # map x-coordinate (real * 128)
  attr_reader   :real_y                   # map y-coordinate (real * 128)
  
  
  # Graphics
  attr_reader   :tile_id                  # tile ID (invalid if 0)
  attr_reader   :character_name           # character file name
  attr_reader   :character_hue            # character hue
  attr_accessor   :opacity                  # opacity level
  attr_reader   :blend_type               # blending method
  
  
  attr_accessor :direction                # direction
  attr_reader   :pattern                  # pattern
  attr_reader   :move_route_forcing       # forced move route flag
  attr_reader   :through                  # through
  attr_accessor :animation_id             # animation ID
  attr_accessor :transparent              # transparent flag
  attr_accessor :ignore_movement          # ignore movement when finding path
  attr_accessor :step_anime               # stop animation
  
  
  # Custom
  attr_accessor :off_x, :off_y
  
  
  # for Mouse pathfinding
  attr_accessor :map
  attr_accessor :runpath
  attr_accessor :ovrdest
  
  # for anti-lag processing
  attr_accessor :inrange_char   # CUT
  attr_accessor :inrange_map    # CUT
  
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @tile_id = 0
    @character_name = ""
    @character_hue = 0
    @blend_type = 0
    @direction = 2
    @pattern = 0
    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0
    @move_type = 0
    @move_speed = 3
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0
    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0
    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
    @ignore_movement = false
    
    # for Mouse pathfinding
    @map = nil
    @runpath = false
    @ovrdest = false
    
    # for anti-lag
    inrange_char = false
    inrange_map = false
    
    # for climbing
    @climbing = false

    @opacity = 255
  end
  #--------------------------------------------------------------------------
  # * Determine if Moving
  #--------------------------------------------------------------------------
  def moving?
    # If logical coordinates differ from real coordinates,
    # movement is occurring.
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # * Determine if Jumping
  #--------------------------------------------------------------------------
  def jumping?
    # A jump is occurring if jump count is larger than 0
    return @jump_count > 0
  end
  #--------------------------------------------------------------------------
  # * Straighten Position
  #--------------------------------------------------------------------------
  def straighten
    # If moving animation or stop animation is ON
    if @walk_anime or @step_anime
      # Set pattern to 0
      @pattern = 0
    end
    # Clear animation count
    @anime_count = 0
    # Clear prelock direction
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # * Force Move Route
  #     move_route : new move route
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # Save original move route
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end
    # Change move route
    @move_route = move_route
    @move_route_index = 0
    # Set forced move route flag
    @move_route_forcing = true
    # Clear prelock direction
    @prelock_direction = 0
    # Clear wait count
    @wait_count = 0
    # Move cutsom
    move_type_custom
  end
  #--------------------------------------------------------------------------
  # * Determine if Passable
  #     x : x-coordinate
  #     y : y-coordinate
  #     d : direction (0,2,4,6,8)
  #         * 0 = Determines if all directions are impassable (for jumping)
  #   Shaz - additions to allow for over-counter contact
  #     step : steps to target
  #     tx : x-coordinate of target
  #     ty : y-coordinate of target
  #--------------------------------------------------------------------------
  def passable?(x, y, d, step = 999, tx = nil, ty = nil)
    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
       
    # If coordinates are outside of map
    unless $map.valid?(new_x, new_y)
      return false
    end
    
    # If through is ON
    if @through
      return true
    end
    
    # Able to leave current tile in desired direction?
    # SHAZ: for counter, must be old, counter, new, in a straight line
    unless $map.passable?(x, y, d, self) || (step == 2 && $map.event_at(x, y)) ||
      (step == 3 && $map.counter?(x, y) && tx != nil && ty != nil &&
      new_x - x == x - tx && new_y - y == y - ty)
      return false
    end

    # Able to enter adjoining tile in current direction?
    unless $map.passable?(new_x, new_y, 10 - d) ||
      (step == 2 && $map.counter?(new_x, new_y))
      return false
    end

    # SHAZ - ignore events sitting on a counter next to the destination
    if step != 2 || !$map.counter?(new_x, new_y)          
      # Loop all events
      for event in $map.events.values
        # If event coordinates are consistent with move destination
        if event.x == new_x and event.y == new_y
          @state = true
          # If through is OFF
          unless event.through
            # If self is event
            if self != $player
              return false
            end
            # With self as the player and partner graphic as character
            if event.character_name != ""
              return false
            end
          end
        end
      end
    end

    # If player coordinates are consistent with move destination
    if $player.x == new_x && $player.y == new_y && self != $player
      # If through is OFF
      unless $player.through
        # If your own graphic is the character
        if @character_name != ""
          return false
        end
      end
    end
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Determine if Can Fight (use on events only before battle processing)
  #--------------------------------------------------------------------------
  def canfight?()
    # Get direction
    x = @x
    y = @y
    return true if @x == $player.x and @y == $player.y
    d = 2 if @x == $player.x and @y == $player.y - 1
    d = 8 if @x == $player.x and @y == $player.y + 1
    d = 4 if @y == $player.y and @x == $player.x + 1
    d = 6 if @y == $player.y and @x == $player.x - 1
    return false if d == nil
    
    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    
    # If coordinates are outside of map
    unless $map.valid?(new_x, new_y)
      # impassable
      return false
    end
    
    # If through is ON
    if @through
      # passable
      return true
    end
        
    # If unable to leave first move tile in designated direction
    unless $map.passable?(x, y, d, self)
      # impassable
      return false
    end
    
    # If unable to enter move tile in designated direction
    unless $map.passable?(new_x, new_y, 10 - d)
      # impassable
      return false
    end

    return true
  end

  #--------------------------------------------------------------------------
  # * Lock
  #--------------------------------------------------------------------------
  def lock
    # If already locked
    if @locked
      # End method
      return
    end
    # Save prelock direction
    @prelock_direction = @direction
    # Turn toward player
    turn_toward_player
    # Set locked flag
    @locked = true
  end

  #--------------------------------------------------------------------------
  # * Determine if Locked
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end

  #--------------------------------------------------------------------------
  # * Unlock
  #--------------------------------------------------------------------------
  def unlock
    # If not locked
    unless @locked
      # End method
      return
    end
    # Clear locked flag
    @locked = false
    # If direction is not fixed
    unless @direction_fix
      # If prelock direction is saved
      if @prelock_direction != 0
        # Restore prelock direction
        @direction = @prelock_direction
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x % $map.width
    @y = y % $map.height
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end

  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    # Get screen coordinates from real coordinates and map display position
    return (@real_x - $map.display_x + 3) / 4 + 16
  end

  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    # Get screen coordinates from real coordinates and map display position
    y = (@real_y - $map.display_y + 3) / 4 + 32
    # Make y-coordinate smaller via jump count
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    return y - (@jump_peak * @jump_peak - n * n) / 2
  end
  #--------------------------------------------------------------------------
  # * Get Screen Z-Coordinates
  #     height : character height
  #--------------------------------------------------------------------------
  def screen_z(height = 0)

    # Some sort of below character here


    if @always_on_top
      # 999, unconditional
      return 999
    end

    # Get screen coordinates from real coordinates and map display position
    z = (@real_y - $map.display_y + 3) / 4 + 32
    # If tile
    if @tile_id > 0
      # Add tile priority * 32
      return z + $map.priorities[@tile_id] * 32
    # If character
    else
      # If height exceeds 32, then add 31
      return z + ((height > 32) ? 31 : 0)
    end

  end

  #--------------------------------------------------------------------------
  # * Get Thicket Depth
  #--------------------------------------------------------------------------
  def bush_depth
    # If tile, or if display flag on the closest surface is ON
    if @tile_id > 0 or @always_on_top
      return 0
    end
    # If element tile other than jumping, then 12; anything else = 0
    if @jump_count == 0 and $map.bush?(@x, @y)
      return 12
    else
      return 0
    end
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #--------------------------------------------------------------------------
  def terrain_tag
    return $map.terrain_tag(@x, @y)
  end

end
"6.#==============================================================================
# ** Game_Character (part 2)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    # Mouse pathfinding
    #run_path if @runpath == true
    
    # Branch with jumping, moving, and stopping
    if jumping?
      update_jump
    elsif moving?
      update_move
    else
      update_stop
    end

    # If animation count exceeds maximum value
    # * Maximum value is move speed * 1 taken from basic value 18
    if @anime_count > 18 - @move_speed * 2
      # If stop animation is OFF when stopping
      if not @step_anime and @stop_count > 0
        # Return to original pattern
        @pattern = @original_pattern
      # If stop animation is ON when moving
      else
        # Update pattern
        @pattern = (@pattern + 1) % 4
      end
      # Clear animation count
      @anime_count = 0
    end
    # If waiting
    if @wait_count > 0
      # Reduce wait count
      @wait_count -= 1
      return
    end
    # If move route is forced
    if @move_route_forcing
      # Custom move
      move_type_custom
      return
    end
    # When waiting for event execution or locked
    if @starting or lock?
      # Not moving by self
      return
    end
    # If stop count exceeds a certain value (computed from move frequency)
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # Branch by move type
      case @move_type
      when 1  # Random
        move_type_random
      when 2  # Approach
        move_type_toward_player
      when 3  # Custom
        move_type_custom
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update (jump)
  #--------------------------------------------------------------------------
  def update_jump
    # Reduce jump count by 1
    @jump_count -= 1
    # Calculate new coordinates
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)
  end

  #--------------------------------------------------------------------------
  # * Update frame (move)
  #--------------------------------------------------------------------------
  def update_move
    # Convert map coordinates from map move speed into move distance
    distance = 2 ** @move_speed
    # If logical coordinates are further down than real coordinates
    if @y * 128 > @real_y
      # Move down
      @real_y = [@real_y + distance, @y * 128].min
    end
    # If logical coordinates are more to the left than real coordinates
    if @x * 128 < @real_x
      # Move left
      @real_x = [@real_x - distance, @x * 128].max
    end
    # If logical coordinates are more to the right than real coordinates
    if @x * 128 > @real_x
      # Move right
      @real_x = [@real_x + distance, @x * 128].min
    end
    # If logical coordinates are further up than real coordinates
    if @y * 128 < @real_y
      # Move up
      @real_y = [@real_y - distance, @y * 128].max
    end
    # If move animation is ON
    if @walk_anime
      # Increase animation count by 1.5
      @anime_count += 1.5
    # If move animation is OFF, and stop animation is ON
    elsif @step_anime
      # Increase animation count by 1
      @anime_count += 1
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update (stop)
  #--------------------------------------------------------------------------
  def update_stop
    # If stop animation is ON
    if @step_anime
      # Increase animation count by 1
      @anime_count += 1
    # If stop animation is OFF, but current pattern is different from original
    elsif @pattern != @original_pattern
      # Increase animation count by 1.5
      @anime_count += 1.5
    end
    # When waiting for event execution, or not locked
    # * If lock deals with event execution coming to a halt
    unless @starting or lock?
      # Increase stop count by 1
      @stop_count += 1
    end
  end
  
  #--------------------------------------------------------------------------
  # * Move Type : Random
  #--------------------------------------------------------------------------
  def move_type_random
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Random
      move_random
    when 4  # 1 step forward
      move_forward
    when 5  # Temporary stop
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # Get difference in player coordinates
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_toward_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Custom
  #--------------------------------------------------------------------------
  def move_type_custom
    # Interrupt if not stopping
    if jumping? or moving?
      return
    end
    # Loop until finally arriving at move command list
    while @move_route_index < @move_route.list.size
      # Acquiring move command
      command = @move_route.list[@move_route_index]
      # If command code is 0 (last part of list)
      if command.code == 0
        # If [repeat action] option is ON
        if @move_route.repeat
          # First return to the move route index
          @move_route_index = 0
        end
        # If [repeat action] option is OFF
        unless @move_route.repeat
          # If move route is forcing
          if @move_route_forcing and not @move_route.repeat
            # Release forced move route
            @move_route_forcing = false
            # Restore original move route
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # Clear stop count
          @stop_count = 0
        end
        return
      end
      # During move command (from move down to jump)
      if command.code <= 14
        # Branch by command code
        case command.code
        when 1  # Move down
          move_down
        when 2  # Move left
          move_left
        when 3  # Move right
          move_right
        when 4  # Move up
          move_up
        when 5  # Move lower left
          move_lower_left
        when 6  # Move lower right
          move_lower_right
        when 7  # Move upper left
          move_upper_left
        when 8  # Move upper right
          move_upper_right
        when 9  # Move at random
          move_random
        when 10  # Move toward player
          move_toward_player
        when 11  # Move away from player
          move_away_from_player
        when 12  # 1 step forward
          move_forward
        when 13  # 1 step backward
          move_backward
        when 14  # Jump
          jump(command.parameters[0], command.parameters[1])
        end
        # If movement failure occurs when [Ignore if can't move] option is OFF
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end
      # If waiting
      if command.code == 15
        # Set wait count
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end
      # If direction change command
      if command.code >= 16 and command.code <= 26
        # Branch by command code
        case command.code
        when 16  # Turn down
          turn_down
        when 17  # Turn left
          turn_left
        when 18  # Turn right
          turn_right
        when 19  # Turn up
          turn_up
        when 20  # Turn 90Â° right
          turn_right_90
        when 21  # Turn 90Â° left
          turn_left_90
        when 22  # Turn 180Â°
          turn_180
        when 23  # Turn 90Â° right or left
          turn_right_or_left_90
        when 24  # Turn at Random
          turn_random
        when 25  # Turn toward player
          turn_toward_player
        when 26  # Turn away from player
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end
      # If other command
      if command.code >= 27
        # Branch by command code
        case command.code
        when 27  # Switch ON
          $game_switches[command.parameters[0]] = true
          $game_map.need_refresh = true
        when 28  # Switch OFF
          $game_switches[command.parameters[0]] = false
          $game_map.need_refresh = true
        when 29  # Change speed
          @move_speed = command.parameters[0]
        when 30  # Change freq
          @move_frequency = command.parameters[0]
        when 31  # Move animation ON
          @walk_anime = true
        when 32  # Move animation OFF
          @walk_anime = false
        when 33  # Stop animation ON
          @step_anime = true
        when 34  # Stop animation OFF
          @step_anime = false
        when 35  # Direction fix ON
          @direction_fix = true
        when 36  # Direction fix OFF
          @direction_fix = false
        when 37  # Through ON
          @through = true
        when 38  # Through OFF
          @through = false
        when 39  # Always on top ON
          @always_on_top = true
        when 40  # Always on top OFF
          @always_on_top = false
        when 41  # Change Graphic
          @tile_id = 0
          @character_name = command.parameters[0]
          @character_hue = command.parameters[1]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # Change Opacity
          @opacity = command.parameters[0]
        when 43  # Change Blending
          @blend_type = command.parameters[0]
        when 44  # Play SE
          $game_system.se_play(command.parameters[0])
        when 45  # Script
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    # Clear stop count
    @stop_count = 0
  end
end
">#==============================================================================
# ** Game_Character (part 3)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  #--------------------------------------------------------------------------
  # * Move Down
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)

    # Turn down
    if turn_enabled
      turn_down
    end
    # If passable
    if passable?(@x, @y, 2)

      # Turn down
      turn_down
      # Update coordinates
      @y += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Left
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)
    # Turn left
    if turn_enabled
      turn_left
    end
    # If passable
    if passable?(@x, @y, 4)
      # Turn left
      turn_left
      # Update coordinates
      @x -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Right
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)
    # Turn right
    if turn_enabled
      turn_right
    end
    # If passable
    if passable?(@x, @y, 6)
      # Turn right
      turn_right
      # Update coordinates
      @x += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move up
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)
    # Turn up
    if turn_enabled
      turn_up
    end
    # If passable
    if passable?(@x, @y, 8)
      # Turn up
      turn_up
      # Update coordinates
      @y -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Left
  #--------------------------------------------------------------------------
  def move_lower_left
    # If no direction fix
    unless @direction_fix
      # Face down is facing right or up
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # When a down to left or a left to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # Update coordinates
      @x -= 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Right
  #--------------------------------------------------------------------------
  def move_lower_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face down if facing up
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # When a down to right or a right to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # Update coordinates
      @x += 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Left
  #--------------------------------------------------------------------------
  def move_upper_left
    # If no direction fix
    unless @direction_fix
      # Face left if facing right, and face up if facing down
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # When an up to left or a left to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # Update coordinates
      @x -= 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Right
  #--------------------------------------------------------------------------
  def move_upper_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face up if facing down
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # When an up to right or a right to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # Update coordinates
      @x += 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move at Random
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # Move down
      move_down(false)
    when 1  # Move left
      move_left(false)
    when 2  # Move right
      move_right(false)
    when 3  # Move up
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * Move toward Player
  #--------------------------------------------------------------------------
  def move_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Move away from Player
  #--------------------------------------------------------------------------
  def move_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move away from player, prioritize left and right directions
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # If vertical distance is longer
    else
      # Move away from player, prioritize up and down directions
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Forward
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Backward
  #--------------------------------------------------------------------------
  def move_backward
    # Remember direction fix situation
    last_direction_fix = @direction_fix
    # Force directino fix
    @direction_fix = true
    # Branch by direction
    case @direction
    when 2  # Down
      move_up(false)
    when 4  # Left
      move_right(false)
    when 6  # Right
      move_left(false)
    when 8  # Up
      move_down(false)
    end
    # Return direction fix situation back to normal
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # * Jump
  #     x_plus : x-coordinate plus value
  #     y_plus : y-coordinate plus value
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # If plus value is not (0,0)
    if x_plus != 0 or y_plus != 0
      # If horizontal distnace is longer
      if x_plus.abs > y_plus.abs
        # Change direction to left or right
        x_plus < 0 ? turn_left : turn_right
      # If vertical distance is longer, or equal
      else
        # Change direction to up or down
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # Calculate new coordinates
    new_x = @x + x_plus
    new_y = @y + y_plus
    # If plus value is (0,0) or jump destination is passable
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # Straighten position
      straighten
      # Update coordinates
      @x = new_x
      @y = new_y
      # Calculate distance
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # Set jump count
      @jump_peak = 10 + distance - @move_speed
      @jump_count = @jump_peak * 2
      # Clear stop count
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Down
  #--------------------------------------------------------------------------
  def turn_down
    unless @direction_fix
      @direction = 2
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Left
  #--------------------------------------------------------------------------
  def turn_left
    unless @direction_fix
      @direction = 4
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Right
  #--------------------------------------------------------------------------
  def turn_right
    unless @direction_fix
      @direction = 6
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Up
  #--------------------------------------------------------------------------
  def turn_up
    unless @direction_fix
      @direction = 8
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Left
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 180Â°
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right or Left
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # * Turn at Random
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Towards Player
  #--------------------------------------------------------------------------
  def turn_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Away from Player
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left away from player
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down away from player
      sy > 0 ? turn_down : turn_up
    end
  end

  #--------------------------------------------------------------------------
  # * Turn Towards Event
  #--------------------------------------------------------------------------
  def turn_toward_event(event_id)
    # Get difference in player coordinates
    evt = $game_map.events[event_id]
    return if evt == nil
    sx = @x - evt.x
    sy = @y - evt.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end
end
"l# #==============================================================================
# # ** Game_Character (part 4 - Pathfinding)
# #------------------------------------------------------------------------------
# #  This class deals with characters. It's used as a superclass for the
# #  Game_Player and Game_Event classes.
# #  These functions are used by the Mouse module for path finding and moving
# #==============================================================================

# class Game_Character
#   #--------------------------------------------------------------------------
#   # * Frame Update (run_path)
#   #--------------------------------------------------------------------------
#   def run_path
#     return if moving?
#     step = @map[@x,@y]
#     if step == 1
#       @map = nil
#       @runpath = false
#       return
#     end
      
#     dir = rand(2)
#     case dir
#     when 0
#       move_right if @map[@x+1,@y] == step - 1 and step != 0
#       move_down if @map[@x,@y+1] == step - 1 and step != 0
#       move_left if @map[@x-1,@y] == step -1 and step != 0
#       move_up if @map[@x,@y-1] == step - 1 and step != 0
#     when 1
#       move_up if @map[@x,@y-1] == step - 1 and step != 0
#       move_left if @map[@x-1,@y] == step -1 and step != 0
#       move_down if @map[@x,@y+1] == step - 1 and step != 0
#       move_right if @map[@x+1,@y] == step - 1 and step != 0
#     end
#   end
#   #--------------------------------------------------------------------------
#   # * Find Path
#   #--------------------------------------------------------------------------
#   def find_path(x,y, force = true)
#     sx, sy = @x, @y
#     result = setup_map(sx,sy,x,y)
#     @runpath = result[0]
#     @map = result[1]
#     @map[sx,sy] = result[2] if result[2] != nil
#     $player.ignore_movement = @runpath ? force : false
#   end
#   #--------------------------------------------------------------------------
#   # * Clear Path
#   #--------------------------------------------------------------------------
#   def clear_path
#     @map = nil
#     @runpath = false
#     @ovrdest = false
#     $player.ignore_movement = false
#   end
#   #--------------------------------------------------------------------------
#   # * Setup Map
#   #--------------------------------------------------------------------------
#   def setup_map(sx,sy,ex,ey)
#     map = Table.new($map.width, $map.height)

#     # Shaz - does the event override the destination?
#     tx = ex
#     ty = ey
#     event = $map.event_at(ex, ey)
#     if !event.nil? && !event.list.nil? && !event.erased && 
#       event.list.size > 1 && event.list[1].code == 108
#       text = event.list[1].parameters.to_s
#       text.gsub!(/[Mm][Oo][Uu][Ss][Ee]\[([-,0-9]+),([-,0-9]+)\]/) do
#         tx = ex + $1.to_i
#         ty = ey + $2.to_i
#         map[ex, ey] = 999
#         @ovrdest = true
#       end
#       tx += 1 if event.y == ey + 1
#     elsif !event.nil? && !event.erased && event.x == ex && event.y == ey + 1
#       tx = ex
#       ty = ey + 1
#       map[ex, ey] = 999
#       @ovrdest = true
#     end
      
#     update_counter = 0
#     map[tx,ty] = 1
#     old_positions = []
#     new_positions = []
#     old_positions.push([tx, ty])
#     depth = 2
#     $path_allow = false
#     depth.upto(100){|step|
#       loop do
#         break if old_positions[0] == nil
#         x,y = old_positions.shift
#         return [true, map, step-1] if x == sx and y == sy
#         if map[x,y + 1] == 0 and $player.passable?(x, y, 2, step, tx, ty) 
#           map[x,y + 1] = step
#           new_positions.push([x,y + 1])
#         end
#         if map[x - 1,y] == 0 and $player.passable?(x, y, 4, step, tx, ty) 
#           map[x - 1,y] = step
#           new_positions.push([x - 1,y])
#         end
#         if map[x + 1,y] == 0 and $player.passable?(x, y, 6, step, tx, ty) 
#           map[x + 1,y] = step
#           new_positions.push([x + 1,y])
#         end
#         if map[x,y - 1] == 0 and $player.passable?(x, y, 8, step, tx, ty) 
#           map[x,y - 1] = step
#           new_positions.push([x,y - 1])
#         end
          
#         # If we've checked quite a few tiles, allow graphics and input
#         # to update - to avoid the 'script hanging' error
#         update_counter += 1
#         if update_counter > 100
#           Graphics.update
#           update_counter = 0
#         end
#       end

#       old_positions = new_positions
#       new_positions = []
#     }
      
#     @ovrdest = false
#     return [false, nil, nil]        
#   end
# end
"ð #==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class deals with events. It handles functions including event page 
#  switching via condition determinants, and running parallel process events.
#  It's used within the Game_Map class.
#==============================================================================

class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :trigger                  # trigger
  attr_reader   :list                     # list of event commands
  attr_reader   :starting                 # starting flag
  
  attr_reader   :name
      
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     event  : event (RPG::Event)
  #--------------------------------------------------------------------------
  def initialize(event)
    super()

    @event = event
    @id = event.id
    
    @erased = false
    @disabled = $state.disable?(@id)
    @deleted = $state.delete?(@id)

    @starting = false
    @through = true

    @width = 1
    @height = 1

    # Name breakdown
    name = @event.name
    if name.include?('::')
      name = name.delete('::')
      clone = name
    end
    if name == '' || name == '#'
      @icon = nil
      @name = 'nil'
    else
      data = name.split('#').first.split('.')
      if data.size > 1
        @icon = data[0].strip
        @name = data[1].strip
      else
        @icon = @name = data[0].strip
      end
    end   
    
    # Set pages from clone or event
    if clone
      @pages = $data.clones[clone]
    else
      @pages = @event.pages 
    end

    # Restore saved location if relevant
    if $state.loc?(@id)
      loc = $state.getloc(@id)
      moveto(loc[0],loc[1])
    else
      moveto(@event.x, @event.y)
    end
    
    refresh
  end

  #--------------------------------------------------------------------------
  # * Clear Starting Flag
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end

  def icon
    return nil if @erased || @disabled || @deleted
    return @icon
  end

  def collide?(x,y)
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine if Over Trigger
  #    is this event under player
  #--------------------------------------------------------------------------
  def over_trigger?
    # If not through situation with character as graphic
    if @character_name != "" and not @through
      # Starting determinant is face
      return false
    end
    # If this position on the map is impassable
    unless $map.passable?(@x, @y, 0)
      # Starting determinant is face
      return false
    end
    # Starting determinant is same position
    return true
  end

  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  def start  
    return if @erased || @deleted || @disabled
    return if !@list || @list.size < 1
    @starting = true    
  end

  def find_page
    return nil if @erased || @deleted
    @pages.reverse.find { |page| 
      conditions_met?(page) 
    } 
  end

  def conditions_met?(page)
      
        # DANHAX - check super conditions
        page.list.each{ |line|
      
          if line.code == 108
            comment = line.parameters[0]
            if comment[0] == '?'[0]
              data = comment.split(' ')
              if !condition_applies?(data)
                return false
              end
            end
          end        
        }  

        return true
  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    new_page = find_page
    setup_page(new_page) if new_page != @page
  end

  
  
  def setup_page(new_page)

    # Set @page as current event page
    @page = new_page
    if @page
      setup_page_settings
      read_comment_data
    else
      clear_page_settings
    end

    # Clear starting flag
    clear_starting
    
    # If trigger is [parallel process]
    if @trigger == 4
      @interpreter = Interpreter.new
      @interpreter.setup(@list, @event.id)
    end

    # Auto event start determinant
    check_event_trigger_auto

  end
  

  def clear_page_settings
      @tile_id = 0
      @character_name = ""
      @character_hue = 0
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
  end

  def setup_page_settings
    # Set each instance variable
    @tile_id = @page.graphic.tile_id
    @character_name = @page.graphic.character_name
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    @opacity = @page.graphic.opacity
    @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    @always_on_top = @page.always_on_top
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil

  end
  
  def read_comment_data
    comment_data = []

    @list.each{ |line|
      next if line.code != 108
      if line.parameters[0].include?('#')
        comment_data.push(line.parameters[0].split(" "))
      end
    }

    comment_data.each{ |data|
      case data[0]

        when '#opacity'
          self.opacity = data[1].to_i
        when '#width'
          @width = data[1].to_i
        when '#height'
          @height = data[1].to_i

      end
    }

  end

  #--------------------------------------------------------------------------
  # * Automatic Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # # If trigger is [touch from event] and consistent with player coordinates
    # if @trigger == 2 and @x == $player.x and @y == $player.y
    #   # If starting determinant other than jumping is same position event
    #   if not jumping? and over_trigger?
    #     start
    #   end
    # end
    # If trigger is [auto run]
    if @trigger == 3 || @event.name == 'AUTORUN'
      start
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    # Automatic event starting determinant
    check_event_trigger_auto

    # If parallel process is valid
    if @interpreter != nil
      @interpreter.update
    end

  end
    
  #--------------------------------------------------------------------------
  # * Save Position
  #--------------------------------------------------------------------------
  def saveloc
    $state.loc!(@event.id)
  end

  #--------------------------------------------------------------------------
  # * Temporarily Erase
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    refresh
  end

  def disable
    @disabled = true
    $state.disable!(@id)
    refresh
  end

  def delete
    @deleted = true
    $state.delete!(@id)
    refresh
  end

end"y<#==============================================================================
# ** Game_Map
#==============================================================================

class Game_Map
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :tileset  
  
  # keep these
  attr_reader   :passages                 # passage table
  attr_reader   :priorities               # prioroty table
  attr_reader   :terrain_tags             # terrain tag table
    
  attr_accessor :display_x                # display x-coordinate * 128
  attr_accessor :display_y                # display y-coordinate * 128
  attr_accessor :need_refresh             # refresh request flag
  
  attr_reader   :events                   # events
  
  attr_reader   :fog_ox                   # fog x-coordinate starting point
  attr_reader   :fog_oy                   # fog y-coordinate starting point
  attr_reader   :fog_tone                 # fog color tone
  
  
  attr_reader   :map_name                 # name of the map
    
  attr_accessor :transition_processing    # transition processing flag
  attr_accessor :transition_name          # transition file name
  
  attr_accessor :new_tileset

  attr_reader :interpreter
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @map_id = 0
    @display_x = 0
    @display_y = 0

    @interpreter = Interpreter.new(0,true)
  end
  
  #--------------------------------------------------------------------------
  # * Setup
  #     map_id : map ID
  #--------------------------------------------------------------------------
  def setup(map_id)
    @new_tileset = true
    
    # Put map ID in @map_id memory
    @map_id = map_id
    
    # Load map from file and set @map
    @map = load_data(sprintf("Data/Map%03d.rxdata", @map_id))
    @map_name = $data.mapinfos[map_id].name 
        
    # Hold onto the tileset
    @tileset = $data.tilesets[@map.tileset_id]
        
    @passages = @tileset.passages
    @priorities = @tileset.priorities
    @terrain_tags = @tileset.terrain_tags
    
    # Initialize displayed coordinates
    @display_x = 0
    @display_y = 0
    
    # Clear refresh request flag
    @need_refresh = false
    
    # Set map event data
    @events = {}
    for i in @map.events.keys
      @events[i] = Game_Event.new(@map.events[i])
    end
    
    # Initialize all fog information
    @fog_ox = 0
    @fog_oy = 0
    @fog_tone = Tone.new(0, 0, 0, 0)
    @fog_tone_target = Tone.new(0, 0, 0, 0)
    @fog_tone_duration = 0
    @fog_opacity_duration = 0
    @fog_opacity_target = 0
    
    # Initialize scroll information
    @scroll_direction = 2
    @scroll_rest = 0
    @scroll_speed = 4
        
    # Clear player path for mouse pathfinding
    #$player.clear_path
    
  end

  #--------------------------------------------------------------------------
  # * Get Tileset ID
  #--------------------------------------------------------------------------
  def tileset_id
    return @map.tileset_id
  end

  #--------------------------------------------------------------------------
  # * Get Map ID
  #--------------------------------------------------------------------------
  def map_id
    return @map_id
  end

  #--------------------------------------------------------------------------
  # * Get Width
  #--------------------------------------------------------------------------
  def width
    return @map.width
  end

  #--------------------------------------------------------------------------
  # * Get Height
  #--------------------------------------------------------------------------
  def height
    return @map.height
  end
  
  #--------------------------------------------------------------------------
  # * Get Map Data
  #--------------------------------------------------------------------------
  def data
    return @map.data
  end
  
  #--------------------------------------------------------------------------
  # * Automatically Change Background Music and Backround Sound
  #--------------------------------------------------------------------------
  def autoplay
    # Zones!
    if @map.autoplay_bgm
      $game_system.bgm_play(@map.bgm)
    end
    if @map.autoplay_bgs
      $game_system.bgs_play(@map.bgs)
    end
  end

  #--------------------------------------------------------------------------
  # * Automatically Change Background Music and Backround Sound
  #--------------------------------------------------------------------------
  def autoplay_bgs
      $game_system.bgs_play(@map.bgs)
  end  
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    # If map ID is effective
    if @map_id > 0
      # Refresh all map events
      for event in @events.values
        event.refresh
      end
    end

    # Clear refresh request flag
    @need_refresh = false
  end
  
  #--------------------------------------------------------------------------
  # * Scroll Down
  #     distance : scroll distance
  #--------------------------------------------------------------------------
  def scroll_down(distance)
    # agf - changed 15 to 14.  Determines bottom of map.
    @display_y = [@display_y + distance, (self.height - 14) * 128].min
  end

  #--------------------------------------------------------------------------
  # * Scroll Left
  #     distance : scroll distance
  #--------------------------------------------------------------------------
  def scroll_left(distance)
    @display_x = [@display_x - distance, 0].max
  end

  #--------------------------------------------------------------------------
  # * Scroll Right
  #     distance : scroll distance
  #--------------------------------------------------------------------------
  def scroll_right(distance)
    @display_x = [@display_x + distance, (self.width - 20) * 128].min
  end
  #--------------------------------------------------------------------------
  # * Scroll Up
  #     distance : scroll distance
  #--------------------------------------------------------------------------
  def scroll_up(distance)
    @display_y = [@display_y - distance, 0].max
  end

  #--------------------------------------------------------------------------
  # * Determine Valid Coordinates
  #     x          : x-coordinate
  #     y          : y-coordinate
  #--------------------------------------------------------------------------
  def valid?(x, y)
    return (x >= 0 and x < width and y >= 0 and y < height)
  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #     x          : x-coordinate
  #     y          : y-coordinate
  #     d          : direction (0,2,4,6,8,10)
  #                  *  0,10 = determine if all directions are impassable
  #     self_event : Self (If event is determined passable)
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil)
    # If coordinates given are outside of the map
    unless valid?(x, y)
      # impassable
      return false
    end
    # Change direction (0,2,4,6,8,10) to obstacle bit (0,1,2,4,8,0)
    bit = (1 << (d / 2 - 1)) & 0x0f
    # Loop in all events
    for event in events.values
      # If tiles other than self are consistent with coordinates
      if event.tile_id >= 0 and event != self_event and
         event.x == x and event.y == y and not event.through
        # If obstacle bit is set
        if @passages[event.tile_id] & bit != 0
          # impassable
          return false
        # If obstacle bit is set in all directions
        elsif @passages[event.tile_id] & 0x0f == 0x0f
          # impassable
          return false
        # If priorities other than that are 0
        elsif @priorities[event.tile_id] == 0
          # passable
          return true
        end
      end
    end
    # Loop searches in order from top of layer
    for i in [2, 1, 0]
      # Get tile ID
      tile_id = data[x, y, i]
      # Tile ID acquistion failure
      if tile_id == nil
        # impassable
        return false
      # If obstacle bit is set
      elsif @passages[tile_id] & bit != 0
        # impassable
        return false
      # If obstacle bit is set in all directions
      elsif @passages[tile_id] & 0x0f == 0x0f
        # impassable
        return false
      # If priorities other than that are 0
      elsif @priorities[tile_id] == 0
        # passable
        return true
      end
    end
    # passable
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine Thicket
  #     x          : x-coordinate
  #     y          : y-coordinate
  #--------------------------------------------------------------------------
  def bush?(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return false
        elsif @passages[tile_id] & 0x40 == 0x40
          return true
        end
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Determine Counter
  #     x          : x-coordinate
  #     y          : y-coordinate
  #--------------------------------------------------------------------------
  def counter?(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return false
        elsif @passages[tile_id] & 0x80 == 0x80
          return true
        end
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #     x          : x-coordinate
  #     y          : y-coordinate
  #--------------------------------------------------------------------------
  def terrain_tag(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return 0
        elsif tile_id > 0   # @terrain_tags[tile_id] > 0
          return @terrain_tags[tile_id]
        end
      end
    end
    return 0
  end

  #--------------------------------------------------------------------------
  # * Get Designated Position Event ID
  #     x          : x-coordinate
  #     y          : y-coordinate
  #--------------------------------------------------------------------------
  def check_event(x, y)
    for event in $map.events.values
      if event.x == x and event.y == y
        return event.id
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Start Scroll
  #     direction : scroll direction
  #     distance  : scroll distance
  #     speed     : scroll speed
  #--------------------------------------------------------------------------
  def start_scroll(direction, distance, speed)
    @scroll_direction = direction
    @scroll_rest = distance * 128
    @scroll_speed = speed
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Scrolling
  #--------------------------------------------------------------------------
  def scrolling?
    return @scroll_rest > 0
  end


  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    @interpreter.update

    # GET IT WORKING BETTER
    #return

    # Refresh map if necessary
    if $map.need_refresh
      refresh
    end
    # If scrolling
    if @scroll_rest > 0
      # Change from scroll speed to distance in map coordinates
      distance = 2 ** @scroll_speed
      # Execute scrolling
      case @scroll_direction
      when 2  # Down
        scroll_down(distance)
      when 4  # Left
        scroll_left(distance)
      when 6  # Right
        scroll_right(distance)
      when 8  # Up
        scroll_up(distance)
      end
      # Subtract distance scrolled
      @scroll_rest -= distance
    end
    # Update map event
    for event in @events.values
      # event must be in range to be updated (anti-lag)
      #if (event.inrange_map and event.event.name != ANTI_LAG_EVENT_NAME) or
      #  [3,4].include?event.trigger
        event.update
      #end
    end
    
    # Manage fog scrolling
   # @fog_ox -= @fog_sx / 8.0
   # @fog_oy -= @fog_sy / 8.0
    
    # Manage change in fog color tone
    # if @fog_tone_duration >= 1
    #   d = @fog_tone_duration
    #   target = @fog_tone_target
    #   @fog_tone.red = (@fog_tone.red * (d - 1) + target.red) / d
    #   @fog_tone.green = (@fog_tone.green * (d - 1) + target.green) / d
    #   @fog_tone.blue = (@fog_tone.blue * (d - 1) + target.blue) / d
    #   @fog_tone.gray = (@fog_tone.gray * (d - 1) + target.gray) / d
    #   @fog_tone_duration -= 1
    # end
    # # Manage change in fog opacity level
    # if @fog_opacity_duration >= 1
    #   d = @fog_opacity_duration
    #   @fog_opacity = (@fog_opacity * (d - 1) + @fog_opacity_target) / d
    #   @fog_opacity_duration -= 1
    # end
  end
  
  #--------------------------------------------------------------------------
  # * Event At
  #--------------------------------------------------------------------------
  def event_at(x, y)
    for event in @events.values
        return event if (event.x == x && event.y == y) or
          (event.x == x && event.y == y + 1 && 
          RPG::Cache.character(event.character_name, event.character_hue).height / 4 > 32)
    end
    return nil
  end
  
  #--------------------------------------------------------------------------
  # * Events At (returns multiple events at the same position in an array)
  #--------------------------------------------------------------------------
  def events_at(x, y)
    eventarray = []
    for event in @events.values
      eventarray.push event if (event.x == x && event.y == y) or
        (event.x == x && event.y == y + 1 && 
        RPG::Cache.character(event.character_name, event.character_hue).height / 4 > 32)
    end
    return eventarray if eventarray.size > 0
    return nil
  end
  #--------------------------------------------------------------------------
  # * Lowest Event At (returns frontmost sprite at mouse position)
  #--------------------------------------------------------------------------
  def lowest_event_at(x, y)
    evt = nil
    for event in @events.values
      if (event.x == x && event.y == y) or
        (event.x == x && event.y == y + 1 && 
        RPG::Cache.character(event.character_name, event.character_hue).height / 4 > 32)
        if evt == nil || event.y > evt.y
          evt = event
        end
      end
    end
    return evt
  end

end
"ŸM#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. Its functions include event starting
#  determinants and map scrolling. Refer to "$game_player" for the one
#  instance of this class.
#==============================================================================

class Game_Player < Game_Character
  #--------------------------------------------------------------------------
  # * Invariables
  #--------------------------------------------------------------------------
  CENTER_X = (320 - 16) * 4   # Center screen x-coordinate * 4
  # agf - change from 240 to 224 to allow for fixed HUD
  CENTER_Y = (224 - 16) * 4   # Center screen y-coordinate * 4



  def initialize
    super
    @character_name = "boyle"
  end

  #--------------------------------------------------------------------------
  # * Passable Determinants
  #     x : x-coordinate
  #     y : y-coordinate
  #     d : direction (0,2,4,6,8)
  #         * 0 = Determines if all directions are impassable (for jumping)
  #--------------------------------------------------------------------------
  def passable?(x, y, d, step=999, tx=nil, ty=nil)
    if DEBUG and Input.press?(Input::CTRL)
      return true
    end
    super
  end
  #--------------------------------------------------------------------------
  # * Set Map Display Position to Center of Screen
  #--------------------------------------------------------------------------
  def center(x, y)
    max_x = ($map.width - 20) * 128
    max_y = ($map.height - 14) * 128
    $map.display_x = [0, [x * 128 - CENTER_X, max_x].min].max
    $map.display_y = [0, [y * 128 - CENTER_Y, max_y].min].max
  end
  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #     x : x-coordinate
  #     y : y-coordinate
  #--------------------------------------------------------------------------
  def moveto(x, y)
    super
    # Centering
    center(x, y)
  end
  #--------------------------------------------------------------------------
  # * Increaase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    super
    # If move route is not forcing
    unless @move_route_forcing
      
      # NOT USING STEPS, GET RID OF THIS PUT SLIP ELSEWHERE
     # if $party.steps % 2 == 0
        # Slip damage check
      #  $party.check_map_slip_damage
      #end
    end
  end
 
  #--------------------------------------------------------------------------
  # â— Change the party battlers (you can have up to 4)
  #--------------------------------------------------------------------------
  def change_battler(index)
    # set battler switch
    char_name = $game_actors[index+1].id
    
    # add character to battle party
    if !$party.has_actor?(char_name)
        add_main(char_name) 
    # add character to reserve party
    else  
        add_reserve(char_name)
    end    
       
    $game_player.restore_leader
    
    # refresh window to show "battler" beside the actor
    refresh     
    
  end  
   
  #-------------------------------------------------------------------------
  # Add character to main party
  #-------------------------------------------------------------------------
  def add_main(act)
    if $party.actors.size < 4
      $game_system.se_play($data_system.decision_se) 
      $party.remove_actor(act)
      $party.add_actor(act)
    else  
      $game_system.se_play($data_system.buzzer_se) 
    end
  end
    
  #-------------------------------------------------------------------------
  # Add character to reserve party
  #-------------------------------------------------------------------------
  def add_reserve(act) 
    if ($party.actors.size > 1 && act != 1)
      $game_system.se_play($data_system.decision_se) 
      $party.remove_actor(act)
      $party.add_reserve(act)
    else
      $game_system.se_play($data_system.buzzer_se)
    end
  end  
  
  #--------------------------------------------------------------------------
  # â— Change the party leader
  #--------------------------------------------------------------------------
  def change_leader(index)

    # turn off all leader switches
    for i in FIRST_LEADER_SWITCH .. LAST_LEADER_SWITCH
      $game_switches[i] = false
    end
   
    # set leader variable to actor ID 
    $game_variables[LEADER_VARIABLE] = $game_actors[index+1].id

    # set the leader sprite to show on the map
    $leader = $game_actors[index+1].character_name
    
    # set leader switch    
    $game_switches[index+FIRST_LEADER_SWITCH] = true
    
    # refresh window to show "leader" beside the leader actor
    refresh     
        
  end  
  
  #--------------------------------------------------------------------------
  # â— Show the default party leader
  #--------------------------------------------------------------------------
  def default_leader
        
    # turn off all leader switches
    for i in FIRST_LEADER_SWITCH .. LAST_LEADER_SWITCH
      $game_switches[i] = false
    end
    
    $game_variables[LEADER_VARIABLE] = 1    
    $game_switches[FIRST_LEADER_SWITCH] = true  
    
    $leader = $party.actors[0].character_name
    $data_actors[1].character_name = $leader
    char_name = $party.actors[0].id
     
    refresh     
    
  end   
  
  #--------------------------------------------------------------------------
  # â— Change the party leader
  #--------------------------------------------------------------------------
  def change_vehicle(name)
    $leader = name
    refresh         
  end    

  #--------------------------------------------------------------------------
  # â— Restore the party leader graphic
  #--------------------------------------------------------------------------
  def restore_leader
        
    # make sure leader is 1-10
    if ($game_variables[LEADER_VARIABLE] != FIRST_ACTOR_ID) && ($game_variables[LEADER_VARIABLE] <= LAST_ACTOR_ID)  
      $leader = $data_actors[$game_variables[LEADER_VARIABLE]].character_name 
      
      # turn off all leader switches
      for i in FIRST_LEADER_SWITCH .. LAST_LEADER_SWITCH
        $game_switches[i] = false
      end
      
      # set leader switch 
      $game_switches[$game_variables[LEADER_VARIABLE]+(FIRST_LEADER_SWITCH-1)] = true
      
    else
      default_leader
      
    end
    refresh         
    
  end  
  
  #--------------------------------------------------------------------------
  # â— Same as show_character. Don't delete
  #--------------------------------------------------------------------------
  def show_leader(num)
    $leader = $data_actors[num].character_name
    refresh         
  end  

  
  #--------------------------------------------------------------------------
  # â— Show the character who is speaking
  #--------------------------------------------------------------------------
  def show_character(num)
    $leader = $data_actors[num].character_name
    refresh         
  end   
  
  
  #--------------------------------------------------------------------------
  # â— Determine if a character is in the active party
  #--------------------------------------------------------------------------
  def is_active(num)
    return $party.actors.include?$game_actors[num]
  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    # If party members = 0
    #if $party.actors.size == 0
      # Clear character file name and hue
      @character_name = ""
      @character_hue = 0
      # End method
      return
    #end
    # Get lead actor and show on map
    actor = $party.actors[0]
    if ($leader == 0)
      # Set character file name and hue
      @character_name = actor.character_name
    else
      @character_name = $leader
    end
    @character_hue = actor.character_hue
    # Initialize opacity level and blending method
    @opacity = 255
    @blend_type = 0
  end
  #--------------------------------------------------------------------------
  # * Same Position Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.collide?(@x,@y) and triggers.include?(event.trigger)
      #if event.x == @x and event.y == @y and triggers.include?(event.trigger)
        # If starting determinant is same position event (other than jumping)
        if not event.jumping? and event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end
  #--------------------------------------------------------------------------
  # * Front Envent Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end

    log_info 'trying'


    # Calculate front event coordinates
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.x == new_x and event.y == new_y and
         triggers.include?(event.trigger) and event.list.size > 1

         log_err "TRYINGHERE"

        # If starting determinant is front event (other than jumping)
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    # If fitting event is not found

    # COUNTER CHECK

    # if result == false
    #   # If front tile is a counter
    #   if $map.counter?(new_x, new_y)
    #     # Calculate 1 tile inside coordinates
    #     new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    #     new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    #     # All event loops
    #     for event in $map.events.values
    #       # If event coordinates and triggers are consistent
    #       if event.x == new_x and event.y == new_y and
    #          triggers.include?(event.trigger) and event.list.size > 1
    #         # If starting determinant is front event (other than jumping)
    #         if not event.jumping? and not event.over_trigger?
    #           event.start
    #           result = true
    #         end
    #       end
    #     end
    #   end
    # end
    return result
  end

  #--------------------------------------------------------------------------
  # * Touch Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.x == x and event.y == y and [1,2].include?(event.trigger)
        # If starting determinant is front event (other than jumping)
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    # if $map.busy? or $hud.busy
    #return

    # Unless Interpretter Running, Forcing a Route or Message Showing
    # unless false# $game_system.map_interpreter.running? or
    #        #@move_route_forcing or $game_temp.message_window_showing
           
    #   # Find Path If Mouse Triggered
    #   if Mouse.trigger?(0) && Mouse.grid != nil

    #     # Check if mouse is over HUD on map 
    #     screen_x,screen_y = Mouse.pos
        
    #     # don't let user move player if below 448 px on screen
    #     if screen_y > 448
    #       if $game_system.menu_disabled
    #         $game_system.se_play($data_system.buzzer_se)
    #         return false
    #       end
          
    #       if screen_x < 32 
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_End.new (2)
    #       elsif screen_x < 64
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_Menu.new
    #       elsif screen_x < 96
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_Save.new
    #       elsif screen_x < 128
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_Journal.new(2)
    #       elsif screen_x < 160
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_Item.new(2)
    #       elsif screen_x < 192
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_Options.new(3)
    #       elsif screen_x < 224
    #         $game_system.se_play($data_system.decision_se)
    #         $scene = Scene_FAQ.new(2)       
    #       elsif screen_x > 235
    #         i = ((screen_x - 236) / 100).to_i
    #         if i < $party.actors.size
    #           $party.actor_lineup
    #           $game_system.se_play($data_system.decision_se)
    #           $scene = Scene_Equip.new($party.actors[i].id - 1, 0, 2)
    #         end
    #       end          
                    
    #       return false
          
    #     end     
        
    #     # Gets Mouse X & Y
    #     mx, my = *Mouse.grid
        
    #     # Turn Character in direction
    #     newd_x = (@x - mx).abs
    #     newd_y = (@y - my).abs
        
    #     if @x > mx 
    #         turn_left if newd_x >= newd_y 
    #     elsif @x < mx
    #         turn_right if newd_x >= newd_y 
    #     end  
            
    #     if @y > my
    #         turn_up if newd_x < newd_y 
    #     elsif @y < my
    #         turn_down if newd_x < newd_y 
    #     end 
        
    #     check_terrain(-1, -1) if WORLD_MAPS.include?($map.map_id)

    #     # Run Pathfinding
    #     evt = $map.lowest_event_at(mx, my)
    #     if evt == nil
    #       find_path(mx, my, false)
    #       @eventarray = @runpath ? $map.events_at(mx, my) : nil
    #     else
    #       find_path(evt.x, evt.y, false)
    #       @eventarray = [evt]
    #     end
        
    #     # If Event At Grid Location
    #     unless @eventarray.nil?
    #       @eventarray.each do |event|
    #         # If Event Autostart
    #         if !event.mouse_autostart
    #           # Set Autostart Event Flag
    #           #@mouse_event_autostarter = event.id
    #           @eventarray.delete(event)
    #         end
    #       end
    #       @eventarray = nil if @eventarray.size == 0
    #     end
        
    #   end
    # end
    
    if @move_route_forcing == true
      clear_path
      @eventarray = nil
    end

    # Clear path if any direction keys pressed
    #$player.clear_path if Input.dir4 != 0
    
    # Remember whether or not moving in local variables
    last_moving = moving?
    # If moving, event running, move route forcing, and message window
    # display are all not occurring
    unless moving? #or $game_system.map_interpreter.running? or
          # @move_route_forcing or $game_temp.message_window_showing
      case Input.dir4
        when 2; move_down
        when 4; move_left
        when 6; move_right
        when 8; move_up
      end
    end
    # Remember coordinates in local variables
    last_real_x = @real_x
    last_real_y = @real_y
    super
    # If character moves down and is positioned lower than the center
    # of the screen
    # if @real_y > last_real_y and @real_y - $map.display_y > CENTER_Y
    #   # Scroll map down
    #   $map.scroll_down(@real_y - last_real_y)
    # end
    # # If character moves left and is positioned more let on-screen than
    # # center
    # if @real_x < last_real_x and @real_x - $map.display_x < CENTER_X
    #   # Scroll map left
    #   $map.scroll_left(last_real_x - @real_x)
    # end
    # # If character moves right and is positioned more right on-screen than
    # # center
    # if @real_x > last_real_x and @real_x - $map.display_x > CENTER_X
    #   # Scroll map right
    #   $map.scroll_right(@real_x - last_real_x)
    # end
    # # If character moves up and is positioned higher than the center
    # # of the screen
    # if @real_y < last_real_y and @real_y - $map.display_y < CENTER_Y
    #   # Scroll map up
    #   $map.scroll_up(last_real_y - @real_y)
    # end
    # If not moving
    unless moving?
      # If player was moving last time
      if last_moving
        # Event determinant is via touch of same position event
        result = check_event_trigger_here([1,2])
      end
      # If C button was pressed
      if Input.trigger?(Input::C)
        # Same position and front event determinant
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
      end
    end
    
    # If Non-nil Event Autostarter
    if @eventarray != nil && !moving? && # @mouse_event_autostarter != nil && !moving? &&
      (!@ovrdest || @map.nil? || @map[@x,@y] == 1)

      # Gets Event
      #event = $map.events[@mouse_event_autostarter]
      @eventarray.each do |event|
      
        # If Event Within Range
        if event and ((@x == event.x or @y == event.y) || @ovrdest)
          # SHAZ - trigger event when:
          # - Autotouch and standing on or beside, or with a counter between
          # - player/event touch and standing as close as possible (on, if possible)
          distance = Math.hypot(@x - event.x, @y - event.y)
          dir = @x < event.x ? 6 : @x > event.x ? 4 : @y < event.y ? 2 : @y > event.y ? 8 : 0
          if (event.trigger == 0 and (distance < 2 or (distance == 2 and 
            $map.counter?((@x+event.x)/2, (@y+event.y)/2)))) or 
            ([1,2].include?(event.trigger) and ((distance == 0 and 
            $game_player.passable?(@x, @y, dir)) or (distance == 1 and
            (@ovrdest || !$game_player.passable?(@x, @y, dir)))))
            # Turn toward Event
            if @x == event.x
              turn_up if @y > event.y
              turn_down if @y < event.y
            else
              turn_left if @x > event.x
              turn_right if @x < event.x
            end
            # Start Event
            clear_path
            event.start # $map.events[@mouse_event_autostarter].start
            @eventarray.delete(event)
            @eventarray = nil if @eventarray.size == 0
            # Clear Flag
            #@mouse_event_autostarter = nil
          end
        end
      end      
    end
    
    # if not on ground terrain, check for boat or dragon exit
    #exit_vehicle if $game_variables[VEHICLE_VARIABLE] != 0 and Input.trigger?(Input::C)
      
  end

end
"r#==============================================================================
# ** Game_BattleAction
#==============================================================================

class Game_BattleAction

  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :speed                    # speed
  attr_accessor :kind                     # kind (basic / skill / item)
                                          #   shaz: (3-equip / 4-swap)
  attr_accessor :basic                    # basic (attack / guard / escape)
  attr_accessor :skill_id                 # skill ID
  attr_accessor :item_id                  # item ID
  attr_accessor :target_index             # target index
  attr_accessor :forcing                  # forced flag
  
  attr_accessor :equip_id                 # equipment ID
  attr_accessor :equip_type               # equipment type (0-weapon, 1-shield...)
  attr_accessor :swap_id                  # id of reserve member to swap with
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    clear
  end

  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @speed = 0
    @kind = 0
    @basic = 3
    @skill_id = 0
    @item_id = 0
    @target_index = -1
    @forcing = false
    
    @equip_id = 0
    @equip_type = 0
    @swap_id = 0
    
  end

  #--------------------------------------------------------------------------
  # * Determine Validity
  #--------------------------------------------------------------------------
  def valid?
    return (not (@kind == 0 and @basic == 3))
  end
  
  #--------------------------------------------------------------------------
  # * Determine if for One Ally
  #--------------------------------------------------------------------------
  def for_one_friend?
    # If kind = skill, and effect scope is for ally (including 0 HP)
    if @kind == 1 and [3, 5].include?($data_skills[@skill_id].scope)
      return true
    end
    # If kind = item, and effect scope is for ally (including 0 HP)
    if @kind == 2 and [3, 5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # * Determine if for One Ally (HP 0)
  #--------------------------------------------------------------------------
  def for_one_friend_hp0?
    # If kind = skill, and effect scope is for ally (only 0 HP)
    if @kind == 1 and [5].include?($data_skills[@skill_id].scope)
      return true
    end
    # If kind = item, and effect scope is for ally (only 0 HP)
    if @kind == 2 and [5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Random Target (for Actor)
  #--------------------------------------------------------------------------
  def decide_random_target_for_actor
    # Diverge with effect scope
    if for_one_friend_hp0?
      battler = $game_party.random_target_actor_hp0
    elsif for_one_friend?
      battler = $game_party.random_target_actor
    else
      battler = $game_troop.random_target_enemy
    end
    # If a target exists, get an index, and if a target doesn't exist,
    # clear the action
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Random Target (for Enemy)
  #--------------------------------------------------------------------------
  def decide_random_target_for_enemy
    # Diverge with effect scope
    if for_one_friend_hp0?
      battler = $game_troop.random_target_enemy_hp0
    elsif for_one_friend?
      battler = $game_troop.random_target_enemy
    else
      battler = $game_party.random_target_actor
    end
    # If a target exists, get an index, and if a target doesn't exist,
    # clear the action
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Last Target (for Actor)
  #--------------------------------------------------------------------------
  def decide_last_target_for_actor
    # If effect scope is ally, then it's an actor, anything else is an enemy
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_party.actors[@target_index]
    else
      battler = $game_troop.enemies[@target_index]
    end
    # Clear action if no target exists
    if battler == nil or not battler.exist?
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Last Target (for Enemy)
  #--------------------------------------------------------------------------
  def decide_last_target_for_enemy
    # If effect scope is ally, then it's an enemy, anything else is an actor
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_troop.enemies[@target_index]
    else
      battler = $game_party.actors[@target_index]
    end
    # Clear action if no target exists
    if battler == nil or not battler.exist?
      clear
    end
  end
end
"&[#==============================================================================
# ** Game_Actor
#------------------------------------------------------------------------------
#  This class handles the actor. It's used within the Game_Actors class
#  ($game_actors) and refers to the Game_Party class ($game_party).
#==============================================================================

class Game_Battler
end

class Game_Actor < Game_Battler
 
  attr_reader   :name                     # name
  
  attr_reader   :character_name           # character file name

  # Equipment
  attr_reader   :weapon                # weapon ID
  
  attr_reader   :armor                # shield ID
  attr_reader   :boots                # helmet ID
  attr_reader   :trinket                # body armor ID
  attr_reader   :bonus                # accessory ID

  attr_reader   :level                    # level
  attr_reader   :exp                      # EXP
  
  attr_reader   :skills                   # skills
  
  attr_reader   :actor_id

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def initialize(actor_id)
    super()
    actor_data = $data.actors[actor_id]
    @actor_id = actor_id

    @name = actor_data.name
    @character_name = actor_id
    
    # @weapon_id = actor.weapon_id
    # @armor1_id = actor.armor1_id
    # @armor2_id = actor.armor2_id
    # @armor3_id = actor.armor3_id
    # @armor4_id = actor.armor4_id
    
    @level = 1
    @exp_list = Array.new(101)
    make_exp_list
    @exp = @exp_list[@level]
    @skills = []
    @hp = maxhp
    @sp = maxsp
    @states = []
    @states_turn = {}
    @maxhp_plus = 0
    @maxsp_plus = 0
    @str_plus = 0
    @dex_plus = 0
    @agi_plus = 0
    @int_plus = 0

  end

  #--------------------------------------------------------------------------
  # * Get Actor ID
  #--------------------------------------------------------------------------
  def id
    return @actor_id
  end

  #--------------------------------------------------------------------------
  # * Get Index
  #--------------------------------------------------------------------------
  def index
    return $game_party.actors.index(self)
  end

  #--------------------------------------------------------------------------
  # * Calculate EXP
  #--------------------------------------------------------------------------
  def make_exp_list
    return
    actor = $data_actors[@actor_id]
    @exp_list[1] = 0
    pow_i = 2.4 + actor.exp_inflation / 100.0
    for i in 2..100
      if i > actor.final_level
        @exp_list[i] = 0
      else
        n = actor.exp_basis * ((i + 3) ** pow_i) / (5 ** pow_i)
        @exp_list[i] = @exp_list[i-1] + Integer(n)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Get Element Revision Value
  #     element_id : element ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # Get values corresponding to element effectiveness
    table = [0,200,150,100,50,0,-100]
    result = table[$data_classes[@class_id].element_ranks[element_id]]
    # If this element is protected by armor, then it's reduced by half
    for i in [@armor1_id, @armor2_id, @armor3_id, @armor4_id]
      armor = $data_armors[i]
      if armor != nil and armor.guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # If this element is protected by states, then it's reduced by half
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # End Method
    return result
  end

  #--------------------------------------------------------------------------
  # * Get State Effectiveness
  #--------------------------------------------------------------------------
  def state_ranks
    return $data_classes[@class_id].state_ranks
  end

  #--------------------------------------------------------------------------
  # * Determine State Guard
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state_guard?(state_id)
    for i in [@armor1_id, @armor2_id, @armor3_id, @armor4_id]
      armor = $data_armors[i]
      if armor != nil
        if armor.guard_state_set.include?(state_id)
          return true
        end
      end
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # * Get Normal Attack Element
  #--------------------------------------------------------------------------
  def element_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.element_set : []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (+)
  #--------------------------------------------------------------------------
  def plus_state_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.plus_state_set : []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (-)
  #--------------------------------------------------------------------------
  def minus_state_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.minus_state_set : []
  end
  #--------------------------------------------------------------------------
  # * Get Maximum HP
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 9999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 9999].min
    return n
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum HP
  #--------------------------------------------------------------------------
  def base_maxhp
    return 0
    return $data_actors[@actor_id].parameters[0, @level]
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum SP
  #--------------------------------------------------------------------------
  def base_maxsp
    return 0
    return $data_actors[@actor_id].parameters[1, @level]
  end
  #--------------------------------------------------------------------------
  # * Get Basic Strength
  #--------------------------------------------------------------------------
  def base_str
    n = $data_actors[@actor_id].parameters[2, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.str_plus : 0
    n += armor1 != nil ? armor1.str_plus : 0
    n += armor2 != nil ? armor2.str_plus : 0
    n += armor3 != nil ? armor3.str_plus : 0
    n += armor4 != nil ? armor4.str_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Get Basic Dexterity
  #--------------------------------------------------------------------------
  def base_dex
    n = $data_actors[@actor_id].parameters[3, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.dex_plus : 0
    n += armor1 != nil ? armor1.dex_plus : 0
    n += armor2 != nil ? armor2.dex_plus : 0
    n += armor3 != nil ? armor3.dex_plus : 0
    n += armor4 != nil ? armor4.dex_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Get Basic Agility
  #--------------------------------------------------------------------------
  def base_agi
    n = $data_actors[@actor_id].parameters[4, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.agi_plus : 0
    n += armor1 != nil ? armor1.agi_plus : 0
    n += armor2 != nil ? armor2.agi_plus : 0
    n += armor3 != nil ? armor3.agi_plus : 0
    n += armor4 != nil ? armor4.agi_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Get Basic Intelligence
  #--------------------------------------------------------------------------
  def base_int
    n = $data_actors[@actor_id].parameters[5, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.int_plus : 0
    n += armor1 != nil ? armor1.int_plus : 0
    n += armor2 != nil ? armor2.int_plus : 0
    n += armor3 != nil ? armor3.int_plus : 0
    n += armor4 != nil ? armor4.int_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Get Basic Attack Power
  #--------------------------------------------------------------------------
  def base_atk
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.atk : 0
  end
  #--------------------------------------------------------------------------
  # * Get Basic Physical Defense
  #--------------------------------------------------------------------------
  def base_pdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    pdef1 = weapon != nil ? weapon.pdef : 0
    pdef2 = armor1 != nil ? armor1.pdef : 0
    pdef3 = armor2 != nil ? armor2.pdef : 0
    pdef4 = armor3 != nil ? armor3.pdef : 0
    pdef5 = armor4 != nil ? armor4.pdef : 0
    return pdef1 + pdef2 + pdef3 + pdef4 + pdef5
  end
  #--------------------------------------------------------------------------
  # * Get Basic Magic Defense
  #--------------------------------------------------------------------------
  def base_mdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    # adjust mdef for shard upgrades
    mdef1 = weapon != nil ? weapon.mdef : 0
    mdef2 = armor1 != nil ? armor1.mdef : 0
    mdef3 = armor2 != nil ? armor2.mdef : 0
    mdef4 = armor3 != nil ? armor3.mdef : 0
    mdef5 = armor4 != nil ? armor4.mdef : 0
    return mdef1 + mdef2 + mdef3 + mdef4 + mdef5
  end
  #--------------------------------------------------------------------------
  # * Get Basic Evasion Correction
  #--------------------------------------------------------------------------
  def base_eva
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    eva1 = armor1 != nil ? armor1.eva : 0
    eva2 = armor2 != nil ? armor2.eva : 0
    eva3 = armor3 != nil ? armor3.eva : 0
    eva4 = armor4 != nil ? armor4.eva : 0
    return eva1 + eva2 + eva3 + eva4
  end
  #--------------------------------------------------------------------------
  # * Get Offensive Animation ID for Normal Attacks
  #--------------------------------------------------------------------------
  def animation1_id
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.animation1_id : 0
  end
  #--------------------------------------------------------------------------
  # * Get Target Animation ID for Normal Attacks
  #--------------------------------------------------------------------------
  def animation2_id
    weapon = $data_weapons[@weapon_id]
    if weapon != nil
      return weapon.animation2_id
    end
    return weapon != nil ? weapon.animation2_id : 4 # Default hit animation 0
  end
  #--------------------------------------------------------------------------
  # * Get Class Name
  #--------------------------------------------------------------------------
  def class_name
    return $data_classes[@class_id].name
  end
  #--------------------------------------------------------------------------
  # * Get EXP String
  #--------------------------------------------------------------------------
  def exp_s
    return @exp_list[@level+1] > 0 ? @exp.to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # * Get Previous Level EXP String
  #--------------------------------------------------------------------------
  def prev_exp_s
    return @exp_list[@level] > 0 ? @exp_list[@level].to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # * Get Next Level EXP String
  #--------------------------------------------------------------------------
  def next_exp_s
    return @exp_list[@level+1] > 0 ? @exp_list[@level+1].to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # * Get Until Next Level EXP String
  #--------------------------------------------------------------------------
  def next_rest_exp_s
    return @exp_list[@level+1] > 0 ?
      (@exp_list[@level+1] - @exp).to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # * Update Auto State
  #     old_armor : unequipped armor
  #     new_armor : equipped armor
  #--------------------------------------------------------------------------
  def update_auto_state(old_armor, new_armor)
    # Forcefully remove unequipped armor's auto state
    if old_armor != nil and old_armor.auto_state_id != 0
      remove_state(old_armor.auto_state_id, true)
    end
    # Forcefully add equipped armor's auto state
    if new_armor != nil and new_armor.auto_state_id != 0
      add_state(new_armor.auto_state_id, true)
    end
  end
  #--------------------------------------------------------------------------
  # * Determine Fixed Equipment
  #     equip_type : type of equipment
  #--------------------------------------------------------------------------
  def equip_fix?(equip_type)
    case equip_type
    when 0  # Weapon
      return $data_actors[@actor_id].weapon_fix
    when 1  # Shield
      return $data_actors[@actor_id].armor1_fix
    when 2  # Head
      return $data_actors[@actor_id].armor2_fix
    when 3  # Body
      return $data_actors[@actor_id].armor3_fix
    when 4  # Accessory
      return $data_actors[@actor_id].armor4_fix
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Change Equipment
  #     equip_type : type of equipment
  #     id    : weapon or armor ID (If 0, remove equipment)
  #--------------------------------------------------------------------------
  def equip(equip_type, id)
    case equip_type
    when 0  # Weapon
      if id == 0 or $game_party.weapon_number(id) > 0
        $game_party.gain_weapon(@weapon_id, 1)
        @weapon_id = id
        $game_party.lose_weapon(id, 1)
      end
    when 1  # Shield
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor1_id], $data_armors[id])
        $game_party.gain_armor(@armor1_id, 1)
        @armor1_id = id
        $game_party.lose_armor(id, 1)
      end
    when 2  # Head
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor2_id], $data_armors[id])
        $game_party.gain_armor(@armor2_id, 1)
        @armor2_id = id
        $game_party.lose_armor(id, 1)
      end
    when 3  # Body
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor3_id], $data_armors[id])
        $game_party.gain_armor(@armor3_id, 1)
        @armor3_id = id
        $game_party.lose_armor(id, 1)
      end
    when 4  # Accessory
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor4_id], $data_armors[id])
        $game_party.gain_armor(@armor4_id, 1)
        @armor4_id = id
        $game_party.lose_armor(id, 1)
      end
    end
    
    # ensure autostate hasn't been incorrectly removed if > 1 item gives that state
    update_auto_state(nil, $data_armors[@armor1_id])
    update_auto_state(nil, $data_armors[@armor2_id])
    update_auto_state(nil, $data_armors[@armor3_id])
    update_auto_state(nil, $data_armors[@armor4_id])
  end
  #--------------------------------------------------------------------------
  # * Determine if Equippable
  #     item : item
  #--------------------------------------------------------------------------
  def equippable?(item)
    # If weapon
    if item.is_a?(RPG::Weapon)
      # If included among equippable weapons in current class
      if $data_classes[@class_id].weapon_set.include?(item.id)
        return true
      end
    end
    # If armor
    if item.is_a?(RPG::Armor)
      # If included among equippable armor in current class
      if $data_classes[@class_id].armor_set.include?(item.id)
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Change EXP
  #     exp : new EXP
  #--------------------------------------------------------------------------
  def exp=(exp)
    @exp = [[exp, 9999999].min, 0].max
    # Level up
    while @exp >= @exp_list[@level+1] and @exp_list[@level+1] > 0
      @level += 1
      # Learn skill
      for j in $data_classes[@class_id].learnings
        if j.level == @level
          learn_skill(j.skill_id)
        end
      end
    end
    # Level down
    while @exp < @exp_list[@level]
      @level -= 1
    end
    # Correction if exceeding current max HP and max SP
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # * Change Level
  #     level : new level
  #--------------------------------------------------------------------------
  def level=(level)
    # Check up and down limits
    level = [[level, $data_actors[@actor_id].final_level].min, 1].max
    # Change EXP
    self.exp = @exp_list[level]
    # Shaz: Refresh game hud
    $game_map.need_hud_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Learn Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def learn_skill(skill_id)
    if skill_id > 0 and not skill_learn?(skill_id)
      @skills.push(skill_id)
      @skills.sort!
    end
  end
  #--------------------------------------------------------------------------
  # * Forget Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def forget_skill(skill_id)
    @skills.delete(skill_id)
  end
  #--------------------------------------------------------------------------
  # * Determine if Finished Learning Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_learn?(skill_id)
    return @skills.include?(skill_id)
  end
  #--------------------------------------------------------------------------
  # * Determine if Skill can be Used
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    if not skill_learn?(skill_id)
      return false
    end
    return super
  end
  #--------------------------------------------------------------------------
  # * Change Name
  #     name : new name
  #--------------------------------------------------------------------------
  def name=(name)
    @name = name
    # shaz: update game HUD
    $game_map.need_hud_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Change Class ID
  #     class_id : new class ID
  #--------------------------------------------------------------------------
  def class_id=(class_id)
    if $data_classes[class_id] != nil
      @class_id = class_id
      # Remove items that are no longer equippable
      unless equippable?($data_weapons[@weapon_id])
        equip(0, 0)
      end
      unless equippable?($data_armors[@armor1_id])
        equip(1, 0)
      end
      unless equippable?($data_armors[@armor2_id])
        equip(2, 0)
      end
      unless equippable?($data_armors[@armor3_id])
        equip(3, 0)
      end
      unless equippable?($data_armors[@armor4_id])
        equip(4, 0)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Change Graphics
  #     character_name : new character file name
  #     character_hue  : new character hue
  #     battler_name   : new battler file name
  #     battler_hue    : new battler hue
  #--------------------------------------------------------------------------
  def set_graphic(character_name, character_hue, battler_name, battler_hue)
    @character_name = character_name
    @character_hue = character_hue
    @battler_name = character_name #battler_name agf
    @battler_hue = character_hue #battler_hue agf
    # shaz: update game HUD
    $game_map.need_hud_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen X-Coordinate
  #--------------------------------------------------------------------------
  def screen_x
    # Return after calculating x-coordinate by order of members in party
    #agf**
    if self.index != nil
      return [BATTLER_1_X_POS, BATTLER_2_X_POS, BATTLER_3_X_POS, BATTLER_4_X_POS][self.index]     
    else
      return 0
    end
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen Y-Coordinate
  #--------------------------------------------------------------------------
  def screen_y
    return [BATTLER_1_Y_POS, BATTLER_2_Y_POS, BATTLER_3_Y_POS, BATTLER_4_Y_POS][self.index]
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen Z-Coordinate
  #--------------------------------------------------------------------------
  def screen_z
    # Return after calculating z-coordinate by order of members in party
    if self.index != nil
      return 4 - self.index
    else
      return 0
    end
  end
end
"ß+#==============================================================================
# ** Game_Battler (part 1)
#==============================================================================

# STATS

class Game_Battler
 
  attr_reader   :battler_name             # battler file name

  attr_reader   :hp                       # HP
  attr_reader   :mp                       # MP

  attr_reader   :states                   # states

  attr_accessor :immortal                 # immortal flag


  attr_accessor :critical                 # critical flag
  
  attr_accessor :collapsing               # collapsing
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @battler_name = ""
    @hp = 0
    @sp = 0
    @states = []
    @states_turn = {}

    @maxhp_plus = 0
    @maxsp_plus = 0
    @str_plus = 0
    @def_plus = 0

    @hidden = false
    @immortal = false
    @damage_pop = false
    @damage = nil
    @critical = false
    @animation_id = 0
    @animation_hit = false
    @white_flash = false
    @blink = false
    @collapsing = false
    @current_action = Game_BattleAction.new
  end

  #--------------------------------------------------------------------------
  # * Get Current Experience Points
  #--------------------------------------------------------------------------
  def now_exp 
    return @exp - @exp_list[@level] 
  end
  
  #--------------------------------------------------------------------------
  # * Get Needed Experience Points
  #--------------------------------------------------------------------------
  def next_exp 
    return @exp_list[@level+1] > 0 ? @exp_list[@level+1] - @exp_list[@level] : 0 
  end

  #--------------------------------------------------------------------------
  # * Get Maximum HP
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 999999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Maximum SP
  #--------------------------------------------------------------------------
  def maxsp
    n = [[base_maxsp + @maxsp_plus, 0].max, 9999].min
    for i in @states
      n *= $data_states[i].maxsp_rate / 100.0
    end
    n = [[Integer(n), 0].max, 9999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Strength (STR)
  #--------------------------------------------------------------------------
  def str
    n = [[base_str + @str_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].str_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Dexterity (DEX)
  #--------------------------------------------------------------------------
  def dex
    n = [[base_dex + @dex_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].dex_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Set Maximum HP
  #     maxhp : new maximum HP
  #--------------------------------------------------------------------------
  def maxhp=(maxhp)
    @maxhp_plus += maxhp - self.maxhp
    @maxhp_plus = [[@maxhp_plus, -9999].max, 9999].min
    @hp = [@hp, self.maxhp].min
  end

  #--------------------------------------------------------------------------
  # * Set Maximum SP
  #     maxsp : new maximum SP
  #--------------------------------------------------------------------------
  def maxsp=(maxsp)
    @maxsp_plus += maxsp - self.maxsp
    @maxsp_plus = [[@maxsp_plus, -9999].max, 9999].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # * Set Strength (STR)
  #     str : new Strength (STR)
  #--------------------------------------------------------------------------
  def str=(str)
    @str_plus += str - self.str
    @str_plus = [[@str_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Set Dexterity (DEX)
  #     dex : new Dexterity (DEX)
  #--------------------------------------------------------------------------
  def dex=(dex)
    @dex_plus += dex - self.dex
    @dex_plus = [[@dex_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Set Agility (AGI)
  #     agi : new Agility (AGI)
  #--------------------------------------------------------------------------
  def agi=(agi)
    @agi_plus += agi - self.agi
    @agi_plus = [[@agi_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Set Intelligence (INT)
  #     int : new Intelligence (INT)
  #--------------------------------------------------------------------------
  def int=(int)
    @int_plus += int - self.int
    @int_plus = [[@int_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # * Get Hit Rate
  #--------------------------------------------------------------------------
  def hit
    n = 100
    for i in @states
      n *= $data_states[i].hit_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Attack Power
  #--------------------------------------------------------------------------
  def atk
    n = base_atk
    for i in @states
      n *= $data_states[i].atk_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Physical Defense Power
  #--------------------------------------------------------------------------
  def pdef
    n = base_pdef
    for i in @states
      n *= $data_states[i].pdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Magic Defense Power
  #--------------------------------------------------------------------------
  def mdef
    n = base_mdef
    for i in @states
      n *= $data_states[i].mdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Evasion Correction
  #--------------------------------------------------------------------------
  def eva
    n = base_eva
    for i in @states
      n += $data_states[i].eva
    end
    return n
  end
  #--------------------------------------------------------------------------
  # * Change HP
  #     hp : new HP
  #--------------------------------------------------------------------------
  def hp=(hp)
    @hp = [[hp, maxhp].min, 0].max
    # add or exclude incapacitation
    for i in 1...$data_states.size
      if $data_states[i].zero_hp
        if self.dead?
          add_state(i)
        else
          remove_state(i)
        end
      end
    end
    $game_map.need_hud_refresh = true # Shaz
    $game_map.need_refresh = true #Shaz
  end
  #--------------------------------------------------------------------------
  # * Change SP
  #     sp : new SP
  #--------------------------------------------------------------------------
  def sp=(sp)
    @sp = [[sp, maxsp].min, 0].max
    $game_map.need_hud_refresh = true # Shaz
    $game_map.need_refresh = true #Shaz
  end
  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    @sp = maxsp
    for i in @states.clone
      remove_state(i)
    end
    $game_map.need_hud_refresh = true # Shaz
    #$game_map.need_refresh = true #Shaz
  end
  #--------------------------------------------------------------------------
  # * Get Current Action
  #--------------------------------------------------------------------------
  def current_action
    return @current_action
  end
  #--------------------------------------------------------------------------
  # * Determine Action Speed
  #--------------------------------------------------------------------------
  def make_action_speed
    @current_action.speed = agi + rand(10 + agi / 4)
  end
  #--------------------------------------------------------------------------
  # * Decide Incapacitation
  #--------------------------------------------------------------------------
  def dead?
    return (@hp == 0 and not @immortal)
  end
  #--------------------------------------------------------------------------
  # * Decide Existance
  #--------------------------------------------------------------------------
  def exist?
    return (not @hidden and (@hp > 0 or @immortal))
  end
  #--------------------------------------------------------------------------
  # * Decide HP 0
  #--------------------------------------------------------------------------
  def hp0?
    return (not @hidden and @hp == 0)
  end
  #--------------------------------------------------------------------------
  # * Decide if Command is Inputable
  #--------------------------------------------------------------------------
  def inputable?
    return (not @hidden and restriction <= 1)
  end
  #--------------------------------------------------------------------------
  # * Decide if Action is Possible
  #--------------------------------------------------------------------------
  def movable?
    return (not @hidden and restriction < 4)
  end
  #--------------------------------------------------------------------------
  # * Decide if Guarding
  #--------------------------------------------------------------------------
  def guarding?
    return (@current_action.kind == 0 and @current_action.basic == 1)
  end
  #--------------------------------------------------------------------------
  # * Decide if Resting
  #--------------------------------------------------------------------------
  def resting?
    return (@current_action.kind == 0 and @current_action.basic == 3)
  end
  #--------------------------------------------------------------------------
  # * Battler Width
  #--------------------------------------------------------------------------
  def battler_width
    return RPG::Cache.battler(@battler_name, @battler_hue).width
  end
  #--------------------------------------------------------------------------
  # * Battler Height
  #--------------------------------------------------------------------------
  def battler_height
    return RPG::Cache.battler(@battler_name, @battler_hue).height
  end
end
" )#==============================================================================
# ** Game_Battler (part 2)
#==============================================================================
# STATES

class Game_Battler
 
  #--------------------------------------------------------------------------
  # * Check State
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state?(state_id)
    return @states.include?(state_id)
  end

  #--------------------------------------------------------------------------
  # * Determine if a state is full or not.
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state_full?(state_id)
    # Return false if the applicable state is not added.
    unless self.state?(state_id)
      return false
    end
    # Return true if the number of maintenance turns is -1 (auto state).
    if @states_turn[state_id] == -1
      return true
    end
    # Return true if the number of maintenance turns is equal to the
    # lowest number of natural removal turns.
    return @states_turn[state_id] == $data_states[state_id].hold_turn
  end
  #--------------------------------------------------------------------------
  # * Add State
  #     state_id : state ID
  #     force    : forcefully added flag (used to deal with auto state)
  #--------------------------------------------------------------------------
  def add_state(state_id, force = false)
    # For an ineffective state
    if $data_states[state_id] == nil
      # End Method
      return
    end
    # If not forcefully added
    unless force
      # A state loop already in existance
      for i in @states
        # If a new state is included in the state change (-) of an existing
        # state, and that state is not included in the state change (-) of
        # a new state (example: an attempt to add poison during dead)
        if $data_states[i].minus_state_set.include?(state_id) and
           not $data_states[state_id].minus_state_set.include?(i)
          # End Method
          return
        end
      end
    end
    # If this state is not added
    unless state?(state_id)
      # Add state ID to @states array
      @states.push(state_id)
      # If option [regarded as HP 0]is effective
      if $data_states[state_id].zero_hp
        # Change HP to 0
        @hp = 0
      end
      # All state loops
      for i in 1...$data_states.size
        # Dealing with a state change (+)
        if $data_states[state_id].plus_state_set.include?(i)
          add_state(i)
        end
        # Dealing with a state change (-)
        if $data_states[state_id].minus_state_set.include?(i)
          remove_state(i)
        end
      end
      # line change to a large rating order (if value is the same, then a
      # strong restriction order)
      @states.sort! do |a, b|
        state_a = $data_states[a]
        state_b = $data_states[b]
        if state_a.rating > state_b.rating
          -1
        elsif state_a.rating < state_b.rating
          +1
        elsif state_a.restriction > state_b.restriction
          -1
        elsif state_a.restriction < state_b.restriction
          +1
        else
          a <=> b
        end
      end
    end
    # If added forcefully
    if force
      # Set the natural removal's lowest number of turns to -1
      @states_turn[state_id] = -1
    end
    # If not added forcefully
    unless  @states_turn[state_id] == -1
      # Set the natural removal's lowest number of turns
      @states_turn[state_id] = $data_states[state_id].hold_turn
    end
    # If unable to move
    unless movable?
      # Clear action
      @current_action.clear
    end
    # Check the maximum value of HP and SP
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # * Remove State
  #     state_id : state ID
  #     force    : forcefully removed flag (used to deal with auto state)
  #--------------------------------------------------------------------------
  def remove_state(state_id, force = false)
    # If this state is added
    if state?(state_id)
      # If a forcefully added state is not forcefully removed
      if @states_turn[state_id] == -1 and not force
        # End Method
        return
      end
      # If current HP is at 0 and options are effective [regarded as HP 0]
      if @hp == 0 and $data_states[state_id].zero_hp
        # Determine if there's another state [regarded as HP 0] or not
        zero_hp = false
        for i in @states
          if i != state_id and $data_states[i].zero_hp
            zero_hp = true
          end
        end
        # Change HP to 1 if OK to remove incapacitation.
        if zero_hp == false
          @hp = 1
        end
      end
      # Delete state ID from @states and @states_turn hash array
      @states.delete(state_id)
      @states_turn.delete(state_id)
    end
    # Check maximum value for HP and SP
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # * Get State Animation ID
  #--------------------------------------------------------------------------
  def state_animation_id
    # If no states are added
    if @states.size == 0
      return 0
    end
    # Return state animation ID with maximum rating
    return $data_states[@states[0]].animation_id
  end
  #--------------------------------------------------------------------------
  # * Get Restriction
  #--------------------------------------------------------------------------
  def restriction
    restriction_max = 0
    # Get maximum restriction from currently added states
    for i in @states
      if $data_states[i].restriction >= restriction_max
        restriction_max = $data_states[i].restriction
      end
    end
    return restriction_max
  end
  #--------------------------------------------------------------------------
  # â— Has Restriction
  #   Determines if battler has a special restriction
  #--------------------------------------------------------------------------
  def has_restriction?(restriction)
    for i in @states
      if $data_states[i].restriction == restriction
        return true
      end
    end
    
    return false
  end
  #--------------------------------------------------------------------------
  # * Determine [Can't Get EXP] States
  #--------------------------------------------------------------------------
  def cant_get_exp?
    for i in @states
      if $data_states[i].cant_get_exp
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Determine [Can't Evade] States
  #--------------------------------------------------------------------------
  def cant_evade?
    for i in @states
      if $data_states[i].cant_evade
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Determine [Slip Damage] States
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Remove Battle States (called up during end of battle)
  #--------------------------------------------------------------------------
  def remove_states_battle
    for i in @states.clone
      if $data_states[i].battle_only
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Natural Removal of States (called up each turn)
  #--------------------------------------------------------------------------
  def remove_states_auto
    for i in @states_turn.keys.clone
      if @states_turn[i] > 0
        @states_turn[i] -= 1
      elsif rand(100) < $data_states[i].auto_release_prob
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * State Removed by Shock (called up each time physical damage occurs)
  #--------------------------------------------------------------------------
  def remove_states_shock
    for i in @states.clone
      if rand(100) < $data_states[i].shock_release_prob
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * State Change (+) Application
  #     plus_state_set  : State Change (+)
  #--------------------------------------------------------------------------
  def states_plus(plus_state_set)
    # Clear effective flag
    effective = false
    # Loop (added state)
    for i in plus_state_set
      # If this state is not guarded
      unless self.state_guard?(i)
        # Set effective flag if this state is not full
        effective |= self.state_full?(i) == false
        # If states offer [no resistance]
        if $data_states[i].nonresistance
          # Set state change flag
          @state_changed = true
          # Add a state
          add_state(i)
        # If this state is not full
        elsif self.state_full?(i) == false
          # Convert state effectiveness to probability,
          # compare to random numbers
          if rand(100) < [0,100,80,60,40,20,0][self.state_ranks[i]]
            # Set state change flag
            @state_changed = true
            # Add a state
            add_state(i)
          end
        end
      end
    end
    # End Method
    return effective
  end
  #--------------------------------------------------------------------------
  # * Apply State Change (-)
  #     minus_state_set : state change (-)
  #--------------------------------------------------------------------------
  def states_minus(minus_state_set)
    # Clear effective flag
    effective = false
    # Loop (state to be removed)
    for i in minus_state_set
      # Set effective flag if this state is added
      effective |= self.state?(i)
      # Set a state change flag
      @state_changed = true
      # Remove state
      remove_state(i)
    end
    # End Method
    return effective
  end
end
"59#==============================================================================
# ** Game_Battler (part 3)
#==============================================================================
# Skills and results



class Game_Battler
  #--------------------------------------------------------------------------
  # * Determine Usable Skills
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    # If there's not enough SP, the skill cannot be used.
    if $data_skills[skill_id].sp_cost > self.sp
      return false
    end
    # Unusable if incapacitated
    if dead?
      return false
    end
    # If silent, only physical skills can be used
    if $data_skills[skill_id].atk_f == 0 and self.has_restriction?(1)
      return false
    end
    # Get usable time
    occasion = $data_skills[skill_id].occasion
    # If in battle
    if $game_temp.in_battle
      # Usable with [Normal] and [Only Battle]
      return (occasion == 0 or occasion == 1)
    # If not in battle
    else
      # Usable with [Normal] and [Only Menu]
      return (occasion == 0 or occasion == 2)
    end
  end
  #--------------------------------------------------------------------------
  # * Applying Normal Attack Effects
  #     attacker : battler
  #--------------------------------------------------------------------------
  def attack_effect(attacker)
    # Clear critical flag
    self.critical = false
    # First hit detection
    hit_result = (rand(100) < attacker.hit)
    # If hit occurs
    if hit_result == true
      # Calculate basic damage
      atk = [attacker.atk - self.pdef / 2, 0].max
      self.damage = atk * (20 + attacker.str) / 20
      # Element correction
      self.damage *= elements_correct(attacker.element_set)
      self.damage /= 100
      # If damage value is strictly positive
      if self.damage > 0
        # Critical correction
        if rand(100) < 4 * attacker.agi / self.agi
          self.damage *= 2
          self.critical = true
        end
        # Guard correction
        if self.guarding?
          self.damage /= 2
        end
      end
      # Dispersion
      if self.damage.abs > 0
        amp = [self.damage.abs * 15 / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # Second hit detection
      eva = 8 * self.agi / attacker.agi + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
    end

    # generate a random number. this will be used to determine
    # if the character dodges an attack.
    chance = (rand(100))    
    
    # agf - party's luck (0 to 16)
    # when party donates the church, the party's luck goes up
    # by default, luck starts at 0
    luck = $game_variables[LUCK_VARIABLE] 
        
    # if enemy missed, give them a 25% chance to miss. 
    if hit_result != true && chance > 75
      self.damage = "Miss"
    
    # if character didn't qualify for a miss, give them an 
    # extra chance with luck (0-16% chance to miss)      
    elsif chance <= luck && attacker.is_a?(Game_Enemy) 
      self.damage = "Miss"
      
    # if character didn't qualify for a miss, hit.
    else
      # State Removed by Shock
      remove_states_shock
      # Substract damage from HP
      mode_adjustment(attacker)
      self.damage = 1 if self.damage.nil? or self.damage < 1 # agf - error happening here with <    
      self.hp -= self.damage
      # State change
      @state_changed = false
      states_plus(attacker.plus_state_set)
      states_minus(attacker.minus_state_set)
    end
    
    self.critical = false if self.damage == "Miss"
    # End Method
    return true
  end
  #--------------------------------------------------------------------------
  # * Apply Skill Effects
  #     user  : the one using skills (battler)
  #     skill : skill
  #--------------------------------------------------------------------------
  def skill_effect(user, skill)
    # Clear critical flag
    self.critical = false
    # If skill scope is for ally with 1 or more HP, and your own HP = 0,
    # or skill scope is for ally with 0, and your own HP = 1 or more
    if ((skill.scope == 3 or skill.scope == 4) and self.hp == 0) or
       ((skill.scope == 5 or skill.scope == 6) and self.hp >= 1)
      # End Method
      return false
    end
    # Clear effective flag
    effective = false
    # Set effective flag if common ID is effective
    effective |= skill.common_event_id > 0
    # First hit detection
    hit = skill.hit
    if skill.atk_f > 0
      hit *= user.hit / 100
    end
    hit_result = (rand(100) < hit)
    # Set effective flag if skill is uncertain
    effective |= hit < 100
    # If hit occurs
    if hit_result == true
      # -------------------------------------------------------------------
      # AGF - See if a weapon can enhance a hero's attack -----------------
      # -------------------------------------------------------------------
      @userid = user.id
      @skillpower = skill.power     

      # Calculate power
      #agf - replaced skill.power with @skillpower for Lydia above
      power = @skillpower + user.atk * skill.atk_f / 100 
      if power > 0
        power -= self.pdef * skill.pdef_f / 200
        power -= self.mdef * skill.mdef_f / 200
        power = [power, 0].max
      end
      # Calculate rate
      rate = 20
      rate += (user.str * skill.str_f / 100)
      rate += (user.agi * skill.agi_f / 100)
      rate += (user.int * skill.int_f / 100)
      # Calculate basic damage
      self.damage = power * rate / 20
      # Element correction
      self.damage *= elements_correct(skill.element_set)
      self.damage /= 100
      # If damage value is strictly positive
      if self.damage > 0
        # Guard correction
        if self.guarding?
          self.damage /= 2
        end
      end
      # Dispersion
      if skill.variance > 0 and self.damage.abs > 0
        amp = [self.damage.abs * skill.variance / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # Second hit detection
      eva = 8 * self.agi / user.agi + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva * skill.eva_f / 100
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
      # Set effective flag if skill is uncertain
      effective |= hit < 100
    end
    # If hit occurs
    if hit_result == true
      # If physical attack has power other than 0
      if skill.power != 0 and skill.atk_f > 0
        # State Removed by Shock
        remove_states_shock
        # Set to effective flag
        effective = true
      end
      # Substract damage from HP
      last_hp = self.hp
      # agf: check difficulty level and adjust strength of attack
      mode_adjustment(user)
      
      self.hp -= self.damage
      effective |= self.hp != last_hp
      # State change
      @state_changed = false
      effective |= states_plus(skill.plus_state_set)
      effective |= states_minus(skill.minus_state_set)
      # If power is 0
      if skill.power == 0
        # Set damage to an empty string
        self.damage = ""
        # If state is unchanged (agf - added steal logic)
        unless @state_changed or skill.id == STEAL_SKILL_ID
          # Set damage to "Miss"
          self.damage = "Miss"
        end
      end
    # If miss occurs
    else
      # Set damage to "Miss"
      self.damage = "Miss"
    end
    # If not in battle
    unless $game_temp.in_battle
      # Set damage to nil
      self.damage = nil
    end
    # End Method
    self.critical = false if self.damage == "Miss"
    return effective
  end
  #--------------------------------------------------------------------------
  # * Application of Item Effects
  #     item : item
  #--------------------------------------------------------------------------
  def item_effect(item)
    # Clear critical flag
    self.critical = false
    # If item scope is for ally with 1 or more HP, and your own HP = 0,
    # or item scope is for ally with 0 HP, and your own HP = 1 or more
    if ((item.scope == 3 or item.scope == 4) and self.hp == 0) or
       ((item.scope == 5 or item.scope == 6) and self.hp >= 1)
      # End Method
      return false
    end
    # Clear effective flag
    effective = false
    # Set effective flag if common ID is effective
    effective |= item.common_event_id > 0
    # Determine hit
    hit_result = (rand(100) < item.hit)
    # Set effective flag is skill is uncertain
    effective |= item.hit < 100
    # If hit occurs
    if hit_result == true
      # Calculate amount of recovery
      recover_hp = maxhp * item.recover_hp_rate / 100 + item.recover_hp
      recover_sp = maxsp * item.recover_sp_rate / 100 + item.recover_sp
      if recover_hp < 0
        recover_hp += self.pdef * item.pdef_f / 20
        recover_hp += self.mdef * item.mdef_f / 20
        recover_hp = [recover_hp, 0].min
      end
      # Element correction
      recover_hp *= elements_correct(item.element_set)
      recover_hp /= 100
      recover_sp *= elements_correct(item.element_set)
      recover_sp /= 100
      # Dispersion
      if item.variance > 0 and recover_hp.abs > 0
        amp = [recover_hp.abs * item.variance / 100, 1].max
        recover_hp += rand(amp+1) + rand(amp+1) - amp
      end
      if item.variance > 0 and recover_sp.abs > 0
        amp = [recover_sp.abs * item.variance / 100, 1].max
        recover_sp += rand(amp+1) + rand(amp+1) - amp
      end
      # If recovery code is negative
      if recover_hp < 0
        # Guard correction
        if self.guarding?
          recover_hp /= 2
        end
      end
      # Set damage value and reverse HP recovery amount
      self.damage = -recover_hp
      # HP and SP recovery
      last_hp = self.hp
      last_sp = self.sp
      self.hp += recover_hp
      self.sp += recover_sp
      effective |= self.hp != last_hp
      effective |= self.sp != last_sp
      # State change
      @state_changed = false
      effective |= states_plus(item.plus_state_set)
      effective |= states_minus(item.minus_state_set)
      # If parameter value increase is effective
      # Shaz - don't allow SP increase for non-SP characters
      if item.parameter_type > 0 and item.parameter_points != 0 and
        (item.parameter_type != 2 or self.maxsp > 0)
        # Branch by parameter
        case item.parameter_type
        when 1  # Max HP
          @maxhp_plus += item.parameter_points
        when 2  # Max SP
          @maxsp_plus += item.parameter_points
        when 3  # Strength
          @str_plus += item.parameter_points
        when 4  # Dexterity
          #@dex_plus += item.parameter_points
        when 5  # Agility
          @agi_plus += item.parameter_points
        when 6  # Intelligence
          @int_plus += item.parameter_points
        end
        # Set to effective flag
        effective = true
      end
      # If HP recovery rate and recovery amount are 0
      if item.recover_hp_rate == 0 and item.recover_hp == 0
        # Set damage to empty string
        self.damage = ""
        # If SP recovery rate / recovery amount are 0, and parameter increase
        # value is ineffective.
        if item.recover_sp_rate == 0 and item.recover_sp == 0 and
           (item.parameter_type == 0 or item.parameter_points == 0)
          # If state is unchanged
          unless @state_changed
              self.damage = "Miss"
          end
        end
      end
    # If miss occurs
    else
      # Set damage to "Miss"
      self.damage = "Miss"
    end
    # If not in battle
    unless $game_temp.in_battle
      # Set damage to nil
      self.damage = nil
    end
    # End Method
    self.critical = false if self.damage == "Miss"
    return effective
  end
  #--------------------------------------------------------------------------
  # * Application of Slip Damage Effects
  #--------------------------------------------------------------------------
  def slip_damage_effect
    # Set damage
    self.damage = self.maxhp / 20 # 10
    # Dispersion
    if self.damage.abs > 0
      amp = [self.damage.abs * 15 / 100, 1].max
      self.damage += rand(amp+1) + rand(amp+1) - amp
    end
    # Subtract damage from HP
    self.hp -= self.damage
    # End Method
    return true
  end
  #--------------------------------------------------------------------------
  # * Calculating Element Correction
  #     element_set : element
  #--------------------------------------------------------------------------
  def elements_correct(element_set)
    # If not an element
    if element_set == []
      # Return 100
      return 100
    end
    # Return the weakest object among the elements given
    # * "element_rate" method is defined by Game_Actor and Game_Enemy classes,
    #    which inherit from this class.
    weakest = -100
    for i in element_set
      weakest = [weakest, self.element_rate(i)].max
    end
    return weakest
  end
  #--------------------------------------------------------------------------
  # â— Adjust attack for mode
  #--------------------------------------------------------------------------
  # agf: note: I've commented out test because it silenty takes a few HP
  # away from the enemy. I can't remember why I had it this way before...
  # a game crash? weird .000002343 hit?
  def mode_adjustment(user)

      test = self.damage 
      
      if ![0, nil, "", "Miss"].include?(test)
        
        if user.is_a?(Game_Actor)
          if $game_variables[DIFFICULTY_VARIABLE] == 1
            test = (test / 1.33).to_i # (test / 1.5).to_i
          elsif $game_variables[DIFFICULTY_VARIABLE] == 2
            test = (test / 1.67).to_i # (test / 2).to_i
          end  
          #test = 1 if test == 0
        end      

        if user.is_a?(Game_Enemy)
          if $game_variables[DIFFICULTY_VARIABLE] == 1
            test = (test * 1.33).to_i # (test * 1.5).to_i
          elsif $game_variables[DIFFICULTY_VARIABLE] == 2
            test = (test * 1.67).to_i # (test * 2).to_i
          end  
        end
      
        #test = 1 if test == 0
        self.damage = test            
      
      end
      
  end
end
"Í/#==============================================================================
# ** Game_Enemy
#==============================================================================

class Game_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     troop_id     : troop ID
  #     member_index : troop member index
  #--------------------------------------------------------------------------
  def initialize(troop_id, member_index)
    super()
    @troop_id = troop_id
    @member_index = member_index
    troop = $data_troops[@troop_id]
    @enemy_id = troop.members[@member_index].enemy_id
    enemy = $data_enemies[@enemy_id]
    @battler_name = enemy.battler_name
    @battler_hue = enemy.battler_hue
    @hp = maxhp
    @sp = maxsp
    @hidden = troop.members[@member_index].hidden
    @immortal = troop.members[@member_index].immortal
  end
  #--------------------------------------------------------------------------
  # * Get Enemy ID
  #--------------------------------------------------------------------------
  def id
    return @enemy_id
  end
  #--------------------------------------------------------------------------
  # * Get Index
  #--------------------------------------------------------------------------
  def index
    return @member_index
  end
  #--------------------------------------------------------------------------
  # * Get Name
  #--------------------------------------------------------------------------
  def name
    return $data_enemies[@enemy_id].name
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum HP
  #--------------------------------------------------------------------------
  def base_maxhp
    return $data_enemies[@enemy_id].maxhp
  end
  #--------------------------------------------------------------------------
  # * Get Basic Maximum SP
  #--------------------------------------------------------------------------
  def base_maxsp
    return $data_enemies[@enemy_id].maxsp
  end
  #--------------------------------------------------------------------------
  # * Get Basic Strength
  #--------------------------------------------------------------------------
  def base_str
    return $data_enemies[@enemy_id].str
  end
  #--------------------------------------------------------------------------
  # * Get Basic Dexterity
  #--------------------------------------------------------------------------
  def base_dex
    return $data_enemies[@enemy_id].dex
  end
  #--------------------------------------------------------------------------
  # * Get Basic Agility
  #--------------------------------------------------------------------------
  def base_agi
    return $data_enemies[@enemy_id].agi
  end
  #--------------------------------------------------------------------------
  # * Get Basic Intelligence
  #--------------------------------------------------------------------------
  def base_int
    return $data_enemies[@enemy_id].int
  end
  #--------------------------------------------------------------------------
  # * Get Basic Attack Power
  #--------------------------------------------------------------------------
  def base_atk
    return $data_enemies[@enemy_id].atk
  end
  #--------------------------------------------------------------------------
  # * Get Basic Physical Defense
  #--------------------------------------------------------------------------
  def base_pdef
    return $data_enemies[@enemy_id].pdef
  end
  #--------------------------------------------------------------------------
  # * Get Basic Magic Defense
  #--------------------------------------------------------------------------
  def base_mdef
    return $data_enemies[@enemy_id].mdef
  end
  #--------------------------------------------------------------------------
  # * Get Basic Evasion
  #--------------------------------------------------------------------------
  def base_eva
    return $data_enemies[@enemy_id].eva
  end
  #--------------------------------------------------------------------------
  # * Get Offensive Animation ID for Normal Attack
  #--------------------------------------------------------------------------
  def animation1_id
    return $data_enemies[@enemy_id].animation1_id
  end
  #--------------------------------------------------------------------------
  # * Get Target Animation ID for Normal Attack
  #--------------------------------------------------------------------------
  def animation2_id
    return $data_enemies[@enemy_id].animation2_id
  end
  #--------------------------------------------------------------------------
  # * Get Element Revision Value
  #     element_id : Element ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # Get a numerical value corresponding to element effectiveness
    table = [0,200,150,100,50,0,-100]
    result = table[$data_enemies[@enemy_id].element_ranks[element_id]]
    # If protected by state, this element is reduced by half
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # End Method
    return result
  end
  #--------------------------------------------------------------------------
  # * Get State Effectiveness
  #--------------------------------------------------------------------------
  def state_ranks
    return $data_enemies[@enemy_id].state_ranks
  end
  #--------------------------------------------------------------------------
  # * Determine State Guard
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state_guard?(state_id)
    return false
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack Element
  #--------------------------------------------------------------------------
  def element_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (+)
  #--------------------------------------------------------------------------
  def plus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Get Normal Attack State Change (-)
  #--------------------------------------------------------------------------
  def minus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # * Aquire Actions
  #--------------------------------------------------------------------------
  def actions
    return $data_enemies[@enemy_id].actions
  end
  #--------------------------------------------------------------------------
  # * Get EXP
  #--------------------------------------------------------------------------
  def exp
    return $data_enemies[@enemy_id].exp
  end
  #--------------------------------------------------------------------------
  # * Get Gold
  #--------------------------------------------------------------------------
  def gold
    return $data_enemies[@enemy_id].gold
  end
  #--------------------------------------------------------------------------
  # * Get Item ID
  #--------------------------------------------------------------------------
  def item_id
    return $data_enemies[@enemy_id].item_id
  end
  #--------------------------------------------------------------------------
  # * Get Weapon ID
  #--------------------------------------------------------------------------
  def weapon_id
    return $data_enemies[@enemy_id].weapon_id
  end
  #--------------------------------------------------------------------------
  # * Get Armor ID
  #--------------------------------------------------------------------------
  def armor_id
    return $data_enemies[@enemy_id].armor_id
  end
  #--------------------------------------------------------------------------
  # * Get Treasure Appearance Probability
  #--------------------------------------------------------------------------
  def treasure_prob
    return $data_enemies[@enemy_id].treasure_prob
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen X-Coordinate
  #--------------------------------------------------------------------------
  def screen_x
    return $data_troops[@troop_id].members[@member_index].x
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen Y-Coordinate
  #--------------------------------------------------------------------------
  def screen_y
    return $data_troops[@troop_id].members[@member_index].y
  end
  #--------------------------------------------------------------------------
  # * Get Battle Screen Z-Coordinate
  #--------------------------------------------------------------------------
  def screen_z
    return screen_y
  end
  #--------------------------------------------------------------------------
  # * Escape
  #--------------------------------------------------------------------------
  def escape
    # Set hidden flag
    @hidden = true
    # Clear current action
    self.current_action.clear
  end
  #--------------------------------------------------------------------------
  # * Transform
  #     enemy_id : ID of enemy to be transformed
  #--------------------------------------------------------------------------
  def transform(enemy_id)
    # Change enemy ID
    @enemy_id = enemy_id
    # Change battler graphics
    @battler_name = $data_enemies[@enemy_id].battler_name
    @battler_hue = $data_enemies[@enemy_id].battler_hue
    # Remake action
    make_action
  end
  #--------------------------------------------------------------------------
  # * Make Action
  #--------------------------------------------------------------------------
  def make_action
    # Clear current action
    self.current_action.clear
    # If unable to move
    unless self.movable?
      # End Method
      return
    end
    # Extract current effective actions
    available_actions = []
    rating_max = 0
    for action in self.actions
      # Confirm turn conditions
      n = $game_temp.battle_turn
      a = action.condition_turn_a
      b = action.condition_turn_b
      if (b == 0 and n != a) or
         (b > 0 and (n < 1 or n < a or n % b != a % b))
        next
      end
      # Confirm HP conditions
      if self.hp * 100.0 / self.maxhp > action.condition_hp
        next
      end
      # Confirm level conditions
      if $game_party.max_level < action.condition_level
        next
      end
      # Confirm switch conditions
      switch_id = action.condition_switch_id
      if switch_id > 0 and $game_switches[switch_id] == false
        next
      end
      # Add this action to applicable conditions
      available_actions.push(action)
      if action.rating > rating_max
        rating_max = action.rating
      end
    end
    # Calculate total with max rating value at 3 (exclude 0 or less)
    ratings_total = 0
    for action in available_actions
      if action.rating > rating_max - 3
        ratings_total += action.rating - (rating_max - 3)
      end
    end
    # If ratings total isn't 0
    if ratings_total > 0
      # Create random numbers
      value = rand(ratings_total)
      # Set things that correspond to created random numbers as current action
      for action in available_actions
        if action.rating > rating_max - 3
          if value < action.rating - (rating_max - 3)
            self.current_action.kind = action.kind
            self.current_action.basic = action.basic
            self.current_action.skill_id = action.skill_id
            self.current_action.decide_random_target_for_enemy
            return
          else
            value -= action.rating - (rating_max - 3)
          end
        end
      end
    end
  end
end
"2#==============================================================================
# ** Game_Troop
#==============================================================================

class Game_Troop
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    # Create enemy array
    @enemies = []
  end
  #--------------------------------------------------------------------------
  # * Get Enemies
  #--------------------------------------------------------------------------
  def enemies
    return @enemies
  end
  #--------------------------------------------------------------------------
  # * Setup
  #     troop_id : troop ID
  #--------------------------------------------------------------------------
  def setup(troop_id)
    # Set array of enemies who are set as troops
    @enemies = []
    troop = $data_troops[troop_id]
    for i in 0...troop.members.size
      enemy = $data_enemies[troop.members[i].enemy_id]
      if enemy != nil
        @enemies.push(Game_Enemy.new(troop_id, i))
      end
    end
    
    # Set up BGM and escape
    if troop.name.index(/[Ff][Ii][Nn][Aa][Ll][Bb][Oo][Ss][Ss]/) != nil
      bgm = RPG::AudioFile.new(FINAL_BOSS_BGM, 100, 100)
      $game_switches[IN_BOSS_BATTLE_SWITCH] = true # in boss battle
    elsif troop.name.index(/[Bb][Oo][Ss][Ss]/) != nil
      bgm = RPG::AudioFile.new(BOSS_BGM, 100, 100)
      $game_switches[IN_BOSS_BATTLE_SWITCH] = true # in boss battle
    elsif troop.name.index(/[Nn][Oo][Bb][Gg][Mm]/) != nil
      #don't play any bgm
    else
      bgm = RPG::AudioFile.new(BATTLE_BGM, 80, 100)
    end
    $game_system.bgm_play(bgm)
  end
  #--------------------------------------------------------------------------
  # * Random Selection of a Target Enemy
  #     hp0 : limited to enemies with 0 HP
  #--------------------------------------------------------------------------
  def random_target_enemy(hp0 = false)
    # Initialize roulette
    roulette = []
    # Loop
    for enemy in @enemies
      # If it fits the conditions
      if (not hp0 and enemy.exist?) or (hp0 and enemy.hp0?)
        # Add an enemy to the roulette
        roulette.push(enemy)
      end
    end
    # If roulette size is 0
    if roulette.size == 0
      return nil
    end
    # Spin the roulette, choose an enemy
    return roulette[rand(roulette.size)]
  end
  #--------------------------------------------------------------------------
  # * Random Selection of a Target Enemy (HP 0)
  #--------------------------------------------------------------------------
  def random_target_enemy_hp0
    return random_target_enemy(true)
  end
  #--------------------------------------------------------------------------
  # * Smooth Selection of a Target Enemy
  #     enemy_index : enemy index
  #--------------------------------------------------------------------------
  def smooth_target_enemy(enemy_index)
    # Get an enemy
    enemy = @enemies[enemy_index]
    # If an enemy exists
    if enemy != nil and enemy.exist?
      return enemy
    end
    # Loop
    for enemy in @enemies
      # If an enemy exists
      if enemy.exist?
        return enemy
      end
    end
  end
end
"‡#==============================================================================
# ** Scene_Base
#------------------------------------------------------------------------------
#  This is a super class of all scenes within the game.
#==============================================================================

MENU_TRANSPARENCY = 200

class Scene_Base
  
  #--------------------------------------------------------------------------
  # * Main
  #--------------------------------------------------------------------------
  def initialize    
    Graphics.transition#(transtime)
    Input.update
    start
  end

  def start
    #overriide
  end
    
  def terminate
    Graphics.freeze    
  end

  #--------------------------------------------------------------------------
  # * Fade Out All Sounds and Graphics
  #--------------------------------------------------------------------------
  def fadeout_all(time = 1000)
    RPG::BGM.fade(time)
    RPG::BGS.fade(time)
    RPG::ME.fade(time)
    Graphics.fadeout(time * Graphics.frame_rate / 1000)
    RPG::BGM.stop
    RPG::BGS.stop
    RPG::ME.stop
  end

end
"0
#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Map < Scene_Base  
  
  attr_accessor :hud_window
   
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def start

    @hud = Game_Hud.new
    @world = Game_World.new
            
  end
  
  def terminate
    super

    @world.dispose
    @hud.dispose
    
    # if $scene.is_a?(Scene_Title)
    #   Graphics.transition
    #   Graphics.freeze
    # end

  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update

      $map.update      
      $player.update

      @world.update
      @hud.update


      return # if not transferring

      # transfer_player
      
      # if $game_temp.transition_processing
      #   break
      # end
    #end   

    if $temp.transition_processing
      $temp.transition_processing = false

      if $temp.transition_name == ""
        Graphics.transition(20)
      else
        Graphics.transition(40, "Graphics/Transitions/" +
          $temp.transition_name)
      end
    end

    # Open Menu at player's request
    unless $map.interpreter.running? or $hud.busy?

      # Check inputs
        
    end
    
  end

  #--------------------------------------------------------------------------
  # * Teleport the Player
  #--------------------------------------------------------------------------
  def transfer_player
   
    $temp.player_transferring = false
    $player.clear_path

    # Map to teleport to 
    if $map.map_id != $temp.player_new_map_id
      $map.setup($game_temp.player_new_map_id)      
    end

    # Location on the map to teleport to
    $player.moveto($temp.player_new_x, $temp.player_new_y)
    $player.direction = $temp.player_new_direction

    $player.straighten
    $map.update

    if $temp.transition_processing
      $temp.transition_processing = false
      Graphics.transition(20)
    end

    $map.autoplay    

    # AUTO SAVING

    # autosave your game (but not on the ending map)
   # if !ENDING_MAPS.include?($game_map.map_id)
   #   save = Scene_Save.new(1)
   #   save.autosave      
   # end
    
  end

end"#==============================================================================
# ** Game_Party
#==============================================================================

class Game_Party

  attr_accessor :actors                   # actors
  attr_accessor :reserve                  # reserve party

  attr_reader   :gold                     # amount of gold

  attr_accessor :all_actors

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    # Create all actors    
    @actors = {}
    $data.actors.each{ |k,v| @actors[k] = Game_Actor.new(k) }    

    # Create actor array
    @active = []
    @reserve = []

    # Initialize amount of gold
    @gold = 0


    # Create amount in possession hash for items, weapons, and armor
    @items = {}
    @weapons = {}
    @armors = {}
    
    # TEMP DISABLE
    set_active("boyle")

  end

  #--------------------------------------------------------------------------
  # * Getting Maximum Level
  #--------------------------------------------------------------------------
  def max_level
    return @actors.max_by(&:level)
  end

  #--------------------------------------------------------------------------
  # * Add an Actor
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def set_active(actor)

    if @active.size < 4 and not @actors.include?(actor)
      
      @active.push(actor)
      
      $player.refresh
    end
   if !@active.include?(actor)
      @reserve.push(actor)
    end

  end

  def set_reserve(actor)
    @reserve.push(actor)
  end

  def back_to_pavillion(actor)
    @actors.delete(actor)
    @reserve.delete(actor)
  end

  #--------------------------------------------------------------------------
  # * Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def add_item(id,n) add(@items,id,n) end
  def lose_item(item,n) add(@items,id,n) end
  def item_number(id) count(@items,id) end
  def has_item?(id) count(type,id) > 0 end



  def add(type,id,number)
    type.has_key?(id) ? type[id] += number : type[id] = number
  end

  def count(type,id)
    return type.has_key?(id) ? type[id] : 0
  end

  

  #--------------------------------------------------------------------------
  # * Clear All Member Actions
  #--------------------------------------------------------------------------
  def clear_actions
    for actor in @actors
      actor.current_action.clear
    end
  end

  #--------------------------------------------------------------------------
  # * Determine Everyone is Dead
  #--------------------------------------------------------------------------
  def all_dead?
    return false if @active.empty?
    for actor in @active
      return false if @actors[actor].hp > 0
    end
    return true
  end

  #--------------------------------------------------------------------------
  # * Slip Damage Check (for map)
  #--------------------------------------------------------------------------
  def check_map_slip_damage
    for actor in @active + @reserve
      if actor.hp > 0 and actor.slip_damage?
        actor.hp -= [actor.maxhp / 100, 1].max
        if actor.hp == 0
          $audio.play_se($data_system.actor_collapse_se)
        end
        $map.world.start_flash(Color.new(255,0,0,128), 4)
        $temp.gameover = $party.all_dead?
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Random Selection of Target Actor
  #     hp0 : limited to actors with 0 HP
  #--------------------------------------------------------------------------
  def random_target_actor(hp0 = false)
    # Initialize roulette
    roulette = []
    # Loop
    for actor in @actors
      # If it fits the conditions
      if (not hp0 and actor.exist?) or (hp0 and actor.hp0?)
        # Get actor class [position]
        position = $data_classes[actor.class_id].position
        # Front guard: n = 4; Mid guard: n = 3; Rear guard: n = 2
        n = 4 - position
        # Add actor to roulette n times
        n.times do
          roulette.push(actor)
        end
      end
    end
    # If roulette size is 0
    if roulette.size == 0
      return nil
    end
    # Spin the roulette, choose an actor
    return roulette[rand(roulette.size)]
  end

  #--------------------------------------------------------------------------
  # * Random Selection of Target Actor (HP 0)
  #--------------------------------------------------------------------------
  def random_target_actor_hp0
    return random_target_actor(true)
  end
  
  #--------------------------------------------------------------------------
  # * Smooth Selection of Target Actor
  #     actor_index : actor index
  #--------------------------------------------------------------------------
  def smooth_target_actor(actor_index)
    # Get an actor
    actor = @actors[actor_index]
    # If an actor exists
    if actor != nil and actor.exist?
      return actor
    end
    # Loop
    for actor in @actors
      # If an actor exists
      if actor.exist?
        return actor
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # â— check if actor is in party
  #--------------------------------------------------------------------------  
  def has_actor?(actor)
    return @active.include?(actor)
  end

  #--------------------------------------------------------------------------
  # â— check if all actors are 'normal' state
  #--------------------------------------------------------------------------  
  def all_normal
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        if (actor.states & ([1] + BAD_STATES)).size > 0 # non-shield status inflicted
          return false
        end
      end
    end
    
    return true
  end

  #--------------------------------------------------------------------------
  # â— remove inflictions
  #--------------------------------------------------------------------------  
  def remove_inflictions()
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        for state in BAD_STATES
          actor.remove_state(state, true)
        end
      end
    end
  end

  #--------------------------------------------------------------------------
  # â— Actor Lineup
  #   Provides a list of party members
  #-------------------------------------------------------------------------- 
  def actor_lineup()
    @lineup = []
    for i in 1..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil and !@lineup.include?(actor) && $game_player.is_present(actor.id)
        @lineup.push(actor)
      end
    end
  end
        
end""
module Av

	class Progress

		attr_accessor :quests, :complete
		attr_accessor :progress


		def initialize
			@quests = []
			@complete = []
			@progress = []
		end

		def add_quest(q)
			@quests.push(q)
		end

		def end_quest(q)
			@quests.delete(q)
			@complete.push(q)
		end

		def quest_active?(q)
			return @quests.include?(q)
		end

		def quest_done?(q)
			return @complete.include?(q)
		end


		def progress!(progress)
			@progress= $data.progress[progress]
		end

		def progress?(progress)
		    return false if !$data.progress.include?(progress)
			return @progress >= $data.progress[progress]
		end

		def beyond?(progress)
			return false if !$data.progress.include?(progress)
			return @progress > $data.progress[progress]
		end

	end

end"V
module Av

	class State

		def initialize

			@flags = []
			@vars = {}

			# Event modifiers
			@states = {} # Event states
			@locs = {}
			@deleted = []
			@disabled = []

		end

		def flag!(f)
			@flags.push(f) if !@flags.include?(f)
		end

		def unflag!(f)
			@flags.delete(f)
		end

		def flag?(f)
			return @flags.include?(f)
		end

		def var!(v,a)
			if @vars.has_key?(v)
				@vars[v] += a
			else
				@vars[v] = a
			end
		end

		def unvar!(v,a)
			if @vars.has_key?(v)
				@vars[v] -= a
			else
				@vars[v] = -a
			end
		end

		def var?(v,t)
			return false if !@vars.has_key?(v)
			return @vars[v] >= t
		end

		def state!(e,s)
			@states[[$map.id,e,s]] = true
		end

		def unstate!(e,s)
			@states[[$map.id,e,s]] = false
		end

		def state?(e,s)
			return false if !@states.has_key?([$map.id,e,s])
			return @states[[$map.id,e,s]]
		end

		def loc!(e)
			@locs[[$map.id,e]] = [e.x,e.y]
		end

		def loc?(e)
			return @locs.has_key?([$map.id,e])			
		end

		def getloc(e)
			return @locs[[$map.id,e]]
		end

		def delete!(e)
			@deleted.push([$map.id,e])
		end

		def delete?(e)
			return @deleted.include?([$map.id,e])
		end

		def disable!(e)
			@disabled.push([$map.id,e])
		end

		def disable?(e)
			return @disabled.include?([$map.id,e])
		end

	end

end"º
#==============================================================================
# ** Game_Temp
#==============================================================================

class Game_Temp
  
  # Put in map where it can be used
  attr_accessor :common_event_id          # common event ID  
  
  
  # Battle setup, don't need?
  attr_accessor :in_battle                # in-battle flag
  attr_accessor :battle_troop_id          # battle troop ID
  attr_accessor :battle_can_escape        # battle flag: escape possible
  attr_accessor :battle_can_lose          # battle flag: losing possible
  attr_accessor :battle_proc              # battle callback (Proc)
  attr_accessor :battle_turn              # number of battle turns
  attr_accessor :battle_event_flags       # battle event flags: completed
  attr_accessor :battle_abort             # battle flag: interrupt
  attr_accessor :battle_main_phase        # battle flag: main phase


  # Put this elsewhere, could open with shop
  attr_accessor :shop_goods               # list of shop goods

  
  # This can surely go elsewhere, in player or map
  attr_accessor :player_transferring      # player place movement flag
  attr_accessor :player_new_map_id        # player destination: map ID
  attr_accessor :player_new_x             # player destination: x-coordinate
  attr_accessor :player_new_y             # player destination: y-coordinate
  attr_accessor :player_new_direction     # player destination: direction
  
 
  # FROM SYSTEM - TO BE CUT
    
  # move out of here, to map perhaps
  #attr_accessor :map_interpreter          # map event interpreter
  #attr_reader   :battle_interpreter       # battle event interpreter
    
  # Possibly useful, maybe move
  # These could be flags? or options somewhere
  attr_accessor :save_disabled            # save forbidden
  attr_accessor :menu_disabled            # menu forbidden
  
  
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    @common_event_id = 0
    
    @in_battle = false
    @battle_calling = false
    @battle_troop_id = 0
    @battle_can_escape = false
    @battle_can_lose = false
    @battle_proc = nil
    @battle_turn = 0
    @battle_event_flags = {}
    @battle_abort = false
    @battle_main_phase = false
    @battleback_name = ''

    
    @player_transferring = false
    @player_new_map_id = 0
    @player_new_x = 0
    @player_new_y = 0
    @player_new_direction = 0
    
    # In game surely? or map
    @transition_processing = false
    @transition_name = ""

  end

end
"½'#==============================================================================
# Extended Sprite Class
#==============================================================================

class Widget < Sprite
    
  attr_accessor :width, :height, :parent, :active
  
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize()
    super()
    
    @width = 150
    @height = 100

    @parent = nil

    @dead = false

    @active = false

    @link_target = nil
    @link_ox = 0
    @link_oy = 0

  end

  def create
    # TO OVERWRITE!!!!!!!!
  end

  def activate
    @active = true
  end

  def deactivate
    @active = false
  end

  def resize(w,h)
    @width = w
    @height = h
  end

  def link(target,ox,oy)
    @link_target = target
    @link_ox = ox
    @link_oy = oy
  end

  def autosize
    self.width = self.bitmap.width
    self.height = self.bitmap.height
  end

  def snap_bottom
    self.y = 416 - self.height
  end

  def update
    super
    if @link_target != nil
      self.x = @link_target.x + @link_ox
      self.y = @link_target.y + @link_oy
    end
  end


  def inside?(pos)
    return false if pos[0] < self.x
    return false if pos[1] < self.y
    return false if pos[0] > self.x + self.width
    return false if pos[1] > self.y + self.height
    return true
  end

  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------

  # visible or not
  def hide() self.visible = false end
  def show() self.visible = true end
    
  #--------------------------------------------------------------------------
  # * Ready to remove
  #--------------------------------------------------------------------------
  def kill() @dead = true end
  def dead?() return @dead end

    #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def from_menu(src) self.bitmap = Cache.menu(src) end
  def from_menu_frame(src,frame) self.bitmap = Cache.menu_frame(src,frame) end
  def from_bitmap(bmp) self.bitmap = bmp end  
  def from_icon(idx,double=false) self.bitmap = Cache.icon(idx,double) end  
  def from_stroke_icon(idx,double=false) self.bitmap = Cache.stroke_icon(idx,double) end
    
  # Stretch out
  def from_menu_stretch(src,width,height)
    self.bitmap = Bitmap.new(width,height)
    img = Cache.menu(src)
    self.bitmap.stretch_blt(Rect.new(0,0,width,height),img,img.rect)
  end
  
  def from_skin(src,shadow=5)

    #    shadow = self.get_skin('skin-shadow')
    #white = self.get_skin('skin-white')

    #self.bitmap = Bitmap.new(self.width + 5,self.height+5)
    #self.bitmap.blt(5,5,shadow,shadow.rect,120)
    #self.bitmap.blt(0,0,white,white.rect)

    width = @width
    height = @height

    self.bitmap = Bitmap.new(width+shadow,height+shadow)
    src = Cache.menu(src)

    ssrc = Cache.menu('skin-shadow')

    w = src.width/3
    h = src.height/3

    sx = 0
    sy = 0
    o = 140


    # shadowwwwwww
    self.bitmap.blt(0+shadow,height-h+shadow,ssrc,Rect.new(sx,sy+40,w,h),o) # bottom left
    self.bitmap.blt(width-w+shadow,0+shadow,ssrc,Rect.new(sx+40,sy,w,h),o) # top right
    self.bitmap.blt(width-w+shadow,height-h+shadow,ssrc,Rect.new(sx+40,sy+40,w,h),o) # bottom right
     self.bitmap.stretch_blt(Rect.new(width-w+shadow,h+shadow,w,height-40),ssrc,Rect.new(w*2,h,w,h),o)
    self.bitmap.stretch_blt(Rect.new(w+shadow,height-h+shadow,width-40,h),ssrc,Rect.new(w,h*2,w,h),o)

  o = 255

    # CORNERS
    self.bitmap.blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
    self.bitmap.blt(width-w,0,src,Rect.new(sx+40,sy,w,h),o) # top right
    self.bitmap.blt(0,height-h,src,Rect.new(sx,sy+40,w,h),o) # bottom left
    self.bitmap.blt(width-w,height-h,src,Rect.new(sx+40,sy+40,w,h),o) # bottom right
    
    #dest_rect, bmp, src_rect

    # Middle
    self.bitmap.stretch_blt(Rect.new(w,h,width-40,height-40),src,Rect.new(w,h,w,h),o)

    # left side
    self.bitmap.stretch_blt(Rect.new(0,h,w,height-40),src,Rect.new(0,h,w,h),o)

    # Right
    self.bitmap.stretch_blt(Rect.new(width-w,h,w,height-40),src,Rect.new(w*2,h,w,h),o)

    #top
    self.bitmap.stretch_blt(Rect.new(w,0,width-40,h),src,Rect.new(w,0,w,h),o)

   #bottom
    self.bitmap.stretch_blt(Rect.new(w,height-h,width-40,h),src,Rect.new(w,h*2,w,h),o)


    #self.bitmap.stretch_blt(Rect.new(0,w,width,height-40),src,Rect.new(sx+w,sy+h,w,h),o)
    #self.bitmap.stretch_blt(Rect.new(w,0,width-40,h),src,Rect.new(sx+w,sy+h,w,h),o)
    #self.bitmap.stretch_blt(Rect.new(w,height-h,width-40,h),src,Rect.new(sx+w,sy+h,w,h),o)
    
  end

  # Character img
  def from_char(img,idx,dir,zoom=1.0,p=1)
    #p img,idx
    zoom = 2.0 if zoom == true
    zoom = 1.0 if zoom == false
    self.bitmap = Cache.char_frame(img,idx,dir,zoom,p)
  end
  
  def from_spr(src)

    dir = 2
    
    if src.bitmap.width < 100
      cw = src.bitmap.width / 3
      ch = src.bitmap.height / 4
    else
      cw = src.bitmap.width / 12
      ch = src.bitmap.height / 8
    end
    #n = idx
    n = src.character.character_index
    p=1
    src_rect = Rect.new((n%4*3+p)*cw, (n/4*4+((dir/2)-1))*ch, cw, ch)
    #if double
      dest_rect = Rect.new(0,0,cw*2,ch*2)
    #else
    #  dest_rect = Rect.new(0,0,cw,ch)
   #end
    bmp = Bitmap.new(dest_rect.width,dest_rect.height)
    bmp.stretch_blt(dest_rect,src.bitmap,src_rect)
        
    self.bitmap = bmp
    #self.src_rect = src.src_rect
  end
  
  # Color box
  def from_color(c)
    self.bitmap = Bitmap.new(self.width,self.height)
    self.bitmap.fill_rect(0,0,self.width,self.height,c)
  end  
  
  # From numbers for bottom bar etc
  def from_numbers(num,color,percent=false)
    
    # Auto coloring depending on number out of 100
    if color == :auto
      
      color = :red
      color = :orange if num > 20
      color = :yellow if num > 40
      color = :green if num > 60
      
    end
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('Bar/numbers.12.7')
    cw = src.width/12
    ch = src.height/7

    # Colors
    colors = [:red,:blue,:yellow,:green,:white,:purple,:orange]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.45

    }
    if percent
      
      c+=cw*0.2
      n=10
      s = n * cw
      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      
    end
    
    
    self.bitmap = bmp
    
  end
  
  def from_numbers_right(num,color,percent=false)
    
    # Auto coloring depending on number out of 100
    if color == :auto
      
      color = :red
      color = :orange if num > 20
      color = :yellow if num > 40
      color = :green if num > 60
      
    end
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('Bar/numbers.12.7')
    cw = src.width/12
    ch = src.height/7

    # Colors
    colors = [:red,:blue,:yellow,:green,:white,:purple,:orange]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.45

    }    
    
    #copy to new bitmap
    c+=8
    final = Bitmap.new(c,ch)
    final.blt(0,0,bmp,bmp.rect)
    
    self.bitmap = final
    
  end
  
  # From Big Numbers
  def from_big_numbers(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('level_nums.10.1')
    cw = src.width/10
    ch = src.height
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+10,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,0,cw,ch))
      c += cw*0.8

    }  
    
    self.bitmap = bmp
    
  end
  
    # From numbers for bottom bar etc
  def from_meganums(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    
    
    # prepare the final image
    width = 0
    nums.each{ |n| 
      width += 50 if n == 1
      width+=100 if n != 1
    }
    bmp = Bitmap.new(width,117)
    c = 0

    nums.each{ |n|

      src = Cache.menu('Lvls/'+n.to_s)
      bmp.blt(c,0,src,src.rect)
      c += src.width

    }   
    
    self.bitmap = bmp
    
  end
  
  def from_pop35(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }
    
    size = 35
    color = :white

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    if nums.size == 1
      width = cw
    else
      width = nums.size * cw*0.78
    end
    #nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.7

    }
    
    self.bitmap=bmp
    
  end
  
  
end
"â6 #==============================================================================
# ** Dan Message Box
#==============================================================================

# States
#
# :closed - hidden and inactive
# :opening - fading in, leads to :texting
# :closing - fading out, leads to :closed
# :texting - showing text, letter by letter
# :done - done showing text, wait for input to continue
# :waiting - waiting a set time, @. @| etc

class Sprite_Textbox < Widget

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @state = :closed
    @side = 'a'      

    # text speed
    @normal_speed = 4 #-$settings.value('text_speed')
    @text_delay = @normal_speed
    
    # Internal tracking
    @skip_all = false
    @wait_frames = 0
    @next_char = 0   
    @top_line_fade = 255
    @line_y_offset = 0
    @indent=25
    @width=425  
    @data = nil # All text
    @line_data = [''] # Text on current line
    @word = "" # Remainder of current word
    @line_images = nil
    @line_indx = 0
    @word_idx = 0

    # show next icon
    @show_next = false
    @next_opacity = 0

    # Setup height for zooming
    self.set_height(64)
    #self.set_zy(0.0)    
    
    @style = 'white'
    @font = 'white'
    
    self.bitmap = @bg_gfx = Cache.menu("chatbox")
    #Cache.menu("Text\\chat_box_white_"+@side)

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end
      

    @next_opacity += 10 if @show_next && @next_opacity < 250
    @next_opacity -= 10 if !@show_next && @next_opacity > 0
    
    # Skip to end of this text, line i guess, but maybe don't have this
    #if Input.trigger?(Input::C) && @state = :texting
    #  @skip_all = true
    #end

    case @state

      when :closed
        #nothing
      when :opening
        @state = :texting if self.zoom_y == 1.0
      when :closing
        if self.zoom_y == 0.0
          @state = :closed
          @line_images = [Bitmap.new(500,40)]
          @line_images[0].font = Fonts.get(@font+"_reg")
          draw_lines
        end
      when :texting
        @next_char -= 1
        if @next_char <= 0
          update_message
          update_message if @text_delay < 0
        end
        draw_lines
      when :fade_line
        @top_line_fade -= 5#(5 * $settings.value('text_speed'))
        if @top_line_fade < 10
          @top_line_fade = 0
          @state = :scroll_line
        end
        draw_lines
      when :scroll_line
        @line_y_offset += 5#$settings.value('text_speed')
        @line_y_offset = 23.0 if @line_y_offset >= 23.0
        draw_lines
        if @line_y_offset >= 23
          @line_y_offset = 0
          @top_line_fade = 255
          @line_images[0].dispose
          @line_images.delete_at(0)
          @line_idx-=1
          @state = :texting
        end
        
      when :waiting
        update_waiting
      when :pausing
        check_input_next
        draw_lines
      when :done
        check_input_done
        draw_lines
    end

    # skipping
    while @state == :texting && @skip_all
      @next_char > 0 ? @next_char -= 1 : update_message
    end

  end

  #--------------------------------------------------------------------------
  # * Setup
  #--------------------------------------------------------------------------
  def set_side(side) 
    @side = side 
    self.bitmap = @bg_gfx = Cache.menu("chatbox")
    #Cache.menu("Text\\chat_box_white_"+@side)
    #@indent = 25 if @side == 'a'
    #@indent = 13 if @side == 'b'
  end
  def set_style(back) 
    @style = back
    case back
    when 'white'
      self.ox=0
      self.bitmap = @bg_gfx = Cache.menu("chatbox")
      #Cache.menu("Text\\chat_box_white_"+@side)
      #@indent = 25 if @side == 'a'
      #indent = 13 if @side == 'b'
      @font='white'
    when 'black'
      self.ox=0
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_black_"+@side)
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'black'
    when 'lines'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_lines")
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'lines'
    when 'yellow'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_yellow")
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'white'
    when 'brwn'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_brwn")
      @indent = 35 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'white'
    end
  end

  #--------------------------------------------------------------------------
  # * Setup text
  #--------------------------------------------------------------------------
  def start_text(text)

    @text_delay = @normal_speed
    
    @skip_all = false
    
    # Read the text
    #p text
    text.lstrip!
    @data = text.split(' ')
    replace_words

    # reset things
    @show_next = false    
    @line_images = []

    # prep for text
    @word_idx = -1
    @line_idx = -1
    next_line
    next_word
    
    # Prepare to open

    #nano
    #self.slide_zy(1.0)
    @state = :opening

  end  

  #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    @word_idx += 1
    (@show_next = true;@state = :done; return) if @word_idx >= @data.size
    @word = @data[@word_idx]
    @wordlength = @word.length

    # CHECK FOR COMMANDS
    if @word[0]=='#' || @word[0] == ';' || @word[0] == '/'
      cmd = @word.split(".")
      wrd = cmd[0]
      wrd.slice!(0)

      # check for command words
      case wrd
      
        when "nl" # New line
          next_line
          
        when "w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
          
        when "ww"
          @wait_frames = 30; @state = :waiting
        when "www"
          @wait_frames = 45; @state = :waiting
        when "wwww"
          @wait_frames = 60; @state = :waiting
        when "wwwww"
          @wait_frames = 75; @state = :waiting
        when "wwwwww"
          @wait_frames = 90; @state = :waiting
        when "wwwwwww"
          @wait_frames = 105; @state = :waiting
        when "wwwwwwww"
          @wait_frames = 120; @state = :waiting
          
        when "sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
          
        when "fl"
          color = cmd.size > 1 ? Colors.get(cmd[1].to_sym) : Colors.get(:black)
          $world.do_flash(color,15)         
          
        when "s" # play sound
          Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "m","music"
          
          case cmd[1]
            when 'stop'
              @bkp = RPG::BGM.last
              Audio.bgm_stop            
            when 'fade'
              @bkp = RPG::BGM.last
              Audio.bgm_fade(750)          
            when 'resume'
              Audio.bgm_play("Audio/BGM/"+@bkp.name,@bkp.volume,@bkp.pitch,@bkp.pos)            
            else
              Audio.bgm_play("Audio/BGM/"+cmd[1])            
          end
          
        when "nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      next_word

    end

  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @line_images.push(Bitmap.new(500,40))
    @line_images[@line_images.size-1].font = Fonts.get(@font+"_reg")
    @line_data = ['']
    if @line_idx > 1     
      @show_next = true     
      @state = :pausing
    end
  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    if @word.empty?

      next_word
      
      # Check if width will be too much, maybe add new line
      total = 0
      @line_data.each{ |w| 
        if w[0] == "%"
          total+=24+@line_images[0].text_size(' ').width 
        else
          total += @line_images[0].text_size(w+' ').width 
        end
      }      
      total += @line_images[0].text_size(@word).width
      total > @width ? next_line : @line_data.push('')      
      
    end
        
    # if not texting then don't go
    return unless @state == :texting
    
    @dodotpause = false
    @dodotpause = true if @word == "." || @word == "!" || @word == "?"
        
    # Add the next character to the final word
    @line_data[@line_data.size-1] += @word.slice!(0,1)
    #sound(:text_char) #if $settings.value('text_sound') 
    
    
    # Redraw this line of text
    cursor = 0
    @line_images[@line_idx].clear   
    @line_images[@line_idx].font = Fonts.get(@font+"_reg")
    @line_data.each{ |w|
      aw = w.dup
      if aw[0] == '^'
        aw.slice!(0)
        @line_images[@line_idx].font = Fonts.get(@font+"_bold")
      end
      if aw[0] == '~'
        aw.slice!(0)
        @line_images[@line_idx].font = Fonts.get(@font+"_talic")
      end
      if aw[0] == "%"
        aw.slice!(0)
        i = aw.to_i
        @line_images[@line_idx].blt(cursor,12,Cache.icon(i),Rect.new(0,0,24,24))
        cursor += 24+@line_images[@line_idx].text_size(' ').width
      else
        @line_images[@line_idx].draw_text(cursor,0,500,50,aw,255)
        cursor += @line_images[@line_idx].text_size(aw+' ').width
      end
      @line_images[@line_idx].font = Fonts.get(@font+"_reg")
    }

    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    (@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end
  
  #--------------------------------------------------------------------------
  # * Draw Lines to final image
  #--------------------------------------------------------------------------
  def draw_lines()
    
    # redraw the current line
    self.bitmap = @bg_gfx.dup

    # Draw lines    
    self.bitmap.blt(@indent,-7-@line_y_offset,@line_images[0],Rect.new(0,0,500,40),@top_line_fade)
    if @line_images.size > 1
      self.bitmap.blt(@indent,16-@line_y_offset,@line_images[1],Rect.new(0,0,500,40))
    end   

    # draw next
    snext = @style == 'black' ? Cache.menu("dots_blue") : Cache.menu("dots_gray")
    if @side == 'a'
      self.bitmap.blt(430,45,snext,Rect.new(0,0,22,6),@next_opacity)    
    else
      self.bitmap.blt(418,45,snext,Rect.new(0,0,22,6),@next_opacity)
    end
  
  end

  #--------------------------------------------------------------------------
  # * Word Replacer
  #--------------------------------------------------------------------------
  def replace_words

    idx = 0
    while(idx<@data.size) do
      word = @data[idx]

      case word
      
        when "&...", "#..."
          @data.delete_at(idx)
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          
        when "@"
          
          @data.delete_at(idx)
          
        end
        
        idx +=1

    end

  end

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all || Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
    Graphics.update
    Input.update
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_next
    if Input.trigger?(Input::B) || Input.trigger?(Input::C)
      #sound(:text_next)
      @state = :fade_line
      @show_next = false
    end
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if Input.trigger?(Input::B) || Input.trigger?(Input::C)
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @show_next = false
    end
  end

  #--------------------------------------------------------------------------
  # * Read from the automatic namings
  #--------------------------------------------------------------------------
  def busy?() return (@state != :closed && @state != :closing) end
  def visible?() return @state != :closed end

end
"Ümodule Graphics
 
  @fps, @fps_tmp = 0, []
 
  class << self
    
    attr_reader :fps
    
    alias fps_update update unless method_defined?(:fps_update)
    def update
	  t = Time.now
	  fps_update
	  @fps_tmp[frame_count % frame_rate] = Time.now != t
	  @fps = 0
	  frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
	  fps_sprite.src_rect.y = @fps * 16
    end
    
    def fps_sprite
	  if !@fps_sprite or @fps_sprite.disposed?
	    @fps_sprite = Sprite.new
	    @fps_sprite.z = 0x7FFFFFFF
	    @fps_sprite.x = 616
	    @fps_sprite.bitmap = Bitmap.new(24, 16*120)
	    #@fps_sprite.bitmap.font.name = "Arial"
	    @fps_sprite.bitmap.font.size = 16
	    @fps_sprite.bitmap.font.color.set(255, 255, 255)
	    @fps_sprite.bitmap.fill_rect(@fps_sprite.bitmap.rect, Color.new(0, 0, 0))
	    120.times {|i| @fps_sprite.bitmap.draw_text(0, i*16, 24, 16, "% 3d"%i, 1)}
	    @fps_sprite.src_rect.height = 16
	  end
	  return @fps_sprite
    end
    
  end
end"B class Array
 	def count
 		return length
 	end
 	def sample
      self[rand(length)]
  	end

 end

 class String
  def is_integer?
    self.to_i.to_s == self
  end
end

class FalseClass; def to_i; 0 end end
class TrueClass; def to_i; 1 end end

class Bitmap

	def fill(color)
		self.fill_rect(0,0,self.width,self.height,color)
	end

end

class Fixnum
	def odd?
		return self % 2 == 1
	end
end


class Sprite
	def hide
		self.visible = false
	end
	def show
		self.visible = true
	end
	def move(x,y)
		self.x = x
		self.y = y
	end
end"Ú#==============================================================================
# ** SpellCheck
#==============================================================================

def execute_spellcheck
    
    data = {} # map name, dialogues?
    
    # Each map
    $data_maps.each{ |k,v| 
    
      map_id = k
      map_name = v.name
      
      event_list = load_data(sprintf("Data/Map%03d.rvdata2",map_id)).events
      next if event_list.empty?
      
      events = {}
      
      # Do for each event
      event_list.each{ |k,v|
      
        ev_id = k
        ev_name = v.name
        
        dialogues = []
        
        # Do for each page
        v.pages.each{ |page|
        
        @cmd_idx = 0        
        while page.list[@cmd_idx] do

            # Do something according to command          
            case page.list[@cmd_idx].code
            
              when 101; # Short text
                
                text = ""
                while page.list[@cmd_idx+1].code == 401       # Text data
                  @cmd_idx += 1
                  text += page.list[@cmd_idx].parameters[0]
                  text += ' '      
                end
                dialogues.push(text)
                
              when 105; # Long text
            
                while page.list[@cmd_idx+1].code == 405
                  @cmd_idx += 1
                  line = page.list[@cmd_idx].parameters[0]
                  if line[0] == "@"
                    dialogues[dialogues.size-1] += " " + line
                  else
                    dialogues.push(line)
                  end
                end
            
            end
              
            @cmd_idx += 1  
          
          end # page        
        
        }

        # any dialogues? save it
        if !dialogues.empty?
          #p dialogues
          events[[ev_id,ev_name]] = dialogues
        end
        
      }

      # Add to overall
      if !events.empty?
        data[[map_id,map_name]] = events
      end
      
      #p name
      #p event_list.size
      
      
      #break
      
      
    }
    
    # Output to file
    # Create a new file and write to it  
    File.open('spellcheck.txt', 'w') do |file|  

      # Write some stats
      file.puts("Total Maps: "+$data_maps.size.to_s)
      file.puts("Maps with dialogue: "+data.size.to_s)

      # Word counts
      words = 0
      data.values.each{ |map|
        map.values.each{ |ev|
          ev.each{ |line|
            words += line.split(" ").size
          }
        }
      }
      file.puts("Word Count: "+words.to_s)

      file.puts("\n")
      file.puts("\n")

      # Each Map
      data.each{ |mk,mv|

        # Map name
        file.puts("Map "+mk[0].to_s+": "+mk[1])
        file.puts("----------------------------------------")
        file.puts("\n")

        # Contents
        mv.each{ |ek,ev|

          # Event name
          file.puts("Event "+ek[0].to_s+": "+ek[1])

          # Event contents
          ev.each{ |line|
            file.puts(line)
          }

          file.puts("\n")

        }
        file.puts("\n")
      }

    end  

    
  end"n#==============================================================================
# ** Sprite_Battler
#------------------------------------------------------------------------------
#  This sprite is used to display the battler.It observes the Game_Character
#  class and automatically changes sprite conditions.
#==============================================================================

class Sprite_Battler < RPG::Sprite
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :battler                  # battler
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     viewport : viewport
  #     battler  : battler (Game_Battler)
  #--------------------------------------------------------------------------
  def initialize(viewport, battler = nil)
    super(viewport)
    @battler = battler
    @battler_visible = false
  end
  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose
    if self.bitmap != nil
      self.bitmap.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    # If battler is nil
    if @battler == nil
      self.bitmap = nil
      loop_animation(nil)
      return
    end
    
    # If file name or hue are different than current ones
    # battler is enemy
    if battler.is_a?(Game_Enemy) or BATTLER_TYPE == 0
      if @battler.battler_name != @battler_name or @battler.battler_hue != @battler_hue
        # Get and set bitmap
        @battler_name = @battler.battler_name
        @battler_hue = @battler.battler_hue
        self.bitmap = RPG::Cache.battler(@battler_name, @battler_hue)       
        @width = bitmap.width
        @height = bitmap.height
        self.ox = @width / 2
        self.oy = @height
        # Change opacity level to 0 when dead or hidden
        if @battler.dead? or @battler.hidden
          self.opacity = 0
        end
      end
    # battler is actor
    else
      if @battler.character_name != @battler_name or @battler.character_hue != @battler_hue
        # Get and set bitmap
        @battler_name = @battler.character_name
        @battler_hue = @battler.character_hue
        # Get character bitmap
        self.bitmap = RPG::Cache.character(@battler_name, @battler_hue)       
        @width = bitmap.width / 4 
        @height = bitmap.height / 4 
        self.ox = @width / 2
        self.oy = @height
        # Set rectangle for character (x, y, width, height)
        self.src_rect.set(0, @height*BATTLER_DIRECTION, @width, @height)        
        # Change opacity level to 0 when dead or hidden
        if @battler.dead? or @battler.hidden
          self.opacity = 0
        end
      end      
    end
    
    # shaz - don't make fallen battlers invisible
    if @battler.is_a?(Game_Actor) && @battler.collapsing && @_collapse_duration == 0
      self.blend_type = 1
      self.color.set(255, 255, 255, 255)
      self.opacity = 150
      @battler.collapsing = false
      @battler_visible = false
    end
    # If animation ID is different than current one
    if @battler.damage == nil and
       @battler.state_animation_id != @state_animation_id
      @state_animation_id = @battler.state_animation_id
      loop_animation($data_animations[@state_animation_id])
    end
    # If actor which should be displayed
    if @battler.is_a?(Game_Actor) and @battler_visible
      # Bring opacity level down a bit when not in main phase
      if $game_temp.battle_main_phase
        self.opacity += 3 if self.opacity < 255
      else
        self.opacity -= 3 if self.opacity > 207
      end
    end
    # Blink
    if @battler.blink
      blink_on
    else
      blink_off
    end
    # If invisible
    unless @battler_visible
      # Appear
      if not @battler.hidden and not @battler.dead? and
         (@battler.damage == nil or @battler.damage_pop)
        appear
        @battler_visible = true
      end
    end
    # If visible
    if @battler_visible
      # Escape
      if @battler.hidden
        $game_system.se_play($data_system.escape_se)
        escape
        @battler_visible = false
      end
      # White flash
      if @battler.white_flash
        whiten
        @battler.white_flash = false
      end
      # Animation
      if @battler.animation_id != 0
        animation = $data_animations[@battler.animation_id]
        animation(animation, @battler.animation_hit)
        @battler.animation_id = 0
      end
      # Damage
      if @battler.damage_pop
        damage(@battler.damage, @battler.critical)
        @battler.damage = nil
        @battler.critical = false
        @battler.damage_pop = false
      end
      # Collapse
      if @battler.damage == nil and @battler.dead?
        if @battler.is_a?(Game_Enemy)
          $game_system.se_play($data_system.enemy_collapse_se)
        else
          $game_system.se_play($data_system.actor_collapse_se)
        end
        collapse
        if @battler.is_a?(Game_Actor)
          @battler.collapsing = true
        end
        @battler_visible = false
      end
    end
    # Set sprite coordinates
    self.x = @battler.screen_x
    self.y = @battler.screen_y
    self.z = @battler.screen_z
  end
end
"E#==============================================================================
# ** Sprite_Character
#------------------------------------------------------------------------------
#  This sprite is used to display the character.It observes the Game_Character
#  class and automatically changes sprite conditions.
#==============================================================================

class Sprite_Character < RPG::Sprite

  attr_accessor :character     

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     viewport  : viewport
  #     character : character (Game_Character)
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @character = character
    update
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    # If tile ID, file name, or hue are different from current ones
    if @tile_id != @character.tile_id or
       @character_name != @character.character_name
      # Remember tile ID, file name, and hue
      @tile_id = @character.tile_id
      @character_name = @character.character_name

      # If tile ID value is valid
      if @tile_id >= 384
        self.bitmap = RPG::Cache.tile($map.tileset.name,@tile_id, 0)
        self.src_rect.set(0, 0, 32, 32)
        self.ox = 16
        self.oy = 32
      # If tile ID value is invalid
      else
        #self.bitmap = RPG::Cache.character(@character.character_name,0)#@character.character_name,
        #if self == $player
          self.bitmap = RPG::Cache.character("boyle",0)#@character.character_name,
        #end
          #@character.character_hue)
        @cw = bitmap.width / 4
        @ch = bitmap.height / 4
        self.ox = @cw / 2
        self.oy = @ch
      end
    end

    # Set visible situation
    self.visible = !@character.transparent
    
    # If graphic is character
    if @tile_id == 0
      # Set rectangular transfer
      sx = @character.pattern * @cw
      sy = (@character.direction - 2) / 2 * @ch
      self.src_rect.set(sx, sy, @cw, @ch)
    end

    # Set sprite coordinates
    self.x = @character.screen_x
    self.y = @character.screen_y
    self.z = @character.screen_z(@ch)
    
    # Set opacity level, blend method, and bush depth
    self.opacity = @character.opacity
    self.blend_type = @character.blend_type
    self.bush_depth = @character.bush_depth
    
    # Animation
    # if @character.animation_id != 0
    #   animation = $data_animations[@character.animation_id]
    #   animation(animation, true)
    #   @character.animation_id = 0
    # end

  end
end
":#==============================================================================
# Game_Interface
#==============================================================================

class Game_Hud
  
  attr_accessor :message, :screen, :menu
  attr_accessor :trans
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize

    #@winder = Window_Item.new
    
      @screen = Ui_Screen.new
      @message = Ui_Message.new
      @menu = Ui_Menu.new
      @trans = Ui_Trans.new
        
  end
  
  #--------------------------------------------------------------------------
  # Good beans
  #--------------------------------------------------------------------------
  def busy?() 
    return false
    return if !@screen
    return true if @screen.busy? || 
                    @message.busy? ||
                    @menu.busy? ||
                    @trans.busy?
    return false
  end
  
  #--------------------------------------------------------------------------
  # Update
  #--------------------------------------------------------------------------  
  def update

    @screen.update
    @message.update
    @menu.update

    @trans.update
    
  end
  
end"##==============================================================================
# ** Spriteset_Map
#------------------------------------------------------------------------------
#  This class brings together map screen sprites, tilemaps, etc.
#  It's used within the Scene_Map class.
#==============================================================================

class Game_World
  
  # Screen attrs
  attr_reader   :tone                     # color tone
  attr_reader   :flash_color              # flash color
  attr_reader   :shake                    # shake positioning
  attr_reader   :weather_type             # weather type
  attr_reader   :weather_max              # max number of weather sprites
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    
    # INit screen
    
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @flash_color = Color.new(0, 0, 0, 0)
    @flash_duration = 0

    @shake_power = 0
    @shake_speed = 0
    @shake_duration = 0
    @shake_direction = 1
    @shake = 0
    
    # weather in map data
    @weather_type = 0
    @weather_max = 0.0
    @weather_type_target = 0
    @weather_max_target = 0.0
    @weather_duration = 0

    
    # Make viewports
    # agf - make viewport shorter to allow for HUD
    @viewport1 = Viewport.new(0, 0, 640, 448)
    @viewport2 = Viewport.new(0, 0, 640, 480)
    @viewport3 = Viewport.new(0, 0, 640, 480)
    @viewport2.z = 200
    @viewport3.z = 5000


    
    # Make tilemap
    @tilemap = Tilemap.new(@viewport1)

    # Make panorama plane
    @panorama = Plane.new(@viewport1)
    @panorama.z = -1000

    # Make fog plane
    @fog = Plane.new(@viewport1)
    @fog.z = 3000

  end

  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose
    # Dispose of tilemap
    @tilemap.tileset.dispose
    for i in 0..6
      @tilemap.autotiles[i].dispose
    end
    @tilemap.dispose
    @panorama.dispose
    @fog.dispose
    for sprite in @character_sprites
      sprite.dispose
    end
    @weather.dispose

    # Dispose of viewports
    @viewport1.dispose
    @viewport2.dispose
    @viewport3.dispose

  end

  def refresh_tileset
      @tilemap.tileset = RPG::Cache.tileset($map.tileset.tileset_name)
      @tilemap.priorities = $map.priorities
      for i in 0..6
        autotile_name = $map.tileset.autotile_names[i]
        @tilemap.autotiles[i] = RPG::Cache.autotile(autotile_name)
      end
      $map.new_tileset = false
      @tilemap.map_data = $map.data
      @tilemap.priorities = $map.priorities

      @character_sprites = []
    for i in $map.events.keys.sort
      sprite = Sprite_Character.new(@viewport1, $map.events[i])
      @character_sprites.push(sprite)
    end
    @character_sprites.push(Sprite_Character.new(@viewport1, $player))

  end

  def refresh_panorama
      @panorama_name = $map.panorama_name
      @panorama_hue = $map.panorama_hue
      if @panorama.bitmap != nil
        @panorama.bitmap.dispose
        @panorama.bitmap = nil
      end
      if @panorama_name != ""
        @panorama.bitmap = RPG::Cache.panorama(@panorama_name, @panorama_hue)
      end
      Graphics.frame_reset
  end


  def refresh_fog
      @fog_name = $map.fog_name
      @fog_hue = $map.fog_hue
      if @fog.bitmap != nil
        @fog.bitmap.dispose
        @fog.bitmap = nil
      end
      if @fog_name != ""
        @fog.bitmap = RPG::Cache.fog(@fog_name, @fog_hue)
      end
      Graphics.frame_reset
  end


  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    update_screen

    # if swapping tilesets
    if $map.new_tileset == true
      refresh_tileset
    end

    
    # If panorama is different from current one
    # if @panorama_name != $map.panorama_name or @panorama_hue != $map.panorama_hue
    #   refresh_panorama
    # end

    # # If fog is different than current fog
    # if @fog_name != $map.fog_name or @fog_hue != $map.fog_hue
    #   refresh_fog
    # end









    # Update tilemap
    @tilemap.ox = $map.display_x / 4
    @tilemap.oy = $map.display_y / 4
    @tilemap.update
    # Update panorama plane
    #@panorama.ox = 0 # $map.display_x / 8
    #@panorama.oy = 0 # $map.display_y / 8
    # Update fog plane
    # @fog.zoom_x = $map.fog_zoom / 100.0
    # @fog.zoom_y = $map.fog_zoom / 100.0
    # @fog.opacity = $map.fog_opacity
    # @fog.blend_type = $map.fog_blend_type
    # @fog.ox = $map.display_x / 4 + $map.fog_ox
    # @fog.oy = $map.display_y / 4 + $map.fog_oy
    # @fog.tone = $map.fog_tone
    # # Update character sprites
    for sprite in @character_sprites
      # only update if in range (anti-lag)
      sprite.update# if in_range?(sprite.character)
    end
    # Update weather graphic
    # @weather.type = $game_screen.weather_type
    # @weather.max = $game_screen.weather_max
    # @weather.ox = $map.display_x / 4
    # @weather.oy = $map.display_y / 4
    # @weather.update
    # Set screen color tone and shake position
    #@viewport1.tone = $game_screen.tone
    #@viewport1.ox = $game_screen.shake
    # Set screen flash color
    #@viewport3.color = $game_screen.flash_color
    # Update viewports
    @viewport1.update
    @viewport3.update

  end
  
  
  
  #--------------------------------------------------------------------------
  # * Start Changing Color Tone
  #     tone : color tone
  #     duration : time
  #--------------------------------------------------------------------------
  def start_tone_change(tone, duration)
    @tone_target = tone.clone
    @tone_duration = duration
    if @tone_duration == 0
      @tone = @tone_target.clone
    end
  end

  #--------------------------------------------------------------------------
  # * Start Flashing
  #     color : color
  #     duration : time
  #--------------------------------------------------------------------------
  def start_flash(color, duration)
    @flash_color = color.clone
    @flash_duration = duration
  end

  #--------------------------------------------------------------------------
  # * Start Shaking
  #--------------------------------------------------------------------------
  def start_shake(power, speed, duration)
    @shake_power = power
    @shake_speed = speed
    @shake_duration = duration
  end

  #--------------------------------------------------------------------------
  # * Set Weather
  #--------------------------------------------------------------------------
  def weather(type, power, duration)
    @weather_type_target = type
    if @weather_type_target != 0
      @weather_type = @weather_type_target
    end
    if @weather_type_target == 0
      @weather_max_target = 0.0
    else
      @weather_max_target = (power + 1) * 4.0
    end
    @weather_duration = duration
    if @weather_duration == 0
      @weather_type = @weather_type_target
      @weather_max = @weather_max_target
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update_screen
    if @tone_duration >= 1
      d = @tone_duration
      @tone.red = (@tone.red * (d - 1) + @tone_target.red) / d
      @tone.green = (@tone.green * (d - 1) + @tone_target.green) / d
      @tone.blue = (@tone.blue * (d - 1) + @tone_target.blue) / d
      @tone.gray = (@tone.gray * (d - 1) + @tone_target.gray) / d
      @tone_duration -= 1
    end
    if @flash_duration >= 1
      d = @flash_duration
      @flash_color.alpha = @flash_color.alpha * (d - 1) / d
      @flash_duration -= 1
    end
    if @shake_duration >= 1 or @shake != 0
      delta = (@shake_power * @shake_speed * @shake_direction) / 10.0
      if @shake_duration <= 1 and @shake * (@shake + delta) < 0
        @shake = 0
      else
        @shake += delta
      end
      if @shake > @shake_power * 2
        @shake_direction = -1
      end
      if @shake < - @shake_power * 2
        @shake_direction = 1
      end
      if @shake_duration >= 1
        @shake_duration -= 1
      end
    end
    if @weather_duration >= 1
      d = @weather_duration
      @weather_max = (@weather_max * (d - 1) + @weather_max_target) / d
      @weather_duration -= 1
      if @weather_duration == 0
        @weather_type = @weather_type_target
      end
    end
  end

end
"#==============================================================================
# Ui_Base
#==============================================================================

class Ui_Base
  
  #--------------------------------------------------------------------------
  # Everything
  #--------------------------------------------------------------------------
  def initialize(z) 
  	@all = [] 
  	#@viewport = Viewport.new()
  	#@viewport.z = z
  end  

  def add(elements) 
  	[*elements].each{ |e| @all.push(e) } 
  end

  def elements() 
  	return @all 
  end

  def clear() 
    @all.each{ |e| e.dispose  } 
    @all = []
  end  

  def hide() @all.each{ |e| e.hide } end
  def show() @all.each{ |e| e.show } end
  def update() end
  
end
"û#==============================================================================
# Ui_Menu
#==============================================================================

class Ui_Menu < Ui_Base
  
  def initialize
    super(1111)
  end

end"Á%#==============================================================================
# Ui_Message
#==============================================================================

class Ui_Message < Ui_Base

  # Consts
  MIN_WIDTH = 200
  MAX_WIDTH = 500
  TAB_WIDTH = 35

  SPACING = 5
  LINE_HEIGHT = 22

  SPEED_1 = 0
  SPEED_2 = 1
  SPEED_3 = 2
  SPEED_4 = 3
  SPEED_5 = 4
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize
    super(500)

    # Create the pieces but do nothing besides
    @state = :idle

    # Hold on to the convo
    @text = ""

    # This line data
    @name = ''

    @scratch = Bitmap.new(400,50)

    # Hold the textbox, 
    #@text_viewport

    @lines = []



    # Settings
    @font = nil
    @bold = true
    @italic = true
    @color = nil

    # Text display
    @text_delay = SPEED_3
    @wait_frames = 0
    @next_char = 0
    
    @line_idx = nil
    @word_idx = nil
    @char_idx = nil

    @width = 0
    @height = 0

    # Setup sprites
    @textbox = Sprite.new
    @namebox = Sprite.new

    @next = Sprite.new
    @face = Sprite.new

    @text_sprite = Sprite.new
    @word_sprite = Sprite.new    
    
  end
  
  #--------------------------------------------------------------------------
  # Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end      
    
    # Skip to end of this text
    if Input.trigger?(Input::C) && @state = :texting
      @skip_all = true
    end

    case @state

      when :closed
        #nothing

      when :opening
        @state = :texting if self.zoom_y == 1.0

      when :closing


      when :texting
        @next_char -= 1
        if @next_char <= 0
          update_message
        end
        
      when :waiting
        update_waiting

        # Choices in here too

      when :pausing
        check_input_next
      when :done
        check_input_done
        
    end

    # skipping
    while @state == :texting && @skip_all
      @next_char > 0 ? @next_char -= 1 : update_message
    end

  end
  
  #--------------------------------------------------------------------------
  # Show Convo
  #--------------------------------------------------------------------------
  def start(text, choices = nil)

    text_data = text.split(":")

    # Find speaker name, use to get face / event
    speaker = text_data[0]

    # Prepare the words to be written
    @lines = split_text(text_data[1])    

    # Now of the height? How many lines are there?
    @width = max_width
    @height = @lines.count * (LINE_HEIGHT)

    # Prepare the sprites
    @text_sprite.bitmap = Bitmap.new(@width,@height)

    @line_idx = -1
    @word_idx = -1

    @word_sprite.x = -1

    next_line
    next_word



    # Start text
    @state = :texting

        
  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    next_word if @char_idx == @word.length
        
    # if not texting then don't go
    return unless @state == :texting
            
    # Add the next character to the final word
    @char_idx += 1
    #@line_data[@line_data.size-1] += @word.slice!(0,1)
    
    # Redraw the word, last char small?
    redraw_word

    # Play a lovely character sound
    #sound(:text_char) if $settings.value('text_sound') 
    
    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    #(@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  def redraw_word
    @word_sprite.bitmap.clear
    txt = @word[0..@char_idx-1]
    size = @scratch.text_size(txt)
    @word_sprite.bitmap.draw_text(0,0,300,LINE_HEIGHT,txt)
    # Half draw the final
    @word_sprite.bitmap.draw_text(size.width,0,100,LINE_HEIGHT,@word[@char_idx])
  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    if @line_idx >= @lines.count
      @state = :done
    else
      @word_idx = -1
      @word_sprite.x = 0
      @word_sprite.y += LINE_HEIGHT
      next_word
    end
  end

    #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    # blit last word onto the main bmp


    @word_idx += 1
    @char_idx = 0
    
    if @word_idx >= @lines[@line_idx].count
      return next_line
    end

    @word = @lines[@line_idx][@word_idx]
    @wordlength = @word.length

    # CHECK FOR COMMANDS
    if @word[0]=='$'
      cmd = @word.split(".")
      wrd = cmd[0]

      # check for command words
      case wrd
      
        when "$n" # New line
          next_line
          
        when "$w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
                    
        when "$sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
          
        when "$fl"
          color = cmd.size > 1 ? Colors.get(cmd[1].to_sym) : Colors.get(:black)
          $world.do_flash(color,15)         
          
        when "$s" # play sound
          Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "$m"
          
          case cmd[1]
            when 'stop'
              @bkp = RPG::BGM.last
              Audio.bgm_stop            
            when 'fade'
              @bkp = RPG::BGM.last
              Audio.bgm_fade(750)          
            when 'resume'
              Audio.bgm_play("Audio/BGM/"+@bkp.name,@bkp.volume,@bkp.pitch,@bkp.pos)            
            else
              Audio.bgm_play("Audio/BGM/"+cmd[1])            
          end
          
        when "$nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "$end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      next_word

    end

  end  

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all #|| Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if Input.trigger?(Input::C)
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @next_sprite.hide
      
      @text_sprite.clear
    end
  end

  #--------------------------------------------------------------------------
  # Calculate size
  #--------------------------------------------------------------------------
  def word_width(word)
      return TAB_WIDTH if word == "$t"
      return 0 if word.include?("$")
      return @scratch.text_size(word).width
  end

  def max_width
    max = 0
    @lines.each{ |line|
      width = line.inject(0) { |t,w| t + word_width(w) }
      max = width if width > max
    }
    return max
  end

  def split_text(text)

    # Split all text into lines
    # Then calc widths and that

    total_width = text.split(" ").inject(0) { |t, w| t + word_width(w) }

    # use total width to split into lines

    # If there is a forced newline, there will be no autosizing
    if text.include?("$n")
      return text.split("$n").map { |i| i = i.split(" ") }  
    end

    # If less than split width, just one line
    if total_width < MIN_WIDTH
      reutrn [text.split(" ")]
    end

    # If width is less than max * 2, we are splitting at the first word after half point
    if total_width < MAX_WIDTH * 2
      limit = total_width / 2
      cursor = 0
      lines = [[]]
      text.split(" ").each{ |word|
        lines[-1].push(word)
        cursor += word_width(word)
        if cursor >= limit
          lines.push([])
          cursor = 0
        end
      }
      return lines
    end

    # Else we are autosizing max width
    lines = [[]]
    limit = MAX_WIDTH
    cursor = 0
    text.split(" ").each{ |word|
      cursor += word_width(word)
      if cursor > limit
        cursor = 0
        lines.push([])
      end
      lines[-1].push(word)
    }
    return lines

  end

  #--------------------------------------------------------------------------
  # Misc
  #--------------------------------------------------------------------------
  def clear() end
  def busy?() return @state != :idle end

end"!#==============================================================================
# Ui_Screen
#==============================================================================

class Ui_Screen < Ui_Base
  
	def initialize
		super(1111)
	end


    def busy?() return false end

end" #==============================================================================
# Ui_Trans
#==============================================================================

class Ui_Trans < Ui_Base

	def initialize
		super(1111)
	end

    def busy?() return false end
    	
end