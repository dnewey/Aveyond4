[T"å#==============================================================================
# ** Game
#==============================================================================

APPFOLDER = "Aveyond 4"

def aveyond4

    # User Data folder
    Win32API.new('System/Utils', "AVSetEnv", ["V"], "I").call          
    $appdata = ENV['AV_APPDATA'] + "\\" + APPFOLDER
    Dir.mkdir($appdata) if !File.exists?($appdata) 

    # Who will debug the debug?
    begin
      $debug = DebugManager.new
    rescue StandardError => e
      p e.inspect
    end

    $audio = AudioManager.new
    $keyboard = KeyboardManager.new
    $mouse = MouseManager.new
    $input = InputManager.new
    $data = DataManager.new
    $tweens = TweenManager.new
    $settings = SettingsManager.new
    $files = FileManager.new
    $battle = Game_Battle.new
    $game = GameManager.new  

    # Call main method as long as $scene is effective      
    $game.update until $game.quit?
    
    # Set the windowed mode for next time
    $settings.conclude

rescue StandardError => e
    
  line = e.message.split(":")[1].to_i      
  log_err e.inspect
  log_err "------------------"
  
  e.backtrace.each{ |location|
    line_num = location.split(":")[1]
    script_name = location.split(":")[0].split("/").last

    if location.include?("Section")
      section = location[/(?#Section)(\d)*(:)/]
      section_err = section[0, section.length - 1]
      script_name = $RGSS_SCRIPTS[section_err.to_i][1]
    end

    method = location.split(":")[2]
    next if method == nil
    loc_err = "Line " + line_num + ", in "+script_name+ ", "+method.to_s
    loc_err = "Game Start" if script_name.include?("{0128")
    log_err("#{loc_err}")
  } 
  
end"Ï#==============================================================================
# ** Sprite_Character
#------------------------------------------------------------------------------
#  This sprite is used to display the character.It observes the Game_Character
#  class and automatically changes sprite conditions.
#==============================================================================

class Sprite_Character < Sprite

  attr_accessor :character     

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     viewport  : viewport
  #     character : character (Game_Character)
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @character = character
    update
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # If tile ID, file name, or hue are different from current ones
    if @character_name != @character.character_name
     
      @character_name = @character.character_name

        self.bitmap = Cache.character(@character.character_name,0)
        if @character == $player
          self.bitmap = Cache.character("Player/boy",0)
        end
        @cw = bitmap.width / 4
        @ch = bitmap.height / 4
        self.ox = @cw / 2
        self.oy = @ch

      end


    # Set visible situation
    self.visible = !@character.transparent
    
    sx = @character.pattern * @cw
    sy = (@character.direction - 2) / 2 * @ch
    self.src_rect.set(sx, sy, @cw, @ch)


    # Set sprite coordinates
    self.x = @character.screen_x
    self.y = @character.screen_y
    self.z = @character.screen_z(@ch)
    
    # Set opacity level, blend method, and bush depth
    self.opacity = @character.opacity
    self.bush_depth = @character.bush_depth
    
    # Animation
    # if @character.animation_id != 0
    #   animation = $data_animations[@character.animation_id]
    #   animation(animation, true)
    #   @character.animation_id = 0
    # end

  end
end
"x


class MapWrap < Tilemap

	def refresh(map)
      self.tileset = Cache.tileset(map.tileset.tileset_name)#+'-big')
      i = 0 
      map.tileset.autotile_names.each{ |a|
        next if a == ''
        self.autotiles[i] = Cache.autotile(a)#+'-big')
        i+=1
      }
      self.map_data = map.data
      self.priorities = map.tileset.priorities
	end

end"A


# Other things of this nature will reside within thine"!*# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # RGSS3 Plane v1.3.5
# # FenixFyreX
# # Thanks to boldpaste2 for debugging help!
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # This is a rewrite of RGSS3's Plane class, mainly for use with custom resolution
# # alterations of RPG Maker VXAce. This allows Plane to function properly on
# # larger resolutions than the hard-coded 640px x 480px in the dll.
# #
# # It also correctly displays ox and oy offset and such, just like the original.
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # CHANGELOG
# # v1.3.5
# #   - Fixed cache not updating disposed plane bitmaps.
# # v1.3.4
# #   - Fixed memory leak.
# # v1.3.3
# #   - Added in check for disposed or nil bitmap, fixing compatibility with fogs.
# # v1.3.2
# #   - Added in checks for already disposed planes, raising an RGSSError like the
# #     original.
# # v1.3.1
# #   - Fixed potential game crash due to undisposed sprites.
# # v1.2.x
# #   - Added in caching of plane bitmaps, to stop the lag from persisting.
# #   - Fixed potential bug where when the viewport was set, the bitmap would
# #     retile incorrectly.
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # To remove any artifacts / conflicts with the original, we alias it then remove
# # the original tie.
# # RGSS3Plane = Plane
# # Object.send(:remove_const, :Plane)

# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # Rect#to_a
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# class Rect
#   def to_a
#     [self.x, self.y, self.width, self.height]
#   end
# end
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # Bitmap
# #   Saves a bitmap's name, for future reference.
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# class Bitmap
#   alias fyx_initialize_save_name initialize
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # initialize
#   #   Instantiate a bitmap's name, if given one.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def initialize(*argv, &argb)
#     @name = ''
#     if name = argv.find {|arg| arg.is_a?(String) }
#       @name = name
#     end
#     fyx_initialize_save_name(*argv, &argb)
#   end
#   attr_reader :name
# end
 
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # Cache
# #   Add in Plane caching, to speed up processing at the slight cost of memory.
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# module Cache
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # Cache::plane_cache
#   #   Convenience method, to not have to type it out in the below methods.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def self.plane_cache
#     @plane_cache ||= {}
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # Cache::plane
#   #   Get a cached plane bitmap.
#   #   key : Object  ( most likely an Array e.g. [Rect, String] )
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def self.plane(key)
#     return plane_cache[key]
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # Cache::add_plane
#   #   Add a tiled plane bitmap to the cache.
#   #   key : Object ( see above )
#   #   bmp : Bitmap
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def self.add_plane(key, bmp)
#     plane_cache[key] = bmp
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # Cache::has_plane?
#   #   Check for a cached plane bitmap.
#   #   key : Object ( see above )
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def self.has_plane?(key)
#     plane_cache[key].is_a?(Bitmap) && !plane_cache[key].disposed?
#   end
 
#   class << self; alias clear_b4_fyx_plane_cache clear; end
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # Cache::clear
#   #   See original documentation.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def self.clear
#     plane_cache.each_value {|v| v.dispose unless v.nil? || v.disposed? }
#     plane_cache.clear
#     clear_b4_fyx_plane_cache
#   end
# end
 
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # Plane
# #   Tiles a bitmap across either the window rect, or a given viewport's rect.
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# class Plane2
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # initialize
#   #   Setup an allocated instance of Plane.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def initialize(v = nil, z = nil)
#     @sprite = Sprite.new(v)
#     @sprite.z = z
#     @bitmap = nil
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # dispose
#   #   Free an instance of Plane.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def dispose
#     @sprite.bitmap.dispose unless bitmap_disposed?
#     @sprite.dispose unless disposed?
#     return nil
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # bitmap_disposed?
#   #   Check whether this instance of Plane's bitmap has been freed.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def bitmap_disposed?
#     disposed? || @sprite.bitmap.nil? || @sprite.bitmap.disposed?
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # disposed?
#   #   Check whether this instance of Plane has been freed.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def disposed?
#     @sprite.nil? || @sprite.disposed?
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # ox=
#   #   Set the offset x of this instance of Plane.
#   #   val : Integer
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def ox=(val)
#     error_disposed if disposed?
#     return if bitmap_disposed?
   
#     @sprite.ox = (val % (@bitmap.nil? ? 1 : @bitmap.width))
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # oy=
#   #   Set the offset y of this instance of Plane.
#   #   val : Integer
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def oy=(val)
#     error_disposed if disposed?
#     return if bitmap_disposed?
   
#     @sprite.oy = (val % (@bitmap.nil? ? 1 : @bitmap.height))
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # bitmap
#   #   Get the tile bitmap of this instance of Plane.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def bitmap
#     @bitmap
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # viewport=
#   #   Set the viewport, and refresh if the vrect has changed.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def viewport=(v)
#     error_disposed if disposed?
#     r = v.nil? ? Rect.new(0, 0, Graphics.width, Graphics.height) : v.rect
#     b = r != vrect
#     ret = @sprite.viewport = v
#     self.bitmap = @bitmap if b
#     return ret
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # bitmap=
#   #   Set the tile bitmap of this instance of Plane.
#   #   bmp : Bitmap
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def bitmap=(bmp)
#     error_disposed if disposed?
#     if bmp.nil?
#       @sprite.bitmap = nil
#       return @bitmap = nil
#     end
   
#     w, h = vrect.width, vrect.height
   
#     nw = bmp.width <= 100 ? 2 : 3
#     nh = bmp.height <= 100 ? 2 : 3
   
#     dx = [(w / bmp.width).ceil, 1].max * nw
#     dy = [(h / bmp.height).ceil, 1].max * nh
 
#     bw = dx * bmp.width
#     bh = dy * bmp.height
 
#     @bitmap = bmp
#     key = [vrect.to_a, bmp.name]
#     if Cache.has_plane?(key)
#       @sprite.bitmap = Cache.plane(key)
#     else
#       @sprite.bitmap = Bitmap.new(bw, bh)
     
#       dx.times do |x|
#         dy.times do |y|
#           @sprite.bitmap.blt(x * bmp.width, y * bmp.height, @bitmap, @bitmap.rect)
#         end
#       end
#       Cache.add_plane(key, @sprite.bitmap)
#     end
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # method_missing
#   #   Here we let any methods not found in this class be redirected to our
#   #   underlying sprite.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def method_missing(sym, *argv, &argb)
#     if @sprite.respond_to?(sym)
#       error_disposed if disposed?
#       return @sprite.send(sym, *argv, &argb)
#     end
#     super(sym, *argv, &argb)
#   end
 
#   # private methods from here down
#   private
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # error_disposed
#   #   If this plane (and it's underlying sprite) has been freed, then throw an
#         #   RGSSError describing a disposed Plane.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def error_disposed
#     raise RGSSError, 'disposed Plane', caller
#   end
 
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   # vrect
#   #   Get the view rect of this instance of Plane, which depends on if the
#   #   viewport has been set or not.
#   #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#   def vrect
#     @sprite.viewport.nil? ? Rect.new(0, 0, Graphics.width, Graphics.height) :
#     @sprite.viewport.rect
#   end
# end
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# # SCRIPT END
# #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"­#==============================================================================
# Tilemap Class
#------------------------------------------------------------------------------
# Script by SephirothSpawn
#==============================================================================

class Tilemap2
  #--------------------------------------------------------------------------
  Animated_Autotiles_Frames = 60
  #--------------------------------------------------------------------------
  Autotiles = [
    [ [27, 28, 33, 34], [ 5, 28, 33, 34], [27,  6, 33, 34], [ 5,  6, 33, 34],
      [27, 28, 33, 12], [ 5, 28, 33, 12], [27,  6, 33, 12], [ 5,  6, 33, 12] ],
    [ [27, 28, 11, 34], [ 5, 28, 11, 34], [27,  6, 11, 34], [ 5,  6, 11, 34],
      [27, 28, 11, 12], [ 5, 28, 11, 12], [27,  6, 11, 12], [ 5,  6, 11, 12] ],
    [ [25, 26, 31, 32], [25,  6, 31, 32], [25, 26, 31, 12], [25,  6, 31, 12],
      [15, 16, 21, 22], [15, 16, 21, 12], [15, 16, 11, 22], [15, 16, 11, 12] ],
    [ [29, 30, 35, 36], [29, 30, 11, 36], [ 5, 30, 35, 36], [ 5, 30, 11, 36],
      [39, 40, 45, 46], [ 5, 40, 45, 46], [39,  6, 45, 46], [ 5,  6, 45, 46] ],
    [ [25, 30, 31, 36], [15, 16, 45, 46], [13, 14, 19, 20], [13, 14, 19, 12],
      [17, 18, 23, 24], [17, 18, 11, 24], [41, 42, 47, 48], [ 5, 42, 47, 48] ],
    [ [37, 38, 43, 44], [37,  6, 43, 44], [13, 18, 19, 24], [13, 14, 43, 44],
      [37, 42, 43, 48], [17, 18, 47, 48], [13, 18, 43, 48], [ 1,  2,  7,  8] ]
  ]
  #--------------------------------------------------------------------------
  attr_reader   :layers
  attr_accessor :tileset
  attr_accessor :autotiles
  attr_accessor :map_data
  attr_accessor :priorities
  attr_accessor :visible
  attr_accessor :ox
  attr_accessor :oy
  #--------------------------------------------------------------------------
  def initialize(viewport, map = $map.map)

    @tile_width  = 32
    @tile_height = 32

    @nxu = 30
    @animo = 0


    @layers = []
    for l in 0...3
      layer = Sprite.new(viewport)
      layer.bitmap = Bitmap.new($map.width * @tile_width, $map.height * @tile_height)
      layer.z = l * 150
      @layers.push(layer)
    end
    @tileset    = nil  # Refers to Map Tileset PNG
    @autotiles  = []   # Refers to Tileset Auto-Tiles (Actual Auto-Tiles)

    @map_data   = nil  # Refers to 3D Array Of Tile Settings

    @priorities = nil  # Refers to Tileset Priorities
    @visible    = true # Refers to Tilest Visibleness
    
    @ox         = 0    # Bitmap Offsets
    @oy         = 0    # bitmap Offsets
    @data       = nil  # Acts As Refresh Flag
    @map         = map

  end
  
  #--------------------------------------------------------------------------
  def dispose
    @tileset.dispose
    @autotiles.each{ |a| a.dispose }    
    @layers.each{ |l| l.dispose }
  end

  def refresh_tileset(map)
      @tileset = Cache.tileset(map.tileset.tileset_name)#+'-big')
      i = 0 
      map.tileset.autotile_names.each{ |a|
        next if a == ''
        @autotiles[i] = Cache.autotile(a)#+'-big')
        i+=1
      }
      @map_data = map.data
      @priorities = map.tileset.priorities
  end

  #--------------------------------------------------------------------------
  def update
    #unless @data == @map_data #&& @tile_width == $map.tilemap_tile_width &&
           #@tile_height == $map.tilemap_tile_height
           refresh
    #end
    for layer in @layers
      layer.ox = @ox
      layer.oy = @oy
    end
    @nxu -= 1
    if @nxu ==0
      @animo+=1
      @anmio = 0 if @animo > 2
    @nxu = 10
    #  refresh
      #refresh_autotiles # Cache the frames or something
    end
  end
  
  def refresh
    @data = @map_data
    for p in 0..5
    p = 0
      for z in 0...@map_data.zsize
        for x in $player.x-5...$player.x+5
          for y in $player.y-5...$player.y+5
            id = @map_data[x, y, z]
            next if id == 0
            next unless p == @priorities[id]
            p = 2 if p > 2
            id < 384 ? draw_autotile(x, y, p, id) : draw_tile(x, y, p, id)
          end
        end
      end
    end
  end





  #--------------------------------------------------------------------------
  def refreshXXX
    @data = @map_data
    for p in 0..5
      for z in 0...@map_data.zsize
        for x in 0...@map_data.xsize
          for y in 0...@map_data.ysize
            id = @map_data[x, y, z]
            next if id == 0
            next unless p == @priorities[id]
            p = 2 if p > 2
            id < 384 ? draw_autotile(x, y, p, id) : draw_tile(x, y, p, id)
          end
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  def refresh_autotiles

    autotile_locations = Table.new(@map_data.xsize, @map_data.ysize,
      @map_data.zsize)
    for p in 0..5
      for z in 0...@map_data.zsize
        for x in 0...@map_data.xsize
          for y in 0...@map_data.ysize
            id = @map_data[x, y, z]
            next if id == 0
            next unless p == @priorities[id]
            p = 2 if p > 2
            if id < 384
              #next if @autotiles[id / 48 - 1] == nil
              next unless @autotiles[id / 48 - 1].width / 96 > 1
              draw_autotile(x, y, p, id)
              autotile_locations[x, y, z] = 1
            else
              if autotile_locations[x, y, z] == 1
                draw_tile(x, y, p, id)
              end
            end
          end
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  def draw_tile(x, y, z, id)
    rect = Rect.new((id - 384) % 8 * @tile_width, (id - 384) / 8 * @tile_height, @tile_width, @tile_height)
    x *= @tile_width
    y *= @tile_height
    @layers[z].bitmap.blt(x, y, @tileset, rect)
  end
  #--------------------------------------------------------------------------
  def draw_autotile(x, y, z, tile_id)
    autotile = @autotiles[tile_id / 48 - 1]
    return if autotile == nil
    tile_id %= 48
    bitmap = Bitmap.new(@tile_width, @tile_height)
    tiles = Autotiles[tile_id / 8][tile_id % 8]
    frames = autotile.width / @tile_width*3
    anim = @animo*96#(Graphics.frame_count / Animated_Autotiles_Frames) % frames * (@tile_width*3)

    hw = @tile_width/2
    hh = @tile_height/2

    for i in 0...4
      tile_position = tiles[i] - 1
      src_rect = Rect.new(tile_position % 6 * hw + anim,
        tile_position / 6 * hh, hw, hh)
      bitmap.blt(i % 2 * hw, i / 2 * hh, autotile, src_rect)
    end
    x *= @tile_width
    y *= @tile_height
    @layers[z].bitmap.blt(x, y, bitmap, Rect.new(0, 0, @tile_width, @tile_height))
  end
end"½'#==============================================================================
# Extended Sprite Class
#==============================================================================

class Widget < Sprite
    
  attr_accessor :width, :height, :parent, :active
  
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize()
    super()
    
    @width = 150
    @height = 100

    @parent = nil

    @dead = false

    @active = false

    @link_target = nil
    @link_ox = 0
    @link_oy = 0

  end

  def create
    # TO OVERWRITE!!!!!!!!
  end

  def activate
    @active = true
  end

  def deactivate
    @active = false
  end

  def resize(w,h)
    @width = w
    @height = h
  end

  def link(target,ox,oy)
    @link_target = target
    @link_ox = ox
    @link_oy = oy
  end

  def autosize
    self.width = self.bitmap.width
    self.height = self.bitmap.height
  end

  def snap_bottom
    self.y = 416 - self.height
  end

  def update
    super
    if @link_target != nil
      self.x = @link_target.x + @link_ox
      self.y = @link_target.y + @link_oy
    end
  end


  def inside?(pos)
    return false if pos[0] < self.x
    return false if pos[1] < self.y
    return false if pos[0] > self.x + self.width
    return false if pos[1] > self.y + self.height
    return true
  end

  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------

  # visible or not
  def hide() self.visible = false end
  def show() self.visible = true end
    
  #--------------------------------------------------------------------------
  # * Ready to remove
  #--------------------------------------------------------------------------
  def kill() @dead = true end
  def dead?() return @dead end

    #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def from_menu(src) self.bitmap = Cache.menu(src) end
  def from_menu_frame(src,frame) self.bitmap = Cache.menu_frame(src,frame) end
  def from_bitmap(bmp) self.bitmap = bmp end  
  def from_icon(idx,double=false) self.bitmap = Cache.icon(idx,double) end  
  def from_stroke_icon(idx,double=false) self.bitmap = Cache.stroke_icon(idx,double) end
    
  # Stretch out
  def from_menu_stretch(src,width,height)
    self.bitmap = Bitmap.new(width,height)
    img = Cache.menu(src)
    self.bitmap.stretch_blt(Rect.new(0,0,width,height),img,img.rect)
  end
  
  def from_skin(src,shadow=5)

    #    shadow = self.get_skin('skin-shadow')
    #white = self.get_skin('skin-white')

    #self.bitmap = Bitmap.new(self.width + 5,self.height+5)
    #self.bitmap.blt(5,5,shadow,shadow.rect,120)
    #self.bitmap.blt(0,0,white,white.rect)

    width = @width
    height = @height

    self.bitmap = Bitmap.new(width+shadow,height+shadow)
    src = Cache.menu(src)

    ssrc = Cache.menu('skin-shadow')

    w = src.width/3
    h = src.height/3

    sx = 0
    sy = 0
    o = 140


    # shadowwwwwww
    self.bitmap.blt(0+shadow,height-h+shadow,ssrc,Rect.new(sx,sy+40,w,h),o) # bottom left
    self.bitmap.blt(width-w+shadow,0+shadow,ssrc,Rect.new(sx+40,sy,w,h),o) # top right
    self.bitmap.blt(width-w+shadow,height-h+shadow,ssrc,Rect.new(sx+40,sy+40,w,h),o) # bottom right
     self.bitmap.stretch_blt(Rect.new(width-w+shadow,h+shadow,w,height-40),ssrc,Rect.new(w*2,h,w,h),o)
    self.bitmap.stretch_blt(Rect.new(w+shadow,height-h+shadow,width-40,h),ssrc,Rect.new(w,h*2,w,h),o)

  o = 255

    # CORNERS
    self.bitmap.blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
    self.bitmap.blt(width-w,0,src,Rect.new(sx+40,sy,w,h),o) # top right
    self.bitmap.blt(0,height-h,src,Rect.new(sx,sy+40,w,h),o) # bottom left
    self.bitmap.blt(width-w,height-h,src,Rect.new(sx+40,sy+40,w,h),o) # bottom right
    
    #dest_rect, bmp, src_rect

    # Middle
    self.bitmap.stretch_blt(Rect.new(w,h,width-40,height-40),src,Rect.new(w,h,w,h),o)

    # left side
    self.bitmap.stretch_blt(Rect.new(0,h,w,height-40),src,Rect.new(0,h,w,h),o)

    # Right
    self.bitmap.stretch_blt(Rect.new(width-w,h,w,height-40),src,Rect.new(w*2,h,w,h),o)

    #top
    self.bitmap.stretch_blt(Rect.new(w,0,width-40,h),src,Rect.new(w,0,w,h),o)

   #bottom
    self.bitmap.stretch_blt(Rect.new(w,height-h,width-40,h),src,Rect.new(w,h*2,w,h),o)


    #self.bitmap.stretch_blt(Rect.new(0,w,width,height-40),src,Rect.new(sx+w,sy+h,w,h),o)
    #self.bitmap.stretch_blt(Rect.new(w,0,width-40,h),src,Rect.new(sx+w,sy+h,w,h),o)
    #self.bitmap.stretch_blt(Rect.new(w,height-h,width-40,h),src,Rect.new(sx+w,sy+h,w,h),o)
    
  end

  # Character img
  def from_char(img,idx,dir,zoom=1.0,p=1)
    #p img,idx
    zoom = 2.0 if zoom == true
    zoom = 1.0 if zoom == false
    self.bitmap = Cache.char_frame(img,idx,dir,zoom,p)
  end
  
  def from_spr(src)

    dir = 2
    
    if src.bitmap.width < 100
      cw = src.bitmap.width / 3
      ch = src.bitmap.height / 4
    else
      cw = src.bitmap.width / 12
      ch = src.bitmap.height / 8
    end
    #n = idx
    n = src.character.character_index
    p=1
    src_rect = Rect.new((n%4*3+p)*cw, (n/4*4+((dir/2)-1))*ch, cw, ch)
    #if double
      dest_rect = Rect.new(0,0,cw*2,ch*2)
    #else
    #  dest_rect = Rect.new(0,0,cw,ch)
   #end
    bmp = Bitmap.new(dest_rect.width,dest_rect.height)
    bmp.stretch_blt(dest_rect,src.bitmap,src_rect)
        
    self.bitmap = bmp
    #self.src_rect = src.src_rect
  end
  
  # Color box
  def from_color(c)
    self.bitmap = Bitmap.new(self.width,self.height)
    self.bitmap.fill_rect(0,0,self.width,self.height,c)
  end  
  
  # From numbers for bottom bar etc
  def from_numbers(num,color,percent=false)
    
    # Auto coloring depending on number out of 100
    if color == :auto
      
      color = :red
      color = :orange if num > 20
      color = :yellow if num > 40
      color = :green if num > 60
      
    end
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('Bar/numbers.12.7')
    cw = src.width/12
    ch = src.height/7

    # Colors
    colors = [:red,:blue,:yellow,:green,:white,:purple,:orange]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.45

    }
    if percent
      
      c+=cw*0.2
      n=10
      s = n * cw
      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      
    end
    
    
    self.bitmap = bmp
    
  end
  
  def from_numbers_right(num,color,percent=false)
    
    # Auto coloring depending on number out of 100
    if color == :auto
      
      color = :red
      color = :orange if num > 20
      color = :yellow if num > 40
      color = :green if num > 60
      
    end
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('Bar/numbers.12.7')
    cw = src.width/12
    ch = src.height/7

    # Colors
    colors = [:red,:blue,:yellow,:green,:white,:purple,:orange]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.45

    }    
    
    #copy to new bitmap
    c+=8
    final = Bitmap.new(c,ch)
    final.blt(0,0,bmp,bmp.rect)
    
    self.bitmap = final
    
  end
  
  # From Big Numbers
  def from_big_numbers(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.menu('level_nums.10.1')
    cw = src.width/10
    ch = src.height
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+10,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,0,cw,ch))
      c += cw*0.8

    }  
    
    self.bitmap = bmp
    
  end
  
    # From numbers for bottom bar etc
  def from_meganums(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    
    
    # prepare the final image
    width = 0
    nums.each{ |n| 
      width += 50 if n == 1
      width+=100 if n != 1
    }
    bmp = Bitmap.new(width,117)
    c = 0

    nums.each{ |n|

      src = Cache.menu('Lvls/'+n.to_s)
      bmp.blt(c,0,src,src.rect)
      c += src.width

    }   
    
    self.bitmap = bmp
    
  end
  
  def from_pop35(num)
    
    # prepare number data
    anums = num.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }
    
    size = 35
    color = :white

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    if nums.size == 1
      width = cw
    else
      width = nums.size * cw*0.78
    end
    #nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.7

    }
    
    self.bitmap=bmp
    
  end
  
  
end
"d	#==============================================================================
# Button
#==============================================================================

class Button < Sprite
  
  # accessors
  attr_accessor :select, :deselect, :press
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
       
    super(vp)

    # handle mouseovers and that and procs and that
    @select = nil#Proc.new{ self.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = nil#Proc.new{ $tweens.clear(self); self.x = 22; $tweens.clear(self) }
    @press = nil#Proc.new{self.do(pingpong("y",-30,300,:quad_in_out));}

    @state = :idle # :over
    
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    # Check inputs if active?
    if @state == :idle
      #if Input.method == :mouse
        check_hover($mouse.position)
      #end
      # check mouse hover?
    end

    if @state == :active
      check_nhover($mouse.position)
      if @state == :active
        if $input.click?
          @press.call()
        end
      end
    end

    if @state == :active
      # check key presses to change to another
      #if Input.trigger?(Input.right)
        # check hover of all neighbours
      #  self.viewport.sprites.each{ |s| s.check_hover(x+100)}
      #end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x
    return if pos[1] < self.y
    return if pos[0] > self.x + self.width
    return if pos[1] > self.y + self.height
    @state = :active
    @select.call() if @select
    log_info("PROC")
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x
    w = true if pos[1] < self.y
    w = true if pos[0] > self.x + self.width
    w = true if pos[1] > self.y + self.height
    return if w == false
    @state = :idle
    @deselect.call() if @select
    log_info("UNPROC")
  end

end"A#==============================================================================
# The magical list
#==============================================================================

# Draw item depends on type, ItemData, WeaponData etc
# All action external to the list

# Scrollbar is part of list?
# Made up of multiple sprites

# All items are predrawn to sprites, for scrollings?
# But what of a really big list?

# Ok hmmmm, draw the sprites when wanted

class List
      
  attr_accessor :x, :y

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)

  	@parent = nil

  	@x = 0
  	@y = 0

  	@data = []

  	@scroll_idx = 0
  	@page_idx = 0

  	@per_page = 7

  	# Sprites
  	@sprites = []
  	@per_page.times{ |i|
  		@sprites.push(Sprite.new(vp))
  	}
  	@dynamo = Sprite.new(vp)

  	@scroll_base = Sprite.new(vp)
  	@scroll_up = Button.new(vp)
  	@scroll_down = Button.new(vp)
  	@scroll_btn = Sprite.new(vp)

  end

  def dispose
  	@sprites.each{ |s| s.dispose }
  	@dynamo.dispose
  	@scroll_base.dispose
  	@scroll_up.dispose
  	@scroll_down.dispose
  	@scroll_btn.dispose
  end

  def setup(data)
  	@data = data
  	refresh
  end

  def refresh

  	# Rebuild the items from data
  	cy = @y

  	(0..@per_page-1).each{ |i|
  		draw_item(@data[i+@scroll_idx],@sprites[i],i==@page_idx)
  		@sprites[i].y = cy
  		@sprites[i].x = @x
      @sprites[i].opacity = 255
  		cy += @sprites[i].bitmap.height
  	}

  	@cybt = cy

  	# The scrollbar
  	@scroll_base.bitmap = Bitmap.new(14,300)
  	@scroll_base.bitmap.vert(Cache.menu("scrollbar"))

  	@scroll_up.bitmap = Cache.menu("scrollup")
  	@scroll_down.bitmap = Cache.menu("scrolldown")

    @scroll_up.press = Proc.new{ 

    if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx -= 1; self.refresh; self.scroll_down }
    @scroll_down.press = Proc.new{ 
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
      @page_idx += 1;self.refresh; self.scroll_up 
    }

  	@scroll_btn.bitmap = Cache.menu("scrollbtn")

  	# POSITION THOSE ^^^^^^^^^

        @scroll_base.x = @x - 20
    @scroll_base.y = @y + 10

        @scroll_up.x = @x-30
    @scroll_up.y = @y - 15

        @scroll_down.x = @x-30
    @scroll_down.y = @y +300

  	# Show selected, a sprite behind hmmmm, 

  end

  def draw_item(data,sprite,on)

  	# DataBox atm
  	sprite.bitmap = Bitmap.new(300,30)
  	sprite.bitmap.fill(Color.new(123,123,219)) if on
  	sprite.bitmap.draw_text(0,0,300,30,data.name)

  end

  def update

    @scroll_up.update
    @scroll_down.update

  	# Check inputs and that
  	if $keyboard.press?(VK_DOWN) #&& @dynamo.done?
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx += 1
  		if @page_idx > 3
        refresh
  			scroll_up
  		else
  		  refresh
      end
  	end

  	if $keyboard.press?(VK_UP) #&& @dynamo.done?
      if !@dynamo.done?
        refresh
        @page_idx += @pagemod
        @dynamo.opacity = 0
        $tweens.clear_all
      end
  		@page_idx -= 1 if @page_idx > 0
  		if @page_idx < 3 && @scroll_idx > 0
        refresh
  			scroll_down
  		else
  		  refresh
      end
  	end

    pos = $mouse.position

    # Check mouseover
    @sprites.each_index{ |i|
      next if pos[0] < @sprites[i].x
      next if pos[1] < @sprites[i].y
      next if pos[0] > @sprites[i].x + @sprites[i].width
      next if pos[1] > @sprites[i].y + @sprites[i].height
      @page_idx = i
      refresh
      break
    }

  end

  def scroll_down

    @scroll_idx -= 1    
          @pagemod = 1

    # Create the dynamo
    @dynamo.y = @y - 30
    @dynamo.x = @x
    @dynamo.opacity = 0

    dur = 200
    ease = :quad_in_out

    draw_item(@data[@scroll_idx],@dynamo,@page_idx == -1)

    @dynamo.do(go("y",30,dur,ease))
    @dynamo.do(go("opacity",255,dur,ease))

    @dynamo.do(proc(Proc.new{
      @page_idx += 1

      self.refresh
      @dynamo.opacity = 0
    },dur+30))

    @sprites.each{ |s|
      s.do(go("y",30,dur,ease))
    }

    @sprites[-1].do(go("opacity",-255,dur,ease))

  end

  def scroll_up

    @scroll_idx += 1    
          @pagemod = -1

  	# Create the dynamo
  	@dynamo.y = @cybt
  	@dynamo.x = @x
  	@dynamo.opacity = 0

    dur = 200
    ease = :quad_in_out

  	draw_item(@data[@scroll_idx + @per_page - 1],@dynamo,@page_idx == @per_page)

  	@dynamo.do(go("y",-30,dur,ease))
  	@dynamo.do(go("opacity",255,dur,ease))



  	@dynamo.do(proc(Proc.new{

      @page_idx -= 1
      self.refresh
      @dynamo.opacity = 0
    },dur+30))

  	@sprites.each{ |s|
  		s.do(go("y",-30,dur,ease))
  	}

  	@sprites[0].do(go("opacity",-255,dur,ease))

  end

 end"#==============================================================================
# Tabs
#==============================================================================

# Horizontal list of sorts
# Image based only
# Drawn to single sprite

class Tabs < Sprite

  SPACING = 5

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

  	#@parent = nil
    @names = []
  	@gfx = []

    @ranges = []

  	@tab_idx = 0

  end

  def push(name,gfx)
    @names.push(name)
    @gfx.push(Cache.menu(gfx))
    refresh
  end

  def dispose
  	
  end

  def refresh

    # Calc width
    width = @gfx.inject(0){ |t,b| t += b.width + SPACING } - SPACING
    height = @gfx[0].height#@gfx.max_by{ |b| b.height }

    self.bitmap = Bitmap.new(width,height)

    # Draw the tabs
    cx = 0
    @gfx.each{ |b|
      self.bitmap.blt(cx,0,b,b.rect)
      cx += b.width + SPACING
    }

  end

  def update

  	# Check inputs and that
  	if $keyboard.press?(VK_RIGHT)
      @idx += 1
      refresh      
  	end

  	if $keyboard.press?(VK_LEFT) #&& @dynamo.done?
      @idx -= 1
      refresh  
  	end

    pos = $mouse.position

    # Check mouseover
    # @sprites.each_index{ |i|
      
    # }

  end

 end"#==============================================================================
# Widget_Bugbox
#==============================================================================

class Widget_Bugbox < Widget

  attr_accessor :name
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @name = "Bugbox"
    @color = Color.new(255,255,255)
    
    refresh

  end
      
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    self.bitmap = Bitmap.new(self.width,self.height)
    self.bitmap.fill_rect(0,0,self.width,self.height,Color.random)

    txt = self.x.to_s + ", " + self.y.to_s + ", "
    txt += self.width.to_s + ", " + self.height.to_s

    self.bitmap.font.size = 18
    self.bitmap.draw_text(5,5,self.width,20,@name+" "+txt)
    
  end
  
end"M	#==============================================================================
# Widget_Button
#==============================================================================

class Widget_Button < Widget
  
  # accessors
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize()
       
    super()

    # handle mouseovers and that and procs and that
    @select = Proc.new{ @btn.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = Proc.new{ $machine.clear(@btn); @btn.x = 22; $machine.clear(self) }
    @press = Proc.new{self.do(pingpong("y",-30,300,:quad_in_out)); $player.zoom_x = 10}

    @state = :idle # :over
    
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    # Check inputs if active?
    if @state == :idle
      if Input.method == :mouse
        check_hover(Mouse.position)
      end
      # check mouse hover?
    end

    if @state == :active
      check_nhover(Mouse.position)
      if @state == :active
        if Mouse.trigger?
          @press.call()
        end
      end
    end

    if @state == :active
      # check key presses to change to another
      #if Input.trigger?(Input.right)
        # check hover of all neighbours
      #  self.viewport.sprites.each{ |s| s.check_hover(x+100)}
      #end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x
    return if pos[1] < self.y
    return if pos[0] > self.x + self.width
    return if pos[1] > self.y + self.height
    @state = :active
    @select.call() if @select
    log_append("PROC")
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x
    w = true if pos[1] < self.y
    w = true if pos[0] > self.x + self.width
    w = true if pos[1] > self.y + self.height
    return if w == false
    @state = :idle
    @deselect.call() if @select
    log_append("UNPROC")
  end

end"#==============================================================================
# Widget_Clicker
#==============================================================================

# Base display of pics

class Widget_Clicker < Widget
  
  # accessors
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize()
       
    super()

    @childport = Layer.new(700)

    # handle mouseovers and that and procs and that
    @select = Proc.new{ @btn.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = Proc.new{ $machine.clear(@btn); @btn.x = 22; $machine.clear(self) }
    @press = Proc.new{self.do(pingpong("y",-30,300,:quad_in_out)); $player.zoom_x = 10}

    @state = :idle # :over

    @btn = @childport.add(Widget.new())
    @btn.width = 60
    @btn.height = 60
    @btn.from_skin("wskin")
    @btn.x = 22
    @btn.y = 22

    
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    @childport.update
    @childport.rect.x = self.x
    @childport.rect.y = self.y
    @childport.rect.width = self.width
    @childport.rect.height = self.height
    #@childport.opacity = self.opacity

    # Check mouseover

    # Check inputs if active?
    if @state == :idle
      if Input.method == :mouse
        check_hover(Mouse.position)
      end
      # check mouse hover?
    end

    if @state == :active
      check_nhover(Mouse.position)
      if @state == :active
        if Mouse.trigger?
          @press.call()
        end
      end
    end

    if @state == :active
      # check key presses to change to another
      #if Input.trigger?(Input.right)
        # check hover of all neighbours
      #  self.viewport.sprites.each{ |s| s.check_hover(x+100)}
      #end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x
    return if pos[1] < self.y
    return if pos[0] > self.x + self.width
    return if pos[1] > self.y + self.height
    @state = :active
    @select.call() if @select
    log_append("PROC")
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x
    w = true if pos[1] < self.y
    w = true if pos[0] > self.x + self.width
    w = true if pos[1] > self.y + self.height
    return if w == false
    @state = :idle
    @deselect.call() if @select
    log_append("UNPROC")
  end

end"ò#==============================================================================
# Widget_Label
#==============================================================================



class Widget_Label < Widget
  
  # accessors
  attr_accessor :align, :font, :skin, :padding, :fix_width, :indent
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @font = Fonts.get('textbox')
    @skin = nil

    @text = "Label"

    @righty = ''#{}"x 10"

    @align = :left

    @padding = 5
    @indent = 0

    # If there is a width, don't auto size width
    @fix_width = 0
    
  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    return if text == nil
    @text = text
    #redraw if @text != ''
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    #self.bitmap.clear

    # Resize as required
    self.height = @font.height + (@padding * 2)
    if @fix_width > 0
      self.width = @fix_width
    else
      self.width = @font.width(@text) + (@padding*2) + @indent
    end
    
    self.from_skin(@skin) if @skin != nil
    self.bitmap = Bitmap.new(self.width,self.height) if @skin == nil

    # Draw the font!!!!
    cy = (self.height - @font.height) / 2
    if @align == :left
      cx = @indent + @padding
    elsif @align == :center
      cx = (self.width - @font.width(@text)) / 2
    else
      cx = self.width - @font.width(@text) - @padding
    end

    @text.split('').each{ |c|
      self.bitmap.blt(cx,cy,@font.letter(c),@font.letter(c).rect)
      cx += @font.step(c)
    }


    #if @righty != ""

      cx = self.width - @font.width(@righty) - @padding

      @righty.split('').each{ |c|
        self.bitmap.blt(cx,cy,@font.letter(c),@font.letter(c).rect)
        cx += @font.step(c)
      }

    #end

    
  end
  
end"B#==============================================================================
# Widget_Label
#==============================================================================

class Widget_List < Widget
  
  # accessors
  attr_accessor :align, :font
  attr_accessor :row_height
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @contents = Layer.new(775)

    @data = []

    @font = Fonts.get("textbox")

    @pointer = Sprite.new()
      
    @rows = 7
    @row_height = 25
    
    @padding = Bounds.new

     @title = @parent.add(Widget_Label.new)
     @title.text = "Items"
     @title.skin = 'skin-red'
     @title.link(self,-22,-22)
     @title.z += 1
     @title.font = Fonts.get('title')
     @title.refresh

     @idx = 0
     @page = 0

     # Cursor needs to be a sibling as does title
     @cursor = @parent.add(Widget.new)
     @cursor.from_menu("cursor")
     @cursor.z = self.z + 1
     @cursor.x = self.x + 5
     @cursor.do(pingpong("x",10,250,:quad_in_out))

  end

  def padding=(padding)
    @padding.left = padding[0]
    @padding.top = padding[1]
    @padding.right = padding[2]
    @padding.bottom = padding[3]
  end

  def update
    super

#    log_append 'update'
    # get rid of?
    @contents.rect.x = self.x 
    @contents.rect.y = self.y  
    @contents.rect.width = self.width
    @contents.rect.height = self.height 

    return if !self.active

    # keys
    if key_down?
      @idx += 1
    end

    if key_up?
      @idx -= 1
    end

    if key_right?
      @contents.sprites.each{ |c| 
        c.do(go("x",-self.width,700,:quad_out))
      }
    end

    if key_left?
      @contents.sprites.each{ |c| 
        c.do(go("x",self.width,700,:quad_out))
      }
    end

    #- @cursor.width
    @cursor.y = self.y + @padding.top + (@idx * @row_height)
    
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    @contents.clear

    self.height = (@row_height * @rows) + @padding.top + @padding.bottom
  
    self.from_skin('skin-white',5)

    @data = [1,1,1,1,1,11,1,1,1,1,1,1,1,1,1,1,1,1,1]

    @contents.rect.x = self.x 
    @contents.rect.y = self.y  
    @contents.rect.width = self.width
    @contents.rect.height = self.height


    # Draw offset rows
    (0..@rows).step(2).each{ |r|
      #next if r % 2 == 0
      self.bitmap.fill_rect(0,@padding.top+@row_height*r,self.width,@row_height,Color.random)
      #fill_rect(x, y, width, height, color) 
    }

    # Creating them labels
    row = 0
    col = 0
    @data.each{ |item| 

      lbl = @contents.add(Widget_Label.new)
      lbl.text = "Item " + ((col * @rows)+row).to_s
      lbl.x = 20
      lbl.y = @padding.top + (row * @row_height) - 3
      lbl.width = self.width - @padding.left - @padding.right
      lbl.fix_width = self.width - @padding.left - @padding.right
      lbl.height = self.height - @padding.top - @padding.bottom
      lbl.refresh

      row += 1
      if row > @rows
        row = 0
        col += 1
      end

      lbl.x = 20 + (self.width * col)


    }

    
  end

  def hide
    @contents.sprites.each{ |s| s.hide }
    @cursor.hide
    @title.hide
    super
  end

  def show
    @contents.sprites.each{ |s| s.show }
    @cursor.show
    @title.show
    super
  end
  
end"#==============================================================================
# Widget_Menu
#==============================================================================

class Widget_Menu < Widget
  
  # accessors
  attr_accessor :align, :font
  attr_accessor :row_height

  attr_accessor :idx

  attr_accessor :on_select
  attr_accessor :on_press
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @contents = Layer.new(775)

    # Handle input with active or not active, only this and list can have mousing? nothing else shall be made active

     @cursor = @parent.add(Widget.new)
     @cursor.from_menu("cursor")
     @cursor.z = 776#self.z + 1
     @cursor.x = self.x + 50
     @cursor.y = self.y + 44
     #@cursor.do(pingpong("x",10,250,:quad_in_out))

     @idx = 0

     @on_select = nil
     @on_press = nil

  end

  def add(button)
    return @contents.add(button)
  end

  def layout_horiz(x,y,spacing=5)
    cx = x
    @contents.sprites.each{ |s|
      s.x = cx
      s.y = y
      cx += s.width + spacing
    }
  end

  def layout_vert(x,y)
    cy = y
    @contents.sprites.each{ |s|
      s.x = x
      s.y = cy
      cy += s.height + spacing
    }
  end

  def layout_grid(x,y,w)

  end

  def select(idx)
    return if idx < 0
    return if idx > @contents.sprites.count - 1
    @idx = idx
    @cursor.x = @contents.sprites[@idx].x
    @cursor.y = @contents.sprites[@idx].y+40
    @on_select.call if @on_select != nil
  end

  def press()
    @on_press.call
  end

  def update
    super

    @contents.rect.x = self.x 
    @contents.rect.y = self.y  
    #@contents.rect.width = self.width
    #@contents.rect.height = self.height 

    return if !self.active



    # keys
    if key_right?
      select(@idx+1)
    end

    if key_left?
      select(@idx-1)
    end

    if key_enter?
      press
    end

    # Check mouse inputs
    @contents.sprites.each{ |s|
      pos = Mouse.position
      pos[0] -= self.x
      pos[1] -= self.y
      #log_append(pos)
      if s.inside?(pos)
       # log_append("DOIT")
        select(@contents.sprites.index(s))
      end
    }

    # if key_right?
    #   @contents.sprites.each{ |c| 
    #     c.do(go("x",-self.width,700,:quad_out))
    #   }
    # end

    # if key_left?
    #   @contents.sprites.each{ |c| 
    #     c.do(go("x",self.width,700,:quad_out))
    #   }
    # end

  end
    
  def hide
    @contents.sprites.each{ |s| s.hide }
    @cursor.hide
    super
  end

  def show
    @contents.sprites.each{ |s| s.show }
    @cursor.show
    super
  end
  
end"#==============================================================================
# Sprite_Pop
#==============================================================================

class Sprite_Pop < Widget
  
  attr_accessor :life,:vx,:vy,:fy
  attr_accessor :base_type
  attr_accessor :type
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)
    
    @state = :in
        
    # Defaults
    @life = 45
    @fy = 0.4
    @vx = rand*2.0-1.0
    @vy = rand*-5.0-10.0
    @base_type = :normal
    @type = :fall
    
  end
  
  #--------------------------------------------------------------------------
  # * Prepare icon popper
  #--------------------------------------------------------------------------
  def pop_icon(ic,double=false)
    prep_sprite(Cache.stroke_icon(ic,double)) 
  end
  
  def pop_gfx(gfx)
    prep_sprite(Cache.menu('Drops/'+gfx))
  end
  
  def pop_hit(gfx)
    prep_sprite(Cache.menu(gfx))
  end
  
  #--------------------------------------------------------------------------
  # * Prepare damage popper
  #--------------------------------------------------------------------------
  def pop_dmg(dmg,size,color)

    # prepare number data
    anums = dmg.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.65

    }
    
    prep_sprite(bmp)    
    
  end
  
  #--------------------------------------------------------------------------
  # * Prepare damage popper
  #--------------------------------------------------------------------------
  def pop_xp(dmg,size,color)

    # prepare number data
    anums = dmg.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.65

    }
    
    src = Cache.menu('xp')
    bmp.blt(c+2,9,src,src.rect)
    
    prep_sprite(bmp)    
    
  end
  
  #--------------------------------------------------------------------------
  # * Prepare sharp popper
  #--------------------------------------------------------------------------
  def pop_sharp(dmg,size,color)

    # prepare number data
    anums = dmg.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)

    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+38,ch+3)
    c = 0
    
    

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.65

    }

    
    src = Cache.menu('dmg')
    bmp.blt(c+1,4,src,src.rect)
    
    prep_sprite(bmp)    

  end
  
  #--------------------------------------------------------------------------
  # * Prepare sharp popper
  #--------------------------------------------------------------------------
  def pop_block(dmg,size,color)

    # prepare number data
    anums = dmg.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+40,ch)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.65

    }
    
    src = Cache.menu('block')
    bmp.blt(c+1,5,src,src.rect)
    
    prep_sprite(bmp)    
    
  end
  
  #--------------------------------------------------------------------------
  # * Prepare damage popper
  #--------------------------------------------------------------------------
  def pop_hp(dmg,size,color)

    # prepare number data
    anums = dmg.to_i.to_s.split(//)
    nums = []
    anums.each{ |n| nums.push(n.to_i) }

    # build the gfx of this number
    src = Cache.system('pop_'+size.to_s)
    cw = src.width/10
    ch = src.height/7

    # Colors
    colors = [:yellow,:orange,:blue,:green,:red,:gray,:white]
    ic = colors.find_index(color)
    
    # prepare the final image
    width = 0
    nums.each{ |n| width+=cw }
    bmp = Bitmap.new(width+20,ch+15)
    c = 0

    nums.each{ |n|

      s = n * cw

      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
      c += cw*0.65

    }
    
    src = Cache.menu('hp')
    bmp.blt(c+2,9,src,src.rect)
    
    prep_sprite(bmp)    
    
  end
  
  #--------------------------------------------------------------------------
  # * Prepare sprite
  #--------------------------------------------------------------------------
  def prep_sprite(bmp)
    
    # setup sprite
    self.opacity = 0
    self.bitmap = bmp
    self.auto_size
    @loc_y = y.to_f-bmp.height/2
    @loc_x = self.x
    @base_y = @base_type == :normal ? @loc_y - (bmp.height/2)+10 : 400
    
  end  
  
  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose

    self.bitmap.dispose if self.bitmap != nil
    super

  end

  #--------------------------------------------------------------------------
  # * Update
  #--------------------------------------------------------------------------
  def update
    super
    
    @vy += @fy if @type == :fall

    @loc_y += @vy
    @loc_x += @vx
    
    if @type == :fall
      if @vy > 0 && @loc_y >= @base_y
        @vy > 2.0 ? @vy *= -0.5 : @vy = 0
        @loc_y = @base_y
      end
    else
      @vy *= 0.9
      @vx *= 0.8
    end

    # Positioning
    self.y = @loc_y
    self.x = @loc_x

    if @state == :in
      self.opacity += 20
      @state = :up if self.opacity >= 255
    elsif @state == :up
      @life -= 1
      @state = :out if @life <= 0
    elsif @state == :out
      self.opacity -= 20
      @state = :done if self.opacity <= 0
    end
    
    #p @state

  end

  #--------------------------------------------------------------------------
  # * Mischecks
  #--------------------------------------------------------------------------
  def dead?() return self.opacity <= 0 end

end"/ #==============================================================================
# ** Dan Message Box
#==============================================================================

# States
#
# :closed - hidden and inactive
# :opening - fading in, leads to :texting
# :closing - fading out, leads to :closed
# :texting - showing text, letter by letter
# :done - done showing text, wait for input to continue
# :waiting - waiting a set time, @. @| etc

class Letter < Sprite

  attr_accessor :px, :py, :ox, :oy

  def initialize
    super

    @px = 0
    @py = 0
    @ox = 0
    @oy = 0

  end

  def update
    super
    self.x = @px# + @ox
    self.y = @py# + @oy
  end

end

class Sprite_Superbox < Widget

  attr_accessor :padding_left, :padding_top, :padding_right, :padding_bottom


  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @state = :closing

    @contents = Layer.new(700)
    #@contents.color = Color.new(255,0,0,120)
    @next = Sprite.new()
    @choice = Sprite.new()

    # text speed
    @normal_speed = 2 #-$settings.value('text_speed')
    @text_delay = @normal_speed
    
    # Internal tracking
    @skip_all = false
    @wait_frames = 0
    @next_char = 0   

    @data = nil # All text
    @word = "" # Remainder of current word

    @title = @parent.add(Widget_Label.new)
     @title.text = "Peter Punkineater"
     @title.skin = 'skin-red'
     @title.link(self,-12,-26)
     @title.z += 1
     @title.font = Fonts.get('title')
     @title.refresh
    
    #@padding = Bounds.new()
    @padding_left = 16
    @padding_top = 14#234
    @padding_right = 10
    @padding_bottom = 20

    @line_spacing = 6

    @cx = @padding_left
    @cy = @padding_top
    
    @font = Fonts.get('textbox')    
    self.bitmap = Cache.menu("chatbox")


    @effects = []

     # # For choices
     # @cursor = @parent.add(Widget.new)
     # @cursor.from_menu("cursor")
     # @cursor.z = self.z + 1
     # @cursor.x = self.x + 5
     # @cursor.do(pingpong("x",10,250,:quad_in_out))

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # Position content viewport
    @contents.rect.x = self.x 
    @contents.rect.y = self.y  
    @contents.rect.width = self.bitmap.width 
    @contents.rect.height = self.bitmap.height

    @contents.update
   
    # Skip to end of this text, line i guess, but maybe don't have this
    
    case @state

      when :closing, :opening
       # log_append("CLOSINGG")

      when :texting
        #if Input.trigger?(Input::C)
          #@skip_all = true
        #end
        return if !$machine.done?(self)
        @next_char -= 1
        if @next_char <= 0
          update_message
          update_message if @text_delay < 0
        end

        # text effects
        @effects.each{ |fx|


        }

      when :scroll_line
        if @contents.sprites.select{ |letter| letter.y > 0 }.empty?
          # removethe sprites
          @contents.clear
          #clear out lines and continue
          @cx = @padding_left
          @cy = @padding_top
          @state = :texting
          @line_idx = -1
        end        

      when :waiting
        update_waiting

      when :pausing
        check_input_next

      when :done
        check_input_done

      when :choice
        check_input_choice

    end

    # skipping
    # while @state == :texting && @skip_all
    #   @next_char > 0 ? @next_char -= 1 : update_message
    # end

  end

  #--------------------------------------------------------------------------
  # * Setup
  #--------------------------------------------------------------------------
  def set_style(back) 
      self.bitmap = Cache.menu("chatbox")
  end

  #--------------------------------------------------------------------------
  # * Setup text
  #--------------------------------------------------------------------------
  def start_text(text)

    @text_delay = @normal_speed
    
    @skip_all = false
    
    # Read the text
    text.lstrip!
    @data = text.split(' ')

    # prep for text
    @word_idx = -1
    @line_idx = -1
    @cx = @padding_left
    @cy = @padding_top #+ @line_spacing

    #next_line
    next_word

    #nano
    @state = :texting

  end  

  #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    @word_idx += 1
    @word = @data.shift
    (@show_next = true;@state = :done; return) if @word == nil
    @wordlength = @word.length

    # CHECK FOR SCRIPT
    if @word[0]=="*"
      # build this script to eval
      # until finding another *
      script = @word
       if @word[-1,1] == "*"
        eval(script.tr('*',''))
        return next_word
      end

      @word = @data.shift

      while !@word.include?("*")
        @word = @data.shift
        script += ' ' + @word
      end

      eval(script.tr('*',''))

      update_waiting while @state == :waiting
      return next_word
    end

    if @word == "@" # Choice
      next_line
    end

    if @word[0] == "%" # Effects
      
      case @word

        when "%"
          # End current effect


        when "%scared"

          fx = {}
          fx[:type] = :scared
          fx[:power] = 10
          fx[:letters] = []

      end

    end


    # CHECK FOR COMMANDS
    if @word[0]=='#' || @word[0] == ';' || @word[0] == '/'
      cmd = @word.split(".")
      wrd = cmd[0]
      wrd.slice!(0)

      # check for command words
      case wrd
      
        when "nl" # New line
          next_line
          
        when "w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
          
        when "ww"
          @wait_frames = 30; @state = :waiting
          
        when "sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
          
        when "fl"
          color = cmd.size > 1 ? Colors.get(cmd[1].to_sym) : Colors.get(:black)
          $world.do_flash(color,15)         

        when "f"
          @font = Fonts.get(cmd[1])
          
        when "s" # play sound
          Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "m","music"
          
          case cmd[1]
            when 'stop'
              @bkp = RPG::BGM.last
              Audio.bgm_stop            
            when 'fade'
              @bkp = RPG::BGM.last
              Audio.bgm_fade(750)          
            when 'resume'
              Audio.bgm_play("Audio/BGM/"+@bkp.name,@bkp.volume,@bkp.pitch,@bkp.pos)            
            else
              Audio.bgm_play("Audio/BGM/"+cmd[1])            
          end
          
        when "nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      next_word

    end

  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line

    @cx = @padding_left
    @cy += @line_spacing + @font.height

    @line_idx += 1
    log_append("LINEIDX")
    log_append(@line_idx)

    # If the first character is @ this is a choice!
    if @word == "@"
      @cx += 20
      next_word
    end

    if @cy > @contents.rect.height - @padding_top - @padding_bottom # check if cursor will push below
      @show_next = true     
      @state = :pausing
    end

  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    if @word.empty?

      next_word
      return if @word == nil

      @cx += @font.letter(" ").width

      # count width of next word
      cx = @cx 
      cx += @font.width(@word)

      next_line if cx > @contents.rect.width - @padding_left - @padding_right
      
    end
        
    # if not texting then don't go
    return unless @state == :texting
    
    @dodotpause = false
    @dodotpause = true if @word == "." || @word == "!" || @word == "?"
        
    # Add the next character to the final word
    #@line_data[@line_data.size-1] += @word.slice!(0,1)

    chr = @word.slice!(0,1)

    # CREATE THE LETTER!
    letter = Letter.new()


    letter.bitmap = @font.letter(chr)
    #letter.color = Color.new(rand(255),rand(255),rand(255))
    #letter.bitmap.font = Fonts.get(@font+"_reg")
    letter.ox = letter.bitmap.width/2

    @cx += letter.ox - @font.outline
    
    letter.px = @cx
    letter.py = @cy
    #letter.update

    letter.opacity = 0
    letter.do(to("opacity",255,20))
    #letter.do(go("y",-400,5000))
    
    #letter.do(sequence(go("zoom_x",1.0,50),go("zoom_x",-1.0,100)))
    
    #letter.do(sequence(go("zoom_y",2.5,1),go("zoom_y",-2.5,300)))
    #letter.do(sequence(go("zoom_x",2.5,1),go("zoom_x",-2.5,300)))
    
    #letter.do(pingpong("y",2,300,:quad_in_out))
    #letter.do(pingpong("x",2,300,:quad_in_out))
    #@letters.push(letter)
    @contents.add(letter)
    @cx += (letter.bitmap.width-letter.ox) + 0 - @font.shadow + @font.outline

    #sound(:text_char) #if $settings.value('text_sound') 

    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    (@wait_frames = @text_delay * 3; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all || Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
    Graphics.update
    Input.update
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_next
    if Input.trigger?(Input::C)
      #sound(:text_next)
      @contents.sprites.each{ |letter|
        letter.do(go("y",-200,1000))
      }
      @state = :scroll_line
    end
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done

    if Input.trigger?(Input::C)
     
      #sound(:text_next)

      log_append("CLOSEIT")
            @contents.sprites.each{ |letter|
        letter.do(go("y",-200,1000))
      }
      @state = :closing
    end

  end

  def check_input_choice

  end

  #--------------------------------------------------------------------------
  # * Read from the automatic namings
  #--------------------------------------------------------------------------
  def busy?() 
    return false if @state == :closing
    return !$machine.done?(self) if @state == :opening || @state == :closing
    return true
  end

end
"S
#==============================================================================
# Widget_Label
#==============================================================================

# 
class Widget_SuperLabel < Widget
  
  # accessors
  attr_accessor :align, :font, :width, :spacing
  attr_reader :text
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    #@font = Fonts.get('textbox')
    @text = "Label"
    @align =  0
    @width = 0

    @spacing = 1.0
    
    # Hold child letters in a layer?
    @children = []

    @angle = 0

    #rebuild
    
  end

  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    return if text == nil
    @text = text
    #rebuild
  end

  def update
    super

    font = Fonts.get('textbox')
    # reput positions of characters
    cx = self.x
    @children.each{ |char| 
      char.x = cx
      #char.y = self.y
      cx += char.bitmap.width + @spacing - font.shadow
    }    

    #CENTER
    width = 0
    @children.each{ |char| 
      width += char.bitmap.width + @spacing - font.shadow
    }  
    width -= @spacing

    # get starter
    cx = self.x - width/2
    @children.each{ |char| 
      char.x = cx
      #char.y = self.y
      cx += char.bitmap.width + @spacing - font.shadow
    }   

    angle = @angle
    @angle += 0.1
    step = 0.2
    power = 8
    @children.each{ |c| 
      c.y = self.y + power * Math.sin(angle)
      angle += step
    }

  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh
  
    @children.each { |c| c.dispose }
    @children.clear

    cx = self.x

    font = Fonts.get('textbox')
    d = 0
    z = 0

    @text.split('').each{ |c|
      log_append(c)
      char = Sprite.new(self.viewport)
      char.bitmap = font.letter(c)
      char.x = cx + char.bitmap.width/2
      char.y = self.y
      char.z += z
      z += 1
      char.ox = char.bitmap.width/2
      char.oy = char.bitmap.height/2
      cx += char.bitmap.width + @spacing - font.shadow
      #char.do(sequence(delay(d),pingpong("y",10,800,:quad_in_out)))
      #d += 50
      @children.push(char)
    }
    
    #self.do(pingpong("spacing",7,300,:quad_in_out))
    
  end
  
end"â6 #==============================================================================
# ** Dan Message Box
#==============================================================================

# States
#
# :closed - hidden and inactive
# :opening - fading in, leads to :texting
# :closing - fading out, leads to :closed
# :texting - showing text, letter by letter
# :done - done showing text, wait for input to continue
# :waiting - waiting a set time, @. @| etc

class Sprite_Textbox < Widget

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create

    @state = :closed
    @side = 'a'      

    # text speed
    @normal_speed = 4 #-$settings.value('text_speed')
    @text_delay = @normal_speed
    
    # Internal tracking
    @skip_all = false
    @wait_frames = 0
    @next_char = 0   
    @top_line_fade = 255
    @line_y_offset = 0
    @indent=25
    @width=425  
    @data = nil # All text
    @line_data = [''] # Text on current line
    @word = "" # Remainder of current word
    @line_images = nil
    @line_indx = 0
    @word_idx = 0

    # show next icon
    @show_next = false
    @next_opacity = 0

    # Setup height for zooming
    self.set_height(64)
    #self.set_zy(0.0)    
    
    @style = 'white'
    @font = 'white'
    
    self.bitmap = @bg_gfx = Cache.menu("chatbox")
    #Cache.menu("Text\\chat_box_white_"+@side)

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end
      

    @next_opacity += 10 if @show_next && @next_opacity < 250
    @next_opacity -= 10 if !@show_next && @next_opacity > 0
    
    # Skip to end of this text, line i guess, but maybe don't have this
    #if Input.trigger?(Input::C) && @state = :texting
    #  @skip_all = true
    #end

    case @state

      when :closed
        #nothing
      when :opening
        @state = :texting if self.zoom_y == 1.0
      when :closing
        if self.zoom_y == 0.0
          @state = :closed
          @line_images = [Bitmap.new(500,40)]
          @line_images[0].font = Fonts.get(@font+"_reg")
          draw_lines
        end
      when :texting
        @next_char -= 1
        if @next_char <= 0
          update_message
          update_message if @text_delay < 0
        end
        draw_lines
      when :fade_line
        @top_line_fade -= 5#(5 * $settings.value('text_speed'))
        if @top_line_fade < 10
          @top_line_fade = 0
          @state = :scroll_line
        end
        draw_lines
      when :scroll_line
        @line_y_offset += 5#$settings.value('text_speed')
        @line_y_offset = 23.0 if @line_y_offset >= 23.0
        draw_lines
        if @line_y_offset >= 23
          @line_y_offset = 0
          @top_line_fade = 255
          @line_images[0].dispose
          @line_images.delete_at(0)
          @line_idx-=1
          @state = :texting
        end
        
      when :waiting
        update_waiting
      when :pausing
        check_input_next
        draw_lines
      when :done
        check_input_done
        draw_lines
    end

    # skipping
    while @state == :texting && @skip_all
      @next_char > 0 ? @next_char -= 1 : update_message
    end

  end

  #--------------------------------------------------------------------------
  # * Setup
  #--------------------------------------------------------------------------
  def set_side(side) 
    @side = side 
    self.bitmap = @bg_gfx = Cache.menu("chatbox")
    #Cache.menu("Text\\chat_box_white_"+@side)
    #@indent = 25 if @side == 'a'
    #@indent = 13 if @side == 'b'
  end
  def set_style(back) 
    @style = back
    case back
    when 'white'
      self.ox=0
      self.bitmap = @bg_gfx = Cache.menu("chatbox")
      #Cache.menu("Text\\chat_box_white_"+@side)
      #@indent = 25 if @side == 'a'
      #indent = 13 if @side == 'b'
      @font='white'
    when 'black'
      self.ox=0
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_black_"+@side)
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'black'
    when 'lines'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_lines")
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'lines'
    when 'yellow'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_yellow")
      @indent = 25 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'white'
    when 'brwn'
      self.ox=-12
      self.bitmap = @bg_gfx = Cache.menu("Text\\chat_box_brwn")
      @indent = 35 if @side == 'a'
      @indent = 13 if @side == 'b'
      @font = 'white'
    end
  end

  #--------------------------------------------------------------------------
  # * Setup text
  #--------------------------------------------------------------------------
  def start_text(text)

    @text_delay = @normal_speed
    
    @skip_all = false
    
    # Read the text
    #p text
    text.lstrip!
    @data = text.split(' ')
    replace_words

    # reset things
    @show_next = false    
    @line_images = []

    # prep for text
    @word_idx = -1
    @line_idx = -1
    next_line
    next_word
    
    # Prepare to open

    #nano
    #self.slide_zy(1.0)
    @state = :opening

  end  

  #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    @word_idx += 1
    (@show_next = true;@state = :done; return) if @word_idx >= @data.size
    @word = @data[@word_idx]
    @wordlength = @word.length

    # CHECK FOR COMMANDS
    if @word[0]=='#' || @word[0] == ';' || @word[0] == '/'
      cmd = @word.split(".")
      wrd = cmd[0]
      wrd.slice!(0)

      # check for command words
      case wrd
      
        when "nl" # New line
          next_line
          
        when "w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
          
        when "ww"
          @wait_frames = 30; @state = :waiting
        when "www"
          @wait_frames = 45; @state = :waiting
        when "wwww"
          @wait_frames = 60; @state = :waiting
        when "wwwww"
          @wait_frames = 75; @state = :waiting
        when "wwwwww"
          @wait_frames = 90; @state = :waiting
        when "wwwwwww"
          @wait_frames = 105; @state = :waiting
        when "wwwwwwww"
          @wait_frames = 120; @state = :waiting
          
        when "sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
          
        when "fl"
          color = cmd.size > 1 ? Colors.get(cmd[1].to_sym) : Colors.get(:black)
          $world.do_flash(color,15)         
          
        when "s" # play sound
          Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "m","music"
          
          case cmd[1]
            when 'stop'
              @bkp = RPG::BGM.last
              Audio.bgm_stop            
            when 'fade'
              @bkp = RPG::BGM.last
              Audio.bgm_fade(750)          
            when 'resume'
              Audio.bgm_play("Audio/BGM/"+@bkp.name,@bkp.volume,@bkp.pitch,@bkp.pos)            
            else
              Audio.bgm_play("Audio/BGM/"+cmd[1])            
          end
          
        when "nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      next_word

    end

  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @line_images.push(Bitmap.new(500,40))
    @line_images[@line_images.size-1].font = Fonts.get(@font+"_reg")
    @line_data = ['']
    if @line_idx > 1     
      @show_next = true     
      @state = :pausing
    end
  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    if @word.empty?

      next_word
      
      # Check if width will be too much, maybe add new line
      total = 0
      @line_data.each{ |w| 
        if w[0] == "%"
          total+=24+@line_images[0].text_size(' ').width 
        else
          total += @line_images[0].text_size(w+' ').width 
        end
      }      
      total += @line_images[0].text_size(@word).width
      total > @width ? next_line : @line_data.push('')      
      
    end
        
    # if not texting then don't go
    return unless @state == :texting
    
    @dodotpause = false
    @dodotpause = true if @word == "." || @word == "!" || @word == "?"
        
    # Add the next character to the final word
    @line_data[@line_data.size-1] += @word.slice!(0,1)
    #sound(:text_char) #if $settings.value('text_sound') 
    
    
    # Redraw this line of text
    cursor = 0
    @line_images[@line_idx].clear   
    @line_images[@line_idx].font = Fonts.get(@font+"_reg")
    @line_data.each{ |w|
      aw = w.dup
      if aw[0] == '^'
        aw.slice!(0)
        @line_images[@line_idx].font = Fonts.get(@font+"_bold")
      end
      if aw[0] == '~'
        aw.slice!(0)
        @line_images[@line_idx].font = Fonts.get(@font+"_talic")
      end
      if aw[0] == "%"
        aw.slice!(0)
        i = aw.to_i
        @line_images[@line_idx].blt(cursor,12,Cache.icon(i),Rect.new(0,0,24,24))
        cursor += 24+@line_images[@line_idx].text_size(' ').width
      else
        @line_images[@line_idx].draw_text(cursor,0,500,50,aw,255)
        cursor += @line_images[@line_idx].text_size(aw+' ').width
      end
      @line_images[@line_idx].font = Fonts.get(@font+"_reg")
    }

    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    (@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end
  
  #--------------------------------------------------------------------------
  # * Draw Lines to final image
  #--------------------------------------------------------------------------
  def draw_lines()
    
    # redraw the current line
    self.bitmap = @bg_gfx.dup

    # Draw lines    
    self.bitmap.blt(@indent,-7-@line_y_offset,@line_images[0],Rect.new(0,0,500,40),@top_line_fade)
    if @line_images.size > 1
      self.bitmap.blt(@indent,16-@line_y_offset,@line_images[1],Rect.new(0,0,500,40))
    end   

    # draw next
    snext = @style == 'black' ? Cache.menu("dots_blue") : Cache.menu("dots_gray")
    if @side == 'a'
      self.bitmap.blt(430,45,snext,Rect.new(0,0,22,6),@next_opacity)    
    else
      self.bitmap.blt(418,45,snext,Rect.new(0,0,22,6),@next_opacity)
    end
  
  end

  #--------------------------------------------------------------------------
  # * Word Replacer
  #--------------------------------------------------------------------------
  def replace_words

    idx = 0
    while(idx<@data.size) do
      word = @data[idx]

      case word
      
        when "&...", "#..."
          @data.delete_at(idx)
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          @data.insert(idx,'.')
          @data.insert(idx,'#w.15')
          
        when "@"
          
          @data.delete_at(idx)
          
        end
        
        idx +=1

    end

  end

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all || Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
    Graphics.update
    Input.update
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_next
    if Input.trigger?(Input::B) || Input.trigger?(Input::C)
      #sound(:text_next)
      @state = :fade_line
      @show_next = false
    end
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if Input.trigger?(Input::B) || Input.trigger?(Input::C)
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @show_next = false
    end
  end

  #--------------------------------------------------------------------------
  # * Read from the automatic namings
  #--------------------------------------------------------------------------
  def busy?() return (@state != :closed && @state != :closing) end
  def visible?() return @state != :closed end

end
"ì#==============================================================================
# ** Dan Message Box
#==============================================================================

class Sprite_Textpop < Widget
  
  attr_accessor :event

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(text,ev,vp,style)
    super(vp)    
    
    self.set_zy(0.0)
    self.set_zx(0.0)
    
    @event = ev

    @dead = false
    @state = :opening
    @wait_frames = 0
    @counter = 120
    
    # Create the graphic here, then zoom it in? 
    bmp = Bitmap.new(500,68)
    bmp.font = Fonts.get("white_reg")
    width = bmp.text_size(text).width
    
    width = [96,width+33].max
    
    self.set_width(width)
    self.set_height(68)
    
    self.slide_zy(1.0)
    self.slide_zx(1.0)
    
    o = 255
    
    
    # position but fix tail
    x = ev.screen_x+6
    y = ev.screen_y-50
        
    off = 0
    if x + width/2 > 544
      newx = 544 - width/2
      off = x-newx
      x = newx
    end
    if x <width/2
      newx = width/2+4
      off = x-newx
      x = newx
    end
    
    
    # fill with guy!!!!  
    if style == :normal
      src = Cache.menu("poptext")
    else
      src = Cache.menu("poptextsign")
    end
    bmp.blt(0,0,src,Rect.new(0,0,32,46),o) # top left
    bmp.blt(width-32,0,src,Rect.new(64,0,32,46),o) # top right
    
    bmp.stretch_blt(Rect.new(32,0,width-64,46),src,Rect.new(32,0,32,46),o)
    
    if style == :normal
    tail = Cache.menu("poptail")
    bmp.blt(width/2-16+off,33,tail,tail.rect)
    end
    bmp.draw_text(0,1,width,40,text,1)
    

    #self.set_xy(100,50)
    self.set_xy(x,y)

    # prep all gfx
    #@bg_gfx = Cache.menu('Text\chat_box_white_a')
    self.bitmap = bmp

  end
  
  def die() @counter = 0 end
  def dead?() return @dead end

  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose
    super
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    
    # Update position
    self.set_y(@event.screen_y-50)
    
    # Update state

    case @state

      when :opening
        #@opacity += @open_speed
        (@state = :texting;) if self.zoom_y == 1.0
      when :closing
        if self.zoom_y == 0.0
          @dead = true
        end
      when :texting
        @counter -= 1
        if @counter <= 0
          self.slide_zy(0)
          self.slide_zx(0)
          @state = :closing
        end
    end

    # skipping
    #while @state == :texting && @skip_all
    #  @next_char > 0 ? @next_char -= 1 : update_message
    #end

  end

end
"`#==============================================================================
# Widget_Bar
#==============================================================================

class Widget_Bar < Widget
  
  # accessors
  attr_accessor :align, :font, :width
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def create
       
    super

    @font = Fonts.get('menu_label')
    @text = "Label"
    @align = 0
    @width = 0
    
    self.bitmap = Bitmap.new(1,1)
    self.bitmap.font = @font
    redraw
    
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def set_text(text)
    return if text == nil
    @text = text
    redraw if @text != ''
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def redraw
  
    sz = self.bitmap.text_size(@text)
    @width = sz.width if @width == 0
    self.bitmap = Bitmap.new(@width,sz.height)
    self.bitmap.font = @font    
    self.bitmap.draw_text(0,0,@width,sz.height,@text,@align) 
    
  end
  
end"7
class ActorCmd

	def initialize

	end

end"

# Update self perhamps? Disregard else
# Uses $battle and that's it

# Handle all inputs?

class BattleHud

	def initialize(vp)

		# Bottom bar
		@chars = []
		idx = 0
		$party.active.each{ |char|
			@chars.push(CharView.new(vp,$party.get(char),idx))
			idx += 1
		}

		# Skill selector
		# Or put this in scene
		@actor_cmd = ActorCmd.new

		# Pointer

		# Message

	end

	def open_actor_cmd(actor)
		@actor_cmd.open(actor)
	end

	def 

	def update

		@actor_cmd.update

	end

end"Ð
# Actor view, show portrait, hp etc

class CharView

	def initialize(vp,char,id)

		@port = Sprite.new(vp)
		@port.bitmap = Cache.face(char.id)

		@port.x = id * 150
		@port.y = 380

	end

end"
class SkillCmd

	def initialize(vp)

		@icons = []

		
		@text = Sprite.new
		@text.bitmap = Cache.menu("battle/text.png")

	end

end"*,#==============================================================================
# Ui_Message
#==============================================================================

class Ui_Message

  # Consts
  MIN_WIDTH = 200
  MAX_WIDTH = 500
  TAB_WIDTH = 35

  SPACING = 7
  LINE_HEIGHT = 29#6
  PADDING_X = 16
  PADDING_Y = 12

  SPEED_1 = 0
  SPEED_2 = 1
  SPEED_3 = 2
  SPEED_4 = 3
  SPEED_5 = 4
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize

    # Create the pieces but do nothing besides
    @state = :idle

    # Hold on to the convo
    @text = ""

    # This line data
    @name = ''

    @scratch = Bitmap.new(400,50)

    # Hold the textbox, 
    #@text_viewport

    @lines = []


    # Settings
    @color = nil

    # Text display
    @text_delay = SPEED_3
    @wait_frames = 0
    @next_char = 0

    @cx = 0
    @cy = 0
    
    @line_idx = nil
    @word_idx = nil
    @char_idx = nil

    @width = 0
    @height = 0

    # Setup sprites
    @textbox = Sprite.new($vp_ui)
    @textbox.x = 50
    @textbox.y = 150
    #@namebox = add(Sprite.new)

    #@next = add(Sprite.new)
    @face = Sprite.new($vp_ui)
    @face.z += 10
    #@tail = add(Sprite.new)

    @window_bmp = nil
    @text_bmp = nil

    
    
  end
  
  #--------------------------------------------------------------------------
  # Frame Update
  #--------------------------------------------------------------------------
  def update
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end      
    
    # Skip to end of this text
    if Input.trigger?(Input::C) && @state == :texting
      @skip_all = true
    end

    case @state

      when :closed
        #nothing

      when :opening
        @state = :texting if self.zoom_y == 1.0

      when :closing
        @state = :idle

      when :texting
        @next_char -= 1
        if @next_char <= 0
          #log_err "DOING"
          update_message
        end
        redraw
        
      when :waiting
        update_waiting

        # Choices in here too

      when :pausing
        check_input_next
      when :done
        check_input_done
        
    end

    # skipping
    # while @state == :texting && @skip_all
    #   @next_char > 0 ? @next_char -= 1 : update_message
    # end

  end
  
  #--------------------------------------------------------------------------
  # Show Convo
  #--------------------------------------------------------------------------
  def start(text, choices = nil)

    @scratch.font.size =28
    @scratch.font.name = "Calibri"

    # Clear out the previous word
    @word = nil

    text_data = text.split(":")

    # Find speaker name, use to get face / event
    speaker = text_data[0]

    # TODO - add actor name to this check
    # Get face if exists
    if $data.actors.keys.include?(speaker[0..2])
      @face.bitmap = Cache.face(speaker)
    end

    # Prepare the words to be written
    @lines = split_text(text_data[1])    

    # Now of the height? How many lines are there?
    @width = max_width
    @height = @lines.count * (LINE_HEIGHT)

    # Add padding
    @width += PADDING_X * 2
    @height += PADDING_Y * 2

    @width += @face.width

    @face.x = max_width + @textbox.x + PADDING_X + PADDING_X
    @face.y = @textbox.y + @height - @face.height - PADDING_Y

    # Position the textbox wherever it best fits

    # Prepare the sprites
    @textbox.bitmap = Bitmap.new(@width,@height)

    @text_bmp = Bitmap.new(@width,@height)

    @window_bmp = Bitmap.new(@width,@height)



    @window_bmp.windowskin("windowskin1")


    @scratch.font.size =28
    @text_bmp.font.size = 28
    @textbox.bitmap.font.size = 28

    @text_bmp.font.name = "Calibri"
    @textbox.bitmap.font.name = "Calibri"


    @line_idx = 0
    @word_idx = -1

    @cx = PADDING_X
    @cy = PADDING_Y

    # Start text
    @state = :texting

        
  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message
    
    # if the current word is empty, get the next one and see if it fits
    next_word if @word == nil || @char_idx > @word.length
        
    # if not texting then don't go
    return unless @state == :texting
            
    # Add the next character to the final word
    @char_idx += 1

    # Play a lovely character sound
    #sound(:text_char) if $settings.value('text_sound') 
    
    # Wait before drawing another character
    @next_char = @text_delay
    
    # AUTO PAUSE AFTER SENTENCE HERE
    #(@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  def redraw

    @textbox.bitmap.clear
    @textbox.bitmap.blt(0,0,@window_bmp,@window_bmp.rect)

    @textbox.bitmap.blt(0,0,@text_bmp,@text_bmp.rect)

    return if @word == nil

    @scratch.font.bold = @word.include?("*")
    @scratch.font.italic = @word.include?("^")

    @textbox.bitmap.font.bold = @word.include?("*")
    @textbox.bitmap.font.italic = @word.include?("^")

    #txt = @word[0..@char_idx-1]
    txt = @word.delete('*^')[0..@char_idx-1]
    size = @scratch.text_size(txt)
    @textbox.bitmap.font.color = Color.new(255,255,255,255)
    @textbox.bitmap.draw_text(@cx,@cy,300,LINE_HEIGHT,txt)
    # Half draw the final
    return if @char_idx >= @word.length
    @textbox.bitmap.font.color = Color.new(255,255,255,100)
    @textbox.bitmap.draw_text(@cx+size.width,@cy-4,100,LINE_HEIGHT,@word.delete('*^').split('')[@char_idx])

  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @word = nil
    if @line_idx >= @lines.count
      @state = :done
    else
      @word_idx = 0
      @cy += LINE_HEIGHT
      @cx = PADDING_X
    end
  end

    #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word

    # blit last word onto the main bmp
    if @word != nil

      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')

      txt = @word.delete('*^')[0..@char_idx]


      @text_bmp.draw_text(@cx,@cy,300,LINE_HEIGHT,txt)

      # Step cursor
      @cx += word_width(@word)

    end

    @word_idx += 1
    @char_idx = 0
    
    if @word_idx >= @lines[@line_idx].count
      next_line
      return if @line_idx >= @lines.count
    end

    @word = @lines[@line_idx][@word_idx]

    return if @word == nil

    # CHECK FOR COMMANDS
    if @word.include?('$')
      cmd = @word.split(".")
      wrd = cmd[0]

      # check for command words
      case wrd
      
        when "$n" # New line
          next_line
          
        when "$w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
                    
        when "$sp"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = cmd[1].to_i
          end
                    
        when "$s" # play sound
          #log_err("TRYPLAYIT")
          #Audio.se_play("Audio/SE/"+cmd[1]) 
          
        when "$m"
          
          case cmd[1]
            when 'stop'
              Audio.bgm_stop            
            when 'fade'
              Audio.bgm_fade(750)                   
            else
              Audio.bgm_play(cmd[1])            
          end
          
        when "$nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "$end"
          @state = :closing
          @show_next = false
          
      end
        
      update_waiting while @state == :waiting
      @word = nil
      next_word

    end

  end  

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    @wait_frames = 0 if @skip_all #|| Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if $input.action? || $input.click?
      #sound(:text_next)
      #self.slide_zy(0.0)
      @state = :closing
      @textbox.bitmap.clear
    end
  end

  #--------------------------------------------------------------------------
  # Calculate size
  #--------------------------------------------------------------------------
  def word_width(word)
      return TAB_WIDTH if word == "$t"
      return 0 if word.include?("$")
      @scratch.font.bold = word.include?('*')
      @scratch.font.italic = word.include?('^')
      return @scratch.text_size(word.delete('*^')).width + SPACING
  end

  def max_width
    max = 0
    @lines.each{ |line|
      width = line.inject(0) { |t,w| t + word_width(w) }
      max = width if width > max
    }
    return max - SPACING
  end

  def split_text(text)

    # Split all text into lines
    # Then calc widths and that

    total_width = text.split(" ").inject(0) { |t, w| t + word_width(w) }

    # use total width to split into lines

    # If there is a forced newline, there will be no autosizing
    if text.include?("$n")
      return text.split("$n").map { |i| i = i.split(" ") }  
    end

    # If less than split width, just one line
    if total_width < MIN_WIDTH
      return [text.split(" ")]
    end

    # If width is less than max * 2, we are splitting at the first word after half point
    if total_width < MAX_WIDTH * 2
      limit = total_width / 2
      cursor = 0
      lines = [[]]
      text.split(" ").each{ |word|
        lines[-1].push(word)
        cursor += word_width(word)
        if cursor >= limit
          lines.push([])
          cursor = 0
        end
      }
      return lines
    end

    # Else we are autosizing max width
    lines = [[]]
    limit = MAX_WIDTH
    cursor = 0
    text.split(" ").each{ |word|
      cursor += word_width(word)
      if cursor > limit
        cursor = 0
        lines.push([])
      end
      lines[-1].push(word)
    }
    return lines

  end

  #--------------------------------------------------------------------------
  # Misc
  #--------------------------------------------------------------------------
  def clear() end
  def busy?() return @state != :idle end

end"#==============================================================================
# Ui_Screen
#==============================================================================

class Ui_Screen

	#attr_reader :message
  
	def initialize
		#@message = Ui_Message.new        
	end

	def update
		#@message.update
	end

    def busy?() 
    	return false#@message.busy?
    end

end"#==============================================================================
# ** Mnu_File
#==============================================================================

class DataBox

	attr_reader :id, :name

	def initialize(i)
		@id = i
		@name = "Item "+i.to_s
	end

end

class Mnu_File

	def initialize(vp)

		@char = Part_Char.new(vp)

		@list = List.new(vp)
		@list.x = 50
		@list.y = 60

		data = []
		(0..100).to_a.each{ |i|
			dta = DataBox.new(i)
			data.push(dta)
		}

		@list.setup(data)

		@tabs = Tabs.new(vp)
		@tabs.push(:weapons,'Tabs/weps')
		@tabs.push(:armors,'Tabs/arms')

	end

	def dispose

		@char.dispose

		@list.dispose
		@tabs.dispose

	end

	def update
		@list.update
		@tabs.update
	end

end" " "#==============================================================================
# ** Part_Char
#==============================================================================

class Part_Char

	def initialize(vp)

		@boyle = Sprite.new(vp)
		@boyle.bitmap = Cache.menu("tempboyle")
		@boyle.x = 500

	end

	def dispose

		@boyle.dispose

	end

	def update

	end

end" " "R.#==============================================================================
# ** Game_Actor
#------------------------------------------------------------------------------
#  This class handles the actor. It's used within the Game_Actors class
#  ($game_actors) and refers to the Game_Party class ($game_party).
#==============================================================================

class Game_Battler
end

class Game_Actor < Game_Battler
 
  attr_reader :id 
  attr_reader   :name                     # name

  attr_reader   :level                    # level
  attr_reader   :exp                      # EXP
  
  attr_reader   :skills                   # skills

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def initialize(id)
    super()

    actor_data = $data.actors[id]
    @id = id

    @name = actor_data.name

    @equips = [] # extrapolate from data, combine weapon and armors!
    actor_data.slots.split(" | ").each{ |s|
      #@equips.
    }
    
    @skills = []
    actor_data.slots.split(" | ").each{ |s|

    }

    @level = 1
    @exp_list = Array.new(101)
    make_exp_list
    @exp = @exp_list[@level]

  end

  #--------------------------------------------------------------------------
  # * Calculate EXP
  #--------------------------------------------------------------------------
  def make_exp_list
    return
    actor = $data_actors[@actor_id]
    @exp_list[1] = 0
    pow_i = 2.4 + actor.exp_inflation / 100.0
    for i in 2..100
      if i > actor.final_level
        @exp_list[i] = 0
      else
        n = actor.exp_basis * ((i + 3) ** pow_i) / (5 ** pow_i)
        @exp_list[i] = @exp_list[i-1] + Integer(n)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Get Element Revision Value
  #     element_id : element ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # Get values corresponding to element effectiveness
    table = [0,200,150,100,50,0,-100]
    result = table[$data_classes[@class_id].element_ranks[element_id]]
    # If this element is protected by armor, then it's reduced by half
    for i in [@armor1_id, @armor2_id, @armor3_id, @armor4_id]
      armor = $data_armors[i]
      if armor != nil and armor.guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # If this element is protected by states, then it's reduced by half
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # End Method
    return result
  end
  

  #--------------------------------------------------------------------------
  # * Get Maximum HP
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 9999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 9999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Basic Maximum HP
  #--------------------------------------------------------------------------
  def base_maxhp
    return $data_actors[@actor_id].parameters[0, @level]
  end

  #--------------------------------------------------------------------------
  # * Get Basic Maximum SP
  #--------------------------------------------------------------------------
  def base_maxsp
    return $data_actors[@actor_id].parameters[1, @level]
  end

  #--------------------------------------------------------------------------
  # * Get Basic Strength
  #--------------------------------------------------------------------------
  def base_str
    n = $data_actors[@actor_id].parameters[2, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.str_plus : 0
    n += armor1 != nil ? armor1.str_plus : 0
    n += armor2 != nil ? armor2.str_plus : 0
    n += armor3 != nil ? armor3.str_plus : 0
    n += armor4 != nil ? armor4.str_plus : 0
    return [[n, 1].max, 999].min
  end

  #--------------------------------------------------------------------------
  # * Get Basic Attack Power
  #--------------------------------------------------------------------------
  def base_atk
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.atk : 0
  end

  #--------------------------------------------------------------------------
  # * Get Basic Physical Defense
  #--------------------------------------------------------------------------
  def base_pdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    pdef1 = weapon != nil ? weapon.pdef : 0
    pdef2 = armor1 != nil ? armor1.pdef : 0
    pdef3 = armor2 != nil ? armor2.pdef : 0
    pdef4 = armor3 != nil ? armor3.pdef : 0
    pdef5 = armor4 != nil ? armor4.pdef : 0
    return pdef1 + pdef2 + pdef3 + pdef4 + pdef5
  end

  #--------------------------------------------------------------------------
  # * Get Basic Magic Defense
  #--------------------------------------------------------------------------
  def base_mdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    # adjust mdef for shard upgrades
    mdef1 = weapon != nil ? weapon.mdef : 0
    mdef2 = armor1 != nil ? armor1.mdef : 0
    mdef3 = armor2 != nil ? armor2.mdef : 0
    mdef4 = armor3 != nil ? armor3.mdef : 0
    mdef5 = armor4 != nil ? armor4.mdef : 0
    return mdef1 + mdef2 + mdef3 + mdef4 + mdef5
  end

  #--------------------------------------------------------------------------
  # * Get Basic Evasion Correction
  #--------------------------------------------------------------------------
  def base_eva
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    eva1 = armor1 != nil ? armor1.eva : 0
    eva2 = armor2 != nil ? armor2.eva : 0
    eva3 = armor3 != nil ? armor3.eva : 0
    eva4 = armor4 != nil ? armor4.eva : 0
    return eva1 + eva2 + eva3 + eva4
  end

  #--------------------------------------------------------------------------
  # * Update Auto State
  #     old_armor : unequipped armor
  #     new_armor : equipped armor
  #--------------------------------------------------------------------------
  def update_auto_state(old_armor, new_armor)
    # Forcefully remove unequipped armor's auto state
    if old_armor != nil and old_armor.auto_state_id != 0
      remove_state(old_armor.auto_state_id, true)
    end
    # Forcefully add equipped armor's auto state
    if new_armor != nil and new_armor.auto_state_id != 0
      add_state(new_armor.auto_state_id, true)
    end
  end

  #--------------------------------------------------------------------------
  # * Change Equipment
  #     equip_type : type of equipment
  #     id    : weapon or armor ID (If 0, remove equipment)
  #--------------------------------------------------------------------------
  def equip(equip_type, id)
    case equip_type
    when 0  # Weapon
      if id == 0 or $game_party.weapon_number(id) > 0
        $game_party.gain_weapon(@weapon_id, 1)
        @weapon_id = id
        $game_party.lose_weapon(id, 1)
      end
    when 1  # Shield
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor1_id], $data_armors[id])
        $game_party.gain_armor(@armor1_id, 1)
        @armor1_id = id
        $game_party.lose_armor(id, 1)
      end
    when 2  # Head
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor2_id], $data_armors[id])
        $game_party.gain_armor(@armor2_id, 1)
        @armor2_id = id
        $game_party.lose_armor(id, 1)
      end
    when 3  # Body
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor3_id], $data_armors[id])
        $game_party.gain_armor(@armor3_id, 1)
        @armor3_id = id
        $game_party.lose_armor(id, 1)
      end
    when 4  # Accessory
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor4_id], $data_armors[id])
        $game_party.gain_armor(@armor4_id, 1)
        @armor4_id = id
        $game_party.lose_armor(id, 1)
      end
    end

  end

  #--------------------------------------------------------------------------
  # * Replace this with can_equip_wep?
  #--------------------------------------------------------------------------
  def equippable?(item)

    # If weapon
    if item.is_a?(WeaponData)
      # If included among equippable weapons in current class
      if $data_classes[@class_id].weapon_set.include?(item.id)
        return true
      end
    end

    # If armor
    if item.is_a?(RPG::Armor)
      # If included among equippable armor in current class
      if $data_classes[@class_id].armor_set.include?(item.id)
        return true
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Change EXP
  #     exp : new EXP
  #--------------------------------------------------------------------------
  def exp=(exp)
    @exp = [[exp, 9999999].min, 0].max
    # Level up
    while @exp >= @exp_list[@level+1] and @exp_list[@level+1] > 0
      @level += 1
      # Learn skill
      for j in $data_classes[@class_id].learnings
        if j.level == @level
          learn_skill(j.skill_id)
        end
      end
    end
    # Level down
    while @exp < @exp_list[@level]
      @level -= 1
    end
    # Correction if exceeding current max HP and max SP
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end

  #--------------------------------------------------------------------------
  # * Change Level
  #     level : new level
  #--------------------------------------------------------------------------
  def level=(level)
    # Check up and down limits
    level = [[level, $data_actors[@actor_id].final_level].min, 1].max
    # Change EXP
    self.exp = @exp_list[level]
  end

  #--------------------------------------------------------------------------
  # * Learn Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def learn_skill(skill_id)
    if skill_id > 0 and not skill_learn?(skill_id)
      @skills.push(skill_id)
      @skills.sort!
    end
  end

  #--------------------------------------------------------------------------
  # * Forget Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def forget_skill(skill_id)
    @skills.delete(skill_id)
  end

  #--------------------------------------------------------------------------
  # * Determine if Finished Learning Skill
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_learn?(skill_id)
    return @skills.include?(skill_id)
  end

end
"Ñ#==============================================================================
# ** Game_Battle
#==============================================================================

# Hold battle state

class Game_Battle

  attr_accessor :map, :weather

	def initialize
		@enemies = []
    @props = []
    @actor_index = 0

    @map = 26
	end

  def add(enemy)
    @enemies.push(Game_Enemy.new(enemy))
  end

  def start
$game.push_scene(Scene_Battle.new)
  end

  def win?
    return false
  end

  



  # CHOOSING TARGETS

	  #--------------------------------------------------------------------------
  # * Determine if for One Ally
  #--------------------------------------------------------------------------
  def for_one_friend?
    # If kind = skill, and effect scope is for ally (including 0 HP)
    if @kind == 1 and [3, 5].include?($data_skills[@skill_id].scope)
      return true
    end
    # If kind = item, and effect scope is for ally (including 0 HP)
    if @kind == 2 and [3, 5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  
  #--------------------------------------------------------------------------
  # * Determine if for One Ally (HP 0)
  #--------------------------------------------------------------------------
  def for_one_friend_hp0?
    # If kind = skill, and effect scope is for ally (only 0 HP)
    if @kind == 1 and [5].include?($data_skills[@skill_id].scope)
      return true
    end
    # If kind = item, and effect scope is for ally (only 0 HP)
    if @kind == 2 and [5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # * Random Target (for Actor)
  #--------------------------------------------------------------------------
  def decide_random_target_for_actor
    # Diverge with effect scope
    if for_one_friend_hp0?
      battler = $game_party.random_target_actor_hp0
    elsif for_one_friend?
      battler = $game_party.random_target_actor
    else
      battler = $game_troop.random_target_enemy
    end
    # If a target exists, get an index, and if a target doesn't exist,
    # clear the action
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Random Target (for Enemy)
  #--------------------------------------------------------------------------
  def decide_random_target_for_enemy
    # Diverge with effect scope
    if for_one_friend_hp0?
      battler = $game_troop.random_target_enemy_hp0
    elsif for_one_friend?
      battler = $game_troop.random_target_enemy
    else
      battler = $game_party.random_target_actor
    end
    # If a target exists, get an index, and if a target doesn't exist,
    # clear the action
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Last Target (for Actor)
  #--------------------------------------------------------------------------
  def decide_last_target_for_actor
    # If effect scope is ally, then it's an actor, anything else is an enemy
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_party.actors[@target_index]
    else
      battler = $game_troop.enemies[@target_index]
    end
    # Clear action if no target exists
    if battler == nil or not battler.exist?
      clear
    end
  end
  #--------------------------------------------------------------------------
  # * Last Target (for Enemy)
  #--------------------------------------------------------------------------
  def decide_last_target_for_enemy
    # If effect scope is ally, then it's an enemy, anything else is an actor
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_troop.enemies[@target_index]
    else
      battler = $game_party.actors[@target_index]
    end
    # Clear action if no target exists
    if battler == nil or not battler.exist?
      clear
    end
  end

end
  "3Q#==============================================================================
# ** Game_Battler (part 1)
#==============================================================================

# STATS

class Game_Battler
 
  attr_reader   :battler_name             # battler file name

  attr_reader   :hp                       # HP
  attr_reader   :mp                       # MP

  attr_reader   :states                   # states

  attr_accessor :immortal                 # immortal flag


  attr_accessor :critical                 # critical flag
  
  attr_accessor :collapsing               # collapsing


  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    @hp = 0
    @sp = 0

    @states = []
    @states_turn = {}

    @maxhp_plus = 0
    @maxsp_plus = 0
    @str_plus = 0
    @def_plus = 0


    @damage = nil
    @critical = false

    # Current action, remembers for next time also
    @skill_id = 0
    @item_id = 0
    @target_index = -1
    @action_selected = false

    @linked_char = 0 # will be set during battle

  end

  #--------------------------------------------------------------------------
  # * Get Current Experience Points
  #--------------------------------------------------------------------------
  def now_exp 
    return @exp - @exp_list[@level] 
  end
  
  #--------------------------------------------------------------------------
  # * Get Needed Experience Points
  #--------------------------------------------------------------------------
  def next_exp 
    return @exp_list[@level+1] > 0 ? @exp_list[@level+1] - @exp_list[@level] : 0 
  end

  #--------------------------------------------------------------------------
  # * Get Maximum HP
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 999999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Maximum SP
  #--------------------------------------------------------------------------
  def maxsp
    n = [[base_maxsp + @maxsp_plus, 0].max, 9999].min
    for i in @states
      n *= $data_states[i].maxsp_rate / 100.0
    end
    n = [[Integer(n), 0].max, 9999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Get Strength (STR)
  #--------------------------------------------------------------------------
  def str
    n = [[base_str + @str_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].str_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end

  #--------------------------------------------------------------------------
  # * Set Maximum HP
  #     maxhp : new maximum HP
  #--------------------------------------------------------------------------
  def maxhp=(maxhp)
    @maxhp_plus += maxhp - self.maxhp
    @maxhp_plus = [[@maxhp_plus, -9999].max, 9999].min
    @hp = [@hp, self.maxhp].min
  end

  #--------------------------------------------------------------------------
  # * Set Maximum SP
  #     maxsp : new maximum SP
  #--------------------------------------------------------------------------
  def maxsp=(maxsp)
    @maxsp_plus += maxsp - self.maxsp
    @maxsp_plus = [[@maxsp_plus, -9999].max, 9999].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # * Set Strength (STR)
  #     str : new Strength (STR)
  #--------------------------------------------------------------------------
  def str=(str)
    @str_plus += str - self.str
    @str_plus = [[@str_plus, -999].max, 999].min
  end
 
  #--------------------------------------------------------------------------
  # * Get Hit Rate
  #--------------------------------------------------------------------------
  def hit
    n = 100
    for i in @states
      n *= $data_states[i].hit_rate / 100.0
    end
    return Integer(n)
  end

  #--------------------------------------------------------------------------
  # * Get Attack Power
  #--------------------------------------------------------------------------
  def atk
    n = base_atk
    for i in @states
      n *= $data_states[i].atk_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Physical Defense Power
  #--------------------------------------------------------------------------
  def pdef
    n = base_pdef
    for i in @states
      n *= $data_states[i].pdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Magic Defense Power
  #--------------------------------------------------------------------------
  def mdef
    n = base_mdef
    for i in @states
      n *= $data_states[i].mdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # * Get Evasion Correction
  #--------------------------------------------------------------------------
  def eva
    n = base_eva
    for i in @states
      n += $data_states[i].eva
    end
    return n
  end

  #--------------------------------------------------------------------------
  # * Change HP
  #     hp : new HP
  #--------------------------------------------------------------------------
  def hp=(hp)
    @hp = [[hp, maxhp].min, 0].max
    # add or exclude incapacitation
    for i in 1...$data_states.size
      if $data_states[i].zero_hp
        if self.dead?
          add_state(i)
        else
          remove_state(i)
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Change SP
  #     sp : new SP
  #--------------------------------------------------------------------------
  def sp=(sp)
    @sp = [[sp, maxsp].min, 0].max
  end
  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    @sp = maxsp
    for i in @states.clone
      remove_state(i)
    end
  end


  def dead?() (@hp == 0 and not @immortal) end
  def exist?() (@hp > 0 or @immortal) end
  def hp0?() @hp == 0 end
  def inputable?() restriction <= 1 end
  def movable?() restriction < 4 end



  #--------------------------------------------------------------------------
  # * Check State
  #     state_id : state ID
  #--------------------------------------------------------------------------
  def state?(state_id)
    return @states.include?(state_id)
  end
  #--------------------------------------------------------------------------
  # * Add State
  #     state_id : state ID
  #     force    : forcefully added flag (used to deal with auto state)
  #--------------------------------------------------------------------------
  def add_state(state_id)
    @states.push(state_id)
  end
  #--------------------------------------------------------------------------
  # * Remove State
  #     state_id : state ID
  #     force    : forcefully removed flag (used to deal with auto state)
  #--------------------------------------------------------------------------
  def remove_state(id)
    @states.delete(id)
  end
  #--------------------------------------------------------------------------
  # * Get State Animation ID
  #--------------------------------------------------------------------------
  def state_anim
    # If no states are added
    if @states.size == 0
      return 0
    end
    # Return state animation ID with maximum rating
    return $data_states[@states[0]].animation_id
  end
  #--------------------------------------------------------------------------
  # * Get Restriction
  #--------------------------------------------------------------------------
  def restriction
    restriction_max = 0
    # Get maximum restriction from currently added states
    for i in @states
      if $data_states[i].restriction >= restriction_max
        restriction_max = $data_states[i].restriction
      end
    end
    return restriction_max
  end
  #--------------------------------------------------------------------------
  # â Has Restriction
  #   Determines if battler has a special restriction
  #--------------------------------------------------------------------------
  def has_restriction?(restriction)
    for i in @states
      if $data_states[i].restriction == restriction
        return true
      end
    end
    
    return false
  end

  #--------------------------------------------------------------------------
  # * Determine [Slip Damage] States
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Remove Battle States (called up during end of battle)
  #--------------------------------------------------------------------------
  def remove_states_battle
    for i in @states.clone
      if $data_states[i].battle_only
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Natural Removal of States (called up each turn)
  #--------------------------------------------------------------------------
  def remove_states_auto
    for i in @states_turn.keys.clone
      if @states_turn[i] > 0
        @states_turn[i] -= 1
      elsif rand(100) < $data_states[i].auto_release_prob
        remove_state(i)
      end
    end
  end

  #--------------------------------------------------------------------------
  # * State Removed by Shock (called up each time physical damage occurs)
  #--------------------------------------------------------------------------
  def remove_states_shock
    for i in @states.clone
      if rand(100) < $data_states[i].shock_release_prob
        remove_state(i)
      end
    end
  end

    #--------------------------------------------------------------------------
  # * Determine Usable Skills
  #     skill_id : skill ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    # If there's not enough SP, the skill cannot be used.
    if $data.skills[skill_id].sp_cost > self.sp
      return false
    end
    
    # If silent, only physical skills can be used
    if $data_skills[skill_id].atk_f == 0 and self.has_restriction?(1)
      return false
    end

    return true
  end

  #--------------------------------------------------------------------------
  # * Apply Skill Effects
  #     user  : the one using skills (battler)
  #     skill : skill
  #--------------------------------------------------------------------------
  def skill_effect(user, skill)
    # Clear critical flag
    self.critical = false
    # If skill scope is for ally with 1 or more HP, and your own HP = 0,
    # or skill scope is for ally with 0, and your own HP = 1 or more
    if ((skill.scope == 3 or skill.scope == 4) and self.hp == 0) or
       ((skill.scope == 5 or skill.scope == 6) and self.hp >= 1)
      # End Method
      return false
    end
    # Clear effective flag
    effective = false
    # Set effective flag if common ID is effective
    effective |= skill.common_event_id > 0
    # First hit detection
    hit = skill.hit
    if skill.atk_f > 0
      hit *= user.hit / 100
    end
    hit_result = (rand(100) < hit)
    # Set effective flag if skill is uncertain
    effective |= hit < 100
    # If hit occurs
    if hit_result == true
      # -------------------------------------------------------------------
      # AGF - See if a weapon can enhance a hero's attack -----------------
      # -------------------------------------------------------------------
      @userid = user.id
      @skillpower = skill.power     

      # Calculate power
      #agf - replaced skill.power with @skillpower for Lydia above
      power = @skillpower + user.atk * skill.atk_f / 100 
      if power > 0
        power -= self.pdef * skill.pdef_f / 200
        power -= self.mdef * skill.mdef_f / 200
        power = [power, 0].max
      end
      # Calculate rate
      rate = 20
      rate += (user.str * skill.str_f / 100)
      rate += (user.agi * skill.agi_f / 100)
      rate += (user.int * skill.int_f / 100)
      # Calculate basic damage
      self.damage = power * rate / 20
      # Element correction
      self.damage *= elements_correct(skill.element_set)
      self.damage /= 100
      # If damage value is strictly positive
      if self.damage > 0
        # Guard correction
        if self.guarding?
          self.damage /= 2
        end
      end
      # Dispersion
      if skill.variance > 0 and self.damage.abs > 0
        amp = [self.damage.abs * skill.variance / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # Second hit detection
      eva = 8 * self.agi / user.agi + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva * skill.eva_f / 100
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
      # Set effective flag if skill is uncertain
      effective |= hit < 100
    end
    # If hit occurs
    if hit_result == true
      # If physical attack has power other than 0
      if skill.power != 0 and skill.atk_f > 0
        # State Removed by Shock
        remove_states_shock
        # Set to effective flag
        effective = true
      end
      # Substract damage from HP
      last_hp = self.hp
      # agf: check difficulty level and adjust strength of attack
      mode_adjustment(user)
      
      self.hp -= self.damage
      effective |= self.hp != last_hp
      # State change
      @state_changed = false
      effective |= states_plus(skill.plus_state_set)
      effective |= states_minus(skill.minus_state_set)
      # If power is 0
      if skill.power == 0
        # Set damage to an empty string
        self.damage = ""
        # If state is unchanged (agf - added steal logic)
        unless @state_changed or skill.id == STEAL_SKILL_ID
          # Set damage to "Miss"
          self.damage = "Miss"
        end
      end
    # If miss occurs
    else
      # Set damage to "Miss"
      self.damage = "Miss"
    end
    # If not in battle
    unless $game_temp.in_battle
      # Set damage to nil
      self.damage = nil
    end
    # End Method
    self.critical = false if self.damage == "Miss"
    return effective
  end
  #--------------------------------------------------------------------------
  # * Application of Item Effects
  #     item : item
  #--------------------------------------------------------------------------
  def item_effect(item)
    # Clear critical flag
    self.critical = false
    # If item scope is for ally with 1 or more HP, and your own HP = 0,
    # or item scope is for ally with 0 HP, and your own HP = 1 or more
    if ((item.scope == 3 or item.scope == 4) and self.hp == 0) or
       ((item.scope == 5 or item.scope == 6) and self.hp >= 1)
      # End Method
      return false
    end
    # Clear effective flag
    effective = false
    # Set effective flag if common ID is effective
    effective |= item.common_event_id > 0
    # Determine hit
    hit_result = (rand(100) < item.hit)
    # Set effective flag is skill is uncertain
    effective |= item.hit < 100
    # If hit occurs
    if hit_result == true
      # Calculate amount of recovery
      recover_hp = maxhp * item.recover_hp_rate / 100 + item.recover_hp
      recover_sp = maxsp * item.recover_sp_rate / 100 + item.recover_sp
      if recover_hp < 0
        recover_hp += self.pdef * item.pdef_f / 20
        recover_hp += self.mdef * item.mdef_f / 20
        recover_hp = [recover_hp, 0].min
      end
      # Element correction
      recover_hp *= elements_correct(item.element_set)
      recover_hp /= 100
      recover_sp *= elements_correct(item.element_set)
      recover_sp /= 100
      # Dispersion
      if item.variance > 0 and recover_hp.abs > 0
        amp = [recover_hp.abs * item.variance / 100, 1].max
        recover_hp += rand(amp+1) + rand(amp+1) - amp
      end
      if item.variance > 0 and recover_sp.abs > 0
        amp = [recover_sp.abs * item.variance / 100, 1].max
        recover_sp += rand(amp+1) + rand(amp+1) - amp
      end
      # If recovery code is negative
      if recover_hp < 0
        # Guard correction
        if self.guarding?
          recover_hp /= 2
        end
      end
      # Set damage value and reverse HP recovery amount
      self.damage = -recover_hp
      # HP and SP recovery
      last_hp = self.hp
      last_sp = self.sp
      self.hp += recover_hp
      self.sp += recover_sp
      effective |= self.hp != last_hp
      effective |= self.sp != last_sp
      # State change
      @state_changed = false
      effective |= states_plus(item.plus_state_set)
      effective |= states_minus(item.minus_state_set)
      # If parameter value increase is effective
      # Shaz - don't allow SP increase for non-SP characters
      if item.parameter_type > 0 and item.parameter_points != 0 and
        (item.parameter_type != 2 or self.maxsp > 0)
        # Branch by parameter
        case item.parameter_type
        when 1  # Max HP
          @maxhp_plus += item.parameter_points
        when 2  # Max SP
          @maxsp_plus += item.parameter_points
        when 3  # Strength
          @str_plus += item.parameter_points
        when 4  # Dexterity
          #@dex_plus += item.parameter_points
        when 5  # Agility
          @agi_plus += item.parameter_points
        when 6  # Intelligence
          @int_plus += item.parameter_points
        end
        # Set to effective flag
        effective = true
      end
      # If HP recovery rate and recovery amount are 0
      if item.recover_hp_rate == 0 and item.recover_hp == 0
        # Set damage to empty string
        self.damage = ""
        # If SP recovery rate / recovery amount are 0, and parameter increase
        # value is ineffective.
        if item.recover_sp_rate == 0 and item.recover_sp == 0 and
           (item.parameter_type == 0 or item.parameter_points == 0)
          # If state is unchanged
          unless @state_changed
              self.damage = "Miss"
          end
        end
      end
    # If miss occurs
    else
      # Set damage to "Miss"
      self.damage = "Miss"
    end
    # If not in battle
    unless $game_temp.in_battle
      # Set damage to nil
      self.damage = nil
    end
    # End Method
    self.critical = false if self.damage == "Miss"
    return effective
  end

  #--------------------------------------------------------------------------
  # * Application of Slip Damage Effects
  #--------------------------------------------------------------------------
  def slip_damage_effect
    # Set damage
    self.damage = self.maxhp / 20 # 10
    # Dispersion
    if self.damage.abs > 0
      amp = [self.damage.abs * 15 / 100, 1].max
      self.damage += rand(amp+1) + rand(amp+1) - amp
    end
    # Subtract damage from HP
    self.hp -= self.damage
    # End Method
    return true
  end
  #--------------------------------------------------------------------------
  # * Calculating Element Correction
  #     element_set : element
  #--------------------------------------------------------------------------
  def elements_correct(element_set)
    # If not an element
    if element_set == []
      # Return 100
      return 100
    end
    # Return the weakest object among the elements given
    # * "element_rate" method is defined by Game_Actor and Game_Enemy classes,
    #    which inherit from this class.
    weakest = -100
    for i in element_set
      weakest = [weakest, self.element_rate(i)].max
    end
    return weakest
  end

end
"O


class Game_Enemy < Game_Battler

	def initialize(e)

	end

end"S#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  
  attr_reader   :x                        # map x-coordinate (logical)
  attr_reader   :y                        # map y-coordinate (logical)
  attr_reader   :real_x                   # map x-coordinate (real * 128) # For precision
  attr_reader   :real_y                   # map y-coordinate (real * 128)
  
  
  # Graphics

  attr_reader   :character_name           # character file name

  attr_accessor   :opacity                  # opacity level
  
  
  attr_accessor :direction                # direction
  attr_reader   :pattern                  # pattern
  attr_reader   :move_route_forcing       # forced move route flag
  attr_reader   :through                  # through
  attr_accessor :animation_id             # animation ID
  attr_accessor :transparent              # transparent flag
  attr_accessor :ignore_movement          # ignore movement when finding path
  attr_accessor :step_anime               # stop animation
  
  
  # Custom
  attr_accessor :off_x, :off_y
  
   
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @character_name = ""
    @direction = 2
    @pattern = 0

    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0

    @move_type = 0
    @move_speed = 3
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0

    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0 #how long has paused for between steps

    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
    @ignore_movement = false

    @opacity = 255
  end
  #--------------------------------------------------------------------------
  # * Determine if Moving
  #--------------------------------------------------------------------------
  def moving?
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # * Determine if Jumping
  #--------------------------------------------------------------------------
  def jumping?
    return @jump_count > 0
  end

  #--------------------------------------------------------------------------
  # * Straighten Position
  #--------------------------------------------------------------------------
  def straighten
    # If moving animation or stop animation is ON
    if @walk_anime or @step_anime
      # Set pattern to 0
      @pattern = 0
    end
    # Clear animation count
    @anime_count = 0
    # Clear prelock direction
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # * Force Move Route
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # Save original move route
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end
    # Change move route
    @move_route = move_route
    @move_route_index = 0
    # Set forced move route flag
    @move_route_forcing = true
    # Clear prelock direction
    @prelock_direction = 0
    # Clear wait count
    @wait_count = 0
    # Move cutsom
    move_type_custom
  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d) #d0 = jump

    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
       
    # If coordinates are outside of map
    return false unless $map.valid?(new_x, new_y)
    return true if @through
    
    # To new tile and from new tile
    return false unless $map.passable?(x, y, d, self)
    return false unless $map.passable?(new_x, new_y, 10 - d) 

    # end
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Determine if Can Fight 
  #--------------------------------------------------------------------------
  def canfight?()

    d = 2 if @x == $player.x and @y == $player.y - 1
    d = 8 if @x == $player.x and @y == $player.y + 1
    d = 4 if @y == $player.y and @x == $player.x + 1
    d = 6 if @y == $player.y and @x == $player.x - 1
    
    return passable?(x,y,d)

  end

  #--------------------------------------------------------------------------
  # * Lock
  #--------------------------------------------------------------------------
  def lock
    return if @locked
    @prelock_direction = @direction
    turn_toward_player
    @locked = true
  end

  #--------------------------------------------------------------------------
  # * Determine if Locked
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end

  #--------------------------------------------------------------------------
  # * Unlock
  #--------------------------------------------------------------------------
  def unlock
    return if !@locked

    # Clear locked flag
    @locked = false
    # If direction is not fixed
    unless @direction_fix
      # If prelock direction is saved
      if @prelock_direction != 0
        # Restore prelock direction
        @direction = @prelock_direction
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x 
    @y = y 
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end

  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    # Get screen coordinates from real coordinates and map display position
    return (@real_x - $map.display_x + 3) / 4 + 16
  end

  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    # Get screen coordinates from real coordinates and map display position
    y = (@real_y - $map.display_y + 3) / 4 + 32
    # Make y-coordinate smaller via jump count
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    return y - (@jump_peak * @jump_peak - n * n) / 2
  end
  #--------------------------------------------------------------------------
  # * Get Screen Z-Coordinates
  #     height : character height
  #--------------------------------------------------------------------------
  def screen_z(height = 0)

    # Some sort of below character here
    # return 0 if @always on bottom

    return 999 if @always_on_top

    # Get screen coordinates from real coordinates and map display position
    z = (@real_y - $map.display_y + 3) / 4 + 32

    # If height exceeds 32, then add 31
    return z #+ ((height > 32) ? 31 : 0)


  end

  #--------------------------------------------------------------------------
  # * Get Thicket Depth
  #--------------------------------------------------------------------------
  def bush_depth
    return 0 if @always_on_top
    return 0 if jumping?
    return 12 if $map.bush?(@x, @y)
    return 0
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #--------------------------------------------------------------------------
  def terrain_tag() return $map.terrain_tag(@x, @y) end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    # Mouse pathfinding
    run_path if @runpath == true
    
    # Branch with jumping, moving, and stopping
    if jumping?
      update_jump
    elsif moving?
      update_move
    else
      update_stop
    end

    # If animation count exceeds maximum value
    # * Maximum value is move speed * 1 taken from basic value 18
    if @anime_count > 18 - @move_speed * 2
      # If stop animation is OFF when stopping
      if not @step_anime and @stop_count > 0
        # Return to original pattern
        @pattern = @original_pattern
      # If stop animation is ON when moving
      else
        # Update pattern
        @pattern = (@pattern + 1) % 4
      end
      # Clear animation count
      @anime_count = 0
    end


    # If waiting
    if @wait_count > 0
      # Reduce wait count
      @wait_count -= 1
      return
    end


    # If move route is forced
    if @move_route_forcing
      # Custom move
      move_type_custom
      return
    end
    # When waiting for event execution or locked
    if @starting or lock?
      # Not moving by self
      return
    end

    # If stop count exceeds a certain value (computed from move frequency)
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # Branch by move type
      case @move_type
        when 1  # Random
          move_type_random
        when 2  # Approach
          move_type_toward_player
        when 3  # Custom
          move_type_custom
      end
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (jump)
  #--------------------------------------------------------------------------
  def update_jump
    # Reduce jump count by 1
    @jump_count -= 1
    # Calculate new coordinates
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)
  end

  #--------------------------------------------------------------------------
  # * Update frame (move)
  #--------------------------------------------------------------------------
  def update_move
    # Convert map coordinates from map move speed into move distance
    distance = 2 ** @move_speed
    # If logical coordinates are further down than real coordinates
    if @y * 128 > @real_y
      # Move down
      @real_y = [@real_y + distance, @y * 128].min
    end
    # If logical coordinates are more to the left than real coordinates
    if @x * 128 < @real_x
      # Move left
      @real_x = [@real_x - distance, @x * 128].max
    end
    # If logical coordinates are more to the right than real coordinates
    if @x * 128 > @real_x
      # Move right
      @real_x = [@real_x + distance, @x * 128].min
    end
    # If logical coordinates are further up than real coordinates
    if @y * 128 < @real_y
      # Move up
      @real_y = [@real_y - distance, @y * 128].max
    end

    # If move animation is ON
    if @walk_anime
      # Increase animation count by 1.5
      @anime_count += 1.5
    # If move animation is OFF, and stop animation is ON
    elsif @step_anime
      # Increase animation count by 1
      @anime_count += 1
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (stop)
  #--------------------------------------------------------------------------
  def update_stop
    # If stop animation is ON
    if @step_anime
      # Increase animation count by 1
      @anime_count += 1
    # If stop animation is OFF, but current pattern is different from original
    elsif @pattern != @original_pattern
      # Increase animation count by 1.5
      @anime_count += 1.5
    end
    # When waiting for event execution, or not locked
    # * If lock deals with event execution coming to a halt
    unless @starting or lock?
      @stop_count += 1
    end
  end
  
  #--------------------------------------------------------------------------
  # * Move Type : Random
  #--------------------------------------------------------------------------
  def move_type_random
    # Branch by random numbers 0-5
    case rand(6)
      when 0..3  # Random
        move_random
      when 4  # 1 step forward
        move_forward
      when 5  # Temporary stop
        @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # Get difference in player coordinates
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end

    # What if they follow more aggressively on harder difficulty?
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_toward_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end
  end

  #--------------------------------------------------------------------------
  # * Move Type : Custom
  #--------------------------------------------------------------------------
  def move_type_custom
    # Interrupt if not stopping
    return if jumping? or moving?

    # Loop until finally arriving at move command list
    while @move_route_index < @move_route.list.size

      # Acquiring move command
      command = @move_route.list[@move_route_index]

      # If command code is 0 (last part of list)
      if command.code == 0

        # Restart
        @move_route_index = 0 if @move_route.repeat

        # If [repeat action] option is OFF
        if !@move_route.repeat
          # If move route is forcing
          if @move_route_forcing

            # Release forced move route
            @move_route_forcing = false

            # Restore original move route
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # Clear stop count
          @stop_count = 0
        end
        return
      end

      # COL 1

      # During move command (from move down to jump)
      if command.code <= 14
        # Branch by command code
        case command.code
          when 1; move_down
          when 2  # Move left
            move_left
          when 3  # Move right
            move_right
          when 4  # Move up
            move_up
          when 5  # Move lower left
            move_lower_left
          when 6  # Move lower right
            move_lower_right
          when 7  # Move upper left
            move_upper_left
          when 8  # Move upper right
            move_upper_right
          when 9  # Move at random
            move_random
          when 10  # Move toward player
            move_toward_player
          when 11  # Move away from player
            move_away_from_player
          when 12  # 1 step forward
            move_forward
          when 13  # 1 step backward
            move_backward
          when 14  # Jump
            jump(command.parameters[0], command.parameters[1])
        end
        # If movement failure occurs when [Ignore if can't move] option is OFF
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end

      # If waiting
      if command.code == 15
        # Set wait count
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end

      # COL 2

      # If direction change command
      if command.code >= 16 and command.code <= 26
        # Branch by command code
        case command.code
        when 16  # Turn down
          turn_down
        when 17  # Turn left
          turn_left
        when 18  # Turn right
          turn_right
        when 19  # Turn up
          turn_up
        when 20  # Turn 90Â° right
          turn_right_90
        when 21  # Turn 90Â° left
          turn_left_90
        when 22  # Turn 180Â°
          turn_180
        when 23  # Turn 90Â° right or left
          turn_right_or_left_90
        when 24  # Turn at Random
          turn_random
        when 25  # Turn toward player
          turn_toward_player
        when 26  # Turn away from player
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end

      # COL 3

      # If other command
      if command.code >= 27
        # Branch by command code
        case command.code
        
        when 29  # Change speed
          @move_speed = command.parameters[0]
        when 30  # Change freq
          @move_frequency = command.parameters[0]
        when 31  # Move animation ON
          @walk_anime = true
        when 32  # Move animation OFF
          @walk_anime = false
        when 33  # Stop animation ON
          @step_anime = true
        when 34  # Stop animation OFF
          @step_anime = false
        when 35  # Direction fix ON
          @direction_fix = true
        when 36  # Direction fix OFF
          @direction_fix = false
        when 37  # Through ON
          @through = true
        when 38  # Through OFF
          @through = false
        when 39  # Always on top ON
          @always_on_top = true
        when 40  # Always on top OFF
          @always_on_top = false
        when 41  # Change Graphic
          @character_name = command.parameters[0]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # Change Opacity
          @opacity = command.parameters[0]
        when 43  # Change Blending
          @blend_type = command.parameters[0]
        when 44  # Play SE
          $game_system.se_play(command.parameters[0])
        when 45  # Script
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end


    end


  end

  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    # Clear stop count
    @stop_count = 0
  end



    #--------------------------------------------------------------------------
  # * Move Down
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)

    # Turn down
    if turn_enabled
      turn_down
    end
    # If passable
    if passable?(@x, @y, 2)

      # Turn down
      turn_down
      # Update coordinates
      @y += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered IF ENEMY ONLY
      #check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Left
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)
    # Turn left
    if turn_enabled
      turn_left
    end
    # If passable
    if passable?(@x, @y, 4)
      # Turn left
      turn_left
      # Update coordinates
      @x -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
      #check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Right
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)
    # Turn right
    if turn_enabled
      turn_right
    end
    # If passable
    if passable?(@x, @y, 6)
      # Turn right
      turn_right
      # Update coordinates
      @x += 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
     # check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move up
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)
    # Turn up
    if turn_enabled
      turn_up
    end
    # If passable
    if passable?(@x, @y, 8)
      # Turn up
      turn_up
      # Update coordinates
      @y -= 1
      # Increase steps
      increase_steps
    # If impassable
    else
      # Determine if touch event is triggered
     # check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Left
  #--------------------------------------------------------------------------
  def move_lower_left
    # If no direction fix
    unless @direction_fix
      # Face down is facing right or up
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # When a down to left or a left to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # Update coordinates
      @x -= 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Right
  #--------------------------------------------------------------------------
  def move_lower_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face down if facing up
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # When a down to right or a right to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # Update coordinates
      @x += 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Left
  #--------------------------------------------------------------------------
  def move_upper_left
    # If no direction fix
    unless @direction_fix
      # Face left if facing right, and face up if facing down
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # When an up to left or a left to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # Update coordinates
      @x -= 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Right
  #--------------------------------------------------------------------------
  def move_upper_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face up if facing down
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # When an up to right or a right to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # Update coordinates
      @x += 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move at Random
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # Move down
      move_down(false)
    when 1  # Move left
      move_left(false)
    when 2  # Move right
      move_right(false)
    when 3  # Move up
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * Move toward Player
  #--------------------------------------------------------------------------
  def move_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Move away from Player
  #--------------------------------------------------------------------------
  def move_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move away from player, prioritize left and right directions
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # If vertical distance is longer
    else
      # Move away from player, prioritize up and down directions
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Forward
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Backward
  #--------------------------------------------------------------------------
  def move_backward
    # Remember direction fix situation
    last_direction_fix = @direction_fix
    # Force directino fix
    @direction_fix = true
    # Branch by direction
    case @direction
    when 2  # Down
      move_up(false)
    when 4  # Left
      move_right(false)
    when 6  # Right
      move_left(false)
    when 8  # Up
      move_down(false)
    end
    # Return direction fix situation back to normal
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # * Jump
  #     x_plus : x-coordinate plus value
  #     y_plus : y-coordinate plus value
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # If plus value is not (0,0)
    if x_plus != 0 or y_plus != 0
      # If horizontal distnace is longer
      if x_plus.abs > y_plus.abs
        # Change direction to left or right
        x_plus < 0 ? turn_left : turn_right
      # If vertical distance is longer, or equal
      else
        # Change direction to up or down
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # Calculate new coordinates
    new_x = @x + x_plus
    new_y = @y + y_plus
    # If plus value is (0,0) or jump destination is passable
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # Straighten position
      straighten
      # Update coordinates
      @x = new_x
      @y = new_y
      # Calculate distance
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # Set jump count
      @jump_peak = 10 + distance - @move_speed
      @jump_count = @jump_peak * 2
      # Clear stop count
      @stop_count = 0
    end
  end

  #--------------------------------------------------------------------------
  # * Turns
  #--------------------------------------------------------------------------
  def turn_down() @direction = 2 unless @direction_fix end
  def turn_left() @direction = 4 unless @direction_fix end
  def turn_right() @direction = 6unless @direction_fix end
  def turn_up() @direction = 8 unless @direction_fix end
  
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Left
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 180Â°
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90Â° Right or Left
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # * Turn at Random
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Towards Player
  #--------------------------------------------------------------------------
  def turn_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Away from Player
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left away from player
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down away from player
      sy > 0 ? turn_down : turn_up
    end
  end

  #--------------------------------------------------------------------------
  # * Turn Towards Event
  #--------------------------------------------------------------------------
  def turn_toward_event(event_id)
    # Get difference in player coordinates
    evt = $map.events[event_id]
    return if evt == nil
    sx = @x - evt.x
    sy = @y - evt.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end

  def turn_toward_pos(x,y)

    sx = @x - x
    sy = @y - y

    # If coordinates are equal
    return if sx == 0 and sy == 0

    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end
  #   #--------------------------------------------------------------------------
#   # * Frame Update (run_path)
#   #--------------------------------------------------------------------------
  def run_path
    return if moving?
    step = @map[@x,@y]
    if step == 1
      @map = nil
      @runpath = false
      return
    end
      
    dir = rand(2)
    case dir
    when 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step -1 and step != 0
      move_up if @map[@x,@y-1] == step - 1 and step != 0
    when 1
      move_up if @map[@x,@y-1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step -1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
    end
  end

  #--------------------------------------------------------------------------
  # * Find Path
  #--------------------------------------------------------------------------
  def find_path(x,y)
    sx, sy = @x, @y
    @tx, @ty = x, y
    result = setup_map(sx,sy)
    @runpath = result[0]
    @map = result[1]
    @map[sx,sy] = result[2] if result[2] != nil
  end
  #--------------------------------------------------------------------------
  # * Clear Path
  #--------------------------------------------------------------------------
  def clear_path
    @map = nil
    @runpath = false
  end
  #--------------------------------------------------------------------------
  # * Setup Map
  #--------------------------------------------------------------------------
  def setup_map(sx,sy)
    map = Table.new($map.width, $map.height)

    update_counter = 0
    map[@tx,@ty] = 1
    old_positions = [[@tx, @ty]]
    new_positions = []

    depth = 2

    depth.upto(100){ |step|
      while !old_positions.empty?

        x,y = old_positions.shift

        #log_sys([x,y])

        if x == sx and y == sy
          log_scr("WINWINWINW")
          return [true, map, step-1] 
        end

        if map[x,y + 1] == 0 and passable?(x, y, 2) 
          #log_err "IN"
          map[x,y + 1] = step
          new_positions.push([x,y + 1])
        end

        if map[x - 1,y] == 0 and passable?(x, y, 4) 
          map[x - 1,y] = step
          new_positions.push([x - 1,y])
        end

        if map[x + 1,y] == 0 and passable?(x, y, 6) 
          map[x + 1,y] = step
          new_positions.push([x + 1,y])
        end

        if map[x,y - 1] == 0 and passable?(x, y, 8) 
          map[x,y - 1] = step
          new_positions.push([x,y - 1])
        end

      end

      old_positions = new_positions
      new_positions = []

      #log_info (old_positions)
    }
      
      log_err "FAILFAIL"
    return [false, nil, nil]     

  end


end
"õ!#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class deals with events. It handles functions including event page 
#  switching via condition determinants, and running parallel process events.
#  It's used within the Game_Map class.
#==============================================================================

class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :trigger                  # trigger
  attr_reader   :list                     # list of event commands
  attr_reader   :starting                 # starting flag
  
  attr_reader   :name

  attr_reader :above
  attr_reader :below
      
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     event  : event (RPG::Event)
  #--------------------------------------------------------------------------
  def initialize(event)
    super()

    @event = event
    @id = event.id
    
    @erased = false
    @disabled = $state.disable?(@id)
    @deleted = $state.delete?(@id)

    @starting = false
    @through = true
    @above = false
    @below = false

    @width = 1
    @height = 1

    # Name breakdown
    name = @event.name
    if name.include?('::')
      name = name.delete('::')
      clone = name
    end
    if name == '' || name == '#'
      @icon = nil
      @name = 'nil'
    else
      data = name.split('#').first.split('.')
      if data.size > 1
        @icon = data[0].strip
        @name = data[1].strip
      else
        @icon = @name = data[0].strip
      end
    end   
    
    # Set pages from clone or event
    if clone
      @pages = $data.clones[clone]
    else
      @pages = @event.pages 
    end

    # Restore saved location if relevant
    if $state.loc?(@id)
      loc = $state.getloc(@id)
      moveto(loc[0],loc[1])
    else
      moveto(@event.x, @event.y)
    end
    
    refresh
  end

  def at?(x,y)
    return self.x == x && self.y == y
  end

  #--------------------------------------------------------------------------
  # * Clear Starting Flag
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end

  def icon
    return nil if @erased || @disabled || @deleted
    return @icon
  end

  def collide?(x,y)
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine if Over Trigger
  #    is this event under player
  #--------------------------------------------------------------------------
  def over_trigger?
    # If not through situation with character as graphic
    if @character_name != "" and not @through
      # Starting determinant is face
      return false
    end
    # If this position on the map is impassable
    unless $map.passable?(@x, @y, 0)
      # Starting determinant is face
      return false
    end
    # Starting determinant is same position
    return true
  end

  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  def start  
    return if @erased || @deleted || @disabled
    return if !@list || @list.size < 1
    @starting = true    
  end

  def find_page
    return nil if @erased || @deleted
    @pages.reverse.find { |page| 
      conditions_met?(page) 
    } 
  end

  def conditions_met?(page)
      
        # DANHAX - check super conditions
        page.list.each{ |line|
      
          if line.code == 108
            comment = line.parameters[0]
            if comment[0] == '?'[0]
              data = comment.split(' ')
              if !condition_applies?(data)
                return false
              end
            end
          end        
        }  

        return true
  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    new_page = find_page
    setup_page(new_page) if new_page != @page
  end

  
  
  def setup_page(new_page)

    # Set @page as current event page
    @page = new_page
    if @page
      setup_page_settings
      read_comment_data
    else
      clear_page_settings
    end

    # Clear starting flag
    clear_starting
    
    # If trigger is [parallel process]
    if @trigger == 4
      @interpreter = Interpreter.new
      @interpreter.setup(@list, @event.id)
    end

    # Auto event start determinant
    check_event_trigger_auto

  end
  

  def clear_page_settings
      @character_name = ""
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
  end

  def setup_page_settings
    # Set each instance variable
    @character_name = @page.graphic.character_name
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    #XP - VX @opacity = @page.graphic.opacity
    #XP - VX @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    #XP - VX @always_on_top = @page.always_on_top
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil

  end
  
  def read_comment_data
    comment_data = []

    @list.each{ |line|
      next if line.code != 108
      if line.parameters[0].include?('#')
        comment_data.push(line.parameters[0].split(" "))
      end
    }

    comment_data.each{ |data|
      case data[0]

        when '#above'
          @above = true
        when '#below'
          @below = true
        when '#opacity'
          self.opacity = data[1].to_i
        when '#width'
          @width = data[1].to_i
        when '#height'
          @height = data[1].to_i
        when '#gfx'
          @character_name += "X/" + data[1]

      end
    }
    

  end

  #--------------------------------------------------------------------------
  # * Automatic Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # # If trigger is [touch from event] and consistent with player coordinates
    # if @trigger == 2 and @x == $player.x and @y == $player.y
    #   # If starting determinant other than jumping is same position event
    #   if not jumping? and over_trigger?
    #     start
    #   end
    # end
    # If trigger is [auto run]
    if @trigger == 3 || @event.name == 'AUTORUN'
      start
    end
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    # Automatic event starting determinant
    check_event_trigger_auto

    # If parallel process is valid
    if @interpreter != nil
      @interpreter.update
    end

  end
    
  #--------------------------------------------------------------------------
  # * Save Position
  #--------------------------------------------------------------------------
  def saveloc
    $state.loc!(@event.id)
  end

  #--------------------------------------------------------------------------
  # * Temporarily Erase
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    refresh
  end

  def disable
    @disabled = true
    $state.disable!(@id)
    refresh
  end

  def delete
    @deleted = true
    $state.delete!(@id)
    refresh
  end

end"U#==============================================================================
# ** Interpreter (part 1)
#------------------------------------------------------------------------------
#  This interpreter runs event commands. This class is used within the
#  Game_System class and the Game_Event class.
#==============================================================================

class Interpreter

  attr_accessor :common_event_id
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #     main  : main flag
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main

    @common_event_id = 0
    
    # Depth goes up to level 100
    if depth > 100
      print("Common event call has exceeded maximum limit.")
      exit
    end
    
    # Clear inner situation of interpreter
    clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Reset
  #   Remove any queued items 
  #--------------------------------------------------------------------------
  def reset
    @list = nil
  end
  
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # map ID when starting up
    @event_id = 0                     # event ID
    @message_waiting = false          # waiting for message to end
    @move_route_waiting = false       # waiting for move completion
    @wait_count = 0                   # wait count
    @child_interpreter = nil          # child interpreter
    @branch = {}                      # branch data
  end

  def this
    return $map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Event Setup
  #     list     : list of event commands
  #     event_id : event ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    
    # Clear inner situation of interpreter
    clear
    
    # Remember map ID
    @map_id = $map.id
    
    # Remember event ID
    @event_id = event_id
    
    # Remember list of event commands
    @list = list
    
    # Initialize index
    @index = 0
    
    # Clear branch data hash
    @branch.clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Current event (as event, not id)
  #--------------------------------------------------------------------------
  def event
    return $map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Running
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  
  #--------------------------------------------------------------------------
  # * Starting Event Setup
  #--------------------------------------------------------------------------
  def setup_starting_event
    
    # Refresh map if necessary
    if $map.need_refresh
      $map.refresh
    end
    
    # If common event call is reserved
    if @common_event_id > 0
      
      # Set up event
      setup($data.commons[@common_event_id].list, 0)
      
      # Release reservation
      @common_event_id = 0
      
      return
      
    end
    
    # Loop (map events)
    $map.starting_events.each{ |e| 

        # If not auto run
        if e.trigger < 3
          e.clear_starting
          e.lock          
        end
        
        # Set up event
        setup(e.list, e.id)
        
        return      
    }
    
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    
    # Initialize loop count
    @loop_count = 0
    
    # Loop
    loop do
      
      # Add 1 to loop count
      @loop_count += 1
      
      # If 100 event commands ran
      if @loop_count > 100
        # Call Graphics.update for freeze prevention
        Graphics.update
        @loop_count = 0
      end
      
      # If map is different than event startup time
      if $map.id != @map_id
        # Change event ID to 0
        @event_id = 0
      end
      
      # If a child interpreter exists, run it then check if done
      if @child_interpreter != nil
        @child_interpreter.update
        @child_interpreter = nil if !@child_interpreter.running?  
        return if @child_interpreter != nil        
      end
      
      # If waiting for message to end
      return if @message_waiting

      # Misc hud busy
      return if $scene.busy?

      # If waiting for move to end
      if @move_route_waiting

        # If player is forcing move route
        if $player.move_route_forcing
          return
        end
        
        # Loop (map events)
        for event in $map.events.values
          
          # If this event is forcing move route
          if event.move_route_forcing
            return
          end
          
        end
        
        # Clear move end waiting flag
        @move_route_waiting = false
        
      end
      
      # If waiting
      if @wait_count > 0
        # Decrease wait count
        @wait_count -= 1
        return
      end

      # If list of event commands is empty
      if @list == nil
        
        # If main map event
        if @main
          # Set up starting event
          setup_starting_event
        end
        
        # If nothing was set up
        if @list == nil
          return
        end
        
      end
      
      # If return value is false when trying to execute event command
      if execute_command == false
        return
      end
      
      # Advance index
      @index += 1
      
    end
  end

    #--------------------------------------------------------------------------
  # * Event Command Execution
  #--------------------------------------------------------------------------
  def execute_command
    
    # If last to arrive for list of event commands
    if @index >= @list.size - 1
      command_end
      return true
    end

    # Make event command parameters available for reference via @parameters
    @parameters = @list[@index].parameters
    
    # Branch by command code
    return true if @list[@index].code == 108
    send("command_"+@list[@index].code.to_s)
    
  end
  #--------------------------------------------------------------------------
  # * End Event
  #--------------------------------------------------------------------------
  def command_end
    # Clear list of event commands
    @list = nil
    # If main map event and event ID are valid
    if @main and @event_id > 0
      # Unlock event
      $map.events[@event_id].unlock
    end
  end

  #--------------------------------------------------------------------------
  # * Command Skip
  #--------------------------------------------------------------------------
  def command_skip
    # Get indent
    indent = @list[@index].indent
    # Loop
    loop do
      # If next event command is at the same level as indent
      if @list[@index+1].indent == indent
        # Continue
        return true
      end
      # Advance index
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # * Get Character
  #     parameter : parameter
  #--------------------------------------------------------------------------
  def get_character(parameter)
    # Branch by parameter
    case parameter
    when -1  # player
      return $player
    when 0  # this event
      events = $map.events
      return events == nil ? nil : events[@event_id]
    else  # specific event
      events = $map.events
      return events == nil ? nil : events[parameter]
    end
  end

  #--------------------------------------------------------------------------
  # * Calculate Operated Value
  #     operation    : operation
  #     operand_type : operand type (0: invariable 1: variable)
  #     operand      : operand (number or variable ID)
  #--------------------------------------------------------------------------
  def operate_value(operation, operand_type, operand)
    # Get operand
    if operand_type == 0
      value = operand
    else
      value = $game_variables[operand]
    end
    # Reverse sign of integer if operation is [decrease]
    if operation == 1
      value = -value
    end
    # Return value
    return value
  end


    def next_event_code
    @list[@index+1].code
  end

    #--------------------------------------------------------------------------
  # * Show Text
  #--------------------------------------------------------------------------
  def command_101

    message = []
    message.push(@list[@index].parameters[0])
    while next_event_code == 401
      @index += 1
      message.push(@list[@index].parameters[0])
    end

    message = message.join(' ')

    # If there is a choice next, add it
    if next_event_code == 102
      @index+=1
      while next_event_code == 402

      end
    end

    $scene.message.start(message)
    
    # Return mouse to default cursor
    #$mouse_sprite.set_bitmap(MouseCursor::Default_Cursor)
    
    # Continue
    return true

  end

  #--------------------------------------------------------------------------
  # * Wait
  #--------------------------------------------------------------------------
  def command_106
    @wait_count = @parameters[0]
    return true
  end

  #--------------------------------------------------------------------------
  # * Conditional Branch
  #--------------------------------------------------------------------------
  def command_111
    
    result = eval(@parameters[1])
    return true if result
  
    # Skip it
    @branch[@list[@index].indent] = result
    return command_skip
  
  end
  #--------------------------------------------------------------------------
  # * Else
  #--------------------------------------------------------------------------
  def command_411
    # If determinant results are false
    if @branch[@list[@index].indent] == false
      # Delete branch data
      @branch.delete(@list[@index].indent)
      # Continue
      return true
    end
    # If it doesn't meet the conditions: command skip
    return command_skip
  end
 
  #--------------------------------------------------------------------------
  # * Exit Event Processing
  #--------------------------------------------------------------------------
  def command_115
    command_end
    return true
  end

  #--------------------------------------------------------------------------
  # * Label
  #--------------------------------------------------------------------------
  def command_118
    return true
  end

  #--------------------------------------------------------------------------
  # * Jump to Label
  #--------------------------------------------------------------------------
  def command_119
    # Get label name
    label_name = @parameters[0]
    # Initialize temporary variables
    temp_index = 0
    # Loop
    loop do

      # If a fitting label was not found
      return true if temp_index >= @list.size-1

      # If this event command is a designated label name
      if @list[temp_index].code == 118 and
         @list[temp_index].parameters[0] == label_name
        # Update index
        @index = temp_index
        # Continue
        return true
      end
      # Advance index
      temp_index += 1
    end
  end

  #--------------------------------------------------------------------------
  # * Transfer Player
  #--------------------------------------------------------------------------
  def command_201

    # If transferring player, showing message, or processing transition
    return false if $player.transferring || $scene.busy?
    
    # If appointment method is [direct appointment]
    $player.queue_xfer(@parameters[1],@parameters[2],@parameters[3],@parameters[4])
    
    # Advance index
    @index += 1

    # If fade is set <---- CUT
    # if @parameters[5] == 0
    #   # Prepare for transition
    #   Graphics.freeze
    #   # Set transition processing flag
    #   $game_temp.transition_processing = true
    #   $game_temp.transition_name = ""
    # end

    # End
    return false
  end

  #--------------------------------------------------------------------------
  # * Set Event Location
  #--------------------------------------------------------------------------
  def command_202

    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # If appointment method is [direct appointment]
    if @parameters[1] == 0
      # Set character position
      character.moveto(@parameters[2], @parameters[3])
    # If appointment method is [appoint with variables]
    elsif @parameters[1] == 1
      # Set character position
      character.moveto($game_variables[@parameters[2]],
        $game_variables[@parameters[3]])
    # If appointment method is [exchange with another event]
    else
      old_x = character.x
      old_y = character.y
      character2 = get_character(@parameters[2])
      if character2 != nil
        character.moveto(character2.x, character2.y)
        character2.moveto(old_x, old_y)
      end
    end
    # Set character direction
    case @parameters[4]
      when 8  # up
        character.turn_up
      when 6  # right
        character.turn_right
      when 2  # down
        character.turn_down
      when 4  # left
        character.turn_left
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Map Settings
  #--------------------------------------------------------------------------
  def command_204
    case @parameters[0]
    when 0  # panorama
      $game_map.panorama_name = @parameters[1]
      $game_map.panorama_hue = @parameters[2]
    when 1  # fog
      $game_map.fog_name = @parameters[1]
      $game_map.fog_hue = @parameters[2]
      $game_map.fog_opacity = @parameters[3]
      $game_map.fog_blend_type = @parameters[4]
      $game_map.fog_zoom = @parameters[5]
      $game_map.fog_sx = @parameters[6]
      $game_map.fog_sy = @parameters[7]
    end
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Change Fog Opacity
  #--------------------------------------------------------------------------
  def command_206
    # Start opacity level change
    $game_map.start_fog_opacity_change(@parameters[0], @parameters[1] * 2)
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Show Animation
  #--------------------------------------------------------------------------
  def command_207
    # Get character
    character = get_character(@parameters[0])
    return true if character == nil

    # Set animation ID
    character.animation_id = @parameters[1]
    # Continue
    return true

  end
  #--------------------------------------------------------------------------
  # * Change Transparent Flag
  #--------------------------------------------------------------------------
  def command_208
    $game_player.transparent = (@parameters[0] == 0)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Move Route
  #--------------------------------------------------------------------------
  def command_209
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    return true if character == nil

    # Force move route - pushes on top of auto movers
    character.force_move_route(@parameters[1])
    return true
  end
  #--------------------------------------------------------------------------
  # * Wait for Move's Completion
  #--------------------------------------------------------------------------
  def command_210
    @move_route_waiting = true
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Change Screen Color Tone
  #--------------------------------------------------------------------------
  def command_223
    $game_screen.start_tone_change(@parameters[0], @parameters[1] * 2)
    return true
  end

  #--------------------------------------------------------------------------
  # * Set Weather Effects
  #--------------------------------------------------------------------------
  def command_236
    # Set Weather Effects
    $game_screen.weather(@parameters[0], @parameters[1], @parameters[2])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Play BGM
  #--------------------------------------------------------------------------
  def command_241
    # Play BGM
    $game_system.bgm_play(@parameters[0])
    # Continue
    return true
  end

  #--------------------------------------------------------------------------
  # * Fade Out BGM
  #--------------------------------------------------------------------------
  def command_242
    # Fade out BGM
    $game_system.bgm_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play BGS
  #--------------------------------------------------------------------------
  def command_245
    # Play BGS
    $game_system.bgs_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Fade Out BGS
  #--------------------------------------------------------------------------
  def command_246
    # Fade out BGS
    $game_system.bgs_fade(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Memorize BGM/BGS
  #--------------------------------------------------------------------------
  def command_247
    # Memorize BGM/BGS
    $game_system.bgm_memorize
    $game_system.bgs_memorize
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Restore BGM/BGS
  #--------------------------------------------------------------------------
  def command_248
    # Restore BGM/BGS
    $game_system.bgm_restore
    $game_system.bgs_restore
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play ME
  #--------------------------------------------------------------------------
  def command_249
    # Play ME
    $game_system.me_play(@parameters[0])
    # Continue
    return true
  end
  #--------------------------------------------------------------------------
  # * Play SE
  #--------------------------------------------------------------------------
  def command_250
    $audio.play_se(@parameters[0])
    return true
  end
  #--------------------------------------------------------------------------
  # * Stop SE
  #--------------------------------------------------------------------------
  def command_251
    # Stop SE
    Audio.se_stop
    # Continue
    return true
  end


  #--------------------------------------------------------------------------
  # * Shop Processing
  #--------------------------------------------------------------------------
  def command_302

    # Set shop calling flag
    $game_temp.shop_calling = true
    # Set goods list on new item
    $game_temp.shop_goods = [@parameters]
    # Loop
    loop do
      # Advance index
      @index += 1
      # If next event command has shop on second line or after
      if @list[@index].code == 605
        # Add goods list to new item
        $game_temp.shop_goods.push(@list[@index].parameters)
      # If event command does not have shop on second line or after
      else
        # End
        return false
      end
    end
  end


    #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    # Set first line to script
    script = @list[@index].parameters[0] + "\n"
    # Loop
    loop do
      # If next event command is second line of script or after
      if @list[@index + 1].code == 655
        # Add second line or after to script
        script += @list[@index + 1].parameters[0] + "\n"
      # If event command is not second line or after
      else
        # Abort loop
        break
      end
      # Advance index
      @index += 1
    end
    
    # Evaluation
    result = eval(script)

  rescue Exception => e

    line = e.message.split(":")[1].to_i      
    log_scr e.inspect

    lc = 0
      script.split("\n").each{ |s|
        if lc == line
          s = "---> "+s
        end
        log_scr s
        lc+=1
      }

    # Continue
    return true
     
  end

end
"+#==============================================================================
# ** Game_Map
#==============================================================================

class Game_Map

  # Keep the zone? 
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :tileset  
  
  # Drawing
  attr_accessor :display_x                # display x-coordinate * 128 # camera pos
  attr_accessor :display_y                # display y-coordinate * 128
  attr_accessor :target

  attr_accessor :need_refresh             # refresh request flag

  attr_reader   :map_name                 # name of the map

  attr_reader :interpreter

  attr_reader :id

  # Try to cut this
  attr_reader :events

  attr_reader :map

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @interpreter = Interpreter.new(0,true)
  end
  
  #--------------------------------------------------------------------------
  # * Setup
  #     map_id : map ID
  #--------------------------------------------------------------------------
  def setup(id)
    
    # Put map ID in @map_id memory
    @id = id
    
    # Load map from file and set @map
    @map = load_data(sprintf("Data/Map%03d.rxdata", @id))
    @map_name = $data.mapinfos[id].name 
        
    # Hold onto the tileset
    @tileset = $data.tilesets[@map.tileset_id]        
    @passages = @tileset.passages 
    
    # Initialize displayed coordinates
    @display_x = 0
    @display_y = 0
    @target = nil
    
    @need_refresh = false
    
    # Set map event data
    @events = {}
    @map.events.keys.each{ |i|
      @events[i] = Game_Event.new(@map.events[i])
    }

    # Disregard if battle map? or use battle zone?
    # Or various battle zones?

    # What is the zone
    autoplay = false
    newzone = get_zone(@id)
    if newzone != @zone.id

      @zone = $data.zones[newzone]
      log_info "Changing Zone: #{newzone}"

      if @zone.id == "@clear"
        $audio.bgm_stop
        $audio.bgs_stop
        autoplay = true
      elsif @zone.id == "@nil"
        # Play nothing do nothing
        autoplay = true
      else
        # Play music from the zone
        $audio.play(@zone.bgm)
        $audio.play(@zone.bgs)
        # Init tints and that
      end

    end
    
    # If a null or clear zone
    if autoplay
      $audio.bgm_play(@map.bgm) if @map.autoplay_bgm
      $audio.bgs_play(@map.bgs) if @map.autoplay_bgs
    end
    
  end

  #--------------------------------------------------------------------------
  # * Get Tileset ID
  #--------------------------------------------------------------------------
  def tileset_id() return @map.tileset_id end
  def width() return @map.width end
  def height() return @map.height end
  def data() return @map.data end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    @interpreter.update

    # Anti lag here
    @events.values.each{ |e| e.update }

    # Refresh map if necessary
    if @need_refresh
      @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

    # Camera update
    @target = $player

    # Camera update, maybe split to camera class
    if @target != nil

      @target_x = @target.real_x- (128 * 9.5)
      @target_y = @target.real_y- (128 * 7)

      if @target_x != @display_x
        @display_x += (@target_x-@display_x) * 0.5
      end

      if @target_y != @display_y
        @display_y += (@target_y-@display_y) * 0.5
      end

      @display_x = @target_x
      @display_y = @target_y

    end

    # Limit cam to screen
    @display_x = 0 if @display_x < 0
    @display_y = 0 if @display_y < 0

    w = ($map.width * 32) - $game.width
    h = ($map.height * 32) - $game.height

    #@display_x = w if @display_x > w
    #@display_y = w if @display_y > h



  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil)

    return false unless valid?(x, y)

    # Change direction (0,2,4,6,8,10) to obstacle bit (0,1,2,4,8,0)
    bit = (1 << (d / 2 - 1)) & 0x0f

    # Loop in all events
    events.values.each{ |e| 
      if e != self_event and e.at?(x,y)
         return false if !(e.through || e.above || e.below)
      end
    }

    # Loop searches in order from top of layer
    [2, 1, 0].each{ |i|

      tile_id = data[x, y, i]

      # If obstacle bit is set
      return false if @passages[tile_id] & bit != 0
        
      # If obstacle bit is set in all directions
      return false if @passages[tile_id] & 0x0f == 0x0f
        
      # If priorities other than that are 0
      return true if @tileset.priorities[tile_id] == 0

    }

    # passable
    return true

  end

  #--------------------------------------------------------------------------
  # * Determine Thicket
  #--------------------------------------------------------------------------
  def bush?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x40 == 0x40 }.empty? end
  def counter?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x80 == 0x80 }.empty? end
  def terrain_tag(x, y)
    [2,1,0].each{ |i| return @tileset.terrain_tags[data[x, y, i]] if data[x, y, i] != nil }
    return 0
  end

  #--------------------------------------------------------------------------
  # * Event At
  #--------------------------------------------------------------------------
  def valid?(x, y) x >= 0 and x < width and y >= 0 and y < height end
  def event_at(x, y) @events.values.find{ |e| e.at?(x,y) } end
  def events_at(x, y) @events.values.select{ |e| e.at?(x,y) } end
  def lowest_event_at(x, y) events_at(x,y).min_by{ |e| e.y } end
  def starting_events() @events.values.select{ |e| e.starting } end


  #--------------------------------------------------------------------------
  # Find the zone name for this map
  #--------------------------------------------------------------------------
  def get_zone(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return map_zone_or_nil(id)
  end

  def map_zone_or_nil(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return '@nil' if $data.mapinfos[id].parent_id == 0
    return map_zone_or_nil($data.mapinfos[id].parent_id)
  end

end"f##==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. Its functions include event starting
#  determinants and map scrolling. Refer to "$game_player" for the one
#  instance of this class.
#==============================================================================

class Game_Player < Game_Character

  attr_accessor :transferring      # player place movement flag

  def initialize
    super
    @character_name = "boyle"

    @transferring = false
    @xfer_data = nil
  end

  def queue_xfer(map,x,y,dir)
    @transferring = true
    @xfer_data = [map,x,y,dir]
  end

  #--------------------------------------------------------------------------
  # * Passable Determinants
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    if DEBUG and Input.press?(Input::CTRL)
      return true
    end
    super
  end

  #--------------------------------------------------------------------------
  # * Same Position Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.collide?(@x,@y) and triggers.include?(event.trigger)
      #if event.x == @x and event.y == @y and triggers.include?(event.trigger)
        # If starting determinant is same position event (other than jumping)
        if not event.jumping? and event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Front Envent Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    result = false
    # If event is running
    if $map.interpreter.running?
      return result
    end

    # Calculate front event coordinates
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    
    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(new_x,new_y) &&
         triggers.include?(event.trigger) and event.list.size > 1


        # If starting determinant is front event (other than jumping)
        if !event.jumping? and !event.over_trigger?
          event.start
          result = true
        end
      end
    end
    # If fitting event is not found

    # COUNTER CHECK

    if result == false

      # If front tile is a counter
      if $map.counter?(new_x, new_y)
        # Calculate 1 tile inside coordinates
        new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
        new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
        # All event loops
        for event in $map.events.values
          # If event coordinates and triggers are consistent
          if event.x == new_x and event.y == new_y and
             triggers.include?(event.trigger) and event.list.size > 1
            # If starting determinant is front event (other than jumping)
            if not event.jumping? and not event.over_trigger?
              event.start
              result = true
            end
          end
        end
      end
    end

    return result
  end

  #--------------------------------------------------------------------------
  # * Touch Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?
      
    result = false

    # All event loops
    for event in $map.events.values
      # If event coordinates and triggers are consistent
      if event.at?(x,y) and [1,2].include?(event.trigger)
        # If starting determinant is front event (other than jumping)
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    return if ($scene.busy?) || $debug.busy?
    return if $map.interpreter.running? or @move_route_forcing

    transfer_player if @transferring 

    # Unless Interpretter Running, Forcing a Route or Message Showing


    if $input.click?

        # Gets Mouse X & Y
        mx, my = *$mouse.grid

        log_info($map.display_x)
        
        # Turn Character in direction
        turn_toward_pos(mx,my)
        
        # Run Pathfinding
        evt = $map.lowest_event_at(mx, my)
#        if evt == nil
          find_path(mx, my)
          @eventarray = @runpath ? $map.events_at(mx, my) : nil
        # else
        #   find_path(evt.x, evt.y)
        #   @eventarray = [evt]
        # end
        
        # If Event At Grid Location
        unless @eventarray.nil?
          @eventarray = nil if @eventarray.empty?
        end
        
      end
    
    if @move_route_forcing == true
      clear_path
      @eventarray = nil
    end

    # Clear path if any direction keys pressed
    clear_path if $input.dir4 != 0
    
    # Remember whether or not moving in local variables
    last_moving = moving?
    # If moving, event running, move route forcing, and message window
    # display are all not occurring
    unless moving? || $map.interpreter.running? || @move_route_forcing
      case $input.dir4
        when 2; move_down
        when 4; move_left
        when 6; move_right
        when 8; move_up
      end
    end

    # Remember coordinates in local variables
    last_real_x = @real_x
    last_real_y = @real_y

    super
   
    # If not moving
    unless moving?
      # If player was moving last time
      if last_moving
        # Event determinant is via touch of same position event
        result = check_event_trigger_here([1,2])
      end
      # If C button was pressed
      if $input.action?
        # Same position and front event determinant
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
      end
    end
    
    # If Non-nil Event Autostarter
    if @eventarray != nil && !moving? && # @mouse_event_autostarter != nil && !moving? &&
      (!@ovrdest || @map.nil? || @map[@x,@y] == 1)

      @eventarray.each do |event|
      
        # If Event Within Range
        # if event and (event.at?(@x,@y) || @ovrdest
          
        #   # SHAZ - trigger event when:
        #   # - Autotouch and standing on or beside, or with a counter between
        #   # - player/event touch and standing as close as possible (on, if possible)
        #   distance = Math.hypot(@x - event.x, @y - event.y)

        #   dir = @x < event.x ? 6 : @x > event.x ? 4 : @y < event.y ? 2 : @y > event.y ? 8 : 0

        #   # if (event.trigger == 0 and (distance < 2 or (distance == 2 and 
        #   #   $map.counter?((@x+event.x)/2, (@y+event.y)/2))))             or ([1,2].include?(event.trigger) and ((distance == 0 and $game_player.passable?(@x, @y, dir))             or (distance == 1 and (@ovrdest || !$game_player.passable?(@x, @y, dir)))))

        #   #   # Turn toward Event
        #   #   if @x == event.x
        #   #     @y > event.y ? turn_up : turn_down
        #   #   else
        #   #     @x > event.x ? turn_left : turn_right
        #   #   end

        #   #   # Start Event
        #   #   clear_path
        #   #   event.start
        #   #   @eventarray.delete(event)
        #   #   @eventarray = nil if @eventarray.empty?

        #   # end
        # end
      end      
    end
    

  end

  #--------------------------------------------------------------------------
  # * Teleport the Player
  #--------------------------------------------------------------------------
  def transfer_player
   
    @transferring = false
    $player.clear_path

    # Map to teleport to 
    if $map.id != @xfer_data[0]
      $map.setup(@xfer_data[0])      
    end

    # Location on the map to teleport to
    $player.moveto(@xfer_data[1],@xfer_data[2])
    $player.direction = @xfer_data[3]
    $player.straighten  

    # AUTO SAVING

    # autosave your game (but not on the ending map)
   # if !ENDING_MAPS.include?($game_map.map_id)
   #   save = Scene_Save.new(1)
   #   save.autosave      
   # end
    
  end

end
"h


# Menu state
# Hold cursor positions, current character etc etc etc

class MenuData

end"#==============================================================================
# ** Game_Party
#==============================================================================

class Game_Party

  attr_accessor :active                  # actors
  attr_accessor :reserve                  # reserve party

  attr_reader   :gold                     # amount of gold

  attr_accessor :all_actors

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    # Create all actors    
    @actors = {}
    $data.actors.each{ |k,v| @actors[k] = Game_Actor.new(k) }    

    # Create actor array
    @active = []
    @reserve = []

    # Initialize amount of gold
    @gold = 0

    # Create amount in possession hash for items, weapons, and armor
    @items = {}
    @weapons = {}
    @armors = {}
    
    # TEMP DISABLE
    set_active("boy")
    set_active("ing")
    set_active("mys")
    set_active("rob")

  end

  #--------------------------------------------------------------------------
  # * Getting Maximum Level
  #--------------------------------------------------------------------------
  def max_level
    return @actors.max_by(&:level).level
  end

  def get(actor)
    return @actors[actor]
  end

  #--------------------------------------------------------------------------
  # * Add an Actor
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def set_active(actor)

    # if @active.size < 4 and not @actors.include?(actor)
      
      @active.push(actor)

    # end
   # if !@active.include?(actor)
   #    @reserve.push(actor)
   #  end

  end

  def set_reserve(actor)
    @reserve.push(actor)
  end

  def back_to_pavillion(actor)
    @actors.delete(actor)
    @reserve.delete(actor)
  end

  #--------------------------------------------------------------------------
  # * Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def add_item(id,n) add(@items,id,n) end
  def lose_item(item,n) add(@items,id,n) end
  def item_number(id) count(@items,id) end
  def has_item?(id) count(type,id) > 0 end



  def add(type,id,number)
    type.has_key?(id) ? type[id] += number : type[id] = number
  end

  def count(type,id)
    return type.has_key?(id) ? type[id] : 0
  end

  #--------------------------------------------------------------------------
  # * Determine Everyone is Dead
  #--------------------------------------------------------------------------
  def all_dead?
    return @active.select{ |a| @actors[a].hp > 0}.empty?
  end

  #--------------------------------------------------------------------------
  # * Slip Damage Check (for map)
  #--------------------------------------------------------------------------
  def check_map_slip_damage
    for actor in @active + @reserve
      if actor.hp > 0 and actor.slip_damage?
        actor.hp -= [actor.maxhp / 100, 1].max
        if actor.hp == 0
          $audio.play_se($data_system.actor_collapse_se)
        end
        $map.world.start_flash(Color.new(255,0,0,128), 4)
        $temp.gameover = $party.all_dead?
      end
    end
  end

  #--------------------------------------------------------------------------
  # * Random Selection of Target Actor
  #     hp0 : limited to actors with 0 HP
  #--------------------------------------------------------------------------
  def random_target_actor(hp0 = false)
    # Initialize roulette
    roulette = []
    # Loop
    for actor in @actors
      # If it fits the conditions
      if (not hp0 and actor.exist?) or (hp0 and actor.hp0?)
        # Get actor class [position]
        position = $data_classes[actor.class_id].position
        # Front guard: n = 4; Mid guard: n = 3; Rear guard: n = 2
        n = 4 - position
        # Add actor to roulette n times
        n.times do
          roulette.push(actor)
        end
      end
    end
    # If roulette size is 0
    if roulette.size == 0
      return nil
    end
    # Spin the roulette, choose an actor
    return roulette[rand(roulette.size)]
  end

  #--------------------------------------------------------------------------
  # * Random Selection of Target Actor (HP 0)
  #--------------------------------------------------------------------------
  def random_target_actor_hp0
    return random_target_actor(true)
  end
  
  #--------------------------------------------------------------------------
  # * Smooth Selection of Target Actor
  #     actor_index : actor index
  #--------------------------------------------------------------------------
  def smooth_target_actor(actor_index)
    # Get an actor
    actor = @actors[actor_index]
    # If an actor exists
    if actor != nil and actor.exist?
      return actor
    end
    # Loop
    for actor in @actors
      # If an actor exists
      if actor.exist?
        return actor
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # â check if actor is in party
  #--------------------------------------------------------------------------  
  def has_actor?(actor)
    return @active.include?(actor)
  end

  #--------------------------------------------------------------------------
  # â check if all actors are 'normal' state
  #--------------------------------------------------------------------------  
  def all_normal
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        if (actor.states & ([1] + BAD_STATES)).size > 0 # non-shield status inflicted
          return false
        end
      end
    end
    
    return true
  end

  #--------------------------------------------------------------------------
  # â remove inflictions
  #--------------------------------------------------------------------------  
  def remove_inflictions()
    for i in 0..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil && $game_player.is_present(actor.id)
        for state in BAD_STATES
          actor.remove_state(state, true)
        end
      end
    end
  end

  #--------------------------------------------------------------------------
  # â Actor Lineup
  #   Provides a list of party members
  #-------------------------------------------------------------------------- 
  def actor_lineup()
    @lineup = []
    for i in 1..LAST_ACTOR_ID
      actor = @all_actors[i]
      if actor != nil and !@lineup.include?(actor) && $game_player.is_present(actor.id)
        @lineup.push(actor)
      end
    end
  end
        
end"ìclass Progress

	attr_accessor :quests, :complete
	attr_accessor :progress


	def initialize
		@quests = []
		@complete = []
		@progress = 0
	end

	def add_quest(q)
		@quests.push(q)
	end

	def end_quest(q)
		@quests.delete(q)
		@complete.push(q)
	end

	def quest_active?(q)
		return @quests.include?(q)
	end

	def quest_done?(q)
		return @complete.include?(q)
	end


	def progress!(progress)
		@progress= $data.progress[progress]
	end

	def progress?(progress)
	    return false if !$data.progress.include?(progress)
		return @progress >= $data.progress[progress]
	end

	def beyond?(progress)
		return false if !$data.progress.include?(progress)
		return @progress > $data.progress[progress]
	end

end
"class State

	def initialize

		@flags = []
		@vars = {}

		# Event modifiers
		@states = {} # Event states
		@locs = {}
		@deleted = []
		@disabled = []

		# Menu indexes?

	end

	def flag!(f)
		@flags.push(f) if !@flags.include?(f)
	end

	def unflag!(f)
		@flags.delete(f)
	end

	def flag?(f)
		return @flags.include?(f)
	end

	def var!(v,a)
		if @vars.has_key?(v)
			@vars[v] += a
		else
			@vars[v] = a
		end
	end

	def unvar!(v,a)
		if @vars.has_key?(v)
			@vars[v] -= a
		else
			@vars[v] = -a
		end
	end

	def var?(v,t)
		return false if !@vars.has_key?(v)
		return @vars[v] >= t
	end

	def state!(e,s)
		@states[[$map.id,e,s]] = true
	end

	def unstate!(e,s)
		@states[[$map.id,e,s]] = false
	end

	def state?(e,s)
		return false if !@states.has_key?([$map.id,e,s])
		return @states[[$map.id,e,s]]
	end

	def loc!(e)
		@locs[[$map.id,e]] = [e.x,e.y]
	end

	def loc?(e)
		return @locs.has_key?([$map.id,e])			
	end

	def getloc(e)
		return @locs[[$map.id,e]]
	end

	def delete!(e)
		@deleted.push([$map.id,e])
	end

	def delete?(e)
		return @deleted.include?([$map.id,e])
	end

	def disable!(e)
		@disabled.push([$map.id,e])
	end

	def disable?(e)
		return @disabled.include?([$map.id,e])
	end

end
"¥#==============================================================================
# ** Scene_Map
#==============================================================================

# Phases

# :none

# :introduction - introduction seq

# :enemy_cmd
# :party_cmd
# :actor_cmd - choose actions

# :main - perform actions

# :victory - player wins
# :defeat - enemy wins

class Scene_Battle

  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    Graphics.freeze

    @vp = Viewport.new(0, 0, $game.width, $game.height)
    @vp_hud = Viewport.new(0, 0, $game.width, $game.height)

    @vp.z = 6000  
    @vp_hud.z = 75000

    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = Cache.menu("tempback")

    @map = Game_Map.new()
    @map.setup($battle.map)

    @player = Game_Player.new
    $player = @player
    @player.moveto(5,5)

        @map.update
        @player.update
        @map.update

        #@map.target = @player

    @tilemap = MapWrap.new(@vp) 
    #@tilemap.z = 500

    
    @tilemap.update

    refresh_tileset

    @hud = BattleHud.new(@vp_hud)

    # @character_sprites.push(Sprite_Character.new(@vp_main, @player))

    # Prepare characters
    (1..4).each{ |c|
      @map.events[c].direction = 4
    }


    Graphics.transition(50,'Graphics/System/trans')  
            
  end
  
  def terminate
    @character_sprites.each{ |s| s.dispose }
    
  end

  def busy?
    return false
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update


    @player.update

    $battle.update
        @tilemap.ox = @map.display_x / 4
    @tilemap.oy = @map.display_y / 4
    @tilemap.update

    @map.display_x = 0
    @map.display_y = 0

    # Update character sprites
    @character_sprites.each{ |s|
      #log_info s.character.character_name
      s.update
      #s.x = 50
      #s.y = 50
    }

  end

def update
    case @phase
      when :introduction
        update_phase_introduction
      when :enemy_cmd
        update_phase_enemy_cmd
      when :party_cmd
        update_phase_party_cmd
      when :actor_cmd
        update_phase_actor_cmd
      when :map
        update_phase_main
      when :victory
        update_phase_victory
      when :defeat
        update_phase_defeat
    end
  end

  def change_phase(ph)
    @phase = ph
    case @phase
      when :introduction
        start_phase_introduction
      when :enemy_cmd
        start_phase_enemy_cmd
      when :party_cmd
        start_phase_party_cmd
      when :actor_cmd
        start_phase_actor_cmd
      when :map
        start_phase_main
      when :victory
        start_phase_victory
      when :defeat
        start_phase_defeat
    end
  end





  def start_phase_introduction

    # Prepare something

  end

  def update_phase_introduction

    # After some time, move on to enemy_cmd

    change_phase(:enemy_cmd)

  end

  def start_phase_enemy_cmd

    # Select skills for each enemy


    change_phase(:party_cmd)

  end

  def update_phase_enemy_cmd
    # Not used
  end

  def start_phase_party_cmd
    
    # Show the visuals!

    change_phase(:actor_cmd)

  end

  def update_phase_party_cmd
    # Not used
  end

  def start_phase_actor_cmd
    # What is this even for?    
    @actor_idx = 0

    # Open the ui
    $scene.hud.open_actor_cmd($party.actor(@actor_idx))

  end

  def actor_skill_select(cmd)

  end

  def actor_skill_cancel

  end

  def update_phase_actor_cmd

    # Player command inputs section
    
    

    # that's about it?
    # show the ui? how?

    $party.clear_actions

  end

  

  def start_phase_main

    # Prep list of actions

  end

  def update_phase_main

  end




  def start_phase_victory

  end

  def update_phase_victory

  end

  def start_phase_defeat

  end

  def update_phase_defeat

  end




  #--------------------------------------------------------------------------
  # * Refresh Tileset
  #--------------------------------------------------------------------------
  def refresh_tileset
    @tileset_id = @map.tileset_id
    @tilemap.refresh(@map)

    #@character_sprites.each{ |s| s.dispose }
     @character_sprites = []

    for i in @map.events.keys.sort
      sprite = Sprite_Character.new(@vp_hud, @map.events[i])
      @character_sprites.push(sprite)
      sprite.x = 50
      sprite.y = 50
    end

    @character_sprites.push(Sprite_Character.new(@vp_hud, @player))

    # @character_sprites.push(Sprite_Character.new(@vp_main, @player))

  end

end"#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Map

  attr_reader   :tone                     # color tone
  attr_reader   :weather_type             # weather type
  attr_reader   :weather_max              # max number of weather sprites
  
  attr_reader :message

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    @map = Game_Map.new
    $map = @map
    @map.setup($data.system.start_map_id)

    @player = Game_Player.new
    $player = @player
    @player.moveto($data.system.start_x, $data.system.start_y)

    @map.target = @player

    # Make viewports - Also in the scene
    @vp_main = Viewport.new(0, 0, $game.width, $game.height)   

    # Make tilemap
    @tilemap = MapWrap.new(@vp_main)    

    #@panorama = Plane.new(@vp_main,-1000)
    #@fog = Plane.new(@vp_main,3000)

    @character_sprites = []

    @tileset_id = 0 # move to tilemap? or cut stupid system

    @hud = Ui_Screen.new

    @message = Ui_Message.new


    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0

    # weather in map data
    @weather_type = 0
    @weather_max = 0.0
    @weather_type_target = 0
    @weather_max_target = 0.0
    @weather_duration = 0    

    Graphics.transition
            
  end
  
  def terminate    

    # Dispose of tilemap    
    @tilemap.dispose
    @panorama.dispose
    @fog.dispose
    @hud.dispose

    @character_sprites.each{ |s| s.dispose }
    @weather.dispose

    # Dispose of viewports
    @vp_main.dispose

  end

  def busy?
    return @hud.busy? || @message.busy?
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update

    @map.update      
    @player.update

    @hud.update
    @message.update

    # check for changes
    refresh_tileset if $map.tileset_id != @tileset_id
    #refresh_panorama if @panorama_name != @map.tileset.panorama_name
    #refresh_fog if @fog_name != @map.tileset.fog_name

    # Update tilemap
    @tilemap.ox = @map.display_x / 4
    @tilemap.oy = @map.display_y / 4
    @tilemap.update

    # Update panorama plane
    #@panorama.ox = 0 # $map.display_x / 8
    #@panorama.oy = 0 # $map.display_y / 8

    # Update fog plane
    # @fog.zoom_x = @map.tileset.fog_zoom / 100.0
    # @fog.zoom_y = @map.tileset.fog_zoom / 100.0
    # @fog.opacity = @map.tileset.fog_opacity
    # @fog.ox = @map.display_x / 4
    # @fog.oy = @map.display_y / 4    

    # # Update character sprites
    @character_sprites.each{ |s|
      s.update
    }

    if @tone_duration >= 1
      d = @tone_duration
      @tone.red = (@tone.red * (d - 1) + @tone_target.red) / d
      @tone.green = (@tone.green * (d - 1) + @tone_target.green) / d
      @tone.blue = (@tone.blue * (d - 1) + @tone_target.blue) / d
      @tone.gray = (@tone.gray * (d - 1) + @tone_target.gray) / d
      @tone_duration -= 1
    end

    if @weather_duration >= 1
      d = @weather_duration
      @weather_max = (@weather_max * (d - 1) + @weather_max_target) / d
      @weather_duration -= 1
      if @weather_duration == 0
        @weather_type = @weather_type_target
      end
    end

    # Update weather graphic
    # @weather.type = $game_screen.weather_type
    # @weather.max = $game_screen.weather_max
    # @weather.ox = $map.display_x / 4
    # @weather.oy = $map.display_y / 4
    # @weather.update

    # Set screen color tone and shake position
    @vp_main.tone = @tone

    # Open Menu at player's request
    unless @map.interpreter.running? or @hud.busy?

      # Check inputs
      if Input.trigger?(Input::F7)
        $game.push_scene(Scene_Menu.new)
      end

      if Input.trigger?(Input::F8)
        $game.push_scene(Scene_Battle.new)
      end
        
    end
    
  end

  #--------------------------------------------------------------------------
  # * Refresh Tileset
  #--------------------------------------------------------------------------
  def refresh_tileset
    
     @tileset_id = $map.tileset_id
     @tilemap.refresh(@map)

    @character_sprites.each{ |s| s.dispose }
    @character_sprites = []

    for i in @map.events.keys.sort
      sprite = Sprite_Character.new(@vp_main, @map.events[i])
      @character_sprites.push(sprite)
    end

    @character_sprites.push(Sprite_Character.new(@vp_main, @player))

  end

  def refresh_panorama
      @panorama_name = $map.tileset.panorama_name
      if @panorama.bitmap != nil
        @panorama.bitmap.dispose
        @panorama.bitmap = nil
      end
      if @panorama_name != ""
        @panorama.bitmap = Cache.panorama(@panorama_name)
      end
      Graphics.frame_reset
  end


  def refresh_fog
      @fog_name = $map.tileset.fog_name
      if @fog.bitmap != nil
        @fog.bitmap.dispose
        @fog.bitmap = nil
      end
      if @fog_name != ""
        @fog.bitmap = Cache.fog(@fog_name)
      end
      Graphics.frame_reset
  end


  #--------------------------------------------------------------------------
  # * Start Changing Color Tone
  #     tone : color tone
  #     duration : time
  #--------------------------------------------------------------------------
  def start_tone_change(tone, duration)
    @tone_target = tone.clone
    @tone_duration = duration
    if @tone_duration == 0
      @tone = @tone_target.clone
    end
  end

  #--------------------------------------------------------------------------
  # * Set Weather
  #--------------------------------------------------------------------------
  def weather(type, power, duration)
    @weather_type_target = type
    if @weather_type_target != 0
      @weather_type = @weather_type_target
    end
    if @weather_type_target == 0
      @weather_max_target = 0.0
    else
      @weather_max_target = (power + 1) * 4.0
    end
    @weather_duration = duration
    if @weather_duration == 0
      @weather_type = @weather_type_target
      @weather_max = @weather_max_target
    end
  end

end"K#==============================================================================
# ** Scene_Menu
#==============================================================================

class Scene_Menu
  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    Graphics.freeze

    # Vp
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 5000

    # Background
    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = Cache.menu("tempback")

    # The current menu
    @menu = Mnu_File.new(@vp)

    Graphics.transition(50,'Graphics/System/trans')            
  end
  
  def terminate

    @menu.dispose
    @bg.dispose

  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    $game.pop_scene if Input.trigger?(Input::F7)

    @menu.update     
    
  end

end" " "ê#==============================================================================
# ** Audio Manager
#==============================================================================

class AudioManager

  def initialize
  	@bgm = nil
  	@bgs = nil
  end

  # send_blank to force start music
  def play_bgm(bgm)
    @bgm = bgm
    return if !$settings.music
    if !FileTest.exists?("Audio/BGM/" + se.name)
      return log_err("Missing Music: #{bgm.name}")
    end
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def play_bgs(bgs)
	  @bgm = bgm
	  return if !$settings.music
    Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
  end

  def stop_bgm
    Audio.bgm_stop
  end

  def stop_bgs
    Audio.bgs_stop
  end

  def fadeout_bgm(time)
    @bgm = nil
    Audio.bgm_fade(time * 1000)
  end
  
  def fadeout_bgs(time)
    @bgs = nil
    Audio.bgs_fade(time * 1000)
  end

  def play_me(me)
  	return if !$settings.music
    if !FileTest.exists?("Audio/ME/" + me.name)
      return log_err("Missing ME: #{me.name}")
    end
    Audio.me_play("Audio/ME/" + me.name, me.volume, me.pitch)
  end

  def play_se(se)
    return if !$settings.sound
    if !FileTest.exists?("Audio/SE/" + se.name)
      return log_err("Missing Sound: #{se.name}")
    end
    Audio.se_play("Audio/SE/" + se.name, se.volume, se.pitch)
  end

  #--------------------------------------------------------------------------
  # * Turn on music
  #--------------------------------------------------------------------------
  def enable_music
    Audio.bgm_play("Audio/BGM/" + @bgm.name, @bgm.volume, @bgm.pitch)
    Audio.bgs_play("Audio/BGS/" + @bgs.name, @bgs.volume, @bgs.pitch)
  end     
  
  #--------------------------------------------------------------------------
  # * Turn off music
  #--------------------------------------------------------------------------
  def disable_music
      stop_bgm
      stop_bgs
  end     

end"
  module Cache

    def self.animation(filename, hue)
      self.load_bitmap("Graphics/Animations/", filename, hue)
    end
    def self.autotile(filename)
      self.load_bitmap("Graphics/Autotiles/", filename)
    end
    def self.character(filename, hue)
      self.load_bitmap("Graphics/Characters/", filename, hue)
    end
    def self.cursor(filename)
      self.load_bitmap("Graphics/Cursors/", filename)
    end
    def self.face(filename)
      self.load_bitmap("Graphics/Faces/", filename)
    end
    def self.fog(filename, hue)
      self.load_bitmap("Graphics/Fogs/", filename, hue)
    end
    def self.icon(filename)
      self.load_bitmap("Graphics/Icons/", filename)
    end
    def self.menu(filename)
      self.load_bitmap("Graphics/Menus/", filename)
    end
    def self.panorama(filename, hue)
      self.load_bitmap("Graphics/Panoramas/", filename, hue)
    end
    def self.picture(filename)
      self.load_bitmap("Graphics/Pictures/", filename)
    end
    def self.tileset(filename)
      self.load_bitmap("Graphics/Tilesets/", filename)
    end
    def self.title(filename)
      self.load_bitmap("Graphics/Titles/", filename)
    end
    def self.windowskin(filename)
      self.load_bitmap("Graphics/Windowskins/", filename)
    end
    def self.tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end

    @cache = {}
    def self.load_bitmap(folder_name, filename, hue = 0)
      path = folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          @cache[path] = Bitmap.new(path)
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def self.clear
      @cache = {}
      GC.start
    end
  end



module RPG
  module Cache

    def self.animation(filename, hue)
      self.load_bitmap("Graphics/Animations/", filename, hue)
    end
    def self.autotile(filename)
      self.load_bitmap("Graphics/Autotiles/", filename)
    end
    def self.character(filename, hue)
      self.load_bitmap("Graphics/Characters/", filename, hue)
    end
    def self.cursor(filename)
      self.load_bitmap("Graphics/Cursors/", filename)
    end
    def self.face(filename)
      self.load_bitmap("Graphics/Faces/", filename)
    end
    def self.fog(filename, hue)
      self.load_bitmap("Graphics/Fogs/", filename, hue)
    end
    def self.icon(filename)
      self.load_bitmap("Graphics/Icons/", filename)
    end
    def self.menu(filename)
      self.load_bitmap("Graphics/Menus/", filename)
    end
    def self.panorama(filename, hue)
      self.load_bitmap("Graphics/Panoramas/", filename, hue)
    end
    def self.picture(filename)
      self.load_bitmap("Graphics/Pictures/", filename)
    end
    def self.tileset(filename)
      self.load_bitmap("Graphics/Tilesets/", filename)
    end
    def self.title(filename)
      self.load_bitmap("Graphics/Titles/", filename)
    end
    def self.windowskin(filename)
      self.load_bitmap("Graphics/Windowskins/", filename)
    end
    def self.tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end

    @cache = {}
    def self.load_bitmap(folder_name, filename, hue = 0)
      path = folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          @cache[path] = Bitmap.new(path)
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def self.clear
      @cache = {}
      GC.start
    end
  end
end"F#==============================================================================
# ** Data Manager
#==============================================================================

class DataManager

  # JsonData
	attr_reader :items
  attr_reader :weapons
  attr_reader :armors

  attr_reader :actors
  attr_reader :enemies
  attr_reader :skills
  attr_reader :states

  attr_reader :progress
  attr_reader :quests
  attr_reader :zones

  # Clone events
  attr_reader :clones

  # RxData
  attr_reader :commons
  attr_reader :tilesets
  attr_reader :system
  attr_reader :mapinfos

	def initialize

    # Create an icon list
    create_icon_list if DEBUG

    # Load up json data
    
    @items = load_json("items",ItemData).merge(load_json("keyitems",ItemData))
    @weapons = load_json("weapons",WeaponData)
    @armors = load_json("armors",ArmorData)

    @actors = load_json("actors",ActorData)
    @enemies = load_json("enemies",EnemyData)
    @skills = load_json("skills",SkillData)
    @states = load_json("states",StateData)
    
    @progress = load_json("progress",ProgressData)
    @quests = load_json("quests",QuestData)
    @zones = load_json("zones",ZoneData)

    @clones = load_clones
    @funcs = load_funcs

		# Convert to json
    @commons = load_data("Data/CommonEvents.rxdata")
    @tilesets = load_data("Data/Tilesets.rxdata")
    @system = load_data("Data/System.rxdata")
    @mapinfos = load_data("Data/MapInfos.rxdata")

	end

  def create_icon_list

    list = Dir.glob('Graphics/Icons/**/*').select{ |e| File.file? e }
    list.each_index { |i|
      list[i] = list[i].gsub("Graphics/Icons/","")
      list[i] = list[i].gsub(".png","")
    }

    File.open('Editor/icons.json', 'w') { |file|
      file.puts("[")
      list.each{ |l| file.puts("\""+l+"\",") }
      file.puts("\"\"")
      file.puts("]")
    }

  end

  def load_clones

    clones = {}
    map = load_data("Data/Map001.rxdata")

    map.events.each{ |k,ev|
      clones[ev.name.split("#")[0].rstrip!] = ev.pages
    }

    return clones

  end

  def load_funcs

    funcs = {}
    map = load_data("Data/Map002.rxdata")

    map.events.each{ |k,ev|
      
      ev.pages.each{ |p|
        name = ''
        p.list.each{ |cmd|
          if cmd.code == 108 && cmd.parameters[0].include?("%")
            name = cmd.parameters[0]
          end
        }
        next if !name
        funcs[name] = p.list
      }
      
    }

    return funcs

  end

  def load_json(file,type)

    # Load from rxdata if not debug
    if !DEBUG
      return load_data("Data/Json/#{file}.rxdata")
    end

    # Clear out garbage files
    process_data_files(file)

    # If there is no data file, make blank
    if !FileTest.exist?("Editor/json/#{file}.json")
      log_sys "Missing data file: #{file}.json"
      return {}
    end

    # Load up the data
    json_data = File.read("Editor/json/#{file}.json")
    json_data = json_data.gsub(/[:]/, '=>')
    json_data = eval(json_data)

  
    # Create datas
    data = {}
    json_data.each{ |v|
      item = type.new
      v.each{ |var,val|
        # Attempt to convert val to int or float

        item.instance_variable_set("@#{var}", val)
      }
      data[item.id] = item
      
    }

    # Export to rxdata for later
    save_data(data,"Data/Json/#{file}.rxdata")

    return data

  end

  def process_data_files(file)

    # RIGHT, START AT 50 DOWN TO NOTHING! WHEN FOUND REPLACE THE BASE
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        # Found it! Delete the base and rename this one
        File.delete("Editor/json/#{file}.json")
        File.rename("Editor/json/#{file}(#{idx}).json","Editor/json/#{file}.json")
        break
      end
      idx -= 1
    end

    # Delete any with brackets
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        File.delete("Editor/json/#{file}(#{idx}).json")
      end      
      idx -= 1
    end

  end

 end"X#==============================================================================
# ** Debug
#==============================================================================

def log_err(msg) $debug.log(msg,'ERROR') end
def log_scr(msg) $debug.log(msg,'SCRIPT') end
def log_info(msg) $debug.log(msg,'INFO') end
def log_sys(msg) $debug.log(msg,'SYSTEM') end
def log_ev(msg) $debug.log(msg,'EVENT') end

class DebugManager

	OSD_OPACITY = 240

	INFO_COLOR = Color.new(220,171,1,OSD_OPACITY)
	SCRIPT_COLOR = Color.new(128,0,64,OSD_OPACITY)
	ERROR_COLOR = Color.new(202,0,0,OSD_OPACITY)
	SYSTEM_COLOR = Color.new(128,0,128,OSD_OPACITY)
	EVENT_COLOR = Color.new(0,128,128,OSD_OPACITY)

	attr_reader :last_color

	def initialize		
		return if !DEBUG

		$DEBUG = true

		# Prepare log file
		@path = $appdata + "\\log.txt"
		File.open(@path, 'w') { |file| }	

		
		# Prepare on screen log
		@viewport = Viewport.new(0,0,640,480)
		@viewport.z = 8888
		
		@console = DebugConsole.new(@viewport)

		@menu = DebugMenu.new(@viewport)

		@last_color = INFO_COLOR

	end	

	def update
		return if !DEBUG

		@console.update if !@menu.active?
		@menu.update if !@console.active?

	end



	def log(msg,type='LOG')
	    return if !DEBUG

	    msg = "NIL" if msg == nil
	    if msg.is_a?(Array)
	    	msg = "Array: "+msg.join(", ")
	    end
	    if msg.is_a?(Hash)

	    end
		out = type + "\t" + msg.to_s
		File.open(@path, 'a') { |file| file.puts(out) }

		out = msg.to_s
		color = nil

		case type
			when 'INFO'; color = INFO_COLOR
			when 'SCRIPT'; color = SCRIPT_COLOR
			when 'ERROR'; color = ERROR_COLOR
			when 'SYSTEM'; color = SYSTEM_COLOR
			when 'EVENT'; color = EVENT_COLOR
		end

		@console.log([out,color])

		@last_color = color

	end

	def busy?
		return @console.active? || @menu.active?
	end
end"Ó#==============================================================================
# ** Save File Manager
#==============================================================================

# 99 save files
class FileManager
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def any_save_files?
    !Dir.glob('Av4-*.save').empty?
  end
  
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def file_exists?(which)
    file = 'Av4-'+which+'.save'
    File.exist?($appPath + file)
  end
  
  #--------------------------------------------------------------------------
  # * Create Filename
  #--------------------------------------------------------------------------
  def make_filename()
    file = "Av4-"+$settings.value('active')+".dean"
    return $appdata + file
  end

  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  def save_game
    File.open(make_filename(), "wb") { |file|
      header = make_save_header  
      body = make_save_contents
      Marshal.dump(header, file)
      Marshal.dump(body, file)
      @last_savefile_index = index
    }
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Execute Load (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_game
    File.open(make_filename(), "rb") do |file|
      Marshal.load(file)
      extract_save_contents(Marshal.load(file))
      reload_map_if_updated
      @index = index
    end
    return true
  end
  
  #--------------------------------------------------------------------------
  # * Load Save Header (No Exception Processing)
  #--------------------------------------------------------------------------
  def load_header
    File.open(make_filename(), "rb") do |file|
      return Marshal.load(file)
    end
    return nil
  end
  
  #--------------------------------------------------------------------------
  # * Delete Save File
  #--------------------------------------------------------------------------
  def delete_save_file()
    File.delete(make_filename()) rescue nil
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Header
  #--------------------------------------------------------------------------
  def make_save_header
    header = {}
    header[:progress] = 140
    #header[:characters] = $game_party.characters_for_savefile
    #header[:playtime_s] = $game_system.playtime_s
    header
  end
  
  #--------------------------------------------------------------------------
  # * Create Save Contents
  #--------------------------------------------------------------------------
  def make_save_contents
    contents = {}
    contents[:state]       = $state
    contents[:progress]         = $progress
    contents[:party]      = $party
    contents[:battle]     = $battle

    contents[:map]        = $map
    contents[:player]        = $player
    contents
  end
  
  #--------------------------------------------------------------------------
  # * Extract Save Contents
  #--------------------------------------------------------------------------
  def extract_save_contents(contents)
    $journal       = contents[:journal]
    $flags         = contents[:flags]
    $switches      = contents[:switches]
    $variables     = contents[:variables]
    $states        = contents[:states]
    $harvey        = contents[:harvey]
  end
  
  #--------------------------------------------------------------------------
  # * Get Update Date of Save File
  #--------------------------------------------------------------------------
  def savefile_time_stamp()
    File.mtime(make_filename()) rescue Time.at(0)
  end
  
  #--------------------------------------------------------------------------
  # * Get File Index with Latest Update Date
  #--------------------------------------------------------------------------
  def latest_savefile_index
    savefile_max.times.max_by {|i| savefile_time_stamp(i) }
  end
  
end
"?#==============================================================================
# ** Game Manager
#==============================================================================

class GameManager

  attr_reader :width, :height

	def initialize

    $game = self

    # Setup font
    Font.default_size = 22
    Font.default_name = "Consolas"

    if ACE_MODE
      Font.default_outline = false
      Font.default_shadow = true
    end

    Graphics.frame_rate = 60
    #resize(853,480)
    resize(640,480)

    @scenes = []

    # Game State Objects
    $progress = Progress.new
    $state = State.new
    $party = Game_Party.new
    $battle = Game_Battle.new    

    # Make scene object (title screen)
    if DEBUG && $settings.debug_skip_title
      push_scene(Scene_Map.new)    
    else
      push_scene(Scene_Splash.new)
    end

  end

  def resize(w,h)
    @width = w
    @height = h
    if ACE_MODE
    Graphics.resize_screen(w,h)
    end
    #set_rez(w,h)
  end

  def push_scene(scene)
    $scene = scene
    @scenes.unshift(scene)
  end

  def pop_scene
    @scenes.shift.terminate
    $scene = @scenes[0]
  end

  def quit?
    return false
  end

  def update

    $keyboard.update
    $mouse.update
    $debug.update
    $tweens.update
    Graphics.update
    Input.update
    @scenes[0].update

  end

  def flip_window
    showm = Win32API.new('user32', 'keybd_event', %w(l l l l), '')
    showm.call(18,0,0,0)
    showm.call(13,0,0,0)
    showm.call(13,0,2,0)
    showm.call(18,0,2,0)
  end

end"¹#============================================================================== 
# ** Input
#==============================================================================

class InputManager

	def dir4
		return 2 if $keyboard.state?(VK_DOWN)
		return 4 if $keyboard.state?(VK_LEFT)
		return 6 if $keyboard.state?(VK_RIGHT)
		return 8 if $keyboard.state?(VK_UP)
		return 0
	end

	def action?
		return $keyboard.press?(VK_ENTER) ||
			   $keyboard.press?(VK_SPACE) 
	end

	def click?
		return $keyboard.press?(VK_LBUTTON)
	end

	def cancel?
		return $keyboard.press?(VK_ESC)
	end

	def shortcut?(s)

	end

	def shift?
		return $keyboard.state?(VK_SHIFT)
	end

end"0#==============================================================================
# ** Keyboard Manager
#==============================================================================


VK_LBUTTON = 1

VK_BS = 8
VK_TAB = 9
VK_ENTER = 13
VK_SHIFT = 16
VK_ESC = 27
VK_SPACE = 32
VK_TILDE = 192

VK_LEFT = 37
VK_UP = 38
VK_RIGHT = 39
VK_DOWN = 40

class KeyboardManager

	KeyState = Win32API.new("user32","GetKeyState",['i'],'i')
	
	def initialize
		@keys = {}
	end

	def state?(key)
		check = KeyState.call(key) #& 0x80 == 128
		return !(check == 1 || check == 0)
	end

	def press?(key)
	  if !@keys.has_key?(key) && state?(key)
	  	@keys[key] = Graphics.frame_count
	  	return true
	  else
	  	return false
	  end
	end 

  def hold?(key)
    return true if press?(key)
    if @keys.has_key?(key)
      if (Graphics.frame_count - @keys[key]) % 8 == 7
        return true
      end
    end
    return false
  end 

  def down?(key)
    return state?(key)
  end

  def up?(key)
    return !state?(key)
  end

	def update
		@keys.delete_if { |k,v| !state?(k)}
	end

	  # http://www.mods.com.au/budapi_docs/Virtual%20Key%20Codes.htm

  def to_char(key)

    shift = $input.shift?

    case key

      when 32; " "
      when 48; shift ? ')' : '0'
      when 49; shift ? '!' : '1'
      when 50; shift ? '@' : '2'
      when 51; shift ? '#' : '3'
      when 52; shift ? '$' : '4'
      when 53; shift ? '%' : '5'
      when 54; shift ? '^' : '6'
      when 55; shift ? '&' : '7'
      when 56; shift ? '*' : '8'
      when 57; shift ? '(' : '9'

      when 65..90; shift ? key.chr.upcase : key.chr.downcase

      when 186; shift ? ':' : ';' 
      when 187; shift ? '+' : '=' 
      when 188; shift ? '<' : ',' 
      when 189; shift ? '_' : '-' 
      when 190; shift ? '>' : '.' 
      when 191; shift ? '?' : '/' 
      
      when 219; shift ? '{' : '[' 
      when 220; shift ? '|' : '\\'
      when 221; shift ? '}' : ']' 
      when 222; shift ? '"' : '\''

      else; ''

    end

  end

end"û#============================================================================== 
# ** Modules.Mouse Input (7.0)              By Near Fantastica & SephirothSpawn
#==============================================================================

class MouseManager

  #--------------------------------------------------------------------------
  # * API Declaration
  #--------------------------------------------------------------------------
  Cursor_Pos = Win32API.new('user32', 'GetCursorPos', 'p', 'i')
  ShowCursor = Win32API.new('user32', 'ShowCursor', 'i', 'l')
  Scr2cli = Win32API.new('user32', 'ScreenToClient', %w(l p), 'i')
  Findwindow = Win32API.new('user32', 'FindWindowA',%w(p p),'l')

  def initialize
    @pos = [0,0]
    @hwnd = Findwindow.call(nil, "Aveyond")
    @sprite = Sprite.new()
    @sprite.z = 10100
    @sprite.ox = 4
    change_cursor("Default")
  end
  
  def position() @pos; end
  def grid() 
    x = (@pos[0] + $map.display_x / 128) / 32
    y = (@pos[1] + $map.display_y / 128) / 32
    return [x.to_i,y.to_i]
  end
  def on_screen?() !(@pos[0] < 0 || @pos[1] < 0 || @pos[0] >= 640 || @pos[1] >= 480); end
        
  #--------------------------------------------------------------------------
  # * Update Mouse Position
  #--------------------------------------------------------------------------
  def update
    
    # Update Position
    pos = [0,0].pack('ll')
    Cursor_Pos.call(pos)
    Scr2cli.call(@hwnd, pos) 
    @pos = pos.unpack('ll')

    # Update sprite pos
    @sprite.x = @pos[0]
    @sprite.y = @pos[1]

    ShowCursor.call(0)#on_screen?.to_i) # on_screen && mouse_mode
    
  end

  def change_cursor(c)
    @sprite.bitmap = Cache.cursor(c)
  end

end

#==============================================================================
# ** Sprite_Mouse
#==============================================================================

class Sprite_Mouse < Sprite

  #--------------------------------------------------------------------------
  # ** Frame Update : Update Event Cursors
  #--------------------------------------------------------------------------
  def update_event_cursors
    
    # If Nil Grid Position
    if Mouse.grid.nil? 
      # Set Default Cursor
      set_bitmap(MouseCursor::Default_Cursor)
      return
    end
    
    # Gets Mouse Position
    x, y = *Mouse.grid
    
    # Gets Mouse Position
    mx, my = *Mouse.position    
    
    # Gets Mouse Event
    event = $game_map.lowest_event_at(x, y)
    
    # If Non-Nil Event or not over map HUD
    unless event.nil? || my >= 448
      # If Not Erased or Nil List
      if event.list != nil && event.erased == false && event.list[0].code == 108
        # Get the cursor to show
        icon = nil
        event.list[0].parameters.to_s.downcase.gsub!(/icon (.*)/) do
          icon = $1.to_s
        end
        
        if !((icon == "talk") || 
           (icon == "touch") || 
           (icon == "fight") || 
           (icon == "examine") || 
           (icon == "point") ||
           (icon == "exit"))
           icon = MouseCursor::Default_Cursor
        end        
        xNPCname = nil 
        if event.list.size > 1 && event.list[1].code == 108
          text = event.list[1].parameters.to_s
          text.gsub!(/[Nn][Aa][Mm][Ee] (.*)/) do
            xNPCname = $1.to_s
          end
        end
        set_bitmap(icon, xNPCname)  
        #self.x = self.x - self.bitmap.width + 24 if self.x + self.bitmap.width > 640
        if event.name != "BOTTOM" # and ["Arrow2", "Arrow4"].include?(icon)
          self.y -= 8
        end
        return
      end
      return
    end
    
    # Set Default Cursor
    set_bitmap(MouseCursor::Default_Cursor)
    
  end
end
"}#==============================================================================
# ** Game_Settings
#==============================================================================

class SettingsManager

  attr_accessor :music
  attr_accessor :sound
  attr_accessor :window
  attr_accessor :effects
  attr_accessor :mouse

  attr_accessor :debug_skip_title
  attr_accessor :debug_fps
  

  # In settings
  attr_accessor :last_file_index          # last save file no.

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize

    # Defaults
    @music = false
    @sound = true
    @window = false
    @effects = false
    @mouse = false

    # Debug options - keys 1-9
    @debug_skip_title = true
    @debug_show_fps = 40
        
    # Load from settings file real quick   
    File.open($appdata+'\settings.txt', "r").each do |line|
      dta = line.split(" ")
      val = dta[1]
      if val.to_i.to_s == val
        val = val.to_i
      elsif val.to_f.to_s == val
        val = val.to_f
      elsif val == "true"
        val = true
      elsif val == "false"
        val = false
      end
      self.instance_variable_set(dta[0],val)
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Get/Set Settings
  #--------------------------------------------------------------------------
  def save() 
    File.open($appdata+'\settings.txt', 'w') { |file|  
      # Write some stats      
      self.instance_variables.each{ |var|
        next if !DEBUG && var.to_s.include?("debug")
        file.puts(var.to_s+" "+self.instance_variable_get(var).to_s)
      }
    }
  end

  def conclude
    @window = Win32API.new('Utils', "IsFullScreen", ["V"], "I").call
  end

end"Ò#==============================================================================
# ** Nano Manager
#==============================================================================

class TweenManager

	def initialize
		@tweens = []
		@last = Time.now
	end

	def update

		# calc delta
		delta = ((Time.now - @last) * 1000).to_i
		@last = Time.now

		@tweens.delete_if{ |n| n == nil || n.done? }
	    @tweens.each{ |n| n.update(delta) }

	end

	def register(tween)
		@tweens.push(tween)
	end

	def clear(object)
		@tweens.delete_if{ |n| n.parent == object } 
	end

	def clear_all
		@tweens.clear
	end

	def done?(object)
		return @tweens.select{ |n| n.parent == object }.empty?
	end

end"%
class ItemData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class WeaponData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class ArmorData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :category
	attr_reader :icon
	attr_reader :price
	attr_reader :action
end

class SkillData

end

class StateData

end

class ActorData
	attr_reader :id
	attr_reader :name
	attr_reader :profile
	attr_reader :armor
	attr_reader :actions
	attr_reader :resource
	attr_reader :slots
	attr_reader :statratings
end

class EnemyData

end

class ZoneData
	attr_reader :id
	attr_reader :bgm
	attr_reader :bgs
	attr_reader :tint
	attr_reader :weather
end

class ProgressData
	attr_reader :category
	attr_reader :id
	attr_reader :value
end

class QuestData
	attr_reader :id
end
"­module RPG
  class Tileset
    def initialize
      @id = 0
      @name = ""
      @tileset_name = ""
      @autotile_names = [""]*7
      @panorama_name = ""
      @panorama_hue = 0
      @fog_name = ""
      @fog_hue = 0
      @fog_opacity = 64
      @fog_blend_type = 0
      @fog_zoom = 200
      @fog_sx = 0
      @fog_sy = 0
      @battleback_name = ""
      @passages = Table.new(384)
      @priorities = Table.new(384)
      @priorities[0] = 5
      @terrain_tags = Table.new(384)
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :tileset_name
    attr_accessor :autotile_names
    attr_accessor :panorama_name
    attr_accessor :panorama_hue
    attr_accessor :fog_name
    attr_accessor :fog_hue
    attr_accessor :fog_opacity
    attr_accessor :fog_blend_type
    attr_accessor :fog_zoom
    attr_accessor :fog_sx
    attr_accessor :fog_sy
    attr_accessor :battleback_name
    attr_accessor :passages
    attr_accessor :priorities
    attr_accessor :terrain_tags
  end
end

module RPG
  class System
    def initialize
      @magic_number = 0
      @party_members = [1]
      @elements = [nil, ""]
      @switches = [nil, ""]
      @variables = [nil, ""]
      @windowskin_name = ""
      @title_name = ""
      @gameover_name = ""
      @battle_transition = ""
      @title_bgm = RPG::AudioFile.new
      @battle_bgm = RPG::AudioFile.new
      @battle_end_me = RPG::AudioFile.new
      @gameover_me = RPG::AudioFile.new
      @cursor_se = RPG::AudioFile.new("", 80)
      @decision_se = RPG::AudioFile.new("", 80)
      @cancel_se = RPG::AudioFile.new("", 80)
      @buzzer_se = RPG::AudioFile.new("", 80)
      @equip_se = RPG::AudioFile.new("", 80)
      @shop_se = RPG::AudioFile.new("", 80)
      @save_se = RPG::AudioFile.new("", 80)
      @load_se = RPG::AudioFile.new("", 80)
      @battle_start_se = RPG::AudioFile.new("", 80)
      @escape_se = RPG::AudioFile.new("", 80)
      @actor_collapse_se = RPG::AudioFile.new("", 80)
      @enemy_collapse_se = RPG::AudioFile.new("", 80)
      @words = RPG::System::Words.new
      @test_battlers = []
      @test_troop_id = 1
      @start_map_id = 1
      @start_x = 0
      @start_y = 0
      @battleback_name = ""
      @battler_name = ""
      @battler_hue = 0
      @edit_map_id = 1
    end
    attr_accessor :magic_number
    attr_accessor :party_members
    attr_accessor :elements
    attr_accessor :switches
    attr_accessor :variables
    attr_accessor :windowskin_name
    attr_accessor :title_name
    attr_accessor :gameover_name
    attr_accessor :battle_transition
    attr_accessor :title_bgm
    attr_accessor :battle_bgm
    attr_accessor :battle_end_me
    attr_accessor :gameover_me
    attr_accessor :cursor_se
    attr_accessor :decision_se
    attr_accessor :cancel_se
    attr_accessor :buzzer_se
    attr_accessor :equip_se
    attr_accessor :shop_se
    attr_accessor :save_se
    attr_accessor :load_se
    attr_accessor :battle_start_se
    attr_accessor :escape_se
    attr_accessor :actor_collapse_se
    attr_accessor :enemy_collapse_se
    attr_accessor :words
    attr_accessor :test_battlers
    attr_accessor :test_troop_id
    attr_accessor :start_map_id
    attr_accessor :start_x
    attr_accessor :start_y
    attr_accessor :battleback_name
    attr_accessor :battler_name
    attr_accessor :battler_hue
    attr_accessor :edit_map_id
  end
end

module RPG
  class System
    class Words
      def initialize
        @gold = ""
        @hp = ""
        @sp = ""
        @str = ""
        @dex = ""
        @agi = ""
        @int = ""
        @atk = ""
        @pdef = ""
        @mdef = ""
        @weapon = ""
        @armor1 = ""
        @armor2 = ""
        @armor3 = ""
        @armor4 = ""
        @attack = ""
        @skill = ""
        @guard = ""
        @item = ""
        @equip = ""
      end
      attr_accessor :gold
      attr_accessor :hp
      attr_accessor :sp
      attr_accessor :str
      attr_accessor :dex
      attr_accessor :agi
      attr_accessor :int
      attr_accessor :atk
      attr_accessor :pdef
      attr_accessor :mdef
      attr_accessor :weapon
      attr_accessor :armor1
      attr_accessor :armor2
      attr_accessor :armor3
      attr_accessor :armor4
      attr_accessor :attack
      attr_accessor :skill
      attr_accessor :guard
      attr_accessor :item
      attr_accessor :equip
    end
  end
end

module RPG
  class System
    class TestBattler
      def initialize
        @actor_id = 1
        @level = 1
        @weapon_id = 0
        @armor1_id = 0
        @armor2_id = 0
        @armor3_id = 0
        @armor4_id = 0
      end
      attr_accessor :actor_id
      attr_accessor :level
      attr_accessor :weapon_id
      attr_accessor :armor1_id
      attr_accessor :armor2_id
      attr_accessor :armor3_id
      attr_accessor :armor4_id
    end
  end
end


"© class Array
 	def count
 		return length
 	end
 	def sample
      self[rand(length)]
  	end

 end

 class String
  def is_integer?
    self.to_i.to_s == self
  end
end

class FalseClass; def to_i; 0 end end
class TrueClass; def to_i; 1 end end

class Bitmap

	def fill(color)
		self.fill_rect(0,0,self.width,self.height,color)
	end

	def windowskin(skin)
		src = Cache.windowskin(skin)
		dest = rect.dup
		dest.x += 3
		dest.y += 3
		dest.width -= 6
		dest.height -= 6
		stretch_blt(dest,src,Rect.new(0,0,128,128),210)

		w = 16
		h = 16
		sx = 128
		sy = 0

		o = 255

		# CORNERS
	    blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
	    blt(width-w,0,src,Rect.new(sx+48,sy,w,h),o) # top right
	    blt(0,height-h,src,Rect.new(sx,sy+48,w,h),o) # bottom left
	    blt(width-w,height-h,src,Rect.new(sx+48,sy+48,w,h),o) # bottom right
	    
	    #dest_rect, bmp, src_rect

	   #  # Middle
	   #stretch_blt(Rect.new(w,h,width-16,height-16),src,Rect.new(sx+16,0,w,h),o)

	   #  # left side
	   stretch_blt(Rect.new(0,h,w,height-32),src,Rect.new(sx,h+16,w,h),o)

	   #  # Right
	     stretch_blt(Rect.new(width-w,h,w,height-32),src,Rect.new(sx+48,h,w,h),o)

	   #  #top
	   stretch_blt(Rect.new(w,0,width-32,h),src,Rect.new(sx+16,0,w,h),o)

	   # #bottom
	   stretch_blt(Rect.new(w,height-h,width-32,h),src,Rect.new(sx+16,h+32,w,h),o)


	end

	def vert(src)
    	blt(0,0,src,Rect.new(0,0,src.width,10)) # top left
    	blt(0,height-10,src,Rect.new(0,src.height-10,src.width,10)) # bottom right
    
    	stretch_blt(Rect.new(0,10,10,height-20),src,Rect.new(0,10,10,10))
	end

end

class Fixnum
	def odd?
		return self % 2 == 1
	end
end

class Sprite
	def hide
		self.visible = false
	end
	def show
		self.visible = true
	end
	def move(x,y)
		self.x = x
		self.y = y
	end

	def width
		return self.bitmap.width
	end

	def height 
		return self.bitmap.height
	end
end"Lif !ACE_MODE
	class Font
		attr_accessor :outline, :shadow
	end
end"~#==============================================================================
# ** Console
#==============================================================================

class DebugConsole

	INPUT_COLOR = Color.new(0,0,0,160)

	MAX_LOGS = 11


	def initialize(vp)

		# Prepare log
		@history = []
		@console_text = ""
		@console_sprite = Sprite.new(vp)
		@console_sprite.move(0,410)
		refresh_console

		# Showing previous
		@logs = []
		@osd_sprite = Sprite.new(vp)

		hide

	end

	def update

		# If console not showing
		if !active?
			show if $keyboard.press?(VK_TILDE) 
		end

		# Hide console if press TILDE
		hide if active? && $keyboard.press?(VK_TILDE)
		hide if active? && $keyboard.press?(VK_ESC)

		if !active?
			if $keyboard.state?(VK_BS)
				@osd_sprite.show
			else
				@osd_sprite.hide
			end
		end

		return if !active?

		# Show last
		if $keyboard.press?(VK_TAB)
			@console_text = @history.empty? ? "" : @history.pop
			refresh_console
		end
									
		# Check console input
		console_chars.each{ |c|
			if $keyboard.press?(c)
				@console_text += $keyboard.to_char(c)
				refresh_console
			end
		}

		# Check inputs now
		if $keyboard.press?(VK_ENTER)
			begin
				eval(@console_text)
			rescue Exception => e
			 	log_scr(e.class.to_s+" --- '" + @console_text + "'")		      
		    end
		    @history.push(@console_text)
			@console_text = ""
			refresh_console
		end

		if $keyboard.hold?(VK_BS)
			@console_text.chop!
			refresh_console
		end

	end

	def hide
		@console_sprite.hide
		@osd_sprite.hide
	end

	def show
		@console_sprite.show
		@osd_sprite.show
	end

	def active?
		return @console_sprite.visible
	end

	def refresh_console
		@console_sprite.bitmap = Bitmap.new(640,60)

		@console_sprite.bitmap.fill_rect(0,0,640,30,INPUT_COLOR)
		@console_sprite.bitmap.draw_text(8,0,640,30,"-> "+@console_text) # Make gfx.width

		if !@history.empty?
			@console_sprite.bitmap.fill_rect(0,30,640,30,Color.new(0,0,0,60))
			@console_sprite.bitmap.draw_text(8,30,640,30,"   "+@history[-1]) # Make gfx.width
		end	

	end

	def refresh_osd

		@osd_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		cx = 0
		cy = 6

		@osd_sprite.bitmap.fill_rect(cx,cy,640,30,Color.new(0,0,0,160))
		@osd_sprite.bitmap.draw_text(cx+8,cy,640,30,"LOG HISTORY")

		cy += 40

		@logs.each{ |log|

			out = log[0]
			color = log[1]

			size = @osd_sprite.bitmap.text_size(out)
			@osd_sprite.bitmap.fill_rect(cx,cy,size.width+20,size.height+6,color)
			@osd_sprite.bitmap.draw_text(cx+8,cy+3,600,size.height,out)

			cy += 32

		}

	end

	def log(msg)

		@logs.push(msg)
		@logs.shift while @logs.count > MAX_LOGS
		refresh_osd

	end

	def console_chars
		chars = (48..57).to_a
		chars += (65..90).to_a
		chars += (186..222).to_a
		chars += [32]
		return chars
	end

end"module Graphics
 
  @fps, @fps_tmp = 0, []
 
  class << self
    
    attr_reader :fps
    
    alias fps_update update unless method_defined?(:fps_update)
    def update
	  t = Time.now
	  fps_update
	  @fps_tmp[frame_count % frame_rate] = Time.now != t
	  @fps = 0
	  frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
	  fps_sprite.src_rect.y = @fps * 30

	  if @old_color != $debug.last_color
	  	back_sprite.bitmap.fill($debug.last_color)
	  	@old_color = $debug.last_color
	  end

    end
    
    def fps_sprite
	  if !@fps_sprite or @fps_sprite.disposed?
	    @fps_sprite = Sprite.new
	    @fps_sprite.z = 9999
	    @fps_sprite.x = $game.width-50
	    @fps_sprite.y = 6
	    @fps_sprite.bitmap = Bitmap.new(30, 30*62)
	    @fps_sprite.bitmap.font.size = 28
	    @fps_sprite.bitmap.font.name = "Consolas"
	    @fps_sprite.bitmap.font.color.set(255, 255, 255)
	    61.times {|i| @fps_sprite.bitmap.draw_text(-2, i*30, 36, 30, "% 3d"%i)}
	    @fps_sprite.bitmap.draw_text(-2, 61*30, 36, 30, "++")
	    @fps_sprite.src_rect.height = 30
	  end
	  return @fps_sprite
    end

    def back_sprite
	  if !@back_sprite or @back_sprite.disposed?
	    @back_sprite = Sprite.new
	    @back_sprite.z = 9997
	    @back_sprite.x = $game.width-50
	    @back_sprite.y = 6
	    @back_sprite.bitmap = Bitmap.new(30, 30)
	  end
	  return @back_sprite
    end
    
  end
end"Y	#==============================================================================
# ** Actions
#==============================================================================

class DebugMenu

	def initialize(vp)

		@actions = []
		@idx = 0

		@mnu_sprite = Sprite.new(vp)
		@idx_sprite = Sprite.new(vp)
		@text_sprite = Sprite.new(vp)
		@text_sprite.z += 10

		@idx_sprite.y = 10

		@menu_title = "DEBUG MENU"

		@esc = Proc.new{ hide }

		page(:main)

		hide

	end

	def page(newpage)
		clear

		case newpage
			when :main
				add("General Settings",Proc.new{ page(:settings) })
				add("Debug Settings",Proc.new{ page(:debug) })
				add("Progress: #{$progress.progress}",nil) if !$progress.nil?
				@esc = Proc.new{ hide }
			when :settings
				add("Toggle Fullscreen",Proc.new{ $game.toggle })
				@esc = Proc.new{ page(:main) }

		end
		refresh
	end


	def clear
		@idx = 0
		@actions.clear
		refresh
	end

	def add(text,proc)
		@actions.push([text,proc])
	end

	def update

		if $keyboard.press?(VK_ESC)
			active? ? @esc.call : show
		end

		return if !active?

		if $keyboard.press?(VK_ENTER)
			@actions[@idx][1].call if @actions[@idx][1] != nil
		end
		
		if $keyboard.press?(VK_DOWN)
			@idx += 1 if @idx != @actions.count - 1
		end

		if $keyboard.press?(VK_UP)
			@idx -= 1 if @idx != 0
		end

		@idx_sprite.y = 46 + (@idx * 34)
		

		#refresh

	end

	def refresh

		@mnu_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)
		@text_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		@idx_sprite.bitmap = Bitmap.new(400,30)
		@idx_sprite.bitmap.fill(Color.new(50,120,180,240))

		cx = 0
		cy = 6

		@mnu_sprite.bitmap.fill_rect(cx,cy,640,30,Color.new(0,0,0,160))
		@text_sprite.bitmap.draw_text(cx+8,cy,640,30,@menu_title)

		cy += 40

		@actions.each_index{ |i|

			out = "-> "+@actions[i][0]
			color = Color.new(0,0,0,120)

			size = @mnu_sprite.bitmap.text_size(out)
			@mnu_sprite.bitmap.fill_rect(cx,cy,400,30,color)
			@text_sprite.bitmap.draw_text(cx+8,cy+0,600,size.height+6,out)

			cy += 34

		}

	end


	def show
		page(:main)
		@mnu_sprite.show
		@idx_sprite.show
		@text_sprite.show
	end

	def hide
		@mnu_sprite.hide
		@idx_sprite.hide
		@text_sprite.hide
	end

	def active?
		@mnu_sprite.visible
	end

end


"Ú#==============================================================================
# ** SpellCheck
#==============================================================================

def execute_spellcheck
    
    data = {} # map name, dialogues?
    
    # Each map
    $data_maps.each{ |k,v| 
    
      map_id = k
      map_name = v.name
      
      event_list = load_data(sprintf("Data/Map%03d.rvdata2",map_id)).events
      next if event_list.empty?
      
      events = {}
      
      # Do for each event
      event_list.each{ |k,v|
      
        ev_id = k
        ev_name = v.name
        
        dialogues = []
        
        # Do for each page
        v.pages.each{ |page|
        
        @cmd_idx = 0        
        while page.list[@cmd_idx] do

            # Do something according to command          
            case page.list[@cmd_idx].code
            
              when 101; # Short text
                
                text = ""
                while page.list[@cmd_idx+1].code == 401       # Text data
                  @cmd_idx += 1
                  text += page.list[@cmd_idx].parameters[0]
                  text += ' '      
                end
                dialogues.push(text)
                
              when 105; # Long text
            
                while page.list[@cmd_idx+1].code == 405
                  @cmd_idx += 1
                  line = page.list[@cmd_idx].parameters[0]
                  if line[0] == "@"
                    dialogues[dialogues.size-1] += " " + line
                  else
                    dialogues.push(line)
                  end
                end
            
            end
              
            @cmd_idx += 1  
          
          end # page        
        
        }

        # any dialogues? save it
        if !dialogues.empty?
          #p dialogues
          events[[ev_id,ev_name]] = dialogues
        end
        
      }

      # Add to overall
      if !events.empty?
        data[[map_id,map_name]] = events
      end
      
      #p name
      #p event_list.size
      
      
      #break
      
      
    }
    
    # Output to file
    # Create a new file and write to it  
    File.open('spellcheck.txt', 'w') do |file|  

      # Write some stats
      file.puts("Total Maps: "+$data_maps.size.to_s)
      file.puts("Maps with dialogue: "+data.size.to_s)

      # Word counts
      words = 0
      data.values.each{ |map|
        map.values.each{ |ev|
          ev.each{ |line|
            words += line.split(" ").size
          }
        }
      }
      file.puts("Word Count: "+words.to_s)

      file.puts("\n")
      file.puts("\n")

      # Each Map
      data.each{ |mk,mv|

        # Map name
        file.puts("Map "+mk[0].to_s+": "+mk[1])
        file.puts("----------------------------------------")
        file.puts("\n")

        # Contents
        mv.each{ |ek,ev|

          # Event name
          file.puts("Event "+ek[0].to_s+": "+ek[1])

          # Event contents
          ev.each{ |line|
            file.puts(line)
          }

          file.puts("\n")

        }
        file.puts("\n")
      }

    end  

    
  end"O# Fullscreen++ v2.2 for VX and VXace by Zeus81
# Free for non commercial and commercial use
# Licence : http://creativecommons.org/licenses/by-sa/3.0/
# Contact : zeusex81@gmail.com
# (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
# (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
 
 if ACE_MODE


class << Graphics
  Disable_VX_Fullscreen = false
 
  CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
  GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
  GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
  GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
  GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
  FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
  FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
  ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
  SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
  SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
  SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
  ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
  SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
  UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
  GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
  WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
  CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
  DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
 
  unless method_defined?(:zeus_fullscreen_update)
    HWND     = FindWindow.call('RGSS Player', 0)
    BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
    alias zeus_fullscreen_resize_screen resize_screen
    alias zeus_fullscreen_update        update
  end
private
  def initialize_fullscreen_rects
    @borders_size    ||= borders_size
    @fullscreen_rect ||= screen_rect
    @workarea_rect   ||= workarea_rect
  end
  def borders_size
    GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
    GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
    wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
    Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
  end
  def screen_rect
    Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
  end
  def workarea_rect
    SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
    rect = rect.unpack('l4')
    Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
  end
  def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
  def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
  def hide_back()    ShowWindow.call(BackHWND, 0)              end
  def show_back
    ShowWindow.call(BackHWND, 3)
    UpdateWindow.call(BackHWND)
    dc    = GetDC.call(BackHWND)
    rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
    brush = CreateSolidBrush.call(0)
    FillRect.call(dc, rect, brush)
    ReleaseDC.call(BackHWND, dc)
    DeleteObject.call(brush)
  end
  def resize_window(w, h)
    if @fullscreen
      x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
    else
      w += @borders_size.width
      h += @borders_size.height
      x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
      y = @workarea_rect.y + (@workarea_rect.height - h) / 2
      z = -2
    end
    SetWindowPos.call(HWND, z, x, y, w, h, 0)
  end
  def release_alt
    inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
    SendInput.call(3, inputs, 28)
  end
public
  def load_fullscreen_settings
    buffer = [].pack('x256')
    section = 'Fullscreen++'
    filename = './Game.ini'
    get_option = Proc.new do |key, default_value|
      l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
      buffer[0, l]
    end
    @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
    @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
    @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
    toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
    fullscreen? ? fullscreen_mode : windowed_mode
  end
  def save_fullscreen_settings
    section = 'Fullscreen++'
    filename = './Game.ini'
    set_option = Proc.new do |key, value|
      WritePrivateProfileString.call(section, key, value.to_s, filename)
    end
    set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
    set_option.call('FullscreenRatio', @fullscreen_ratio)
    set_option.call('WindowedRatio'  , @windowed_ratio)
  end
  def fullscreen?
    @fullscreen or vx_fullscreen?
  end
  def vx_fullscreen?
    rect = screen_rect
    rect.width == 640 and rect.height == 480
  end
  def toggle_fullscreen
    fullscreen? ? windowed_mode : fullscreen_mode
  end
  def toggle_vx_fullscreen
    windowed_mode if @fullscreen and !vx_fullscreen?
    inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
    SendInput.call(4, inputs, 28)
    zeus_fullscreen_update
    self.ratio += 0 # refresh window size
  end
  def vx_fullscreen_mode
    return if vx_fullscreen?
    toggle_vx_fullscreen
  end
  def fullscreen_mode
    return if vx_fullscreen?
    initialize_fullscreen_rects
    show_back
    hide_borders
    @fullscreen = true
    self.ratio += 0 # refresh window size
  end
  def windowed_mode
    toggle_vx_fullscreen if vx_fullscreen?
    initialize_fullscreen_rects
    hide_back
    show_borders
    @fullscreen = false
    self.ratio += 0 # refresh window size
  end
  def toggle_ratio
    return if vx_fullscreen?
    self.ratio += 1
  end
  def ratio
    return 1 if vx_fullscreen?
    @fullscreen ? @fullscreen_ratio : @windowed_ratio
  end
  def ratio=(r)
    return if vx_fullscreen?
    initialize_fullscreen_rects
    r = 0 if r < 0
    if @fullscreen
      @fullscreen_ratio = r
      w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
    else
      @windowed_ratio = r
      w_max = @workarea_rect.width  - @borders_size.width
      h_max = @workarea_rect.height - @borders_size.height
    end
    if r == 0
      w, h = w_max, w_max * height / width
      h, w = h_max, h_max * width / height if h > h_max
    else
      w, h = width * r, height * r
      return self.ratio = 0 if w > w_max or h > h_max
    end
    resize_window(w, h)
    save_fullscreen_settings
  end
  def update
    release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
    zeus_fullscreen_update
    toggle_fullscreen if Input.trigger?(Input::F5)
    toggle_ratio      if Input.trigger?(Input::F6)
  end
  def resize_screen(width, height)
    zeus_fullscreen_resize_screen(width, height)
    self.ratio += 0 # refresh window size
  end
end
Graphics.load_fullscreen_settings


end"ê# if ACE_MODE
  
#   def set_rez(width,height)

#     eval "

#     # Do not edit
#     wt, ht = width.divmod(32), height.divmod(32)
#     #wt.last + ht.last == 0 || fail('Incorrect width or height')
#     wh = -> w, h, off = 0 { [w + off, h + off].pack('l2').scan /.{4}/ }
#     w, h = wh.(width, height)
#     ww, hh = wh.(width, height, 32)
#     www, hhh = wh.(wt.first.succ, ht.first.succ)
#     base = 0x10000000  # fixed?
#     mod = -> adr, val { DL::CPtr.new(base + adr)[0, val.size] = val }
#     mod.(0x195F, \"\x90\" * 5)  # ???   
#     mod.(0x19A4, h)
#     mod.(0x19A9, w)
#     mod.(0x1A56, h)
#     mod.(0x1A5B, w)
#     mod.(0x20F6, w)
#     mod.(0x20FF, w)
#     mod.(0x2106, h)
#     mod.(0x210F, h)
#     # speed up y?
#     #mod.(0x1C5E3, h)
#     #mod.(0x1C5E8, w)
#     zero = [0].pack ?l
#     mod.(0x1C5E3, zero)
#     mod.(0x1C5E8, zero)
#     mod.(0x1F477, h)
#     mod.(0x1F47C, w)
#     mod.(0x211FF, hh)
#     mod.(0x21204, ww)
#     mod.(0x21D7D, hhh[0])
#     mod.(0x21E01, www[0])
#     mod.(0x10DEA8, h)
#     mod.(0x10DEAD, w)
#     mod.(0x10DEDF, h)
#     mod.(0x10DEF0, w)
#     mod.(0x10DF14, h)
#     mod.(0x10DF18, w)
#     mod.(0x10DF48, h)
#     mod.(0x10DF4C, w)
#     mod.(0x10E6A7, w)
#     mod.(0x10E6C3, h)
#     mod.(0x10EEA9, w)
#     mod.(0x10EEB9, h)
#     Graphics.resize_screen width, height
#     GC.start"

#   end

# else

#   def set_rez(x,y)
#     log_err "Can't resize in XP mode"
#   end

# end"^#=============================================================================
# * Snapshot script from screenshot.dll, Modified from GAMEGUY's SCRIPT
#=============================================================================
module Snapshot
  def self.snap
    snp = Win32API.new('screenshot.dll', 'Screenshot', %w(l l l l p l l), '')
    window = Win32API.new('user32', 'FindWindowA', %w(p p), 'l')
    ini = (Win32API.new 'kernel32', 'GetPrivateProfileStringA', %w(p p p p l p), 
      'l')
    game_name = '\0' * 256
    ini.call('Game', 'Title', '', game_name, 255, '.\Game.ini')
    game_name.delete!('\0')
    win = window.call('RGSS Player', game_name)
    count = 0
    
    file_name = "Graphics/Pictures/temp_screenshot#{rand(30)}.png"


    log_info 'works to here'

    snp.call(0, 0, 640, 480, file_name, win, 2)
  end
end"T/# Zeus Video Player v2.3 for XP, VX and VXace by Zeus81
# Free for commercial use
# Licence : http://creativecommons.org/licenses/by/4.0/
# Contact : zeusex81@gmail.com
#
# How to Use :
#   Graphics.play_movie( filename, cancellable, fit_to_screen )
#   - filename = path of the video file.
#   - cancellable = true if you want to allow the player to stop the video
#                   by pressing Enter or Escape, false otherwise.
#                   This option can be omitted and default value is true.
#   - fit_to_screen = true if you want the video to be stretched to fit the screen in
#                     case it doesn't match, false if you just want it to be centered.
#                     If you're using scripts like Fullscreen++ true is recommended.
#                     This option can be omitted and default value is true.
#   ex : Graphics.play_movie( "Movies/prout.avi", true, true )
#   or   Graphics.play_movie( "Movies/prout.avi" )
#
# Codec choice :
#   I haven't tested all of them but I guess wmv9 (standard) would be a good choice.
#   You can find a list of codecs installed by default on windows here :
#   http://support.microsoft.com/kb/899113
#
# Background Image :
#   You can choose the background image of the player (in case your video doesn't fill all the space).
#   It will automatically load the image named "ZeusVideoPlayer" if found in Pictures folder (the extension doesn't matter).
#   If not found it will be black.
#
# Known bugs :
#  - With some video codecs stretching to fit screen doesn't work in fullscreen mode.
#  - When switching fullscreen mode during playback the display can freeze.
#  - Sometimes the display doesn't render when playing a video for the second time.
#  - Weird behaviour in fullscreen mode.
#
# ZVP_OldAviMode :
#   Just bellow you can enable this mode by setting the variable to true.
#   Advantages :
#     - More stable, no known bugs.
#   Drawbacks :
#     - It can only play avi files.
#     - You must use vfw codecs for video, and windows defaults vfw codecs are very limited.
#       Exhaustive list : MS RLE, MS Video 1, Cinepak, iyuv. And they all sucks.
#       Any other codec will require to be installed on user side to ensure that it's supported.
#       But if it's not a problem then you can find very nice vfw codecs on the internet, eg x264vfw.
#     - You must use acm codecs for audio.
#       Windows defaults : mp3, pcm.
#       You can also find better codecs like aac acm.
 
module Graphics
  ZVP_OldAviMode = false
end
 
$imported ||= {}
$imported[:Zeus_Video_Player] = __FILE__
 
def xp?() false end ; 
def vx?() false end ; 
def vxace?() false end
  
RUBY_VERSION == '1.8.1' ? defined?(Hangup) ?
def xp?() true  end : def vx?() true  end : def vxace?() true  end
 
Cache = RPG::Cache if xp?
 
class String
  alias getbyte  []
  alias setbyte  []=
  alias bytesize size
end unless vxace?
 
module Zeus
  module Encode # 1.1
    MultiByteToWideChar = Win32API.new('kernel32', 'MultiByteToWideChar', 'iipipi'  , 'i')
    WideCharToMultiByte = Win32API.new('kernel32', 'WideCharToMultiByte', 'iipipipp', 'i')
    CodePages = {
      'ANSI'=>0, 'OEM'=>1, 'MAC'=>2, 'THREAD_ANSI'=>3, 'SYMBOL'=>42,
      'WINDOWS874'=>874, 'SHIFT_JIS'=>932, 'BIG5'=>950, 'WINDOWS1250'=>1250,
      'WINDOWS1251'=>1251, 'WINDOWS1252'=>1252, 'WINDOWS1253'=>1253,
      'WINDOWS1254'=>1254, 'WINDOWS1255'=>1255, 'WINDOWS1256'=>1256,
      'WINDOWS1257'=>1257, 'WINDOWS1258'=>1258, 'US_ASCII'=>20127,
      'ISO8859_1'=>28591, 'ISO8859_2'=>28592, 'ISO8859_3'=>28593,
      'ISO8859_4'=>28594, 'ISO8859_5'=>28595, 'ISO8859_6'=>28596,
      'ISO8859_7'=>28597, 'ISO8859_8'=>28598, 'ISO8859_9'=>28599,
      'ISO8859_13'=>28603, 'ISO8859_15'=>28605, 'ISO8859_8I'=>38598,
      'ISO2022_JP'=>50220, 'ISO2022_KR'=>50225, 'ISO2022_CN'=>50227,
      'EUC_JP'=>51932, 'EUC_CN'=>51936, 'EUC_KR'=>51949, 'GB2312'=>52936,
      'UTF7'=>65000, 'UTF8'=>65001, 'UTF16'=>-1
    }
    def self.encode(str, from, to, dchar=nil, dflag=nil)
      if from != -1
        l = MultiByteToWideChar.call(from, 0, str, str.bytesize, nil, 0)
        utf16 = [].pack('x') * (l*2)
        MultiByteToWideChar.call(from, 0, str, str.bytesize, utf16, l)
      else utf16 = str
      end
      if to != -1
        l = WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, nil, 0, dchar, dflag)
        str = [].pack('x') * l
        WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, str, l, dchar, dflag)
      else str = utf16
      end
      case to
      when 20127; str.force_encoding('US-ASCII')
      when 65001; str.force_encoding('UTF-8')
      when    -1; str.force_encoding('UTF-16LE')
      end if vxace?
      str
    rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
    end
    def self.method_missing(method, str, *options)
      from, to = *method.to_s.upcase.split('_TO_', 2).map! {|s| CodePages[s]}
      super unless from and to
      encode(str, from, to, *options)
    rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
    end
  end
end
 
module Graphics
  DefWindowProc       = Win32API.new('user32', 'DefWindowProc'      , 'iiii', 'i')
  DestroyWindow       = Win32API.new('user32', 'DestroyWindow'      , 'i'   , 'i')
  EnableWindow        = Win32API.new('user32', 'EnableWindow'       , 'ii'  , 'i')
  FindWindow          = Win32API.new('user32', 'FindWindow'         , 'pp'  , 'i')
  GetClientRect       = Win32API.new('user32', 'GetClientRect'      , 'ip'  , 'i')
  GetForegroundWindow = Win32API.new('user32', 'GetForegroundWindow', ''    , 'i')
  GetMessage          = Win32API.new('user32', 'GetMessage'         , 'piii', 'i')
  GetWindowLong       = Win32API.new('user32', 'GetWindowLong'      , 'ii'  , 'i')
  PostMessage         = Win32API.new('user32', 'PostMessage'        , 'iiii', 'i')
  RedrawWindow        = Win32API.new('user32', 'RedrawWindow'       , 'ipii', 'i')
  SetWindowLong       = Win32API.new('user32', 'SetWindowLong'      , 'iii' , 'i')
  MciGetErrorString   = Win32API.new('winmm' , 'mciGetErrorStringW' , 'ipi' , 'i')
  MciSendString       = Win32API.new('winmm' , 'mciSendStringW'     , 'ppii', 'i')
  class << self
    def hwnd() @hwnd ||= FindWindow.call('RGSS Player', nil) end
    def play_movie(filename, cancellable = true, fit_to_screen = true)
      @zvp ||= {:buffer => [].pack('x') * 256}
      @zvp[:filename] = Dir["#{filename}.*"][0] || filename
      @zvp[:cancellable] = cancellable
      @zvp[:fit_to_screen] = fit_to_screen
      return unless open_video_player
      back_sprite = Sprite.new
      back_sprite.z = 0x7FFF_FFFF
      begin
        cached = true
        back_sprite.bitmap = Cache.picture('ZeusVideoPlayer')
        back_sprite.zoom_x = width  / back_sprite.bitmap.width.to_f
        back_sprite.zoom_y = height / back_sprite.bitmap.height.to_f
      rescue
        cached = false
        back_sprite.bitmap = Bitmap.new(1, 1)
        back_sprite.bitmap.set_pixel(0, 0, Color.new(0,0,0))
        back_sprite.zoom_x = width
        back_sprite.zoom_y = height
      end
      frame_reset
      update
      update_video_player
      back_sprite.bitmap.dispose unless cached
      back_sprite.dispose
    ensure
      close_video_player
    end
    def width()  640 end unless method_defined?(:width)
    def height() 480 end unless method_defined?(:height)
  private
    def mci(command)
      error = mci_silent(command)
      return true if error == 0
      MciGetErrorString.call(error, @zvp[:buffer], @zvp[:buffer].bytesize/2)
      print(mci_result, "\nCommand : ", command)
      return false
    end
    def mci_silent(command)
      command = Zeus::Encode.utf8_to_utf16("#{command}\0")
      MciSendString.call(command, @zvp[:buffer], @zvp[:buffer].bytesize/2, hwnd)
    end
    def mci_result
      str = Zeus::Encode.utf16_to_utf8(@zvp[:buffer])
      str[0, str.index("\0")]
    end
    def open_video_player(position=0)
      if ZVP_OldAviMode
        return false unless mci("open \"#{@zvp[:filename]}\" type AVIVideo alias ZeusVideoPlayer")
        return false unless mci("window ZeusVideoPlayer handle #{hwnd}")
        return false unless mci("play ZeusVideoPlayer from #{position} notify")
      else
        return false unless mci("open \"#{@zvp[:filename]}\" type MPEGVideo style Child parent #{hwnd} alias ZeusVideoPlayer")
        return false unless mci("play ZeusVideoPlayer from #{position} notify")
        return false unless mci('status ZeusVideoPlayer window handle')
        @zvp[:hwnd] = mci_result.to_i
        EnableWindow.call(@zvp[:hwnd], 0)
        style = GetWindowLong.call(hwnd, -16) #GWL_STYLE
        SetWindowLong.call(hwnd, -16, style | 0x02000000) #WS_CLIPCHILDREN
      end
      return true
    end
    def close_video_player
      if !ZVP_OldAviMode and @zvp[:hwnd]
        DestroyWindow.call(@zvp[:hwnd])
        @zvp[:hwnd] = nil
      end
      mci_silent('stop ZeusVideoPlayer')
      mci_silent('close ZeusVideoPlayer')
    end
    def resize_video_player
      if mci_silent('where ZeusVideoPlayer source') == 0
        x, y, w, h = *mci_result.split(' ', 4).map! {|s| s.to_i}
        GetClientRect.call(hwnd, @zvp[:buffer])
        client_w, client_h = *@zvp[:buffer].unpack('x8L2')
        if @zvp[:fit_to_screen]
          ratio = w / h.to_f
          w, h = client_w, (client_w / ratio).round
          h, w = client_h, (client_h * ratio).round if h > client_h
        end
        x, y = (client_w-w)/2, (client_h-h)/2
        window = ZVP_OldAviMode ? 'destination' : 'window'
        mci_silent("put ZeusVideoPlayer #{window} at #{x} #{y} #{w} #{h}")
      end
      RedrawWindow.call(@zvp[:hwnd] || hwnd, nil, 0, 0)
    end
    def update_video_player
      focus = false
      loop do
        GetMessage.call(@zvp[:buffer], 0, 0, 0)
        DefWindowProc.call(*msg = @zvp[:buffer].unpack('L4'))
        if focus != (GetForegroundWindow.call == hwnd)
          focus = !focus
          mci_silent("#{focus ? 'resume' : 'pause'} ZeusVideoPlayer")
          resize_video_player
        end
        next unless focus
        Input.update
        if Input.trigger?(Input::B) or Input.trigger?(Input::C)
          mci_silent('stop ZeusVideoPlayer') if @zvp[:cancellable]
        elsif Input.trigger?(Input::F5) or Input.trigger?(Input::F6)
          if $imported[:Zeus_Fullscreen] and !vx_fullscreen?
            update
            resize_video_player
          end
        end
        case msg[1]
        when 0x0012 #WM_QUIT
          exit
        when 0x0100 #WM_KEYDOWN
          next if msg[3][30] == 1
          case msg[2]
          when 0x70, 0x7B #VK_F1, VK_F12
            focus = false
            mci_silent('pause ZeusVideoPlayer')
            PostMessage.call(*msg)
            update
          end
        when 0x0104 #WM_SYSKEYDOWN
          next if msg[2] != 0x0D or msg[3][30] == 1
          next if $imported[:Zeus_Fullscreen] and Disable_VX_Fullscreen
          if ZVP_OldAviMode
            PostMessage.call(*msg)
            update
            resize_video_player
          else
            next if mci_silent('status ZeusVideoPlayer position') != 0
            position = mci_result.to_i
            close_video_player
            PostMessage.call(*msg)
            update
            break unless open_video_player(position)
            resize_video_player
          end
        else
          mci_silent('status ZeusVideoPlayer length')
          length = mci_result.to_i
          mci_silent('status ZeusVideoPlayer position')
          break if mci_result.to_i >= length
          mci_silent('status ZeusVideoPlayer mode')
          break if mci_result == 'stopped'
        end
      end
    end
    if xp?
      alias anti_hangup_update_video_player update_video_player
      def update_video_player
        anti_hangup_update_video_player
      rescue Hangup
        retry
      end
    end
  end
end"P

def condition_applies?(cond)
      # cond is [code,data1.....]

    case cond[0]

      # Flag
      when '?flag'
          return false if !flag?(cond[1])
              
        # Progress
      when '?progress'
        return false if !progress?(cond[1])

      # Active Quest
      when '?active'
        return false if !on_quest?(cond[1])
         when '?quest'
        return false if !on_quest?(cond[1])  
              
        # Item Check
      when '?item'
        return false if !$game_party.has_item?(cond[1].to_i)

    end

    return true

  end"?
# Copyright (c) 2013 DamiÃ¡n Silvani

# MIT License

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# https://github.com/munshkr/easing-ruby

  # Added function
  def easing(t,b,c,d,e)

  	t = t.to_f; b = b.to_f; c = c.to_f; d = d.to_f

  	case e
  		when :linear; linear_tween(t,b,c,d)

  		when :quad_in; ease_in_quad(t,b,c,d)
  		when :quad_out; ease_out_quad(t,b,c,d)
  		when :quad_in_out; ease_in_out_quad(t,b,c,d)

  		when :cubic_in; ease_in_cubic(t,b,c,d)
  		when :cubic_out; ease_out_cubic(t,b,c,d)
  		when :cubic_in_out; ease_in_out_cubic(t,b,c,d)

  		when :quart_in; ease_in_quart(t,b,c,d)
  		when :quart_out; ease_out_quart(t,b,c,d)
  		when :quart_in_out; ease_in_out_quart(t,b,c,d)

  		when :quint_in; ease_in_quint(t,b,c,d)
  		when :quint_out; ease_out_quint(t,b,c,d)
  		when :quint_in_out; ease_in_out_quint(t,b,c,d)

  		when :sine_in; ease_in_sine(t,b,c,d)
  		when :sine_out; ease_out_sine(t,b,c,d)
  		when :sine_in_out; ease_in_out_sine(t,b,c,d)

  		when :expo_in; ease_in_expo(t,b,c,d)
  		when :expo_out; ease_out_expo(t,b,c,d)
  		when :expo_in_out; ease_in_out_expo(t,b,c,d)

  		when :circ_in; ease_in_circ(t,b,c,d)
  		when :circ_out; ease_out_circ(t,b,c,d)
  		when :circ_in_out; ease_in_out_circ(t,b,c,d)

      when :bounce_in; ease_in_bounce(t,b,c,d)
      when :bounce_out; ease_out_bounce(t,b,c,d)
      when :bounce_in_out; ease_in_out_bounce(t,b,c,d)

  	end

  end

  def linear_tween(t, b, c, d)
    c * t / d + b
  end

  def ease_in_quad(t, b, c, d)
    return c*(t/=d)*t + b;
  end

  def ease_out_quad(t, b, c, d)
    return -c *(t/=d)*(t-2) + b;
  end

  def ease_in_out_quad(t, b, c, d)
    t /= d / 2
    return c / 2*t*t + b if (t < 1)
    t -= 1
    return -c/2 * (t*(t-2) - 1) + b
  end

  def ease_in_cubic(t, b, c, d)
    return c*(t/=d)*t*t + b
  end

  def ease_out_cubic(t, b, c, d)
    return c*((t=t/d-1)*t*t + 1) + b
  end

  def ease_in_out_cubic(t, b, c, d)
    return c/2*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t + 2) + b
  end

  def ease_in_quart(t, b, c, d)
    return c*(t/=d)*t*t*t + b
  end

  def ease_out_quart(t, b, c, d)
    return -c * ((t=t/d-1)*t*t*t - 1) + b
  end

  def ease_in_out_quart(t, b, c, d)
    return c/2*t*t*t*t + b if ((t/=d/2) < 1)
    return -c/2 * ((t-=2)*t*t*t - 2) + b
  end

  def ease_in_quint(t, b, c, d)
    return c*(t/=d)*t*t*t*t + b
  end

  def ease_out_quint(t, b, c, d)
    return c*((t=t/d-1)*t*t*t*t + 1) + b
  end

  def ease_in_out_quint(t, b, c, d)
    return c/2*t*t*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t*t*t + 2) + b
  end

  def ease_in_sine(t, b, c, d)
    return -c * Math.cos(t/d * (Math::PI/2)) + c + b
  end

  def ease_out_sine(t, b, c, d)
    return c * Math.sin(t/d * (Math::PI/2)) + b
  end

  def ease_in_out_sine(t, b, c, d)
    return -c/2 * (Math.cos(Math::PI*t/d) - 1) + b
  end

  def ease_in_expo(t, b, c, d)
    return (t==0) ? b : c * (2 ** (10 * (t/d - 1))) + b
  end

  def ease_out_expo(t, b, c, d)
    return (t==d) ? b+c : c * (-2**(-10 * t/d) + 1) + b
  end

  def ease_in_out_expo(t, b, c, d)
    return b if t == 0
    return b + c if t == d
    return (c/2) * 2**(10 * (t-1)) + b if ((t /= d/2) < 1)
    return (c/2) * (-2**(-10 * t-=1) + 2) + b
  end

  def ease_in_circ(t, b, c, d)
    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b
  end

  def ease_out_circ(t, b, c, d)
    return c * Math.sqrt(1 - (t=t/d-1)*t) + b
  end

  def ease_in_out_circ(t, b, c, d)
    return -c/2 * (Math.sqrt(1 - t*t) - 1) + b if ((t/=d/2) < 1)
    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b
  end

  # Added
  def ease_in_bounce(t,b,c,d)
  	return c - ease_out_bounce(d-t,0,c,d) + b
  end

  def ease_out_bounce(t,b,c,d)
  	t /= d
  	if ( (t) < (1 / 2.75))
  		return c * (7.5625 * t * t) + b
  	elsif (t < (2 / 2.75))
  		t -= (1.5 / 2.75)
  		return c * (7.5625 * (t) * t + 0.75) + b
  	elsif (t < (2.5 / 2.75))
  		t -= (2.25 / 2.75)
  		return c * (7.5625 * (t) * t + 0.9375) + b
  	else
  		t -= (2.625 / 2.75)
  		return c * (7.5625 * (t) * t + 0.984375) + b
  	end
  end

  def ease_in_out_bounce(t,b,c,d)
  	if (t < d / 2)
  		return ease_in_bounce(t * 2, 0, c, d) * 0.5 + b;
  	else
  		return ease_out_bounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  	end
  end"©class Object
	def do(tween)
		# Register
		tween.set_parent(self)
		$tweens.register(tween)
		tween.start
	end
	def done?
		return $tweens.done?(self)
	end
end"
def sequence(a,b)
	return SequenceTween.new(a,b)
end

def repeat(a,times=-1)
	return LoopTween.new(a,times)
end

def parallel(*args)
	return ParallelTween.new(args)
end

def pingpong(var,amount,duration,ease=:linear)
	return PingPongTween.new(var,amount,duration,ease)
end

def set(var,value)
	return SetTween.new(var,value)
end

def delay(duration)
	return DelayTween.new(duration)
end

def call(script)
	return CallTween.new(script)
end

def go(var,amount,dur,ease=:linear)
	return TimedTween.new(var,amount,dur,ease)
end

def to(var,target,speed=nil)
	return TargetTween.new(var,target,speed)
end

def proc(prc,delay=0)
	return ProcTween.new(prc,delay)
end


#==============================================================================
# ** Tweens
#==============================================================================

class Tween

	attr_reader :parent

	def initialize
		@parent = nil
	end

	def set_parent(parent)
		@parent = parent
	end

	def start
	end

end

class SetTween < Tween

	def initialize(var,value)
		@var = var
		@value = value
	end

	def done?
		return true
	end

	def start
		@parent.send(@var+"=",@value)
	end

	def copy
		return SetTween(@var,@value)
	end

end

class CallTween < Tween

	def initialize(script)
		@script = script
	end

	def done?
		return true
	end

	def start
		eval(@script)
	end

	def copy
		return CallTween(@script)
	end

end

class ProcTween < Tween

	def initialize(proc,delay)
		@proc = proc
		@delay = delay
	end

	def done?
		return @delay <= 0
	end

	def update(delta)
		@delay -= delta
		@proc.call()if done?
	end

end

class DelayTween < Tween

	def initialize(duration)
		@elapsed = 0
		@duration = duration
	end

	def done?
		return @elapsed >= @duration
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
	end

end

# Timed Tween
class TimedTween < Tween

	attr_accessor :elapsed, :duration, :ease

	def initialize(var,amount,duration,ease=:linear)
		@elapsed = 0
		@duration = duration
		@ease = ease
		@var = var
		@amount = amount
	end

	def done?
		return @elapsed >= @duration
	end

	def start
		@initial = @parent.send(@var)
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
		var = easing(elapsed, @initial, @amount, @duration, @ease)
		@parent.send(@var+"=",var)
	end

	def reverse
		nano = TimedTween.new(@var,-@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

	def copy
		nano = TimedTween.new(@var,@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

end

class TargetTween < Tween

	attr_accessor :initial, :target, :speed

	def initialize(var,target,speed=nil) # speed default to 10% distance
		@target = target
		@var = var
		@speed = @speed
	end

	def done?
		return @target == @parent.send(@var)
	end

	def start
		@initial = @parent.send(@var)
		@dist = @target - @initial
		@speed = @dist.to_f/10 if @speed == nil
	end

	def update(delta)
		val = @parent.send(@var)
		if (@target-val).abs < @speed.abs
			val = @target
		else
			val += @speed
		end		
		@parent.send(@var+"=",val)
	end

	def reverse

	end

	def copy
		nano = TargetTween.new(@var,@target,@speed)
		nano.set_parent(@parent)
		return nano
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class PingPongTween < TimedTween

	def done?
		# Never ending nano
		return false
	end

	def update(delta)
		super(delta)
		if @elapsed == @duration
			@initial = @parent.send(@var)
			@elapsed = 0
			@amount= -@amount
		end
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class LoopTween < Tween

	def initialize(child,times=-1)
		#super
		@initial = child.copy
		@child = child
		@times = times
	end

	def done?
		return @child.done? && @times == 0
	end

	def set_parent(parent)
		super(parent)
		@initial.set_parent(parent) if @initial
		@child.set_parent(parent)
	end

	def start
		@child.start
	end

	def update(delta)
		@child.update(delta)
		if @child.done?
			@times -= 1
			if @times != 0
				@child = @initial
				@initial = @child.copy
				@child.set_parent(@parent)
				#log_append 'start child'
				@child.start
			end
		end
	end

	def reverse

	end

	def copy
		return LoopTween.new(@child.copy, @times)
	end

end

class SequenceTween < Tween

	def initialize(*args)
		@sequence = args
	end

	def push(nano)
		@sequence.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@sequence.each{ |n| n.set_parent(parent)}
	end

	def done?
		return @sequence.empty?
	end

	def clear
		@sequence.clear
	end

	def start
		start_instants
	end

	def start_instants
		return if @sequence.empty?
		#log_append @sequence.first
		@sequence.first.start
		while !@sequence.empty? && @sequence.first.done?
			@sequence.shift#.dispose
			@sequence.first.start if !@sequence.empty?
		end
	end

	def update(delta)
		return if @sequence.empty?
		@sequence.first.update(delta)
		if @sequence.first.done?
			@sequence.shift#.dispose
			start_instants
		end
	end

	def count
		return @sequence.count
	end

	def reverse
		nano = SequenceTween.new()
		@sequence.reverse.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

	def copy
		nano = SequenceTween.new()
		@sequence.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end

class ParallelTween < Tween

	def initialize(*args)
		@nanos = args
	end

	def push(nano)
		@nanos.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@sequence.each{ |n| n.set_parent(parent)}
	end

	def done?
		@nanos.each{ |n|
			return false if !n.done?
		}
		return true
	end

	def start
		@nanos.each{ |n| 
			n.start
		}
	end

	def update(delta)
		@nanos.each{ |n| 
			n.update(delta)
		}
	end

	def reverse

	end

	def copy
		nano = ParallelTween.new()
		@nanos.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end