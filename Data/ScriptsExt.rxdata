[ê"˙#==============================================================================
# ** Game
#==============================================================================

APPFOLDER = "Aveyond 4"

def aveyond4

    # User Data folder
    Win32API.new('System/Utils', "AVSetEnv", ["V"], "I").call          
    $appdata = ENV['AV_APPDATA'] + "\\" + APPFOLDER
    Dir.mkdir($appdata) if !File.exists?($appdata) 

    # Who will debug the debug?
    begin
      $debug = DebugManager.new
    rescue StandardError => e
      p e.inspect
    end

    $cache = CacheManager.new
    $audio = AudioManager.new
    $keyboard = KeyboardManager.new
    $mouse = MouseManager.new
    $input = InputManager.new
    $data = DataManager.new
    $tweens = TweenManager.new
    $settings = SettingsManager.new
    $files = FileManager.new
    $battle = Game_Battle.new
    $fonts = FontManager.new
    $game = GameManager.new  

    $scratch = Bitmap.new(400,50)

    # Call main method as long as $scene is effective      
    $game.update until $game.quit?
    
    # Set the windowed mode for next time
    $settings.conclude
    $audio.dispose

rescue SystemExit

    $settings.conclude
    $audio.dispose

rescue StandardError => e

  $audio.dispose
    
  line = e.message.split(":")[1].to_i      
  log_err e.inspect
  log_err "------------------"
  
  e.backtrace.each{ |location|
    line_num = location.split(":")[1]
    script_name = location.split(":")[0]
    if script_name.include?("Scripts/")
      script_name['Scripts/'] = ''
    end

    if location.include?("Section")
      section = location[/(?#Section)(\d)*(:)/]
      section_err = section[0, section.length - 1]
      script_name = $RGSS_SCRIPTS[section_err.to_i][1]
    end

    method = location.split(":")[2]
    next if method == nil
    loc_err = "Line " + line_num + ", "+method.to_s+" in "+script_name    
    loc_err = "Game Start" if script_name.include?("{0128")
    log_err("#{loc_err}")
  } 
  
end"è#==============================================================================
# ** Sprite_Character
#==============================================================================

class Sprite_Character < Sprite

  attr_accessor :character     

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @vp = viewport

    @character = character
    @iconmode = false
    @pulse_delay = 0
    @pulse_idx = 0
    @fx_delay = 0
    @icons = [] # Sprites


    @windmill = @character.character_name.include?('mill')




    update
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    #update_windmill if @windmill

    # If tile ID, file name, or hue are different from current ones
    update_bitmap if graphic_changed?
    update_src_rect if src_rect_changed?   

    # Set visible situation
    update_position
    update_misc
    update_colors
    update_spark_trail
    update_icons

  end

  # Updates

  def update_bitmap

      @character_name = @character.character_name

      if @character_name.include?("Icons")
        self.bitmap = $cache.get(@character.character_name)
        @cw = bitmap.width
        @ch = bitmap.height
        self.ox = @cw/2
        self.oy = @ch
        @iconmode = true
        return
      end

      @iconmode = false

      self.bitmap = $cache.character(@character.character_name)

      @cw = bitmap.width / 4
      @ch = bitmap.height / 4
      self.ox = @cw / 2
      self.oy = @ch

      if @character_name.include?("Prop")
        @cw = bitmap.width
        @ch = bitmap.height
        self.ox = @cw / 2
        self.oy = @ch
        @iconmode = true
      end

      update_src_rect

  end

  def update_src_rect

    @old_pattern = @character.pattern
    @old_dir     = @character.direction
    @old_showdir     = @character.showdir

        # Src rect
    if !@iconmode
      if @character.force_pattern
        sx = @character.force_pattern * @cw
      else
        sx = @character.pattern * @cw
      end
      sy = (@character.showdir - 2) / 2 * @ch
      self.src_rect.set(sx, sy, @cw, @ch)
    end

  end

  def update_position
    # Set sprite coordinates
    self.x = @character.screen_x
    self.y = @character.screen_y - 8
    self.z = @character.screen_z(@ch)
  end

  def update_colors

    # Color
    if @character.color.is_a?(Color)
      self.color = @character.color
      return
    end

    # Flash effect
    if @character.flash_dur != nil
      self.flash(Color.new(255,255,255,160),@character.flash_dur)
      @character.flash_dur = nil
    end

    # Pulse effect
    if !@character.pulse_colors.empty?
      @pulse_delay -= 1
      if @pulse_delay <= 0
        @pulse_delay = 75
        self.flash(@character.pulse_colors[@pulse_idx],75)
        @pulse_idx += 1
        if @pulse_idx >= @character.pulse_colors.count
          @pulse_idx = 0
        end
      end
    end

  end

  def update_spark_trail

    return if @character == $player

    if @character.fxtrail != nil && @character.moving? && !@character.deleted
      @fx_delay -= 1
      if @fx_delay <= 0
        @fx_delay = 8
        spark(@character.id,@character.fxtrail,@character.off_x,@character.off_y+8)
      end
    end

  end

  def update_icons

    # Icons
    if @icons.count != @character.icons.count
      
      # If higher, pop the last one
      #num_new = @character.icons.count - @icons.count        

      # Rebuild icons
      @icons.each{ |i| i.dispose }
      @icons.clear

      total = (@icons.count-1) * (16+2)
      #total -= 2
      cx = 0#-total/2

      @character.icons.each{ |i|

        spr = Sprite.new(@vp)
        spr.bitmap = $cache.icon("states/#{i}")
        spr.ox = 8
        spr.oy = 8
        spr.x = self.x - cx
        spr.y = self.y - @ch
        spr.z += 1000
        @icons.push(spr)

        cx += 26

        # Pop
        spr.zoom_x = 0.8
        spr.zoom_y = 0.8
        spr.do(seq(go("zoom_x",0.5,200,:qio),go("zoom_x",-0.3,100,:qio)))
        spr.do(seq(go("zoom_y",0.5,200,:qio),go("zoom_y",-0.3,100,:qio)))

      }

    end

  end

  def update_misc

    self.visible = !@character.transparent
    self.zoom_x = @character.zoom
    self.zoom_y = @character.zoom

    self.opacity = @character.opacity
    self.bush_depth = @character.bush_depth 

  end

  def update_windmill
    # Windmill hack
    if @character.character_name.include?('mill')

      if @character.pattern < 4
        @character.pattern += 1
      else

        @character.pattern = 0

        # Get num, next pic thanks
        num = @character.character_name.split("-")[1].to_i
        num+=1
        num = 1 if num > 6
        @character.character_name = 'Props/mill-'+num.to_s

      end

    end
  end


  # Misc
  def graphic_changed?
    @character_name != @character.character_name
  end

  def src_rect_changed?
    @character.pattern != @old_pattern ||
      @character.direction != @old_dir ||
        @character.showdir != @old_showdir
  end

end
"©


class MapWrap < Tilemap

  attr_accessor :map_id

	def refresh(map)

      @map_id = map.id

      self.tileset = $cache.tileset(map.tileset.tileset_name)
      i = 0 
      map.tileset.autotile_names.each{ |a|
        next if a == ''
        self.autotiles[i] = $cache.autotile(a)
        i+=1
      }
      
      self.map_data = map.data
      self.priorities = map.tileset.priorities

	end

end"Ø
class Panorama

  attr_accessor :spd_x, :spd_y # Speed
  attr_accessor :pad_x, :pad_y # Padding
  attr_accessor :off_x, :off_y 
  attr_accessor :att_x, :att_y # Attach
  attr_accessor :start_x, :start_y 
  attr_accessor :repeat
 
  def initialize(v)
    @sprite = Sprite.new(v)
    @bitmap = nil

    @spd_x = @spd_y = 0
    @pad_x = @pad_y = 0
    @off_x = @off_y = 0

    @repeat = true
    @att_x = 0.0
    @att_y = 0.0

    @start_x = 0
    @start_y = 0

  end

  def blend=(b)
    @sprite.blend_type = b
  end

  def opacity=(o)
    @sprite.opacity = o
  end
 
 def dispose
    @sprite.bitmap.dispose
    @sprite.dispose
    @bitmap.dispose
  end

  def disposed?
    @bitmap.disposed? || @sprite.disposed?
  end
 
  def update

    return if disposed?
    
    @off_x += @spd_x
    @off_y += @spd_y

    @sprite.ox = -@off_x
    @sprite.oy = -@off_y

    @sprite.ox += ($map.display_x / 4 * @att_x)
    @sprite.oy += ($map.display_y / 4 * @att_y)

    @sprite.ox = @sprite.ox % @bitmap.width
    @sprite.oy = @sprite.oy % @bitmap.height

    @sprite.x = @start_x
    @sprite.y = @start_y

  end

  def bitmap=(bmp)
   
    w, h = 640,480
   
    nw = bmp.width <= 100 ? 2 : 3
    nh = bmp.height <= 100 ? 2 : 3
   
    dx = [(w / bmp.width).ceil, 1].max * nw
    dy = [(h / bmp.height).ceil, 1].max * nh

    dy = 1 if !@repeat
 
    bw = dx * bmp.width
    bh = dy * bmp.height
 
    @bitmap = bmp
    @sprite.bitmap = Bitmap.new(bw, bh)
     
      dx.times do |x|
        dy.times do |y|
          @sprite.bitmap.blt((x * bmp.width), (y * bmp.height), @bitmap, @bitmap.rect)
        end
      end

   end

end"Î

class Pop < Sprite

	attr_accessor :anim_delay

	def initialize(ein,eout,vp)
		super(vp)

		@anim_in = ein
		@anim_out = eout
		@anim_delay = 200

	end

	def start

		anim_seq = seq()

		case @anim_in

			when :rise
				self.opacity = 0
				anim_seq.push(go("opacity",255,300,:qio))
				anim_seq.push(go("y",-20,1500,:qo))

			when :fall
				anim_seq.push(go("y",-5,100,:qio))
				anim_seq.push(go("y",25,450,:bounce_o))

			when :fade
				self.opacity = 0
				#anim_seq.push(set("opacity",0))
				anim_seq.push(go("opacity",255,500,:qio))

			when :blast
				self.zoom_x = 1
				self.zoom_y = 0
				#anim_seq.push(para(go("zoom_x",1,500,:bounce_io),go("zoom_y",1,500,:bounce_io)))
				anim_seq.push(go("zoom_y",1,350,:bounce_o))

			when :lower
				self.opacity = 200
				anim_seq.push(go("y",15,1050,:quad_in))

		end

		anim_seq.push(delay(@anim_delay))

		case @anim_out

			when :fade
				anim_seq.push(go("opacity",-255,350,:qio))

			when :fade_quick
				anim_seq.push(go("opacity",-255,350,:qio))

			when :blast
				#anim_seq.push(para(go("zoom_x",1,500,:bounce_io),go("zoom_y",1,500,:bounce_io)))
				anim_seq.push(go("zoom_y",-1,700,:bounce_i))				

		end

		self.do(anim_seq)

	end

	def icon=(ico)

		self.bitmap = $cache.icon(ico)

		self.ox = width/2
		self.oy = height/2

	end

	def number(num,color,suffix=nil)

		# prepare number data
	    data = num.to_i.to_s.split(//)
	    nums = []
	    data.each{ |n| nums.push(n.to_i) }


	    # Default to dmg color for now
	    #color = :dmg

	    # Colors
	    colors = [:dmg,:mp,:sp,:rp,:hp,:hp2]
	    ic = colors.index(color)


	    # build the gfx of this number
	    src = $cache.numbers('pops')
	    cw = src.width/10
	    ch = src.height/colors.count

	    # Char width is now custom, same as cx
	    offsets = [0,17,33,50,67,84,101,117,134,151]
	    widths = [16,16,16,16,17,16,16,16,15,16]
	    
	    # prepare the final image
	    width = 0
	    nums.each{ |n| width+=cw }

	    # Add suffix
	    if suffix != nil
	    	suff_bmp = $cache.numbers(suffix.to_s)
	    	width += suff_bmp.width
	    end

	    # Create the bmp
	    bmp = Bitmap.new(width,ch)
	    
	    # Cursor
	    c = 0

	    nums.each{ |n|

	      s = offsets[n]
	      cw = widths[n]

	      bmp.blt(c,0,src,Rect.new(s,ic*ch,cw,ch))
	      c += cw - 3

	    }

	    # Blt the suffix
	    if suffix != nil
	    	bmp.blt(width-suff_bmp.width-3,3,suff_bmp,suff_bmp.rect)
	    end

	    self.bitmap = bmp
	    
		self.ox = width/2
		self.oy = height/2 

	end

	def image(img)

		# For critical and that
		self.bitmap = $cache.numbers(img)
		self.ox = self.bitmap.width/2
		self.oy = self.bitmap.height/2

	end


end"~
class Projectile < Sprite

	def initialize(fx,x,y,t,vp)

		self.bitmap = $cache.projectile(fx)

		

	end

end"◊
class Spark < Sprite

	attr_accessor :ev

	def initialize(fx,x,y,vp)
		super(vp)

		#self.zoom_x = 1.2
		#self.zoom_y = 1.2

		@reverse = false
		@idx = -1
		@next = 0

		# fx is database id, also gfx name
		# If not in database, use defaults

		self.bitmap = $cache.animation(fx)

		# Defaults
		@frames = 25
		@delay = 0

		@fade_out = true

		self.opacity = 122
		self.blend_type = 0

		@sound = nil
		@sound_delay = 1

		if $data.anims.has_key?(fx)

			anim = $data.anims[fx]
			@loop = true if anim.loop == "true"
			@frames = anim.frames
			@delay = anim.delay
			@fadeout = anim.fadeout
			self.opacity = anim.opacity
			case anim.order
				when 'below'
					self.z = 0
				when 'same'
				when 'above'
					self.z = 5000
			end

			@idx = anim.offset.to_i if anim.offset != nil

			#self.blend_type = anim.blend if anim.blend != nil

			# Split sound input
			if anim.sound != ''
				dta = anim.sound.split('=>')
				if dta.count > 1
					@sound_delay = dta[1].to_i
				end
				@sound = dta[0]
			end

		end

		self.center(x,y)
		
		update

	end

	def reverse
		@reverse = true
	end

	def width
		return self.bitmap.width / 5
	end

	def height
		return self.bitmap.width / 5
	end

	def done?
		return false if @fade_out && self.opacity > 0
		return @idx == @frames && !@loop
	end

	def update

		#self.ox = -$scene.map.display_x
    	#self.oy = -$scene.map.display_y

		# Step counters
		@next -= 1
		if @next < 1
			@next = @delay

			@idx += 1

			if @idx > @frames
				@loop ? @idx = 0 : @idx = @frames 
			end

			if @fadeout && !@loop
				self.opacity -= 30 if @idx >= @frames - 2
			end

			if @sound && @idx == @sound_delay
				sfx(@sound)
			end

			idx = @idx
			if @reverse
				idx = @frames - @idx
			end



			fx = idx % 5 # frames_per_row
			fy = idx / 5



			# Refresh
			
			self.src_rect = Rect.new(fx*width,fy*height,width,height)


		end

	end

end"æ
class Wave # Or just projectiles all spawned

	def initialize(fx,vp)

		#self.bitmap = $cache.projectile(fx)


		# Spawn all the sprites within
		@sprites = []

		

	end

end"m
# Spawn and manage weather particles

class Particle < Sprite

  attr_accessor :mx, :my, :sx, :sy, :opac
  
end

class Weather

end

class Weather_RainBroke

	def initialize(vp)

		@stars = []
	    (1..40).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle('rain')
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4 + rand(640)
	      s.sy = $scene.map.display_y/4
	      s.mx = 0
	      s.my = rand * 2.5
	      s.x = s.sx
	      s.y = s.sy
	   	  s.opac = 150 + rand(100)
	      s.opacity = 250
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      #s.sx += s.mx * (0.3+rand)
	      s.sy += 1#s.my * (0.3+rand)
	      #s.x = s.sx
	      s.y = s.sy
	      next
	      #s.opacity += 3 if s.opac > s.opacity
	      
	      if s.y > $scene.map.display_y/4 + 720

	        s.mx = rand
	        s.my = rand
	      	#s.sx = $scene.map.display_x/4 + rand(640) - 320
	      	s.sy = $scene.map.display_y/4
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	        s.opac = 150 + rand(100)
	        s.opacity = 250
	      end		      
		}

	end

	def dispose

	end

end

class Weather_Rain

	def initialize(vp)

		@stars = []
	    (1..40).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle('rain')
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4 + rand(640) - 200#-120+800)#rand(640)
	      s.sy = $scene.map.display_y/4 - rand(3080)#+ rand(480+240) - 240 #-140+700)#rand(480)
	      s.mx = rand * 0.5
	      s.my = (rand * 1.5) + 10
	      s.x = s.sx
	      s.y = s.sy
	   	  s.opac = 70 + rand(100)
	      s.opacity = 0
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      #s.sx += s.mx * (0.3+rand)
	      s.sy += s.my #* (0.3+rand)
	      s.x = s.sx
	      s.y = s.sy

	      s.opacity += 3 if s.opac > s.opacity
	      
	      if s.x > $scene.map.display_x/4 + 860 || s.y > $scene.map.display_y/4+720 || s.x < $scene.map.display_x/4 - 320 || s.y < $scene.map.display_y/4 - 240
	        s.mx = rand
	        s.my = (rand * 2) + 6
	      	s.sx = $scene.map.display_x/4 + rand(640) - 200# - 320#-120+800)#rand(640)
	      	s.sy = $scene.map.display_y/4 - rand(3080) #-140+700)#rand(480)
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	        s.opac = 10 + rand(40)
	        s.opacity = 0
	      end		      
		}

	end

	def dispose
		@stars.each{ |s| s.dispose }
	end

end

class Weather_DarkDots

	def initialize(vp)

		@stars = []
	    (1..30).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle(['yellow','blue'].sample)
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4+ rand(640+220) - 320#-120+800)#rand(640)
	      s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	      s.mx = rand * 0.5
	      s.my = rand * 0.5
	      s.x = s.sx
	      s.y = s.sy
	   	  s.opac = 10 + rand(40)
	      s.opacity = 0
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      s.sx += s.mx * (0.3+rand)
	      s.sy += s.my * (0.3+rand)
	      s.x = s.sx
	      s.y = s.sy

	      s.opacity += 3 if s.opac > s.opacity
	      
	      if s.x > $scene.map.display_x/4 + 860 || s.y > $scene.map.display_y/4+720 || s.x < $scene.map.display_x/4 - 320 || s.y < $scene.map.display_y/4 - 240
	        s.mx = rand
	        s.my = rand
	      	s.sx = $scene.map.display_x/4+ rand(640+320) - 320#-120+800)#rand(640)
	      	s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	        s.opac = 70 + rand(100)
	        s.opacity = 0
	      end		      
		}

	end

def dispose
		@stars.each{ |s| s.dispose }
	end

end

class Weather_FireDots

	def initialize(vp)

		@stars = []
	    (1..50).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle(['yellow','red'].sample)
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4+ rand(640+220) - 320#-120+800)#rand(640)
	      s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	      s.mx = rand * 2.5
	      s.my = rand * 2.5
	      s.x = s.sx
	      s.y = s.sy
	   	  s.opac = 10 + rand(40)
	      s.opacity = 0
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      s.sx += s.mx * (4.3+rand)
	      s.sy += s.my * (4.3+rand)
	      s.x = s.sx
	      s.y = s.sy

	      s.opacity += 3 if s.opac > s.opacity
	      
	      if s.x > $scene.map.display_x/4 + 860 || s.y > $scene.map.display_y/4+720 || s.x < $scene.map.display_x/4 - 320 || s.y < $scene.map.display_y/4 - 240
	        s.mx = rand
	        s.my = rand
	      	s.sx = $scene.map.display_x/4+ rand(640+320) - 320#-120+800)#rand(640)
	      	s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	        s.opac = 70 + rand(100)
	        s.opacity = 0
	      end		      
		}

	end

def dispose
		@stars.each{ |s| s.dispose }
	end

end

class Weather_LeafDots

	def initialize(vp)

		@stars = []
	    (1..30).each{ |s|
	      s = Particle.new(vp)
	      s.bitmap = $cache.particle(['leaf-1','leaf-2','leaf-3'].sample)
	      @stars.push(s)
	      s.sx = $scene.map.display_x/4+ rand(220) - 320#-120+800)#rand(640)
	      s.sy = $scene.map.display_y/4+ rand(240) - 240 #-140+700)#rand(480)
	      s.mx = rand * 2.5
	      s.my = rand * 2.5
	      s.x = s.sx
	      s.y = s.sy
	      # z = 1 + rand
	      # s.zoom_x = z
	      # s.zoom_y = z

	    }

	end

	def update

		@stars.each{ |s|

	      s.sx += s.mx * (7.3+rand)
	      s.sy += s.my * (7.3+rand)
	      s.x = s.sx
	      s.y = s.sy

	      
	      if s.x > $scene.map.display_x/4 + 860 || s.y > $scene.map.display_y/4+720 || s.x < $scene.map.display_x/4 - 320 || s.y < $scene.map.display_y/4 - 240
	        s.mx = rand
	        s.my = rand
	      	s.sx = $scene.map.display_x/4+ rand(640+320) - 320#-120+800)#rand(640)
	      	s.sy = $scene.map.display_y/4+ rand(480+240) - 240 #-140+700)#rand(480)
	        # if rand > 0.5
	        #   s.sx = rand(-120+750)
	        #   s.sy = -100 + rand(50)
	        # else
	        #   s.sx = -100 + rand(50)
	        #   s.sy = rand(-140+560)
	        # end
	      end		      
		}

	end

def dispose
		@stars.each{ |s| s.dispose }
	end

end"^#==============================================================================
# Widget_Label
#==============================================================================

class Area < Sprite
  
  # accessors
  attr_accessor :font 
  attr_accessor :fixed_width
  attr_accessor :padding
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug

    @text = "Label"

    @padding = 5
    @spacing = 5

    # Required for next lining
    @fixed_width = 250
    
  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    if @text != text
      @text = text
      refresh
    end
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

  	# Split into lines that fit
  	lines = [""]
  	cx = 0
  	@text.split(" ").each{ |word|
  		w = $fonts.size(word,@font)
  		cx += w.width
  		if cx < @fixed_width
  			lines[-1] += word + ' '
  			cx += @spacing
  		else
  			lines.push(word + ' ')
  			cx = w.width + @spacing
  		end
  	}

  	#log_scr(lines)

  	height = $fonts.size("Happy",@font).height

  	# Build the bitmap now
  	w = @fixed_width
    h = height * lines.count

    self.bitmap = Bitmap.new(w+@padding*2,h+@padding*2)
    self.bitmap.font = @font

    cy = 0
    lines.each{ |line|
    	self.bitmap.draw_text(@padding,@padding+cy,w*2,height,line)
    	cy += height
    }
    
    
  end
  
end"¥	

def build_value_bmp(num)

	# prepare number data
    data = num.ceil.to_s.split(//)
    nums = []
    data.each{ |n| nums.push(n.to_i) }

    # Char width is now custom, same as cx
	offsets = [0,14,27,39,52,65,78,91,104,117]
	widths = [11,10,10,10,11,10,11,11,11,11]

    # build the gfx of this number
    src = $cache.menu_common("stat-nums")
    cw = src.width/10
    ch = src.height#/7

    # prepare the final image
    width = 2
    nums.each{ |n| width+= (widths[n]-2) }
    bmp = Bitmap.new(width,ch)
    c = 0

    nums.each{ |n|

   		s = offsets[n]
	    cw = widths[n]

	    bmp.blt(c,0,src,Rect.new(s,0,cw,ch))
	    c += cw - 2

    }

    return bmp

end

class Bar < Sprite

	attr_accessor :value, :max, :target

	def initialize(vp,w,h)

		super(vp)

		
		@value = 100
		@drawn = @value

		@target = 0
		@max = 100

		@width = w
		@height = h

		@base_color = Color.new(40,40,40,200)
		@ghost_color = Color.new(255,255,255,180)
		@bar_color = Color.new(0,255,0,255)

		@border = Color.new(255,255,255,255)
		#@border = Color.new(0,0,0,150)

		self.bitmap = Bitmap.new(w,h)

		redraw

	end

	def for(which)
		case which
			when :hp
				#@ghost_color = Color.new(255,87,38,110)
				@bar_color = Color.new(255,87,38,255)
			when :xp
				#@ghost_color = Color.new(44,178,34,110)
				@bar_color = Color.new(44,178,34,255)
			when 'boy'
				#@ghost_color = Color.new(102,31,232,110)
				@bar_color = Color.new(102,31,232,255)
			when 'ing','hib',:mp
				#@ghost_color = Color.new(52,75,252,110)
				@bar_color = Color.new(52,75,252,255)
			when 'phy'
				#@ghost_color = Color.new(232,31,50,110)
				@bar_color = Color.new(232,31,50,255)
		end
		redraw
	end

	def update
		if @drawn #!= @value.to_i
			redraw
		end
	end

	def redraw

		@drawn = @value#.to_i

		# Draw the 3 layers
		self.bitmap.clear
		self.bitmap.fill(@base_color)

		# Draw ghost
		if @target > @value
			gw = ((@target.to_f/@max) * @width).to_i
			self.bitmap.fill_rect(0,0,gw,@height,@ghost_color)
		end

		# Draw next
		vw = ((@value.to_f/@max) * @width).to_i
		self.bitmap.fill_rect(0,0,vw,@height,@bar_color)

		# Draw border
		# if @border
		# 	self.bitmap.fill_rect(0,0,@width,1,@border)
		# 	self.bitmap.fill_rect(0,@height-1,@width,1,@border)
		# 	self.bitmap.fill_rect(0,1,1,@height-2,@border)
		# 	self.bitmap.fill_rect(@width-1,1,1,@height-2,@border)
		# end

	end

end"ô
class Box 

	attr_accessor :name
	attr_accessor :window

	attr_accessor :alpha

	attr_accessor :px, :py
	
	def initialize(vp,w=100,h=100)

		@wallpaper = Sprite.new(vp)
		@window = Sprite.new(vp)		

		@skin = nil
		@src = nil

		@width = w
		@height = h

		@alpha = 210#230		

		# Keep a hold of it
		@x = 0
		@y = 0

		# Wallapper Position
		@px, @py = 0.0, 0.0

		# Display position, integer
		@dx, @dy = 0, 0

		# Anim speed - default to still
		@sx = 0.0#0.2
		@sy = 0.0#0.2

	end

	# def wall_sprite
	# 	return @wallpaper
	# end

	def disposed?
		return @wallpaper.disposed? || @window.disposed?
	end

	def flash_light
		@wallpaper.flash(Color.new(255,255,255,40),20)
	end

	def flash_heavy
		@wallpaper.flash(Color.new(255,255,255,100),20)
	end

	def scroll(x,y)
		@sx = x
		@sy = y
	end

	def dispose
		@wallpaper.dispose
		@window.dispose
	end

	def skin=(bmp)
		@skin = bmp
		@window.bitmap = Bitmap.new(@width,@height)
		@window.bitmap.borderskin(@skin)
	end

	def wallpaper=(w)
		@src = w
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		redraw
	end

	def color=(c)
		@color = c
		@wallpaper.bitmap = Bitmap.new(@width-8,@height-8)
		@wallpaper.bitmap.fill(c)
	end

	def opacity=(o)
		@wallpaper.opacity = o
		@window.opacity = o
	end

	def opacity
		return @window.opacity
	end

	def hide
		@wallpaper.opacity = 0
		@window.opacity = 0
	end

	def show 
		@wallpaper.opacity = 255
		@window.opacity = 255
	end

	def x=(v)
		@x = v
		@wallpaper.x = v+4
		@window.x = v
	end

	def x
		return @x
	end

	def y=(v)
		@y = v
		@wallpaper.y = v+4
		@window.y = v
	end

	def y
		return @y
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def width() return @width end
	def height() return @height end

	def height=(h)
		resize(@width,h)
	end

	def width=(w)
		resize(w,@height)
	end

	def resize(w,h)
		@width = w
		@height = h
		@window.bitmap = Bitmap.new(w,h)
		@window.bitmap.borderskin(@skin)
		@wallpaper.bitmap = Bitmap.new(w-8,h-8)	
		if @src != nil	
			redraw
		else
			@wallpaper.bitmap.fill(@color)
		end
	end

	def update

		@wallpaper.update

		# Redraw the bmp if needed
		@px += @sx
		@py += @sy

		# Mod to width of bmp
		@px -= @src.width if @px > @src.width
		@px += @src.width if @px < -@src.width
		@py -= @src.height if @py > @src.height
		@py += @src.height if @py < @src.height		

		if @px.to_i != @dx || @py.to_i != @dy
			@dx = @px.to_i
			@dy = @py.to_i
			redraw
		end

	end

	def redraw

		@wallpaper.bitmap.clear

		cx = -@dx
		cy = -@dy

		while cx < @width

			while cy < @height

				rct = @src.rect
				# If draw's over, cancel
				# Also for offset for first

				@wallpaper.bitmap.blt(cx,cy,@src,rct,@alpha)

				cy += @src.height

			end

			cy = -@dy
			cx += @src.width
			#log_info("DRAW #{cx}")

		end

	end

end"
#==============================================================================
# Button
#==============================================================================

class Button < Sprite
  
  # accessors
  attr_accessor :select, :deselect, :press
  attr_accessor :bmp_up, :bmp_over, :bmp_disable

  attr_accessor :shrink
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp=nil)
       
    super(vp)

    @bmp_up = nil
    @bmp_over = nil

    # handle mouseovers and that and procs and that
    @select = nil#Proc.new{ self.do(pingpong("x",-50,500,:quad_in_out)) }
    @deselect = nil#Proc.new{ $tweens.clear(self); self.x = 22; $tweens.clear(self) }
    @press = nil#Proc.new{self.do(pingpong("y",-30,300,:quad_in_out));}

    @state = :idle # :over
    @disabled = false

    @shrink = 0
    
  end

  def disabled=(v)
    @disabled = v
    self.bitmap = @bmp_disable if @disabled
  end
  
  #--------------------------------------------------------------------------
  # * Update inputs
  #--------------------------------------------------------------------------
  def update

    return if @disabled

    # Check inputs if active?
    if @state == :idle
      #if Input.method == :mouse
        check_hover($mouse.position)
      #end
      # check mouse hover?
    end

    if @state == :active
      check_nhover($mouse.position)
      if @state == :active
        if $input.click?
          @press.call() if @press
        end
      end
    end

  end

  # check from mouse or pressing leftright
  def check_hover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    return if pos[0] < self.x + @shrink
    return if pos[1] < self.y + @shrink
    return if pos[0] > self.x + self.width - @shrink
    return if pos[1] > self.y + self.height - @shrink
    @state = :active
    self.bitmap = @bmp_over if @bmp_over
    @select.call() if @select
  end

  def check_nhover(pos)
    #log_append "CHECKHOVER"
    #log_append pos
    #log_append [self.x,self.y]
    w = false
    w = true if pos[0] < self.x + @shrink
    w = true if pos[1] < self.y + @shrink
    w = true if pos[0] > self.x + self.width - @shrink
    w = true if pos[1] > self.y + self.height - @shrink
    return if w == false
    @state = :idle
    self.bitmap = @bmp_up if @bmp_up
    @deselect.call() if @deselect
  end

end"%
#==============================================================================
# Widget_Label
#==============================================================================

class Label < Sprite
  
  # accessors
  attr_accessor :align 
  attr_accessor :font 
  attr_accessor :shadow
  attr_accessor :fixed_width
  attr_accessor :padding

  attr_accessor :gradient

  attr_accessor :icon_oy
    
  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

    @font = $fonts.debug
    @shadow = nil

    @text = "Label"

    @align = 0

    @icon = nil

    @padding = 5

    @icon_oy = 0

    # If there is a width, don't auto size width
    @fixed_width = 0

  end

  def update
    super
    #redraw
  end
  
  #--------------------------------------------------------------------------
  # * Manage
  #--------------------------------------------------------------------------
  def text=(text)
    text = text.to_s
    if @text != text
      @text = text
      refresh
    end
  end

  def icon=(icon)
    @icon = icon
    refresh
  end
    
  #--------------------------------------------------------------------------
  # * Redraw
  #--------------------------------------------------------------------------
  def refresh

    # If fixed width, don't recreate
    if @fixed_width > 0 
      if self.bitmap && self.bitmap.width == @fix_width
        self.bitmap.clear
      else
        size = $fonts.size(@text,@font)
        size.height += @padding*2
        self.bitmap = Bitmap.new(@fixed_width,size.height)
      end
    else
      size = $fonts.size(@text,@font)
      size.width += @padding*2
      size.width += 32 if @icon
      size.height += @padding*2
      self.bitmap = Bitmap.new(size.width,size.height)
    end

    self.bitmap.font = @font

    # Draw the icon
    if @icon

      self.bitmap.blt(@padding,(size.height-28)/2+3+@icon_oy,@icon,@icon.rect)

    end

    # Draw the text
    x = @padding
    x += 26 if @icon
    y = @padding
    w = self.bitmap.width-@padding*2
    h = self.bitmap.height-@padding*2
    
    if @shadow
      self.bitmap.font = @shadow
      self.bitmap.draw_text(x+1,y+1,w,h,@text,@align)
    end

    self.bitmap.font = @font
    if @gradient
      self.bitmap.draw_gtext(x,y,w,h,@text,@align)
    else
      self.bitmap.draw_text(x,y,w,h,@text,@align)
    end
        
  end
  
end"M#==============================================================================
# The magical list REDUX
#==============================================================================

class List
      
  attr_accessor :x, :y
  attr_accessor :per_page
  attr_accessor :item_width, :item_height
  attr_accessor :item_ox, :item_space

  attr_accessor :select, :cancel, :change

  attr_accessor :active

  attr_accessor :user
  attr_accessor :type

  attr_accessor :page_idx
  attr_accessor :scroll_idx

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize() 

    # Make own viewport
    @vp = Viewport.new(0,0,1000,1000)
    @vp.z = 9500

    @font = Font.new
    @font.name = "Verdana"
    @font.size = 20 #was 26
    @font.color = Color.new(245,223,200)

    @font_inactive = Font.new
    @font_inactive.name = "Verdana"
    @font_inactive.size = 20 #was 26
    @font_inactive.color = Color.new(245,223,200,130)

    @item_width = 0
    @item_height = 0

    @item_ox = 0
    @item_space = 0

    # Procs
    @select = nil
    @cancel = nil
    @change = nil

  	@x = 0
  	@y = 0

    @user = nil
    @type = :item
  	@data = []

  	@scroll_idx = 0
  	@page_idx = 0

  	@per_page = 8

  	# Sprites
    @back_sprite = Sprite.new(@vp)
    @back_sprite.z = 0
    @select_sprite = Sprite.new(@vp)    
    @select_sprite.z = 20
    @content_sprite = Sprite.new(@vp)
    @content_sprite.z = 30

    @scroll_box = Sprite.new()
    @scroll_box.bitmap = $cache.menu_common('scroll-box')
    @scroll_box.x = 234
    @scroll_box.y = 406
    @scroll_box.z = 5000

    @scroll_down = Button.new()
    @scroll_down.shrink = 4
    @scroll_down.bitmap = $cache.menu_common('scroll-down')
    @scroll_down.bmp_up = $cache.menu_common('scroll-down')
    @scroll_down.bmp_over = $cache.menu_common('scroll-down-red')
    @scroll_down.bmp_disable = $cache.menu_common('scroll-down-off')
    @scroll_down.x = 239
    @scroll_down.y = 408
    @scroll_down.z = 5000
    @scroll_down.press = Proc.new{ self.scrollbar_down }

    @scroll_up = Button.new()
    @scroll_up.shrink = 4
    @scroll_up.bitmap = $cache.menu_common('scroll-up')
    @scroll_up.bmp_up = $cache.menu_common('scroll-up')
    @scroll_up.bmp_over = $cache.menu_common('scroll-up-red')
    @scroll_up.bmp_disable = $cache.menu_common('scroll-up-off')
    @scroll_up.x = 262
    @scroll_up.y = 408
    @scroll_up.z = 5000
    @scroll_up.press = Proc.new{ self.scrollbar_up }

    # Setup
    @select_sprite.bitmap = $cache.menu_common('list-bar-'+$menu.char)    

    @active = true

  end

  def move(x,y)
    @x = x
    @y = y
  end

  def opacity=(o)
    @back_sprite.opacity = o
    @content_sprite.opacity = o
    @select_sprite.opacity = o
    @scroll_box.opacity = o
    @scroll_down.opacity = o
    @scroll_up.opacity = o
  end

  def opacity
    return @back_sprite.opacity
  end

  def dispose
  	@back_sprite.dispose
    @select_sprite.dispose
    @content_sprite.dispose
    @scroll_box.dispose
    @scroll_down.dispose
    @scroll_up.dispose
  end

  def setup(data,idx=0)

    @back_sprite.bitmap.clear if @back_sprite.bitmap
    @content_sprite.bitmap.clear if @content_sprite.bitmap

  	@data = data
    @scroll_idx = 0
    @page_idx = idx
    @select_sprite.y = idx * row_height
    @active = true

    # Remove the scroll arrows if mouse is off OR not enough to need
    if @data.count <= @per_page
      @scroll_box.hide
      @scroll_down.hide
      @scroll_up.hide
    else
      @scroll_box.show
      @scroll_down.show
      @scroll_up.show
    end

  	refresh(false) #if !data.empty?

  end

  def slide
    @content_sprite.opacity = 0
    @content_sprite.do(go("opacity",255,300,:qio))
    @content_sprite.x = -20
    @content_sprite.do(go("x",20,300,:qio))
  end

  def set_idx(page_idx,scroll_idx)
    @page_idx = page_idx
    @scroll_idx = scroll_idx
    @page_idx -= 1 while @page_idx >= @per_page
    @page_idx -= 1 while @page_idx >= @data.count
    refresh
  end

  def idx
    return @scroll_idx + @page_idx
  end

  def row_height
    @item_height + @item_space
  end

  def can_scroll?
    @data.count > @per_page
  end

  def call_change

        i = idx
        #i -= 1 if !can_scroll?
        @change.call(current) if !@change.nil?

  end

  # When data changes
  def refresh(ch=true)

    @vp.rect = Rect.new(@x,@y,@item_width,row_height*@per_page)

    @scroll_box.y = @y + (row_height*@per_page) + 2
    @scroll_down.y = @scroll_box.y + 2
    @scroll_up.y = @scroll_box.y + 2

    # Draw the background sprite and position it
    rows = [@per_page,@data.count].min
    rows += 2 if can_scroll?
    rows = 1 if rows == 0
    height = row_height * rows

    #log_info(rows)

    @back_sprite.bitmap = Bitmap.new(@item_width,height)
    @content_sprite.bitmap = Bitmap.new(@item_width,height)

    @back_sprite.y = can_scroll? ? -row_height : 0
    @content_sprite.y = can_scroll? ? -row_height : 0

    @select_sprite.y = @page_idx * row_height
    @select_sprite.show

    # Disable arrows
    #@scroll_down.disabled = can_scroll_down?
    #@scroll_up.disabled = can_scroll_up?


    src = $cache.menu_common('list-bar')

    i = 0
    rows.times{ 
      @back_sprite.bitmap.blt(0,i*row_height,src,src.rect)
      # Draw each row
      if can_scroll?
        draw(@data[@scroll_idx + i-1],i) # -1 makes the first row visible on can scrolls
      else
        draw(@data[@scroll_idx + i],i)
      end
      i += 1
    }

    call_change if ch

  end

  def can_scroll_down?
    return false if !can_scroll? || @scroll_idx >= (@data.count - @per_page)
    return true    
  end

  def can_scroll_up?
    return false if !can_scroll?
    return false if @scroll_idx <= 0
    return true
  end

  # ADD THIS MOUSE CONTROL
  def scrollbar_down
    return if !can_scroll? || @scroll_idx >= (@data.count - @per_page)
      #@page_idx += 1
      sys('select')   
      @select_sprite.y += row_height      
      @page_idx += 1
      scroll_up 
  end

  def scrollbar_up
      return if !can_scroll?
      return if @scroll_idx <= 0
      #@page_idx -= 1
      sys('select')   
      @select_sprite.y -= row_height      
      @page_idx -= 1
      scroll_down
  end

  def current
    #return @current[0] if @type == :misc
    return @data[idx] if can_scroll?
    return @data[idx]
  end

  def draw(data,row)

    #return if data == nil # For above or below accessible
    if data == nil
      return draw_empty(row)
    end

    # Drw the contents
    case @type
      when :item
        draw_item(data,row)
      when :potion
        draw_potion(data,row)
      when :shop
        draw_shop(data,row)
      when :sell
        draw_sell(data,row)
      when :chester
        draw_chester(data,row)
      when :equip
        draw_equip(data,row)
      when :skill
        draw_skill(data,row)
      when :quest
        draw_quest(data,row)
      when :misc
        draw_misc(data,row)
      when :file
        draw_file(data,row)
    end

  end

  def draw_empty(row)

    name = " - Empty - "
    #ico = $cache.icon("misc/unknown")
    #number = 0
    
    #@content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    #if number > 0
    #  @content_sprite.bitmap.draw_text(222+21,row*row_height,@item_width,@item_height,"x"+number.to_s,0)
    #end

  end

  def draw_item(data,row)

    return if data != 'remove' && !$data.items.has_key?(data)

    item = $data.items[data] if data != 'remove'

    active = true # $party.get(@user).can_use_item?(item) # Check if in battle perhaps?

    if data != 'remove'
      name = item.name
      ico = $cache.icon(item.icon)
      number = $party.item_number(data)
    else
      name = "Remove"
      ico = $cache.icon("misc/cross")
      number = 0
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.font = @font_inactive if !active
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    if number > 0
      @content_sprite.bitmap.draw_text(222+21,row*row_height,@item_width,@item_height,"x"+number.to_s,0)
    end

  end

  def draw_potion(data,row)

    item = $data.potions[data]

    if item != nil
      name = item.name
      ico = $cache.icon("misc/unknown")
      ico = $cache.icon($data.items['potion-'+data].icon)
    else
      name = "ERROR NIL"
      ico = $cache.icon("misc/unknown")
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)

  end

  def draw_shop(data,row)

    return if !$data.items.has_key?(data)

    item = $data.items[data]

    if item != nil
      name = item.name
      ico = $cache.icon(item.icon)
      price = item.price.to_i
    else
      name = "Remove"
      ico = $cache.icon("misc/unknown")
      price = 0
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.font = @font_inactive if !$party.has_gold?(price)
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    if price > 0
      @content_sprite.bitmap.font = $fonts.pop_type
      ico = $cache.icon("misc/coins")
      @content_sprite.bitmap.blt(220,(row*row_height)+5,ico,ico.rect)
      @content_sprite.bitmap.draw_text(245,row*row_height,@item_width,@item_height,price.to_s,0)
    end

  end

  def draw_sell(data,row)

    return if !$data.items.has_key?(data)

    item = $data.items[data]

    if item != nil
      name = item.name
      ico = $cache.icon(item.icon)
      price = item.price.to_i/2
    else
      name = "Remove"
      ico = $cache.icon("misc/unknown")
      price = 0
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    if price > 0
      @content_sprite.bitmap.font = $fonts.pop_type
      ico = $cache.icon("misc/coins")
      @content_sprite.bitmap.blt(220,(row*row_height)+5,ico,ico.rect)
      @content_sprite.bitmap.draw_text(245,row*row_height,@item_width,@item_height,price.to_s,0)
    end

  end

  def draw_chester(data,row)

    #log_sys(data)

    item = $data.skills[data]

    if item != nil
      name = item.name
      ico = $cache.icon(item.icon)
      price = item.price.to_i
    else
      name = "Remove"
      ico = $cache.icon("misc/unknown")
      price = 0
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.font = @font_inactive if !$party.has_gold?(price)
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)
    if price > 0
      ico = $cache.icon("misc/magics")
      @content_sprite.bitmap.blt(228,(row*row_height)+5,ico,ico.rect)
      @content_sprite.bitmap.draw_text(254,row*row_height,@item_width,@item_height,price.to_s,0)
    end

  end

  def draw_equip(data,row)

    return if !$data.items.has_key?(data)

    if data == nil
      icon =  $cache.icon("misc/unknown")
      name = "Nothing"
      slot = "NONE"
    else
      item = $data.items[data]
      name = item.name
      icon =  $cache.icon(item.icon)
      slot = item.slot
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,icon,icon.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

    #sprite.bitmap.font = @font 
    #sprite.bitmap.draw_text(-10,-1,@item_width,@item_height,slot,2)

  end

  def draw_skill(data,row)

    return if !$data.skills.has_key?(data)

    item = $data.skills[data]
    ico = $cache.icon(item.icon)

    active = $party.get(@user).can_use_skill?(item.id)
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.font = @font_inactive if !active
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

    # If cooldown, show that instead of mana
    if $party.get(@user).get_cooldown(data) > 0

      cooldown = $party.get(@user).get_cooldown(data)

      ico = $cache.icon("misc/cooldown")
      @content_sprite.bitmap.blt(220,(row*row_height)+6,ico,ico.rect)
      @content_sprite.bitmap.draw_text(245,row*row_height,@item_width,@item_height,cooldown.to_s,0)

    elsif item.cost > 0

      # Mana
      if @user == 'boy'
        ico = $cache.icon("misc/darkness")
      elsif @user == 'phy'
        ico = $cache.icon("misc/rage")
      else
        ico = $cache.icon("misc/mana")
      end
      @content_sprite.bitmap.blt(220,(row*row_height)+6,ico,ico.rect)
      @content_sprite.bitmap.draw_text(245,row*row_height,@item_width,@item_height,item.cost.to_s,0)

    end

  end

  def draw_quest(data,row)

    return if !$data.quests.has_key?(data)

    item = $data.quests[data]

    ico = $cache.icon('misc/'+item.type)
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,item.name,0)

  end

  def draw_misc(data,row)

    #log_info(data)

    ico = $cache.icon(data[2])

    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,data[1],0)

    if data[0] == 'music' || data[0] == 'sound'
      ia = $cache.icon("misc/sound-down")
      ib = $cache.icon("misc/sound-up")
      @content_sprite.bitmap.blt(215,(row*row_height)+5,ia,ia.rect)
      @content_sprite.bitmap.blt(250,(row*row_height)+5,ib,ib.rect)
    end

  end


  def draw_file(data,row)

    header = $files.headers[data] 

    if header == nil
      name = "- Empty -"
      ico = $cache.icon('misc/dots') 
    else

        header[:location] = "Wyrmwood" if !header.has_key?(:location)

        if header[:time].is_a?(String)
          time = header[:time]
        else
          time = build_time_string(header[:time])
        end
        name = "#{header[:location]} - "
        name = "Autosave - " if data == 0
        name += time

      ico = $cache.icon("faces/"+header[:leader])
    end
    
    @content_sprite.bitmap.blt(8,(row*row_height)+5,ico,ico.rect)
    @content_sprite.bitmap.font = @font 
    @content_sprite.bitmap.draw_text(18+21,row*row_height,@item_width,@item_height,name,0)

  end


  def update

    @vp.rect.x = @x
    @vp.rect.y = @y

    return if !@active

    @select_sprite.update

    if !$tweens.done?(@back_sprite)

      # Still use up the inputs
      #$input.action? || $input.click? || $input.cancel? || $input.rclick?
      return

    end

    @scroll_down.update
    @scroll_up.update

  	# Check inputs and that
  	if $input.down?

      return if idx >= @data.count - 1

      # If the tweens are going, skip to done
      $tweens.resolve(@back_sprite)
      $tweens.resolve(@content_sprite)
      $tweens.resolve(@select_sprite)

      sys('select')

      # Move the sprite down, but not too far!
      @select_sprite.y += row_height  		
      @page_idx += 1

      if @select_sprite.y > (@per_page-1) * row_height
        @select_sprite.y -= row_height
        @page_idx -= 1
      end

      @select_sprite.flash(Color.new(255,255,255,40),20)
  		
      #if @data.count > @max_per_page

      if can_scroll? && @page_idx >= (@per_page-2) && @scroll_idx < (@data.count - @per_page) #-1 # makes bottom row not visible on can_scroll
        scroll_up
  		else
        i = idx
        #i -= 1 if !can_scroll?
  		  @change.call(current) if !@change.nil?
      end
      

      #@change.call(current) if !@change.nil?

  	end

  	if $input.up? #&& @dynamo.done?

      return if idx <= 0

      # If the tweens are going, skip to done
      $tweens.resolve(@back_sprite)
      $tweens.resolve(@content_sprite)
      $tweens.resolve(@select_sprite)

      sys('select')      
      
      # Move the sprite down
      @select_sprite.y -= row_height
  		@page_idx -= 1

       if @select_sprite.y < 0
        @select_sprite.y += row_height
        @page_idx += 1
      end

      @select_sprite.flash(Color.new(255,255,255,40),20)

  		if can_scroll? && @scroll_idx > 0 && @page_idx <= 1
        scroll_down
      else
        i = idx
        #i -= 1 if !can_scroll?
        @change.call(current) if !@change.nil?
      end
      
      #@change.call(current) if !@change.nil?

  	end

    # Selection

    # Cancel
    if !@cancel.nil? && ($input.cancel? || $input.rclick?)
      @cancel.call(current)
    end

    pos = $mouse.position.dup
    pos[0] -= @x
    pos[1] -= @y

    if !@select.nil? 
      if $input.action?
        @select.call(current)
      end
      if $input.click? 
        if pos[0] < @vp.rect.width && pos[1] < @vp.rect.height
          @select.call(current)
        end
      end
    end

    if within?(pos)
      
      row = pos[1] / row_height
      @select_sprite.y = row * row_height
      @page_idx = row
      @change.call(current) if !@change.nil?
      sys('select')

    end

  end

  def within?(pos)
    
    return false if pos[0] < 0
    return false if pos[0] > @item_width
    row = pos[1] / row_height
    return false if row < 0
    return false if row >= @per_page
    return false if row >= @data.count
    return false if row == @page_idx
    return true

  end

  def down_one
      # Move the sprite down, but not too far!
      @select_sprite.y += row_height      
      @page_idx += 1
  end

  def up_one
      @select_sprite.y -= row_height      
      @page_idx -= 1
  end

  def scroll_down
    
    @change.call(current) if !@change.nil?
    
    @scroll_idx -= 1    
    #      @pagemod = 1

    dur = 110
    ease = :quad_in_out

    @back_sprite.do(go("y",row_height,dur,ease))
    @content_sprite.do(go("y",row_height,dur,ease))
    @select_sprite.do(go("y",row_height,dur,ease))

    @back_sprite.do(proc(Proc.new{

      @page_idx += 1
      refresh

    },dur+1))

  end

  def scroll_up

     @change.call(current) if !@change.nil?

    @scroll_idx += 1    
          #@pagemod = -1

         

    dur = 110
    ease = :quad_in_out

  	#draw_item(@data[@scroll_idx + @per_page-1],@dynamo,@page_idx == @per_page)

  	@back_sprite.do(go("y",-row_height,dur,ease))
    @content_sprite.do(go("y",-row_height,dur,ease))
    @select_sprite.do(go("y",-row_height,dur,ease))

  	@back_sprite.do(proc(Proc.new{

      @page_idx -= 1
      refresh      

    },dur+1))

  end

 end
"
class SpriteGroup

	attr_reader :sprites

	def initialize
		@sprites = [] # [spr,ox,oy] -- maybe add opacity offset
		@opacity = 255
		@x = 0
		@y = 0
	end

	def disposed?
		return @sprites[0][0].disposed?
	end

	def update
		@sprites.each{ |s| s[0].update }
	end

	def add(spr,ox=0,oy=0)
		@sprites.push([spr,ox,oy])
	end

	def delete(spr)
		@sprites.delete_if{ |a| a[0] == spr}
	end

	def change(spr,ox,oy)
		@sprites.each{ |s|
			if s[0] == spr
				s[1] = ox
				s[2] = oy
			end
		}
	end

	def move(nx,ny)
		self.x = nx
		self.y = ny
	end

	def remove
		move(@x,@y)
	end

	def x=(v)
		@x = v
		@sprites.each{ |s| s[0].x = v + s[1] }
	end
	def x
		return @x
	end

	def y=(v)
		@y = v
		@sprites.each{ |s| s[0].y = v + s[2] }
	end
	def y
		return @y
	end

	def opacity=(v)
		@opacity = v
		@sprites.each{ |s| s[0].opacity = v }
	end
	def opacity
		return @opacity
	end

	def hide
		self.opacity = 0
	end

	def show
		self.opacity = 255
	end

end"ì
# Audio

def sfx(file,vol=1.0,delay=0)
	if delay > 0
		$audio.queue(file,vol,delay)
	else
		$audio.sfx(file,vol)
	end
end

def sys(file,vol=1.0)
	$audio.sys(file,vol)
end

def music(file,vol=1.0)
	# $audio.music_target = 1
	$audio.music(file,vol)
end

def atmosphere(file)
	$audio.atmosphere(file)
end

def music_skip
	$map.skip_music_change = true
end

def music_pause
	$audio.pause
end

def music_unpause
	$audio.unpause
end

def music_fadeout
	$audio.music_target = 0.0
end

def music_fadein
	$audio.unpause
	$audio.music_target = 1.0
end

def music_restore
	# Restore the zone music
	$map.setup_audio
end

def audio_fadeout
	$audio.music_target = 0.0
end

def atmosphere_fadeout
	$audio.atmosphere_target = 0.0
end

def atmosphere_fadein
	$audio.atmosphere_target = 1.0
end

def atmosphere_restore
	# Restore the zone music
	$map.setup_audio
end"‚
def bqs(skill,turn)
	$battle.queue_sill(skill,turn)
end

def bqt(text,turn)
	$battle.queue_text(text,turn)
end

def bqe(turn)
	$battle.queue_escape(turn)
end

def bqj(who,turn)
	$battle.queue_join(who,turn)
end"	#==============================================================================
# ** Common Functions
#==============================================================================

def plr
	return $player
end

def me
	return $scene.map.interpreter.event_id
end

def this
	return $scene.map.events[me]
end

def dummy
	# return a dummy event that can be screwed around
end

def gid(str)

	if str == 'me'
		return me
	end

	# empty means eid
	return gev(str).id

end

def gev(str)

	if str.is_a?(Game_Event)
		return str
	end


	#check for int that is in a string
	#treat as an int

	return $player if str == -1
	return $player if str == 'plr'

	if str.kind_of?(Integer)
		return $scene.map.events[str]
	end

	if str.include?(',')

		coords = str.split(",")
		# Get by coords
		return $scene.map.event_at(coords[0].to_i,coords[1].to_i)

	end

	if str.numeric?
		return $scene.map.events[str.to_i]
	end

	if str == 'me'
		return $scene.map.events[me] 
	end

	case str

		when $player
			return $player

		when this
			return str

		when nil
			return this

			# Move all of this elsewhere
		when '@up'
			return $scene.map.event_at(this.x,this.y-1) # || dummy
		when '@up2'
			return $scene.map.event_at(this.x,this.y-2) # || dummy
		when '@down'
			return $scene.map.event_at(this.x,this.y+1)
		when '@down2'
			return $scene.map.event_at(this.x,this.y+2)
		when '@left'
		 	return $scene.map.event_at(this.x-1,this.y)
		when '@left2'
		 	return $scene.map.event_at(this.x-2,this.y)
		when '@right'
			return $scene.map.event_at(this.x+1,this.y)
		when '@right2'
			return $scene.map.event_at(this.x+2,this.y)
		when '@under'
			return $scene.map.lowest_event_at(this.x,this.y)
		when '@facing'
			return $scene.map.event_at(this.x,this.y-1) if $player.direction == 8
			return $scene.map.event_at(this.x,this.y+1) if $player.direction == 2
			return $scene.map.event_at(this.x-1,this.y) if $player.direction == 4
			return $scene.map.event_at(this.x+1,this.y) if $player.direction == 6

		
		else

			# Check if name of event
			ev = $scene.map.event_by_name(str)
			return ev if !ev.nil?

		end

	log_err("Can't find event: #{str}")
	return nil

end

def moblin(ev,delay=1)

	$scene.add_moblin(ev,delay)

end"ï
def spark(ev,fx,ox=0,oy=0)

	return if gev(ev) == nil
	$scene.add_spark(fx,gev(ev).real_x/4+16+ox,gev(ev).real_y/4+16-10+oy)

end

def spark_r(ev,fx,ox=0,oy=0)
	sprk = $scene.add_spark(fx,gev(ev).real_x/4+16+ox,gev(ev).real_y/4+16-10+oy)
	sprk.reverse
end

def flash(ev,dur=20)
	gev(ev).flash_dur = dur
end

def shake_ev(ev)

	amount = 20
	dur = 70
	rep = 50
	e = :qio

	ev.do(
		repeat(
			seq(
				go(
					"x",amount,dur,e
					),
				go(
					"x",-amount,dur,e
					)
			),rep
		)
	)

end

def shake_1

	amount = 20
	dur = 70
	rep = 3
	e = :qio

	$scene.map.do(
		repeat(
			seq(
				go(
					"cam_ox",amount,dur,e
					),
				go(
					"cam_ox",-amount,dur,e
					)
			),rep
		)
	)

end

def shake_tiny

	amount = 5
	dur = 150
	rep = 2
	e = :qio

	$scene.map.do(
		repeat(
			seq(
				go(
					"cam_ox",amount,dur,e
					),
				go(
					"cam_ox",-amount,dur,e
					)
			),rep
		)
	)

end

def shake_mid

	amount = 20
	dur = 140
	rep = 7
	e = :qio

	$scene.map.do(
		repeat(
			seq(
				go(
					"cam_ox",amount,dur,e
					),
				go(
					"cam_ox",-amount,dur,e
					)
			),rep
		)
	)

end


def pop_huh(ev)

	pop_icon(ev,"misc/exclaim","exclaim")

end

def pop_huh_r(ev)

	pop_icon_r(ev,"misc/exclaim-r","exclaim")

end

def pop_love(ev)

	pop_icon_r(ev,"misc/exclaim-r","jump")

end

def pop_wha(ev)

	pop_icon(ev,"misc/unknown","wha")

end

def pop_sweat(ev,o=false)
	pop_icon_sweat(ev,"misc/sweat","sweat",o)
end

def pop_dots(ev)
	x = gev(ev).screen_x+2
	y = gev(ev).screen_y - 70
	$scene.add_icon('misc/dots',x,y,:blast,:fade)

	sfx('dots')
end

def pop_bulb(ev)
	pop_icon(ev,"misc/bulb","bulb")
end

def pop_icon_sweat(ev,icon,sfx,o=false)

	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	if o == true
	x = gev(ev).screen_x - 10
	else
	x = gev(ev).screen_x + 10
	end
	y = gev(ev).screen_y - 45

	$scene.add_icon(icon,x,y,:lower,:fade,1)

	sfx(sfx)

end

def pop_icon(ev,icon,sfx)

	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	x = gev(ev).screen_x+2
	y = gev(ev).screen_y - 70
	$scene.add_icon(icon,x,y,:blast,:fade)

	sfx(sfx) if sfx != nil

end

def pop_icon_r(ev,icon,sfx)

	gev(ev).do(seq(go("off_y",8,90,:qio),go("off_y",-8,90,:qio)))

	x = gev(ev).screen_x+2
	y = gev(ev).screen_y + 10
	$scene.add_icon(icon,x,y,:blast,:fade)

	sfx(sfx)

end

def pop_icon_get(ev,item)

	icon = $data.items[item].icon	
	x = gev(ev).screen_x+2
	y = gev(ev).screen_y - 24
	$scene.add_icon(icon,x,y,:fade,:fade)

end

def icon(ev,icon,ein=:blast,eout=:blast)

	x = gev(ev).screen_x
	y = gev(ev).screen_y - 32
	$scene.add_icon(icon,x,y,ein,eout)

end






# -------------------------------------------------------------------------
# Battle System Pops
# -------------------------------------------------------------------------

def pop_num(ev,number)

	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	x = gev(ev).screen_x 
	y = gev(ev).screen_y - 20

	# Create the pop
	pop = Pop.new(ein,eout,@vp_over)
    pop.number = nm
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end


def pop_dmg(ev,number)

	# Jump the target? # Might will cut this
	gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y - 20
	
	# Create the pop
	pop = Pop.new(:fall,:fade,@vp_over)
    pop.number(number,:dmg)
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_heal(ev,number)

	# Jump the target? # Might will cut this
	#gev(ev).do(seq(go("off_y",-8,90,:qio),go("off_y",8,90,:qio)))

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y - 20
		
	# Create the pop
	pop = Pop.new(:rise,:fade,@vp_over)
    pop.number(number,:hp)
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_gain(ev,number,suffix)

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y - 60
		
	# Create the pop
	pop = Pop.new(:rise,:fade,@vp_over)
    pop.number(number,suffix,suffix)
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_crit(ev)

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y + 5
		
	# Create the pop
	pop = Pop.new(:blast,:fade,@vp_over)
    pop.image('critical')
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_evade(ev)

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y + 5
		
	# Create the pop
	pop = Pop.new(:blast,:fade,@vp_over)
    pop.image('evade')
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_resist(ev)

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y + 5
		
	# Create the pop
	pop = Pop.new(:blast,:fade,@vp_over)
    pop.image('resist')
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

def pop_state(ev,state)

	# Position
	x = gev(ev).screen_x
	y = gev(ev).screen_y - 50
		
	# Create the pop
	pop = Pop.new(:rise,:fade,@vp_over)
    pop.image(state)
    pop.move(x,y)
    pop.start
	$scene.add_pop(pop)

end

# -------------------------------------------------------------------------





"¡#==============================================================================
# ** Event Functions
#==============================================================================


# Jumpings
def jump(e,x,y)
	gev(e).jump(x,y)
end

def jump_xy(e,x,y)
	ev = gev(e)
	ev.jump(x-ev.x,y-ev.y)
end

def jump_to(e,t)
	ev = gev(e)
	target = gev(t)
	ev.jump(target.x-ev.x,target.y-ev.y)
end

# Opacity
def hide(e)
	gev(e).opacity = 0
end
def unhide(e)
	gev(e).opacity = 255
end

def unhide3(*args)
	args.each{ |a|
		unhide(a+'3')
	}
end

def unhide6(e,o = 255)
	gev('plr').opacity = 255 - o
	gev('boy'+e).opacity = o
	gev('mys'+e).opacity = o
	gev('rob'+e).opacity = o
	gev('hib'+e).opacity = o
	gev('row'+e).opacity = o
	gev('ing'+e).opacity = o
end

def unhide7(e,o = 255)
	gev('plr').opacity = 255 - o
	gev('boy'+e).opacity = o
	gev('mys'+e).opacity = o
	gev('rob'+e).opacity = o
	gev('hib'+e).opacity = o
	gev('row'+e).opacity = o
	gev('ing'+e).opacity = o
	gev('phy'+e).opacity = o
end

def uhx(n,e,o = 255)
	party = ['boy','ing','mys','rob','hib','row','phy']
	gev('plr').opacity = 255 - o
	n.times do
    	x = party.shift
    	gev(x+e.to_s).opacity = o
	end
end

def delete7(e)
	unhide 'plr'
	delete ('boy'+e)
	delete ('mys'+e)
	delete ('rob'+e)
	delete ('hib'+e)
	delete ('row'+e)
	delete ('ing'+e)
	delete ('phy'+e)
end

def occupied?(e)
	ev = gev(e)
	(ev.x..ev.x+ev.width-1).each{ |x|
		(ev.y..ev.y+ev.height-1).each{ |y|
			return $map.events_at(x,y).count > 1
		}
	}
end

def other_here(e)
	ev = gev(e)
	list = $map.events_at(ev.x,ev.y)
	list.delete(e)
	return list[0].id
end

def roll(range)
	gev(me).random = rand(range) + 1
end

def voll(v)
	gev(me).voll = $state.varval(v)
end

def fade(ev)
	gev(ev).opacity = 255
	gev(ev).do(go("opacity",-255,300))
end

def unfade(ev)
	gev(ev).opacity = 0
	gev(ev).do(go("opacity",+255,300))
end

def gfx(ev,name)
	gev(ev).character_name = name	
end

def blast(ev)
	gev(ev).zoom = 1.0
	a = go("zoom",0.2,100)
	b = go("zoom",-0.2,120)
	gev(ev).do(seq(a,b))
end

# Routes

def face2face
	td me
	x = gev(me).x
	y = gev(me).y
	path 'plr',x,y+1,'u'
	wfc
end

def wfc
	$scene.map.interpreter.command_210
end

def td(e) gev(e).turn_down end
def tl(e) gev(e).turn_left end
def tr(e) gev(e).turn_right end
def tu(e) gev(e).turn_up end


def approach(ev,target)

	# Walk over to and face an event, position will be the closest side
	char = gev(ev)
	other = gev(target)

	dx = other.x - char.x
	dy = other.y - char.y

	if dx.abs >= dy.abs
		if dx < 0
			path(ev,other.x+1,other.y,'l')
		else
			path(ev,other.x-1,other.y,'r')
		end
	else
		if dy < 0
			path(ev,other.x,other.y+1,'u')
		else
			path(ev,other.x,other.y-1,'d')
		end
	end

end

def stop

	$player.clear_path
	w 1

end

def path(ev,tx,ty,after=nil)

	char = gev(ev)

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	x = 0
	y = 0
	sx = sy = 0

	sx = char.x
	sy = char.y
	x = char.x
	y = char.y

	result = char.setup_map(sx,sy,tx,ty)

	if !result[0]
		log_err("CANNOT FIND PATH")
		return
	end
	map = result[1]
	map[sx,sy] = result[2] if result[2] != nil

	# Now step through the path building cmds
	step = map[x,y] 
	while step != 1

	     if map[x+1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(3))
	     	x+=1
	     end
	     if map[x,y+1] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(1))
	     	y+=1
	     end
	     if map[x-1,y] == step - 1 and step != 0
	     	route.list.push(RPG::MoveCommand.new(2))
	     	x-=1
	     end
	     if map[x,y-1] == step - 1 and step != 0
			route.list.push(RPG::MoveCommand.new(4))
			y -= 1
	     end

	     step = map[x,y] 

	end		

	if after != nil
		case after
			when 2, 'd'
				route.list.push(RPG::MoveCommand.new(16))
			when 4, 'l'
				route.list.push(RPG::MoveCommand.new(17))
			when 6, 'r'
				route.list.push(RPG::MoveCommand.new(18))
			when 8, 'u'
				route.list.push(RPG::MoveCommand.new(19))
		end
	end
	
	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)

end

def route(ev,move)

	char = gev(ev)

	data = move.split(',')

	route = RPG::MoveRoute.new()
	route.list.clear
	route.repeat = false
	route.skippable = false

	live_dir = char.direction

	data.each{ |step|

		params = []

		# build params split off step
		if step.include?("-")
			dta = step.split("-")
			step = dta[0]
			params.push(dta[1].to_i) if dta.count > 1
			params.push(dta[2].to_i) if dta.count > 2
			params.push(dta[3].to_i) if dta.count > 3
		end

		case step

			when 'd'
				live_dir = 2
				route.list.push(RPG::MoveCommand.new(1))
			when 'l'
				live_dir = 4
				route.list.push(RPG::MoveCommand.new(2))
			when 'r'
				live_dir = 6
				route.list.push(RPG::MoveCommand.new(3))
			when 'u'
				live_dir = 8
				route.list.push(RPG::MoveCommand.new(4))

			when 'td'
				live_dir = 2
				route.list.push(RPG::MoveCommand.new(16))
			when 'tl'
				live_dir = 4
				route.list.push(RPG::MoveCommand.new(17))
			when 'tr'
				live_dir = 6
				route.list.push(RPG::MoveCommand.new(18))
			when 'tu'
				live_dir = 8
				route.list.push(RPG::MoveCommand.new(19))

			when 'f'
				route.list.push(RPG::MoveCommand.new(12))

			when 'b'
				route.list.push(RPG::MoveCommand.new(13))


			when 'walk'
				route.list.push(RPG::MoveCommand.new(31))
			when 'unwalk'
				route.list.push(RPG::MoveCommand.new(32))

			when 'step'
				route.list.push(RPG::MoveCommand.new(33))
			when 'unstep'
				route.list.push(RPG::MoveCommand.new(34))

			when 'fix'
				route.list.push(RPG::MoveCommand.new(35))
			when 'unfix'
				route.list.push(RPG::MoveCommand.new(36))

			when 'thr', 'through'
				route.list.push(RPG::MoveCommand.new(37))
			when 'unthr', 'unthrough'
				route.list.push(RPG::MoveCommand.new(38))	

			when 'sp'
				route.list.push(RPG::MoveCommand.new(29,[params[0]]))


			when 'w'
				route.list.push(RPG::MoveCommand.new(15,[params[0]]))

			when 'j'
				route.list.push(RPG::MoveCommand.new(14,[0,0]))
			when 'jf'
				jc = [0,1] if live_dir == 2
				jc = [-1,0] if live_dir == 4
				jc = [1,0] if live_dir == 6
				jc = [0,-1] if live_dir == 8
				route.list.push(RPG::MoveCommand.new(14,jc))
			when 'jb'
				jc = [0,1] if live_dir == 8
				jc = [-1,0] if live_dir == 6
				jc = [1,0] if live_dir == 4
				jc = [0,-1] if live_dir == 2
				live_dir = 10 - live_dir
				route.list.push(RPG::MoveCommand.new(14,jc))


		end

	}

	route.list.push(RPG::MoveCommand.new())

	char.force_move_route(route)
	#$map.interpreter.command_210

end
"ÿ
def arch_investigate

	# Check the item, do the flag
	case $menu.chosen

		when 'dig-nothing'
			flag("arch-nothing")

		when 'dig-vhs'
			flag("arch-vhs")

		when 'dig-shop'
			flag("arch-shop")

		when 'dig-quest'
			flag("arch-quest")

		when 'dig-attract'
			flag("arch-attract")

		when 'dig-chki'
			flag("arch-chki")

		else
			item($menu.chosen,1,'s')
			flag("arch-void")

	end

	unitem($menu.chosen)
	$menu.chosen = nil

end

def biscuit_investigate

	# Check the item, do the flag
	case $menu.chosen

		when 'ginger'
			flag("biscuit-ginger")

		when 'jam-2'
			flag("biscuit-jam")

		when 'honey'
			flag("biscuit-honey")

		else
			item($menu.chosen,1,'s')
			flag("biscuit-void")

	end

	unitem($menu.chosen)
	$menu.chosen = nil

end

def test_riddle_answer

	win = false

	# Does the item match the current quest
	if $progress.quest_active?('rq-riddle-1')
		win = ($menu.chosen == 'punkin-key')	
	end

	if $progress.quest_active?('rq-riddle-2')
		win = ($menu.chosen == 'cheese')			
	end

	if $progress.quest_active?('rq-riddle-3')
		win = ($menu.chosen == 'chocolate')			
	end

	if $progress.quest_active?('rq-riddle-4')
		win = ($menu.chosen == 'lemon')			
	end

	if $progress.quest_active?('rq-riddle-5')
		win = ($menu.chosen == 'elf-bread')			
	end

	if $progress.quest_active?('rq-riddle-6')
		win = ($menu.chosen == 'doll-witch')			
	end

	if win
		state(me,'riddle-win')
	else
		text('this: Not right!')
	end
	$menu.chosen = nil

end

def complete_riddle

	# Does the item match the current quest
	if $progress.quest_active?('rq-riddle-1')
		unquest('rq-riddle-1')	
	end

	if $progress.quest_active?('rq-riddle-2')
		unquest('rq-riddle-2')	
	end

	if $progress.quest_active?('rq-riddle-3')
		unquest('rq-riddle-3')	
	end

	if $progress.quest_active?('rq-riddle-4')
		unquest('rq-riddle-4')	
	end

	if $progress.quest_active?('rq-riddle-5')
		unquest('rq-riddle-5')	
	end

	if $progress.quest_active?('rq-riddle-6')
		unquest('rq-riddle-6')	
	end

end

def text_riddle

	# Does the item match the current quest
	if $progress.quest_active?('rq-riddle-1')
		txt = $data.quests['rq-riddle-1'].description
		text('this:'+txt)
	end

	if $progress.quest_active?('rq-riddle-2')
		txt = $data.quests['rq-riddle-2'].description
		text('this:'+txt)
	end

	if $progress.quest_active?('rq-riddle-3')
		txt = $data.quests['rq-riddle-3'].description
		text('this:'+txt)
	end

	if $progress.quest_active?('rq-riddle-4')
		txt = $data.quests['rq-riddle-4'].description
		text('this:'+txt)
	end

	if $progress.quest_active?('rq-riddle-5')
		txt = $data.quests['rq-riddle-5'].description
		text('this:'+txt)
	end

	if $progress.quest_active?('rq-riddle-6')
		txt = $data.quests['rq-riddle-6'].description
		text('this:'+txt)
	end

end

def next_riddle


	if $progress.quest_complete?('rq-riddle-6')
		state me,'riddle-done'
		return
	end

	if $progress.quest_complete?('rq-riddle-5')
		quest('rq-riddle-6')
		return
	end

	if $progress.quest_complete?('rq-riddle-4')
		quest('rq-riddle-5')	
		return
	end

	if $progress.quest_complete?('rq-riddle-3')
		quest('rq-riddle-4')	
		return
	end

	if $progress.quest_complete?('rq-riddle-2')
		quest('rq-riddle-3')
		return
	end

	if $progress.quest_complete?('rq-riddle-1')
		quest('rq-riddle-2')
	end

end

def show_book(which)

	data = $data.books[which]
	text('sys:'+data.title)


end

def party_gossip

	# Check who is in the party
	if $party.all.include?('phy')
		gossips = 12
	elsif $party.all.include?('row')
		gossips = 10
	elsif $party.all.include?('hib')
		gossips = 8
	elsif $party.all.include?('rob')
		gossips = 6
	else
		gossips = 4
	end

	# Choose a gossip
	$player.next_common = 31 + rand(gossips)

end

def witch_gossip

	$player.next_common = 51 + rand(7)

end

def vault_card_refresh

	# MAIN ROOM MAIN ROOM
	cards = []
	[67,41,68].each{|e|
		cards.push(card_from_ev(e))
	}

	log_info cards

	if cards.sort == ['','archer','thief']
		flag('vaughn-ch1')
	end

	if cards.sort == ['archer','arrow','king']
		flag('vaughn-ch2')
	end

	if cards.sort == ['','crown','thief']
		flag('vaughn-ch3')
	end

	if cards.sort == ['begger','dagger','thief']
		flag('vaughn-ch4')
	end

	# ARCHER POISONS ARROW

	cards = []
	[69,70,71].each{|e|
		cards.push(card_from_ev(e))
	}

	if cards.sort == ['archer','arrow','poison']
		flag('vaughn-side-archer')
	end
	
	# KING TRADES BEGGAR

	cards = []
	[72,73,74].each{|e|
		cards.push(card_from_ev(e))
	}

	if cards.sort == ['','beggar','king']
		flag('vaughn-side-king')
	end

	# THIEF PAYS ARCHER

	cards = []
	[75,76,77].each{|e|
		cards.push(card_from_ev(e))
	}

	if cards.sort == ['archer','gold','thief']
		flag('vaughn-side-payment')
	end


end

def gogogo

	log_ev("Debug function GO!")

	log_sys("Refreshing stat mods")
	$party.all_battlers.each{ |b| b.refresh_stat_mods }

end"Õ#==============================================================================
# ** Item Functions
#==============================================================================

def gold(amount,type='f')
	sys('coins')
	$party.add_gold(amount)
	pop_gold(amount,type)
end

def ungold(amount)
	sys('coins')
	$party.add_gold(-amount)
end

def gold?(amount)
	return $party.has_gold?(amount)
end

def magics(amount)
	sys('coins')
	$party.add_magics(amount)
end

def unmagics(amount)
	sys('coins')
	$party.add_magics(-amount)
end

def magics?(amount)
	return $party.has_magics?(amount)
end

def magics_exchange
	adding = $party.item_number('cheeki')
	mult = $data.numbers['cheeki-magic'].value
	amount = adding*mult
	#amount = 7
	magics(amount)
	pop_magics(amount)
	unitem('cheeki',amount)
end

def bugs_exchange
	sfx 'item'
	adding = $party.item_number('night-bug')
	mult = $data.numbers['night-bugs'].value
	amount = adding*mult
	$progress.add_night_xp(amount)
	pop_night(amount)
	unitem('night-bug',amount)

	if $progress.night_xp >= 400
		$progress.night_rank = 5
		flag('nw-rank-4') 
	elsif $progress.night_xp >= 300
		$progress.night_rank = 4
		flag('nw-rank-3') 
	elsif $progress.night_xp >= 200
		$progress.night_rank = 3
		flag('nw-rank-2') 
	elsif $progress.night_xp >= 100
		$progress.night_rank = 2
		flag('nw-rank-1') 
	else
		$progress.night_rank = 1
		flag('nw-rank-0') 
	end


end

def owl_exchange
	sfx 'item'
	adding = $party.item_number('owl-feather')
	mult = $data.numbers['owl-feather'].value
	amount = adding*mult
	$progress.add_night_xp(amount)
	pop_night(amount)
	unitem('owl-feather',amount)

	if $progress.night_xp >= 400
		$progress.night_rank = 5
		flag('nw-rank-4') 
	elsif $progress.night_xp >= 300
		$progress.night_rank = 4
		flag('nw-rank-3') 
	elsif $progress.night_xp >= 200
		$progress.night_rank = 3
		flag('nw-rank-2') 
	elsif $progress.night_xp >= 100
		$progress.night_rank = 2
		flag('nw-rank-1') 
	else
		$progress.night_rank = 1
		flag('nw-rank-0') 
	end
end

def item(id,number=1,type='f')
	if !number.is_a?(Integer)
		type = number
		number = 1
	end
	sfx 'item'
	$party.add_item(id,number)
	return if !$scene.is_a?(Scene_Map) && !$scene.is_a?(Scene_Battle)
	pop_item(id,number,type) if type != 's'
end

def unitem(id,number=1)
	$party.lose_item(id,number)
end

def item?(id,number=1)
	$party.has_item?(id,number)
end

def grant_items
	$data.items.each{ |k,v|
		#log_scr(v.id)
		item(v.id,99,'s')
	}
end

def grant_shop_items
	$data.items.each{ |k,v|
		if v.tab == 'shop'
			item(v.id,1,'s')
		end
	}
end

# For the vault
def item_from_card(e)
	cards = ['archer','arrow','begger','crown','dagger','false','gold','king','poison','thief']
    cards.each{ |c|
        if $state.state?(e,'card-'+c)
          item('card-'+c)
          unstate(e,'card-'+c)
          unstate(e,'on')
          return
        end        
    }
end

def card_from_ev(e)
	cards = ['archer','arrow','begger','crown','dagger','false','gold','king','poison','thief']
    cards.each{ |c|
        if $state.state?(e,'card-'+c)
          return c
        end        
    }
    return ''
end

#==============================================================================
# ** Members
#==============================================================================

# Only this one will do popper
def join(who)
	sys('join2')
	$party.set_active(who)
	pop_join(who)
	$scene.hud.bar.refresh if $scene.is_a?(Scene_Map)
end

def join_s(who)
	$party.set_active(who)
	$scene.hud.bar.refresh if $scene.is_a?(Scene_Map)
end

def unjoin(who)
	sys('unjoin')
	pop_leave(who)
	$party.back_to_pavillion(who)
	$scene.hud.bar.refresh if $scene.is_a?(Scene_Map)
end

def unjoin_s(who)
	$party.back_to_pavillion(who)
	$scene.hud.bar.refresh if $scene.is_a?(Scene_Map)
end

def party_of_boy
	$party.backup_party
	$party.leader = 'boy'
	join_s('boy')
end

def party_of_hib
	$party.backup_party
	$party.leader = 'hib'
	join_s('hib')
end

def party_of_ing
	$party.backup_party
	$party.leader = 'ing'
	join_s('ing')
end

def party_of_nightwatch
	$party.backup_party
	$party.leader = 'rob'
	join_s('rob')
	join_s('mys')
end

def party_of_all
	$party.restore_party
end

def make_reserve(who)
	$party.set_reserve(who)
end

def make_active(who)
	$party.set_active(who)
end


def grant_stat(who,stat,amount)
	$party.get(who).grant_stat(stat,amount)
	pop_stat_bonus(who,stat,amount)
end

def grant_stat_all(stat,amount)
	($party.active+$party.reserve).each{ |m|
		$party.get(m).grant_stat(stat,amount)
	}
	pop_stat_all(stat,amount)
end

def ungrant_stat(who,stat,amount)
	$party.get(who).ungrant_stat(stat,amount)
	pop_stat_unbonus(who,stat,amount)
end

def grant_xp_all(amount)

	($party.active+$party.reserve).each{ |m|
		$party.get(m).gain_xp(amount)
		if $party.get(m).level_up?
			pop_level(m)
		end
	}

	pop_xp_all(amount)

end

def grant_level_all
	($party.active+$party.reserve).each{ |m|
		$party.get(m).grant_level
	}
	pop_level_all
end

def grant_level(who)
	$party.get(who).grant_level
	pop_level(who)
end

def grant_level_s(who)
	$party.get(who).grant_level
end

def grant_level_free(who)
	$party.get(who).grant_level(false)
	pop_level(who)
end

def learn_skill(who,skill)
	sys 'join'
	pop_learn(skill,who)
	$party.get(who).learn(skill)
end

def unlearn_skill(who,skill)
	$party.get(who).unlearn(skill)
end"ª
def pop_item(item,number,type)

	data = $data.items[item]
	
	b = data.name
	ib = $cache.icon(data.icon)
	if number > 1 
		b = data.name + " x #{number}"
	end		

	pop_get(type,b,ib)

end

def pop_gold(number,type)

	ib = $cache.icon('misc/coins')
	b = "#{number} Gold"	


	pop_get(type,b,ib,'green')

end

def pop_magics(number)

	ib = $cache.icon('misc/magics')
	b = "#{number} Magic"	

	pop_get('r',b,ib,'wizard')

end

def pop_ing_pickup(i)
	sfx 'item'
	ib = $cache.icon($data.items[i].icon)
	pop_get('p',$data.items[i].name,ib)
end

def pop_learn(s,w)

	b = $data.skills[s].name.sub("=>",":")
	ib = $cache.icon($data.skills[s].icon)

	a = $data.actors[w].name+" has learned: "
	ia = $cache.icon("faces/#{w}")	

	popper = $scene.hud.open_popper
	popper.color = 'blue'
	popper.setup(a,ia,b,ib)

end

def pop_use_skill(s,w)

	b = $data.skills[s].name
	ib = $cache.icon($data.skills[s].icon)

	a = $data.actors[w].name+" uses:"
	ia = $cache.icon("faces/#{w}")	

	popper = $scene.hud.open_popper
	popper.color = 'blue'
	popper.setup(a,ia,b,ib)

end

def pop_get(type,b,ib,color=nil)

	case type

		when 'f'
			a = "You found: "
			ia = nil

		when 'mf'
			a = "Myst found: "
			ia = ia = $cache.icon("faces/mys")

		when 'b'
			a = "You bought: "
			ia = nil

		when 'm'
			a = "You made: "
			ia = nil

		when 'r'
			a = "You receive: "
			ia = nil

		when 'fang'
			a = "Fang receives: "
			ia = nil

		when 'sister'
			a = "Lorelai receives: "
			ia = nil

		when 'rat'
			a = "Colby found: "
			ia = nil

		when 'p'
			a = "Ingrid picks up: "
			ia = $cache.icon("faces/ing")	

		when 'boy','ing','hib','mys','phy','rob','row'
			a = $data.actors[type].name+" receives: "
			ia = $cache.icon("faces/#{type}")

		when 's'
			return

	end

	popper = $scene.hud.open_popper
	color = 'diamonds' if color == nil
	popper.color = color
	popper.setup(a,ia,b,ib)

end

def pop_nothing
	popper = $scene.hud.open_popper
	popper.setup("You found: Nothing",nil,nil,nil)
end

def pop_friends

	a = "Hi'beru and "
	ia = $cache.icon("faces/hib")
	
	b = "Rowen are good now friends"
	ib = $cache.icon("faces/row")

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_join(who)

	char = $party.get(who)
	a = "#{char.name} joins the party"
	ia = $cache.icon("faces/#{who}")
	
	b = ""
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_leave(who)

	char = $party.get(who)
	a = "#{char.name} leaves the party"
	ia = $cache.icon("faces/#{who}")
	
	b = ""
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_quest(q)

	popper = $scene.hud.open_popper
	popper.setup("New quest: ",nil,$data.quests[q].name,nil)

end

def pop_unquest(q)

	popper = $scene.hud.open_popper
	popper.setup("Quest complete: ",nil,$data.quests[q].name,nil)

end

def pop_level(who)
	
	a = "#{$party.get(who).name} gains a level"
	ia = $cache.icon("faces/#{who}")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_level_all

	a = "Everybody gains a level!"
	ia = $cache.icon("misc/exclaim")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_stat_all(stat,amount)

	stat_text = case stat
		when 'hp'; "Max Hp"
		when 'mp'; "Max Mp"
		when 'str'; "Strength"
		when 'def'; "Defense"
		when 'eva'; "Evasion"
		when 'luk'; "Luck"
		when 'res'; "Resist"
	end

	a = "Everybody gains #{amount} #{stat_text}"
	ia = $cache.icon("misc/exclaim")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_xp_all(amount)

	a = "Everybody gains #{amount} xp"
	ia = $cache.icon("misc/exclaim")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_stat_bonus(who,stat,amount)

	stat_text = case stat
		when 'hp'; "Max Hp"
		when 'mp'; "Max Mp"
		when 'str'; "Strength"
		when 'def'; "Defense"
		when 'eva'; "Evasion"
		when 'luk'; "Luck"
		when 'res'; "Resist"
	end

	a = "#{$party.get(who).name} gains #{amount} #{stat_text}"
	ia = $cache.icon("faces/#{who}")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_stat_unbonus(who,stat,amount)

	stat_text = case stat
		when 'hp'; "Max Hp"
		when 'mp'; "Max Mp"
		when 'str'; "Strength"
		when 'def'; "Defense"
		when 'eva'; "Evasion"
		when 'luk'; "Luck"
		when 'res'; "Resist"
	end

	a = "#{$party.get(who).name} loses #{amount} #{stat_text}"
	ia = $cache.icon("faces/#{who}")

	b = nil
	ib = nil

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_attract(who)
	
	a = "Ingrid gains an"
	ia = $cache.icon("faces/ing")
	
	b = "Attraction Point with #{$party.get(who).name}"
	ib = $cache.icon("misc/attract-get")

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end

def pop_night(amount)
	
	a = " |"
	ia = $cache.icon("faces/rob")

	b = " Nightwatch progress increased by " + amount.to_s + "%"
	ib = $cache.icon("faces/mys")

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

end"#==============================================================================
# ** Progress Functions
#==============================================================================

# Quests
def quest(id) 
	sys('quest')
	$progress.add_quest(id) 
	pop_quest(id)
	$scene.hud.quest_sparkle("misc/profile")
end

def unquest(id)
	sys('quest-complete')
	$progress.end_quest(id)
	pop_unquest(id)
end

def quest?(id)
	return active?(id) || complete?(id)
end

def active?(id)
	return $progress.quest_active?(id)
end

def complete?(id)
	return $progress.quest_complete?(id)
end

# Progress
def progress(id) $progress.progress(id) end
def progress?(id) return $progress.progress?(id) end

def before?(id) return $progress.before?(id) end
def beyond?(id) return $progress.beyond?(id) end

def attract(who)
	case who
		when 'boy'
			$progress.attract_boy += 1
		when 'hib'
			$progress.attract_hib += 1
		when 'phy'
			$progress.attract_phy += 1
	end
	sys('attract')
	pop_attract(who)
end"6

def shop_choice

	case $menu.grid_action

		when 'Buy'

			# Have money, buy it
			data = $data.items[gev(me).name]
			if $party.gold >= data.price
				item(gev(me).name,'b')
				state(me,'sold')
				state(me,'on')
				ungold(data.price)
				erase me
			else
				text("#{$shopkeep}: You can't afford that.")				
			end

		when 'Info'

			case gev(me).name

			# Windshire

			when 'level-egg'
				text("#{$shopkeep}: Eggs contain the essence of life.")

			when 'mutton-bag'
				text("#{$shopkeep}: They're fine, I just couldn't finish them all. They're not THAT old.")

			when 'p-kit'
				text("#{$shopkeep}: Use that to start over if you make a mistake with a potion. Personally, I feel that any potion is a mistake.")

			when 'acc-ghost'
				text("#{$shopkeep}: There's something spooky about that thing.")

			when 'cheeki'
				text("#{$shopkeep}: I found it creeping around. Probably worth 500 gold.")

			when 'junk-bandana-blue'
				text("#{$shopkeep}: That washed up on the shore facing Whisper Woods.")

				#Wyrmwood

			when 'soda-ash'
					text("#{$shopkeep}: That's used in potion making, isn't it?")

			when 'haunch'
					text("#{$shopkeep}: I have a haunch you'd enjoy that.")

			when 'covey'
					text("#{$shopkeep}: I don't use mana.")

			when 'vamp-teeth'
					text("#{$shopkeep}: If you want them, you should get them before Vic Venom wakes up.")

			# Goblin Cave

			when 'doll-vamp'
					text("#{$shopkeep}: People trade and collect these types of things.")

			when 'acc-frog-boots'
					text("#{$shopkeep}: Be careful with that.")

			#Tor

			when 'super-balm'
					text("#{$shopkeep}: I think I've been trying to sell that to the wrong crowd. Maybe you'd have more luck.")

			when 'spider-eyes'
					text("#{$shopkeep}: Witches sometimes buy this sort of stuff.")

			when 'spell-zit'
					text("#{$shopkeep}: I won that in a game of two-card flip.")

			# Royal Town Outdoor

			when 'helm-royal'
				text("#{$shopkeep}: A paladin gave it to me.")

			when 'mutton'
				text("#{$shopkeep}: Straight from Windshire.")

			when 'tinctura'
				text("#{$shopkeep}: That is a good item! Well worth it!")

			when 'pine-drink'
				text("#{$shopkeep}: That'll give you a real boost.")

			when 'grape-drink'
				text("#{$shopkeep}: That'll give you a real boost.")

			when 'apple-drink'
				text("#{$shopkeep}: That'll give you a real boost.")

			# Fruit Shop

			when 'fruit-a'
				text("#{$shopkeep}: I eat five of those a day.")

			when 'fruit-b'
				text("#{$shopkeep}: Remove the skin before eating that.")

			when 'fruit-c'
				text("#{$shopkeep}: Remove the skin before eating that.")

			when 'fruit-d'
				text("#{$shopkeep}: Remove the skin before eating that.")

			# Crete Street

			when 'mineral-man'
				text("#{$shopkeep}: Those things grow into the weirdest shapes.")

			when 'juniper'
				text("#{$shopkeep}: That's a very ^mysterious item that will sell out soon.")

			when 'magic-scroll-summon'
				text("#{$shopkeep}: Don't be using that in town, the guards will come after me.")

			when 'brightsword-potion'
				text("#{$shopkeep}: I was once bitten by a drakefang, very painful.")

			# Royal Town Indoor

			when 'recipe-blabber'
				text("#{$shopkeep}: It's all gibberish to me.")

			when 'fan'
				text("#{$shopkeep}: Keep yourself cool and look cool doing it.")

			when 'spell-pig'
				text("#{$shopkeep}: I tried to master the skill myself but I failed.")

			when 'acc-snake-boots'
				text("#{$shopkeep}: Be careful when you wear that, they can see you.")

			# Weeville

			when 'god-food'
				text("#{$shopkeep}: The Dark God just loves this stuff.")			

			when 'tonic'
				text("#{$shopkeep}: The recipe has been handed down through generations.")			

			when 'spell-pie'
				text("#{$shopkeep}: I don't accept refunds if you are unable to use the spell.")			

			# Delamere

			when 'book-hib-help'
				text("#{$shopkeep}: I don't care for reading, too boring.")			

			when 'wine'
				text("#{$shopkeep}: Tether your steed for the eveing and indulge.")			

			when 'spell-mud'
				text("#{$shopkeep}: I recommended this to only the best witches.")			

			when 'elf-cloth'
				text("#{$shopkeep}: It's so soft. Feel how soft it is.")			

			# Dwarf Town

			when 'secret-recipe'
				text("#{$shopkeep}: Shhh, that's only for my most special customers.")			

			when 'hib-book-heal'
				text("#{$shopkeep}: That one of those heebie-jeebie books.")			

			when 'acc-bat-boots'
				text("#{$shopkeep}: It doesn't take echolocation to see this is a good deal.")			

			when 'crab-hammer'
				text("#{$shopkeep}: A might hammer indeed, use it wisely.")			

			when 'recipe-calming'
				text("#{$shopkeep}: Get your cauldron ready, this is a good one.")			

			end

		when 'Cancel'

	end


end

def setup_item_shop

	$menu.shop_init
	stock = []

	case $map.zone.id

		when '@windshire'	
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('mutton')
			stock.push('pepper')
			stock.push('cassia')

		when '@wyrmwood'	
			stock.push('covey')
			stock.push('gingerbread')
			stock.push('toffee-apple')
			stock.push('cheese')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('pepper')			

		when '@tor'	
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('kurry')
			stock.push('cassia')
			stock.push('pepper')

		when '@royal-town'	
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('cheese-round')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('pepper')

		when '@weeville'	
			stock.push('fruit-c')
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('pepper')

		when '@elf-town'	
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('elf-bread')
			stock.push('pepper')

		when '@dwarf-town'	
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('sausage')
			stock.push('pepper')

		when '@ravwyn'
			stock.push('covey')
			stock.push('cheese')
			stock.push('bread')
			stock.push('haunch')
			stock.push('cassia')
			stock.push('biscuit')
			stock.push('pepper')

	end

	stock.each{ |s| $menu.shop_add(s) }
	open_shop_buy

end

def setup_special_shop(type)

	$menu.shop_init
	stock = []

	case type

		when 'fruit'	
			stock.push('fruit-a')
			stock.push('fruit-b')
			stock.push('fruit-c')
			stock.push('fruit-d')
			stock.push('fruit-e')

		when 'grape'	
			stock.push('grape-drink')
			stock.push('pine-drink')
			stock.push('apple-drink')

		when 'preserves'	
			stock.push('lemon')
			stock.push('gingerbread')
			stock.push('jam')
			stock.push('jam-2')

		when 'pastry'	
			stock.push('fruit-a')

		when 'ingredients'	
			stock.push('fruit-a')

		when 'keys'	
			stock.push('game-key-1')
			stock.push('game-key-2')
			stock.push('game-key-3')
			stock.push('game-key-4')
			stock.push('game-key-5')
			stock.push('game-key-6')
			stock.push('game-key-7')
			stock.push('game-key-8')
			stock.push('game-key-9')

		when 'helms'	
			stock.push('helm-ultimate')

		when 'diamond'	
			stock.push('heavy-arm-ultimate')

		when 'leather'	
			stock.push('mid-arm-ultimate')

	end

	stock.each{ |s| $menu.shop_add(s) }
	open_shop_buy

end

def setup_smith_shop

	$menu.shop_init
	stock = []

	case $map.zone.id

		when '@windshire'	
			stock.push('mid-arm-shire')
			stock.push('mid-arm-shire-a')
			stock.push('mid-arm-shire-e')
			stock.push('mys-claw-shire')

		when '@tor'	
			stock.push('mid-arm-tor')
			stock.push('heavy-arm-tor')
			stock.push('helm-tor')
			stock.push('rob-shield-tor')

		when '@tor'	
			stock.push('boy-arm-briar')
			stock.push('acc-arena')

		when '@royal-town'	
			stock.push('mid-arm-royal')
			stock.push('heavy-arm-royal')
			stock.push('rob-hammer-royal')

		when '@royal-crusade'	
			stock.push('helm-royal')
			stock.push('rob-shield-royal')

		when '@elf-town'	
			stock.push('mid-arm-elves')
			stock.push('heavy-arm-elves')
			stock.push('rob-shield-elves')
			stock.push('rob-hammer-elves')
			stock.push('helm-elves')

		when '@dwarf-town'	
			stock.push('mid-arm-dwarf')
			stock.push('helm-dwarf')
			stock.push('heavy-arm-dwarf')
			stock.push('rob-shield-dwarf')

		when '@ravwyn'	
			stock.push('mid-arm-shadow')
			stock.push('heavy-arm-shadow')
			stock.push('helm-shadow')

	end

	stock.each{ |s| $menu.shop_add(s) }
	open_shop_smith

end

def setup_magic_shop

	$menu.shop_init
	stock = []

	case $map.zone.id

		when '@windshire'	
			stock.push('light-arm-shire')
			stock.push('ing-athame-shire')

		when '@tor'	
			stock.push('light-arm-tor')
			stock.push('ing-wand-tor')

		when '@royal-town'	
			stock.push('light-arm-royal')
			stock.push('ing-wand-royal')
			stock.push('mys-claw-royal')

		when '@weeville'	
			stock.push('light-arm-little')
			stock.push('ing-athame-little')

		when '@elf-town'	
			stock.push('light-arm-elves')
			stock.push('ing-wand-elves')
			stock.push('mys-claw-elves')
			stock.push('hib-charm-elf')

		when '@dwarf-town'	
			stock.push('light-arm-dwarf')
			stock.push('ing-athame-dwarf')
			stock.push('mys-claw-dwarf')
			stock.push('hib-charm-dwarf')

		when '@ravwyn'	
			stock.push('light-arm-shadow')
			stock.push('hib-charm-shadow')

		when '@wind-tower'	
			stock.push('light-arm-ultimate')

	end

	stock.each{ |s| $menu.shop_add(s) }
	open_shop_magic

end

def setup_chester_shop

	$menu.char = 'boy'

	$menu.shop_init
	stock = []

	boy = $party.get('boy')

	# Based on $progress.chester_level

	# Skills to add at level five - RAVWYN
	if $progress.chester_level >= 6
		stock.push('ug-staff-7') if boy.has_skill?('ug-staff-6')
	end

	# Skills to add at level five - DWARVES
	if $progress.chester_level >= 5		
		stock.push('ug-mana-5') if boy.has_skill?('ug-mana-4')
		stock.push('ug-staff-6') if boy.has_skill?('ug-staff-5')
		stock.push('flames-4') if boy.has_skill?('ug-flames-3')
		stock.push('ug-passive-scare')
	end

	# Skills to add at level 4 - ELVES
	if $progress.chester_level >= 4
		stock.push('ug-mana-4') if boy.has_skill?('ug-mana-3')
		stock.push('staff-4') if boy.has_skill?('staff-3')
		stock.push('ug-staff-5') if boy.has_skill?('ug-staff-4')
		stock.push('ug-passive-cheeki')
		stock.push('ug-magic-minion')
		stock.push('triumph-2')
	end

	# Skills to add at level 3 - WEE
	if $progress.chester_level >= 3
		stock.push('levitate')
		stock.push('flames-3') if boy.has_skill?('ug-flames-2')
		stock.push('ug-mana-3') if boy.has_skill?('ug-mana-2')
		stock.push('ug-staff-4') if boy.has_skill?('ug-staff-3')
		stock.push('ug-passive-shop')
	end

	# Skills to add at level 2 - ROYAL
	if $progress.chester_level >= 2
		stock.push('sacrifice')
		stock.push('contempt-3') if boy.has_skill?('contempt-2')
		stock.push('ug-mana-2') if boy.has_skill?('ug-mana-1')
		stock.push('staff-3') if boy.has_skill?('staff-2')
		stock.push('ug-staff-3') if boy.has_skill?('ug-staff-2')
	end

	# Skills to add at level 1 - TOR
	if $progress.chester_level >= 1
		stock.push('triumph')
		stock.push('flames-2')
		stock.push('ug-mana-1')
		stock.push('ug-staff-2') if boy.has_skill?('ug-staff-1')
	end

	# Skills to add ALWAYS - WINSHIRE
	if $progress.chester_level >= 0
		stock.push('empower')
		stock.push('contempt-2')
		stock.push('staff-2')
		stock.push('ug-staff-1')
	end
	
	# Don't add if have
	stock.delete_if{ |s| boy.has_skill?(s) }

	# Don't include multiple of the same types, only use lowest


	# Add skills to shop
	stock.each{ |s| $menu.shop_add(s) }
	open_shop_chester

end

def buy_chester_skill(skill)

	boy = $party.get('boy')

	$skill = skill

	case skill

		# New skills
		when 'sacrifice','empower','triumph', 'levitate'
			boy.learn(skill)
			flag('chester-new-skill')

		# Skill upgrades
		when 'contempt-2','contempt-3'
			boy.replace_skill('contempt',skill)
			flag('chester-new-skill')

		when 'flames-2','flames-3'
			boy.replace_skill('flames',skill)
			flag('chester-new-skill')

		when 'staff-2','staff-3','staff-4','staff-5','staff-6'
			boy.replace_skill('staff',skill)	
			flag('chester-new-skill')

		when 'triumph-2'
			boy.replace_skill('triumph',skill)		
			flag('chester-new-skill')

		# Staff upgrades

		when 'ug-staff-1','ug-staff-2','ug-staff-3','ug-staff-4','ug-staff-5','ug-staff-6','ug-staff-7'

			log_sys("GET NEW STAFF")

			# Replace boy equip with new
			boy.learn(skill)
			eq = skill.sub('ug','boy')
			boy.force_equip('staff',eq)

			$staff = eq
			flag('chester-new-staff')

		# Stat upgrades

		when 'ug-mana-1'
			boy.learn(skill)
			$party.boy_mp_bonus = 10
		when 'ug-mana-2'
			boy.learn(skill)
			$party.boy_mp_bonus = 20
		when 'ug-mana-3'
			boy.learn(skill)
			$party.boy_mp_bonus = 30
		when 'ug-mana-4'
			boy.learn(skill)
			$party.boy_mp_bonus = 40
		when 'ug-mana-5'
			boy.learn(skill)
			$party.boy_mp_bonus = 50


		# Passives
		when 'ug-passive-shop'
			boy.learn(skill)
			$party.passive_shop = true

		when 'ug-passive-cheeki'
			boy.learn(skill)
			$party.passive_cheekis = true

		when 'ug-passive-scare'
			boy.learn(skill)
			$party.passive_scare = true

	end

end

"q#==============================================================================
# ** State Functions
#==============================================================================

# Flag shorthands
def flag(id) $state.flag(id) end
def unflag(id) $state.unflag(id) end
def flag?(id) return $state.flag?(id) end

# Var shorthands
def incvar(id,a=1) $state.var(id,a) end
def var(id,a=1) $state.var(id,a) end
#def unvar(id,a=1) $state.var(id,a) end
def var?(id,a) return $state.var?(id,a) end
#def gvar(id)

# State shortands
def state(e,s) 
	$state.state(gid(e),s)
end
def unstate(e,s)
	$state.unstate(gid(e),s)
end
def state?(e,s)
	return $state.state?(gid(e),s)
end

# Misc shorthands
def loc(e) gev(e).saveloc end

def erase(e) gev(e).erase end
def delete(e) gev(e).delete end
def disable(e) gev(e).disable end

def enable(e) gev(e).enable end
"d

def store_init

	# Make a list of customers for this time

	items = $data.shop.keys.shuffle

	# Remove all not allowed
	possible = []

	items.each{ |i|
		item = $data.shop[i]
		next if $progress.store_done.include?(i)
		next if item.level > $progress.store_level
		possible.push(i)
	}

	# Choose 3
	possible.sort_by { rand }

	$store_customers = possible[0,1]

end

def store_next_customer

	customer = $store_customers.shift
	$customer = $data.shop[customer]

	gev(1).opacity = 0
	gev(1).character_name = "NPCS/Shop/#{customer}"
	gev(1).direction = 8
	gev(1).moveto(19,20)

	unfade(1)
	route(1,'u,u,u')

end

def store_say_request
	#log_sys($customer.request)
	text("1: #{$customer.request}")
end

def store_test_item
	if $menu.chosen == $customer.id
		unitem($menu.chosen)
		$reward = $data.items[$menu.chosen].price
		flag('store-accept')
	else
		flag('store-deny')
	end
	$menu.chosen = nil
end

def store_say_accept
	sfx 'shop-buy'
	text("1: #{$customer.accept}")
	$progress.store_done.push($customer.id)
	$progress.store_xp += 1
end

def store_level_up?
	if $progress.store_xp >= 5
		sfx 'shop-level'
		$progress.store_level += 1
		$progress.store_xp -= 5
		text("sys: News of your store has spread! Richer customers will now visit.")
	end
end

def store_say_deny
	text("1: #{$customer.deny}")
end
"

# Misc

def text(t)
	$scene.hud.message.start(t)
end

def text_wall(w='diamonds')
	$scene.hud.message.wallpaper = w
end

def w(f=5)
	$map.interpreter.wait_count = f
end

# Camera

def camera(e,dur=nil)
	$map.camera_to(gev(e),dur)
	w 1
end

def camera_xy(x,y,dur=nil)
	$map.camera_xy(x,y,dur)
	w 1
end

def camera_snap
	$map.camera_snap
end

def sn
	$map.camera_snap
end

def cam_oy(amount)
	$map.do(go("cam_oy",amount,amount.abs*6,:qio))
end

def cam_ox(amount)
	$map.do(go("cam_ox",amount,amount.abs*6,:qio))
end


# Menus Access

def menu_snapshot

	$mouse.hide_cursor
      	Graphics.update
      	$game.snapshot = Graphics.snap_to_bitmap
      	$mouse.show_cursor

end

def open_main_menu
	unitem nil,500
	menu_snapshot
	$menu.sub_only = false
	$menu.menu_page = "Main"
end

def open_sub_menu(which)
	unitem nil,500
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = which
end

def open_char_menu(who)
	menu_snapshot
	$menu.sub_only = true
	$menu.char = who
	$menu.menu_page = "Char"
end

def open_potions_menu
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Potions"
end

def open_chooser_menu(cat=nil)
	menu_snapshot
	log_info(me)
	$menu.chosen_ev = me
	$menu.sub_only = true
	$menu.choose_cat = cat
	$menu.menu_page = "Chooser"	
end

def open_potions_book
	$menu.sub_only = true
	$scene.hud.open_book
end

def open_shop_buy
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Shop"
end

def open_shop_sell
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Sell"
end

def open_shop_smith
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Smith"
end

def open_shop_magic
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Magic"
end

def open_shop_chester
	menu_snapshot
	$menu.sub_only = true
	$menu.menu_page = "Chester"
end

def open_difficulty_options
	grid = $scene.hud.open_grid
	grid.x = 70
	grid.y = 60
	grid.add_difficulty('easy')
	grid.add_difficulty('mid')
	grid.add_difficulty('hard')
	return grid
end

# Fades

def fadeout(f=30)
	$scene.black.do(to("opacity",255,255/f))
	w f
end

def fadein(f=30)
	$scene.black.do(to("opacity",0,-255/f))
	w f
end

def overlay(bmp,f=30)
	if f == 0
		$scene.overlay.opacity = 255
		return
	end
	$scene.overlay.bitmap = $cache.overlay(bmp)
	$scene.overlay.do(to("opacity",255,255/f))
	w f
end

def noverlay(f=30)
	if f == 0
		$scene.overlay.opacity = 0
		return
	end
	$scene.overlay.do(to("opacity",0,-255/f))
	w f
end"WWORLD_MAP_ID = 146

def start_transfer(map,room=nil,dir=nil)

	id = map
	id = find_map_id(map) if map.is_a?(String)
	room = map if room == nil
	$player.transfer_to(id,room,dir)

end

# instant jump to another map
def transfer_scene(map,room=nil,dir=nil)

	id = map
	id = find_map_id(map) if map.is_a?(String)
	room = map if room == nil
	$map.setup id


      ev = gev(room)
      
	    case dir
	      when 'd'
	        $player.direction = 2
	      when 'l'
	        $player.direction = 4
	      when 'r'
	        $player.direction = 6
	      when 'u'
	        $player.direction = 8
	    end

      dx = 0
      dy = 0
      dx = 1 if $player.direction == 6
      dx = -1 if $player.direction == 4
      dy = 1 if $player.direction == 2
      dy = -1 if $player.direction == 8

      tx = ev.x + dx
      ty = ev.y + dy

      if ev.width > 1
        tx += ev.width/2
      end

      if ev.height > 1
        ty += ev.height/2
      end

      $player.moveto(tx,ty)

end

def transfer(map,room=nil,dir=nil)
	$player.trans_type = :cross
	start_transfer(map,room,dir)
end

def transfer_cross(map,room=nil,dir=nil)
	$player.trans_type = :cross
	start_transfer(map,room,dir)
end

def transfer_instant(map,room=nil,dir=nil)
	$player.trans_type = :instant
	start_transfer(map,room,dir)
end

def transfer_fade(map,room=nil,dir=nil)
	$player.trans_type = :fade
	start_transfer(map,room,dir)
end

def transfer_cave(map,room=nil,dir=nil)
	$player.trans_type = :cave
	start_transfer(map,room,dir)
end

def transfer_same(dir=nil)
	$player.trans_type = :cross
	id = $scene.map.id
	name = $map.events[me].name
	room = $map.find_other(name,me)
	$player.transfer_to(id,room,dir)
end

def transfer_world(dir=nil)

	$player.trans_type = :cross

	# Get name of transfer
	room = $map.events[me].name

	# Do the transfer
	$player.transfer_to(WORLD_MAP_ID,room,dir)

end

def transfer_map(dir=nil)

	$player.trans_type = :cross
	
	# Get name of transfer
	room = $map.events[me].name

	# Find child map
	map = find_map_id(room.split(" *")[0])

	# Do the transfer
	$player.transfer_to(map,room,dir)

end

def transfer_chester_in(dir=nil)
	party_of_boy
	transfer(48,1,dir)
	$player.trans_type = :cave
end

def transfer_house_in(dir=nil)
	transfer_in("Indoor",dir)
	$player.trans_type = :fade
end

def transfer_house_in2(dir=nil)
	transfer_in("Indoor2",dir)
	$player.trans_type = :fade
end

def transfer_house_out(dir=nil)
	sfx 'door-open'
	transfer_out(dir)
	$player.trans_type = :fade
end

def transfer_house_out_s(dir=nil)
	transfer_out(dir)
	$player.trans_type = :fade
end

def transfer_cave_in(dir=nil)
	transfer_in("Cave",dir)
	$player.trans_type = :cave
end

def transfer_cave_in2(dir=nil)
	transfer_in("Cave2",dir)
	$player.trans_type = :cave
end

def transfer_cave_out(dir=nil)
	transfer_out(dir)
	$player.trans_type = :cave
end

def transfer_in(name,dir=nil)

	$player.trans_type = :cross

	# Get name of transfer
	room = $map.events[me].name

	# Find child map of name
	map = find_child_id($map.id,room)

	# If couldn't find, use the given name of the type of transfer understand?
	# Name will be Indoor or cave etc
	if map == 0
		map = find_child_id($map.id,name)
	end

	# Do the transfer
	$player.transfer_to(map,room,dir)

end

def transfer_out(dir=nil)

	$player.trans_type = :cross

	# Get name of transfer
	room = $map.events[me].name

	# Find child map
	map = find_parent_id($map.id)

	# Do the transfer
	$player.transfer_to(map,room,dir)

end


def find_parent_id(map_id)
	return $data.mapinfos[map_id].parent_id
end

def find_parent_name(map_id)
	parent = $data.mapinfos[map_id].parent_id
	return $data.mapinfos[parent].name
end

def find_child_id(parent_id,name)

	$data.mapinfos.each{ |k,map|
		next if map.parent_id != parent_id
		next if map.name.split(" @")[0] != name
		return k
	}

	return 0

 end

 def find_map_id(name)

 	# Remove zone
 	name = name.split("@")[0].rstrip

	$data.mapinfos.each{ |k,map|
		return k if map.name == name
	}

	return 0

 end" 



def potion_equip(item)
	$party.potion_item = item
end

def potion_dequip
	$party.potion_item = nil
end

def potion_state(s)
	$party.potion_state = s
	$map.need_refresh = true
end

def potion_current
	return $data.potions[$party.potion_id]
end

def potion_chose_recipe

	# Check if this is even a recipe
	if $menu.chosen.include?('recipe')

		recipe = $menu.chosen.sub('recipe-','')
		log_scr(recipe)
		$party.potion_id = recipe
		$menu.chosen = nil
		potion_state('start')

	else

		text("x-ing: This isn't a potion recipe!")
		$menu.chosen = nil
		potion_state('empty')

	end

	# Clear
	

end

def potion_chose_secret?		
	#log_sys($menu.chosen)
	#log_ev(potion_current.ingredient)
	return potion_current.ingredient == $menu.chosen
end

def potion_use_item

	case $party.potion_item

		when 'vials'

			a = "Ingrid uses"
			ia = $cache.icon("faces/ing")

			b = "Undo Vials" 
			ib = $cache.icon("witchery/vials")


		when 'glacial-essence'

			a = "Ingrid adds a few drops of"
			ia = $cache.icon("faces/ing")

			b = "Glacial Essence" 
			ib = $cache.icon("witchery/glacial-essence")

		when 'dream-shroom'

			a = "Ingrid shakes the "
			ia = $cache.icon("faces/ing")

			b = "Dream Shroom" 
			ib = $cache.icon("witchery/dream-shroom")

		when 'rock-powder'

			a = "Ingrid shaves off some"
			ia = $cache.icon("faces/ing")

			b = "Rock Powder" 
			ib = $cache.icon("witchery/rock-powder")

		when 'moon-tear'

			a = "Ingrid squeezes the"
			ia = $cache.icon("faces/ing")

			b = "Moon Tear" 
			ib = $cache.icon("witchery/moon-tear")

		when 'violin'

			a = "Ingrid plays the"
			ia = $cache.icon("faces/ing")

			b = "Violin" 
			ib = $cache.icon("witchery/violin")

		when 'soda-ash'

			a = "Ingrid adds a handful of"
			ia = $cache.icon("faces/ing")

			b = "Soda Ash" 
			ib = $cache.icon("witchery/soda-ash")

		when 'baby-dragon'

			a = "The"
			ia = nil

			b = "Baby Dragon breathes fire"
			ib = $cache.icon("witchery/baby-dragon")

		when 'mineral-man'
		
			a = "Ingrid breaks off a piece of the"
			ia = $cache.icon("faces/ing")
				
			b = "Mineral Man"
			ib = $cache.icon("witchery/mineral-man")

		else

			text("x-ing: I need to add something.")
			return

	end

	popper = $scene.hud.open_popper
	popper.setup(a,ia,b,ib)

	if $party.potion_item == 'vials'
		potion_state('empty')
		item(potion_current.ingredient,'s')
		item(potion_current.ingredient)
	end

end

def potion_problem

	i = $party.potion_item	

	solved = false
	case $party.potion_state

		when 'hot' # Glacial Essence
			if i == 'glacial-essence'	

				solved = true

			end

		when 'rotten' # Mineral man
			solved = true if i == 'mineral-man'	


		when 'acidic' # Soda ash
			solved = true if i == 'soda-ash'	

		when 'claggy' # dream leaf
			solved = true if i == 'dream-shroom'	

		when 'slimy' # Rock Powder
			solved = true if i == 'rock-powder'	

		when 'cold' # Baby Dragon
			solved = true if i == 'baby-dragon'	

		when 'sour' # moon tear
			solved = true if i == 'moon-tear'	

		when 'volatile' # MUSIC
			solved = true if i == 'violin'	

	end

	if solved
		potion_next_problem
	else
		text("x-ing: That didn't work.")
	end

end

def potion_next_problem

	$party.potion_level += 1

	problems = potion_current.problems.split("\n")
	if $party.potion_level > problems.count
		$party.potion_state = 'done'
	else
		problem = problems[$party.potion_level-1]
		$party.potion_state = problem
	end

	$map.need_refresh = true

	case $party.potion_state

		when 'hot'
			
			text("x-ing: Something isn't right, it's very red.")

		when 'rotten'
			
			text("x-ing: This is wrong, it shouldn't be orange.")

		when 'acidic'
			
			text("x-ing: Hmm, it shouldn't be so yellow.")

		when 'claggy'
			
			text("x-ing: All the color has come out of it.")

		when 'slimy'
			
			text("x-ing: It's gone green, what will I do?")

		when 'cold'
			
			text("x-ing: I wonder what made it so blue.")

		when 'sour'
			
			text("x-ing: Something is wrong, it's pink!")

		when 'volatile'
			
			text("x-ing: This purple color doesn't seem right.")

		else
			text("x-ing: That's it! Perfect!")

	end

end

def cauldron_graphic(ev)

	case $party.potion_state

		when 'empty'
			ev.character_name = 'Objects/cauldron-base'
			ev.direction = 2

		when 'choose-recipe'
			ev.character_name = 'Objects/cauldron-base'
			ev.direction = 2

		when 'start'
			ev.character_name = 'Objects/cauldron-base'
			ev.direction = 2

		when 'started'
			ev.character_name = 'Objects/cauldron-base'
			ev.direction = 4

		when 'kaboom'
			ev.character_name = 'Objects/cauldron-base'
			ev.direction = 4

		when 'hot' # Glacial Essence
			ev.character_name = 'Objects/cauldron-problem-a'
			ev.direction = 2		

		when 'rotten' # Mineral man
			ev.character_name = 'Objects/cauldron-problem-a'
			ev.direction = 4

		when 'acidic' # Soda ash
			ev.character_name = 'Objects/cauldron-problem-a'
			ev.direction = 6

		when 'claggy' # dream leaf
			ev.character_name = 'Objects/cauldron-problem-a'
			ev.direction = 8

		when 'slimy' # Rock Powder
			ev.character_name = 'Objects/cauldron-problem-b'
			ev.direction = 2

		when 'cold' # Baby Dragon
			ev.character_name = 'Objects/cauldron-problem-b'
			ev.direction = 4

		when 'sour' # moon tear
			ev.character_name = 'Objects/cauldron-problem-b'
			ev.direction = 8

		when 'volatile' # MUSIC
			ev.character_name = 'Objects/cauldron-problem-b'
			ev.direction = 6

		when 'done'

			# Potion graphic
			case $party.potion_id

				when 'neon' # a - green
					ev.character_name = 'Objects/cauldron-potions-a'
					ev.direction = 8

				when 'blabber' # a - blue
					ev.character_name = 'Objects/cauldron-potions-a'
					ev.direction = 6

				when 'unslave' # a - brown
					ev.character_name = 'Objects/cauldron-potions-a'
					ev.direction = 2

				when 'shrink' # b - red
					ev.character_name = 'Objects/cauldron-potions-b'
					ev.direction = 2

				when 'mindbend' # b - yellow
					ev.character_name = 'Objects/cauldron-potions-b'
					ev.direction = 4

				when 'calming' # b - aqua
					ev.character_name = 'Objects/cauldron-potions-b'
					ev.direction = 8

				when 'guild' # b - gray
					ev.character_name = 'Objects/cauldron-potions-b'
					ev.direction = 6

				when 'love' # a - purple
					ev.character_name = 'Objects/cauldron-potions-a'
					ev.direction = 4

			end

	end

end"¥	
# Update self perhamps? Disregard else
# Uses $battle and that's it

# Handle all inputs?

class BattleHud

	attr_reader :chars

	def initialize(vp)

		@vp = vp

		@chars = []

		build_views

		# Help box
		@help_box = Box.new(vp)
		@help_box.skin = $cache.menu_common("skin-plain")
    	@help_box.wallpaper = $cache.menu_wallpaper("diamonds")
		@help_box.resize(300,50)
		@help_box.move(166,8-15)

	    @help_text = Sprite.new(vp)
	    @help_text.bitmap = Bitmap.new(300,50)
	    @help_text.bitmap.font = $fonts.message
	    @help_text.bitmap.draw_text(0,0,300,50,"Shadow - Gain Darkness",1)
		@help_text.move(166,9-15)

		# Try hiding the info box
		@help_box.opacity = 0
		@help_text.opacity = 0

		@help_timer = -1

	end

	def dispose
		@chars.each{ |c| c.dispose }
		@help_box.dispose
		@help_text.dispose
	end

	def build_views
		# Bottom bar
		@chars.each{ |c| c.dispose }
		@chars = []
		idx = 0
		cx = 5
		cx = 240 if $party.active.count == 1
		cx = 170 if $party.active.count == 2
		cx = 85 if $party.active.count == 3
		$party.active.each{ |char|
			view = CharView.new(@vp,$party.actor_by_id(char),idx)
			view.x = cx + (idx * 158)
			view.y = 340
			@chars.push(view)
			$party.get(char).view = view
			idx += 1
		}
	end

	def all_win
		@chars.each{ |c| c.win }
	end

	def deselect_all
		@chars.each{ |c| c.deselect }
	end

	def set_help(text)

		# Show it for a bit when called

		@help_timer = 120

		# Fadein the help now
		@help_text.bitmap.clear
		@help_text.bitmap.draw_text(0,0,300,50,text,1)

		@help_text.do(go('opacity',255,160,:qio))
		@help_box.do(go('opacity',255,160,:qio))

		@help_box.move(166,8-15)
		@help_text.move(166,9-15)

		@help_text.do(go('y',15,160,:qio))
		@help_box.do(go('y',15,160,:qio))

	end
	
	def update

		@help_timer -= 1
		if @help_timer == 0
			# Fadeout the help now thx
			@help_text.do(go('opacity',-255,160,:qio))
			@help_box.do(go('opacity',-255,160,:qio))

			@help_text.do(go('y',-15,160,:qio))
			@help_box.do(go('y',-15,160,:qio))
		end

		@chars.each{ |c|
			c.update
		}

		@help_box.update

		if @popper
			@popper.update 
			if $input.action? || $input.click?
				$tweens.clear(@popper)
				@popper.dispose
				@popper = nil
			end
		end

	end

	def open_popper()
		@popper = Ui_Popper.new(@vp)
		@popper.middle = true
		return @popper
	end

	def busy?
		return @popper != nil
	end

end"÷

class Popper < Sprite

	attr_accessor :value

	def initialize(vp)
		super(vp)

		@value = 0
		@old_value = 0

		self.bitmap = Bitmap.new(200,50)
		self.bitmap.font = $fonts.namebox

		refresh

	end

	def update

		if @value != @old_value
			refresh
		end

	end

	def done?
		return self.opacity == 0
	end

	def refresh

		# Draw the value out!
		self.bitmap.clear
		self.bitmap.draw_text(0,0,200,50,@value.to_i.to_s,2)

	end

end"ı
class ActorCmd

	def initialize(vp)

		@vp = vp

		@icons = []
		@texts = []
		#@text = Sprite.new(@vp)

		@idx = 0

	end

	def dispose
		@icons.each{ |i| i.dispose }
		@texts.each{ |i| i.dispose }
	end

	def setup(battler)

		close

		@battler = battler
		@actions = @battler.get_actions

		@icons.each{ |i| i.dispose }
		@icons = []

		@texts.each{ |i| i.dispose }
		@texts = []

		# Read the categories for this guy
		@actions.each{ |action|

			# Add an icon?
			spr = Sprite.new(@vp)
			@icons.push(spr)

			spr = Sprite.new(@vp)
			@texts.push(spr)
		}

		# Position the things
		#@idx = 1
		

		reposition
		select

		# Prep the text
		#@text.bitmap = Cache.menu("Battle/text")
		#@text.center(battler.ev.screen_x,battler.ev.screen_y + 24)

	end

	def close
		return if !@icons || @icons.empty?

		@icons.each{ |i|
			$tweens.clear(i)
		}
		@texts.each{ |i|
			$tweens.clear(i)
		}

		if @icons.count == 2

			@icons[0].do(go("x",18,250,:qio))
			@icons[0].do(go("y",25,250,:qio))

			@icons[1].do(go("x",-18,250,:qio))
			@icons[1].do(go("y",25,250,:qio))

		end

		if @icons.count == 3

			@icons[0].do(go("x",36,250,:qio))
			@icons[0].do(go("y",16,250,:qio))

			@icons[1].do(go("y",25,250,:qio))

			@icons[2].do(go("x",-36,250,:qio))
			@icons[2].do(go("y",16,250,:qio))

		end

		if @icons.count == 4

			@icons[0].do(go("x",54,250,:qio))
			@icons[0].do(go("y",16,250,:qio))

			@icons[1].do(go("x",18,250,:qio))
			@icons[1].do(go("y",25,250,:qio))

			@icons[2].do(go("x",-18,250,:qio))
			@icons[2].do(go("y",25,250,:qio))

			@icons[3].do(go("x",-54,250,:qio))
			@icons[3].do(go("y",16,250,:qio))

		end

		(@texts + @icons).each{ |i|
			i.do(go("opacity",-255,250,:qio))
			i.do(go("opacity",-255,250,:qio))
			i.do(go("opacity",-255,250,:qio))
		}

	end

	def get_action
		return @actions[@idx]
	end

	def reposition
		sx = @battler.ev.screen_x
		sy = @battler.ev.screen_y-44

		# Move selectors down on myst as a fox, maybe do for frog etc too
		if @battler.get_transform == 'x-fox'
			sy += 16
		end

		@icons.each{ |i|

				# Hide and fade in
				i.opacity = 0
				i.do(go("opacity",255,250,:qio))

				# Move
				i.move(sx,sy+12)

			}

		if @icons.count == 2

			cx = -18

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-25,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

		end

		if @icons.count == 3

			cx = -36

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-16,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[2].do(go("x",cx,250,:qio))
			@icons[2].do(go("y",-16,250,:qio))

			@texts[2].move(sx+cx+2,sy-35)

		end

		if @icons.count == 4

			cx = -36-18

			@icons[0].do(go("x",cx,250,:qio))
			@icons[0].do(go("y",-16,250,:qio))

			@texts[0].move(sx+cx+2,sy-35)

			cx += 36

			@icons[1].do(go("x",cx,250,:qio))
			@icons[1].do(go("y",-25,250,:qio))

			@texts[1].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[2].do(go("x",cx,250,:qio))
			@icons[2].do(go("y",-25,250,:qio))

			@texts[2].move(sx+cx+2,sy-35-9)

			cx += 36

			@icons[3].do(go("x",cx,250,:qio))
			@icons[3].do(go("y",-16,250,:qio))

			@texts[3].move(sx+cx+2,sy-35)
			
		end


	end

	def select
		sys('select')
		
		idx = 0
		@icons.each{ |i|
			#$tweens.resolve(i)
			
			i.bitmap = $cache.icon("battle/#{@actions[idx]}")

			i.ox = i.width/2
			i.oy = i.height
			idx += 1
		}
		idx = 0
		@texts.each{ |i|
			$tweens.resolve(i)

			i.opacity = 0
			
			i.bitmap = $cache.icon("texts/#{@actions[idx]}")

			i.ox = i.width/2
			i.oy = i.height
			idx += 1
		}

		
		#reposition
		@icons[@idx].bitmap = $cache.icon("battle/#{@actions[@idx]}-on")
		#seq = sequence(go("y",-3,400),go("y",3,400))
		@icons[@idx].do(repeat(seq))
		#$scene.hud.set_help(@battler.actions[@idx])
		@icons[@idx].ox = @icons[@idx].width/2
		@icons[@idx].oy = @icons[@idx].height

		@texts[@idx].y -= 10
		@texts[@idx].do(go("y",10,250,:qio))
		@texts[@idx].do(go("opacity",255,250,:qio))

		#@texts[@idx].zoom_x -= 10
		@icons[@idx].zoom_x = 1.0
		@icons[@idx].zoom_y = 1.0
		@icons[@idx].do(seq(go("zoom_x",0.2,50,:qio),go("zoom_x",-0.2,50,:qio)))
		@icons[@idx].do(seq(go("zoom_y",0.2,50,:qio),go("zoom_y",-0.2,50,:qio)))

	end

	def update

		return if @battler.nil?

		# Left and right to change
		if $input.right? && @idx < @icons.count-1
			@idx += 1
			select
		end

		if $input.left? && @idx > 0
			@idx -= 1 			
			select
		end

		pos = $mouse.position
		pos[0] += 13
		pos[1] += 34
			@icons.each{ |i|
			if i.within?(pos[0],pos[1],0,30)
				break if @icons.index(i) == @idx
				@idx = @icons.index(i)
				select
			end
		}

	end

end"M
# Actor view, show portrait, hp etc

class CharView < SpriteGroup

	attr_reader :box, :port

	def initialize(vp,char,id)

		super()

		@down = false
		@revert = false
		@revert_delay = 0

		@battler = char

		# Currently showing
		@state = nil

		@box = Box.new(vp)
		@box.skin = $cache.menu_common("skin-plain")
    	@box.wallpaper = $cache.menu_wallpaper(char.id)
		@box.resize(153,135)
		add(@box)   

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_battle(char.id)
		add(@port,153-@port.width-10,135-@port.height-10)

		@state_icon = Sprite.new(vp)
		#@state_icon.bitmap = $cache.face_battle(char.id)
		add(@state_icon,16,30)

		@shadow = Sprite.new(vp)
		@shadow.bitmap = $cache.menu_char("battlehud-shadow")
		add(@shadow,6,74)

		# @xform = Sprite.new(vp)
		# @xform.bitmap = $cache.menu_char("Transforms/frog") if rand(10) > 3
		# add(@xform,15,65)

		# Health
		#bars

		@hp_bar = Bar.new(vp,130,8)
		@hp_bar.for(:hp)
		#@hp_bar.value = @battler.hp_percent
		add(@hp_bar,11,118)

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200		
		add(@hp_label,12,110)

		@hp_value = Sprite.new(vp)
		@hp_value.bitmap = build_value_bmp(@battler.hp)
		@hp_value.opacity = 200
		add(@hp_value,140-@hp_value.bitmap.width,111)
		@hp_value.z += 50

		@mp_bar = Bar.new(vp,130,8)
		#@mp_bar.value = @battler.mp
		add(@mp_bar,11,100)

		@mp_label = Sprite.new(vp)
		@mp_label.bitmap = $cache.menu_char("label-mp")
		@mp_label.opacity = 200
		add(@mp_label,12,92)

		@mp_value = Sprite.new(vp)
		@mp_value.bitmap = build_value_bmp(@battler.mp)
		@mp_value.opacity = 200
		add(@mp_value,140-@mp_value.bitmap.width,93)
		@mp_value.z += 50


		# Show the right mana bar
		case @battler.id
			when 'boy','ing','phy'
				@mp_bar.for(@battler.id)
			else
				@mp_label.hide
				@mp_bar.hide
				@mp_value.hide
		end		

	end

	def dispose
		self.sprites.each{ |s| s[0].dispose }
	end

	def update

		@box.update
		@port.update

		@hp_bar.value = @battler.hp
		@mp_bar.value = @battler.mp

		@hp_bar.max = @battler.maxhp
		@mp_bar.max = @battler.maxmp

		@hp_value.bitmap = build_value_bmp(@battler.hp)
		@mp_value.bitmap = build_value_bmp(@battler.mp)

		@hp_bar.update
		@mp_bar.update

		if @revert && !@down
			@revert_delay -= 1
			if @revert_delay <= 0
				@revert = false
				@port.bitmap = $cache.face_battle(@battler.id)		
			end
		end

		# Has the state changed?
		if !@battler.states.empty?

			return if @battler.states[0] == @state

			@state = @battler.states[0]

			@state_icon.bitmap = $cache.icon("big-states/#{@state}")
			@box.wallpaper = $cache.menu_wallpaper(@state)
			@box.scroll(0,0.2)

		else

			return if @battler.states[0] == @state

			@state = nil

			@state_icon.bitmap = nil
			@box.wallpaper = $cache.menu_wallpaper(@battler.id)
			@box.scroll(0,0)

		end

	end

	def level
		return if @down
		@port.bitmap = $cache.face_battle(@battler.id+'-x')
		@revert = true
		@revert_delay = 75
	end

	def grin
		return if @down
		@port.bitmap = $cache.face_battle(@battler.id+'-h')
		@revert = true
		@revert_delay = 75
		@port.flash(Color.new(240,230,50,150),20)
	end

	def damage
		return if @down
		@port.bitmap = $cache.face_battle(@battler.id+'-a')
		@revert = true
		@revert_delay = 75
		@port.flash(Color.new(240,0,0,150),20)
	end

	def win
		return if @down
		@port.bitmap = $cache.face_battle(@battler.id+'-h')
	end

	def down
		@down = true
		@port.bitmap = $cache.face_battle(@battler.id+'-d')
	end

	def revive
		@down = false
		@port.bitmap = $cache.face_battle(@battler.id)		
	end

	def select
		#$tweens.clear(self)
		@port.do(go("oy",6,100,:qio))
		@box.flash_light
	end

	def deselect
		#$tweens.clear(self)
		@port.do(to("oy",0,-2))
	end

end"ê
class ItemCmd

	def initialize(vp)

		# Left side window
		@window = Box.new(vp,300,221)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	@window.move(14,66)

    	@box = Item_Box.new(vp)
		@box.item('covey')
		@box.move(326,100)
		@box.opacity = 0

		# Left side list
		@list = List.new()
		@list.move(20,72)

		@list.per_page = 6
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 1

		@list.change = Proc.new{ |option| self.change(option) }

		@list.setup([])
		@list.refresh


		@list.opacity = 0
		@window.opacity = 0

	end

	def dispose
		@window.dispose
		@box.dispose
		@list.dispose
	end

	def setup

		item_list = $party.battle_item_list
		@list.setup(item_list)
		change(item_list[0])

		open
	end

	def open
		$tweens.clear(@list)
		$tweens.clear(@window)
		$tweens.clear(@box)

		@list.opacity = 0
		@window.opacity = 0
		@box.opacity = 0

		@list.x = -132
		@list.do(go("x",150,250,:qio))
		@list.do(go("opacity",255,250,:qio))

		@window.x = -138
		@window.do(go("x",150,250,:qio))
		@window.do(go("opacity",255,250,:qio))

		@box.x = 326+150
		@box.do(go("x",-150,250,:qio))
		@box.do(go("opacity",255,250,:qio))
	end

	def close
		$tweens.clear(@list)
		$tweens.clear(@window)
		$tweens.clear(@box)

		@list.do(go("x",-150,250,:qio))
		@list.do(go("opacity",-255,250,:qio))

		@window.do(go("x",-150,250,:qio))
		@window.do(go("opacity",-255,250,:qio))

		@box.do(go("x",150,250,:qio))
		@box.do(go("opacity",-255,250,:qio))
	end

	def update
		@list.update
	end

	def change(option)

		@item = option

		@box.item(option)
		@box.move(326,100) if @box

		if @box && @last_option != option
			@last_option = option
			$tweens.clear(@box)
			@box.y -= 7
			@box.do(go("y",7,150,:qio))
		end

	end

	def get_item
		return @item
	end

end"r
class SkillCmd < ItemCmd

	def setup(battler,action)

		@battler = battler

		skill_list = @battler.skill_list(action)

		@box.type = :skill
		@list.per_page = 6
		@list.type = :skill
		@list.user = @battler.id
		@list.setup(skill_list)
		change(skill_list[0]) if !skill_list.empty?

		open
	end

	def get_skill
		return @item
	end

	def change(option)
		return if !@box
		@item = option
		@box.skill(option)
		@box.move(326,100) if @box

		#if @box && @last_option != option
			@last_option = option
			$tweens.clear(@box)
			@box.y -= 7
			@box.do(go("y",7,150,:qio))
		#end

	end

end"p
class TargetCmd

	attr_reader :active

	def initialize(vp)

		@vp = vp

		@arrow = Sprite.new(@vp)
		@arrow.bitmap = $cache.menu_common("target")
		@arrow.hide

		@targets_sy = nil
		@targets_sx = nil
		@targets = nil

		@active = nil

		@idx = 0

	end

	def dispose
		@arrow.dispose
	end

	def setup(targets)

		@arrow.show

		@targets = targets

		# Sort targets by y pos
		# Maybe x sort for left and right?
		@targets_sy = targets.sort_by{ |t| t.ev.screen_y }
		@targets_sx = targets.sort_by{ |t| t.ev.screen_x }

		@arrow.do(pingpong("oy",7,400,:qio))

		# Arrow pos
		@active = targets[0]
		point_at(targets[0])

	end

	def point_at(char)
		@arrow.center(char.ev.screen_x,char.ev.screen_y-($cache.get("Characters/"+char.ev.character_name).height/4)-6)
		@active.ev.flash_dur = 15

		$scene.hud.set_help(char.name)
	end

	def close
		@arrow.hide
	end

	def update

		# Left and right to change
		if $input.right?


			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx += 1
			if idx >= @targets_sx.count
			  idx -=1
			else
				@active = @targets_sx[idx]
				point_at(@active)
			end
			
		end

		if $input.left?
			# Get idx of sortings
			idx = @targets_sx.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			else
				@active = @targets_sx[idx]
				point_at(@active)
			end
		end



		# Left and right to change
		if $input.down?	
			
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx += 1
			if idx >= @targets_sy.count
			  idx -=1
			else
				@active = @targets_sy[idx]
				point_at(@active)
			end
			
		end

		if $input.up?
			# Get idx of sortings
			idx = @targets_sy.index(@active)

			idx -= 1
			if idx < 0
			  idx +=1
			else
				@active = @targets_sy[idx]
				point_at(@active)
			end
		end

		pos = $mouse.position
		@targets.each{ |i|
			next if i == @active
			next if pos[0] < i.ev.screen_x - 20
			next if pos[0] > i.ev.screen_x + 20
			next if pos[1] < i.ev.screen_y - 64
			next if pos[1] > i.ev.screen_y
			@active = i
			point_at(@active)
		}

	end

end
"#==============================================================================
# Ui_Screen
#==============================================================================

class Ui_Screen

	attr_reader :message, :bar
  
	def initialize(vp)

		@vp = vp
		
		@message = Ui_Message.new(vp)

		@bar = Ui_Bar.new(vp)
		#@bar.hide
		
		@info = Ui_Info.new(vp,@message)

		@popper = nil
		@grid = nil
		@item = nil

		@book = nil

		@blackbars = Sprite.new(vp)
		@blackbars.bitmap = $cache.menu_common('black-bars')
		@blackbars.opacity = 0

	end

	def dispose
		@message.dispose
		@bar.dispose
		@info.dispose
	end

	def blackbars
		hide
		@blackbars.do(go('opacity',255,1000,:qio))
		@blackbars.zoom_x = 1.2
		@blackbars.zoom_y = 1.2
		@blackbars.do(go('zoom_x',-0.2,1000,:qio))
		@blackbars.do(go('zoom_y',-0.2,1000,:qio))		
	end

	def quickbars
		@blackbars.opacity = 255
		hide
	end

	def nobars
		@blackbars.do(go('opacity',-255,1000,:qio))
		show
	end

	def hide
		@bar.hide
		@info.hide
	end
	def show
		@bar.show
		@info.show
	end

	def update

		#return

		if !$settings.bottombar
			@info.move(0,447)
			@bar.move(0,480)
		else
			@info.move(0,415)
			@bar.move(0,480-32)
		end

		@message.update
		@bar.update
		@info.update
		if @popper
			@popper.update 
			if $input.action? || $input.click?
				$tweens.clear(@popper)
				@popper.dispose
				sys('next')
				@popper = nil
			end
		end

		if @grid
			@grid.update 
			if $input.action? || $input.click?
				# Record action and close
				$menu.grid_action = @grid.get_chosen

				$tweens.clear(@grid)
				@grid.dispose
				@grid = nil
				if @item
					$tweens.clear(@item)
					@item.dispose
					@item = nil
				end
			end
		end

		if @item
			@item.update 
			if $input.action? || $input.click?
				$tweens.clear(@item)
				@item.dispose
				@item = nil
			end
		end

		if @book
			@book.update 
			if $input.action? || $input.cancel? || $input.rclick?
				$tweens.clear(@book)
				@book.dispose
				@book = nil
			end
		end

	  # Check inputs
	  return if busy? or $map.interpreter.running?
	  return if $party.leader == "minion-fang"
      if $input.cancel? || $input.rclick?
      	$menu.player_x = $player.screen_x
      	$menu.player_y = $player.screen_y
      	open_main_menu
      end

      # if $keyboard.press?(VK_J)
      # 	$menu.player_x = $player.screen_x
      # 	$menu.player_y = $player.screen_y
      # 	open_sub_menu("Journal")
      # end

      # if $keyboard.press?(VK_I)
      # 	$menu.player_x = $player.screen_x
      # 	$menu.player_y = $player.screen_y
      # 	open_sub_menu("Items")
      # end

      # if !$party.reserve.empty? && $keyboard.press?(VK_P)
      # 	$menu.player_x = $player.screen_x
      # 	$menu.player_y = $player.screen_y
      # 	open_sub_menu("Party")
      # end

	end

	def open_buy_item(i)

		@item = Item_Box.new(@vp)
		@item.show_price
		@item.item(i)
		@item.move($player.screen_x-@item.width/2,$player.screen_y-64-@item.height)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height + 64
		grid.add_button('Buy',"Buy",'misc/coins')
		grid.add_button('Info',"Info",'misc/dots')
		grid.add_button('Exit',"Exit",'misc/cross')

	end

	def open_sell_item(i)
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move($player.screen_x-@item.width,$player.screen_y-64-@item.height-40)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height
		grid.add_button('Buy',"Buy",'misc/unknown')
		grid.add_button('Info',"Info",'misc/unknown')
		grid.add_button('Cancel',"Cancel",'misc/unknown')
	end

	def open_empty_item
		@item = Item_Box.new(@vp)
		@item.item(i)
		@item.move($player.screen_x-@item.width,$player.screen_y-64-@item.height-40)

		# Also grid opens
		grid = open_grid
		grid.spacing = 0
		grid.x = @item.x#$player.screen_x
		grid.y = @item.y+@item.height
		grid.add_button('Buy',"Buy",'misc/unknown')
		grid.add_button('Info',"Info",'misc/unknown')
		grid.add_button('Cancel',"Cancel",'misc/unknown')
	end

	def open_popper()
		@popper = Ui_Popper.new(@vp)
		return @popper
	end

	def open_grid()
		@grid = Ui_Grid.new(@vp)
		return @grid
	end

	def open_book()
		@book = Ui_Book.new(@vp)
	end

	def quest_sparkle(icon)
		@bar.add_quest(icon)
	end

    def busy?() 
    	return @message.busy? || @item || @popper || @grid || @book
    end

end"¬#==============================================================================
# Ui_Bar
#==============================================================================

class Ui_Bar < SpriteGroup

	def initialize(vp)
		super()

		@vp = vp

		@base = Sprite.new(vp)
		@base.bitmap = $cache.menu_common("bottom-bar")
		#@base.bitmap.fill_rand
		add(@base)

		# Buttons
		cx = 6

		@quit = Button.new(vp)
		@quit.bitmap = $cache.icon("misc/quit")
		@quit.press = Proc.new{ open_sub_menu("Quit") }
		@quit.select = Proc.new{ $tweens.clear(@quit); @quit.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@quit.deselect = Proc.new{ $tweens.clear(@quit); @quit.oy = 0 }
		add(@quit,cx,4)

		cx += 32

		@journal = Button.new(vp)
		@journal.bitmap = $cache.icon("misc/journal")
		@journal.press = Proc.new{ open_sub_menu("Journal") }
		@journal.select = Proc.new{ $tweens.clear(@journal); @journal.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@journal.deselect = Proc.new{ $tweens.clear(@journal); @journal.oy = 0 }
		add(@journal,cx,4)

		cx += 32

		@items = Button.new(vp)
		@items.bitmap = $cache.icon("misc/items")
		@items.press = Proc.new{ open_sub_menu("Items") }
		@items.select = Proc.new{ $tweens.clear(@items); @items.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@items.deselect = Proc.new{ $tweens.clear(@items); @items.oy = 0 }
		add(@items,cx,4)

		cx += 32

		@party = Button.new(vp)
		@party.bitmap = $cache.icon("misc/party")
		@party.press = Proc.new{ open_sub_menu("Party") }
		@party.select = Proc.new{ $tweens.clear(@party); @party.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@party.deselect = Proc.new{ $tweens.clear(@party); @party.oy = 0 }
		add(@party,cx,4)

		cx += 32

		@progress = Button.new(vp)
		@progress.bitmap = $cache.icon("misc/progress")
		@progress.press = Proc.new{ open_sub_menu("Progress") }
		@progress.select = Proc.new{ $tweens.clear(@progress); @progress.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@progress.deselect = Proc.new{ $tweens.clear(@progress); @progress.oy = 0 }
		add(@progress,cx,4)

		cx += 32

		@settings = Button.new(vp)
		@settings.bitmap = $cache.icon("misc/settings")
		@settings.press = Proc.new{ open_sub_menu("Options") }
		@settings.select = Proc.new{ $tweens.clear(@settings); @settings.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@settings.deselect = Proc.new{ $tweens.clear(@settings); @settings.oy = 0 }
		add(@settings,cx,4)

		cx += 32

		@save = Button.new(vp)
		@save.bitmap = $cache.icon("misc/save")
		@save.press = Proc.new{ open_sub_menu("Save") }
		@save.select = Proc.new{ $tweens.clear(@save); @save.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
		@save.deselect = Proc.new{ $tweens.clear(@save); @save.oy = 0 }
		add(@save,cx,4)

		@char_icons = []
		@hp_bars = []
		@mp_bars = []

		@journal_pop = Sprite.new(vp)

		refresh

		move(0,480-32)

	end

	def dispose
		# Dispose all in spritegroup
	end

	def add_quest(icon)

		@journal_pop.x = @journal.x
		@journal_pop.y = @journal.y - 48
		@journal_pop.bitmap = $cache.icon(icon)
		@journal_pop.do(seq(go("y",48,1000),go("opacity",-255,500)))
		
	end

	def update
		super()

		#return

		refresh if @hp_bars.count < $party.active.count

		# Update the bars
		$party.active.each_index{ |i|
			@hp_bars[i].value = $party.get($party.active[i]).hp
			@mp_bars[i].value = $party.get($party.active[i]).mp
			@hp_bars[i].max = $party.get($party.active[i]).maxhp
			@mp_bars[i].max = $party.get($party.active[i]).maxmp
		}

		(@mp_bars+@hp_bars).each{ |b| b.update }

	end

	def refresh

		(@char_icons+@hp_bars+@mp_bars).each{ |i|

			i.dispose
			self.delete(i)

		}

		@char_icons = []
		@hp_bars = []
		@mp_bars = []

		# Chars
		i = 0
		$party.active.each{ |m|

			char = $party.get(m)

			# Add icon
			icon = Button.new(@vp)
			icon.bitmap = $cache.icon("faces/#{m}")
			icon.press = Proc.new{ 
				$tweens.clear(icon); icon.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio),call("open_char_menu('#{m}')")))				 
			}
			icon.select = Proc.new{ $tweens.clear(icon); icon.do(seq(go("oy",-4,100,:qio),go("oy",4,100,:qio))) }
			icon.deselect = Proc.new{ $tweens.clear(icon); icon.oy = 0 }
			add(icon,238+i*98,4)
			@char_icons.push(icon)

			mp_bar = Bar.new(@vp,66,6)
			mp_bar.opacity = 200
			mp_bar.for(:mp)
			add(mp_bar,27+238+i*98,9)
			@mp_bars.push(mp_bar)

			case m
				when 'boy', 'ing', 'hib', 'phy'
					mp_bar.for(m)
				else
					mp_bar.hide
			end

			hp_bar = Bar.new(@vp,66,8)
			hp_bar.opacity = 200
			hp_bar.for(:hp)
			add(hp_bar,27+238+i*98,17)
			@hp_bars.push(hp_bar)

			i += 1

		}

		move(0,480-32)

	end

end"6
#==============================================================================
# Ui_Book
#==============================================================================

class Ui_Book < SpriteGroup

	def initialize(vp)
		super()

		@base = Sprite.new(vp)
		@base.bitmap = $cache.menu_book('base')
		add(@base,0,0)

		@page = Sprite.new(vp)
		#@page.bitmap = $cache.menu_book('sampler')
		add(@page,0,0)

		@turner = Sprite.new(vp)
		@turner.bitmap = $cache.menu_book('turn-1')
		@turner.opacity = 0
		add(@turner,0,0)

		move(48,4)

		@state = :idle

		@page_idx = $menu.potion_page
		@turn_step = 20
		@turn_dir = 1

		@page.bitmap = $cache.menu_book("page-#{@page_idx}")
		@state = :fadein

		# Key display
		@key_left = Sprite.new(vp)
		@key_left.bitmap = $cache.icon('misc/key-left')
		@key_left.move(110,370)

		@key_right = Sprite.new(vp)
		@key_right.bitmap = $cache.icon('misc/key-right')
		@key_right.move(530,370)

		#refresh

	end

	def dispose
		$menu.potion_page = @page_idx
		@base.dispose
		@page.dispose
		@turner.dispose
	end

	def update
		super

		case @state

			when :fadeout

				@page.opacity -= 40
				if @page.opacity <= 0
					@state = :flip
				end



			when :flip

				@turn_step += (12 * @turn_dir)
				@turner.bitmap = $cache.menu_book("turn-#{@turn_step/20}")
				@turner.opacity = 255
				if (@turn_dir == 1 && @turn_step >= 119) || (@turn_dir == -1 && @turn_step <= 20)
					@turner.opacity = 0
					@state = :fadein
					@page.bitmap = $cache.menu_book("page-#{@page_idx}")
				end

			when :fadein

	
				@page.opacity += 40
				if @page.opacity >= 255
					@turner.opacity = 0
					@state = :idle
				end

		end

		# Mouse cursor

		if $mouse.x > 420 || $mouse.x < 220
			$mouse.change_cursor('Use')
		else
			$mouse.change_cursor('Default')
		end

		# Check left and right inputs to change pages
		return if @state != :idle
		if @page_idx != 0 && $input.left?
			@page_idx -= 1
			@turn_step = 119
			@turn_dir = -1
			@state = :fadeout
			sfx('page')
		end

		if @page_idx != 4 && $input.right?
			@page_idx += 1
			@turn_step = 20
			@turn_dir = 1
			@state = :fadeout
			sfx('page')
		end

		if $input.click?

			# If to the right
			if @page_idx != 4 && $mouse.x > 420
				@page_idx += 1
				@turn_step = 20
				@turn_dir = 1
				@state = :fadeout
				sfx('page')
			end

			if @page_idx != 0 &&  $mouse.x < 220
				@page_idx -= 1
				@turn_step = 119
				@turn_dir = -1
				@state = :fadeout
				sfx('page')
			end

		end

	end

end"eL#==============================================================================
# ** Ui_Grid
#==============================================================================

class Ui_Grid

	attr_reader :idx

	attr_accessor :spacing, :cx, :cy

	attr_reader :active

	attr_reader :selected_box

	attr_reader :bars

	def initialize(vp)

		@vp = vp

		@active = true

		@layout = :vertical

		@cx = 0
		@cy = 0

		@spacing = 5

		@fix_width = 0

		@boxes = []
		@contents = []
		@extra = []
		@bars = []

     	@glow = Sprite.new(vp)
     	@glow.bitmap = Bitmap.new(100,100)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow-#{$menu.char}"))
     	@glow.do(pingpong("opacity",-100,300,:quad_in_out))
     	@glow.z += 50

     	@idx = 0

     	@type = :slot
     	@char = 'boy'
     	
     	#@selected = "Journal"
     	#choose(@selected)

	end

	def hide_glow
		@glow.hide
	end

	def enable
		@active = true
		choose(@selected)
	end

	def disable
		@active = false
		@glow.move(-1000,-1000)
	end

	def move(x,y)
		@cx = x
		@cy = y
	end

	def opacity=(o)

	end
	def opacity
		return 255
	end

	def x=(v)
		@cx = v
	end
	def x
		return @cx
	end

	def y=(v)
		@cy = v
	end
	def y
		return @cy
	end

	def all
		return @contents + @extra + @boxes + @bars
	end

	def dispose

		$tweens.clear(@glow)
		@glow.dispose
		@contents.each{ |i| i.dispose }
		@extra.each{ |i| i.dispose }
		@bars.each{ |i| i.dispose }
		@boxes.each{ |i| i.dispose }

	end

	def clear
		@contents.each{ |i| i.dispose }
		@extra.each{ |i| i.dispose }
		@bars.each{ |i| i.dispose }
		@boxes.each{ |i| i.dispose }
		@contents = []
		@boxes = []
		@extras = []
		@bars = []

		@cx = 0
		@cy = 0

	end

	def add_active(id)

		char = $party.get(id)

		# Create new things
		btn = add_part_box(char.name,148,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("faces/#{id}")
     	#cont.gradient = true
     	cont.text = ' '
     	@contents.push(cont)

     	hp_bar = Bar.new(@vp,92,8)
		@extra.push(hp_bar)

		mp_bar = Bar.new(@vp,92,8)
		@extra.push(mp_bar)

     	# Position
     	cont.move(@cx+8,@cy+7)
     	hp_bar.move(@cx + 42,@cy+14)
     	mp_bar.move(@cx + 42,@cy+14+12)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @boxes.count % 2 == 0
  			@cy += btn.height + @spacing - 2
  			@cx -= btn.width + @spacing - 1
  		else
			@cx += btn.width + @spacing - 1
  		end

	end

	def add_reserve(id)

		char = $party.get(id)

		# Create new things
		btn = add_part_box(char.name,97,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("faces/#{id}")
     	#cont.gradient = true
     	cont.text = ' '
     	@contents.push(cont)

     	hp_bar = Bar.new(@vp,42,8)
		@extra.push(hp_bar)

		mp_bar = Bar.new(@vp,42,8)
		@extra.push(mp_bar)

     	# Position
     	cont.move(@cx+8,@cy+7)
     	hp_bar.move(@cx + 42,@cy+14)
     	mp_bar.move(@cx + 42,@cy+14+12)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
		@cx += btn.width + @spacing - 1

	end

	def add_button(name,text,icon)

		# Create new things
		btn = add_part_box(name,100,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx+10,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	#if @layout == :vertical
     		#@cy += btn.height + @spacing
     	#end

     	@cx += btn.width

	end

	def add_choice(name,text,w)

		# Create new things
		btn = add_part_box(name,w,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	#cont.icon = $cache.icon(icon)
     	#cont.gradient = true
     	cont.align = 1
     	cont.fixed_width = w #- 10
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height #+ @spacing
     	end

	end

	def add_wide(name,text,icon)

		# Create new things
		btn = add_part_box(name,300,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx+10,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + @spacing - 1
     	end

	end

	def add_midwidth(name,text,icon)

		# Create new things
		btn = add_part_box(name,250,46)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	# Position
     	cont.move(@cx+10,@cy+7)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + @spacing - 1
     	end

	end

	def add_slot(slot,eq)

		#log_info(slot)

		item = $data.items[eq]

		if item != nil
			
			text = item.name
			icon = item.icon
		else
			icon = "misc/unknown"
			text = 'Empty'
		end

		# Create new things
		btn = add_part_box(slot,300,66)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon(icon)
     	cont.gradient = true
     	cont.text = text
     	@contents.push(cont)

     	stat = Label.new(@vp)
     	stat.font = $fonts.pop_type

     	if item != nil && item.stats != ''
	    	data = item.stats.split("\n")[0].split("=>")
	    	log_info(data)
	    	stat.icon = $cache.icon("stats/#{data[0]}")
	    	text = ''
	    	case data[0]
	    		when 'str'
	    			text = "#{data[1]} Strength"
	    		when 'def'
					text = "#{data[1]} Defense"
	    		when 'eva'
	    			text = "#{data[1]}% Evasion"
	    		when 'luk'
	    			text = "#{data[1]}% Luck"
	    		when 'res'
	    			text = "#{data[1]}% Resist"
	    	end
	    	text += " +" if item.stats.split("\n").count > 1
	    	stat.text = text
	    end

	    if item != nil && slot == 'minion'
    		data = $data.actors[item.id.sub('boy-','')]
    		actions = data.actions.split(' | ')
    		actions.each{ |a|
    			text += $data.skills[a].name
    			text += ', ' if actions.count > 1 && a != actions[-1]
    		}
    		stat.icon = $cache.icon("stats/str")
    		stat.text = text
	    end

	    if item != nil && slot == 'book'
	    	case item.id
	    		when 'hib-book-sleep'
	    			text = 'Slumberfy, Rude Awakening'
	    		when 'hib-book-dmg'
	    			text = 'Recurring Nightmare, Chase'
	    		when 'hib-book-heal'
	    			text = 'Heal, Friendly Heal'
	    		when 'hib-book-help'
	    			text = 'Crit Chance, Detox'
	    		when 'hib-book-ice'
	    			text = 'Shard, Hail'
	    	end
    		stat.icon = $cache.icon("stats/str")
    		stat.text = text
	    end

     	@extra.push(stat)

     	# Put in caps

     	cat = Label.new(@vp)
    	cat.fixed_width = 100
    	cat.font = $fonts.pop_type
    	cat.align = 2
    	cat.text = slot.upcase.delete("12")
    	cat.opacity = 200
    	@extra.push(cat)

     	# Position
     	cont.move(@cx+10,@cy+7)
     	stat.move(@cx+25,@cy+32)
     	cat.move(@cx+188,@cy+8)

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + 6
     	end

	end

	def add_users(gear)

		data = $data.items[gear]

		btn = add_part_box('users',300,46)

		ocx = @cx

		@cx += 4
		@cy += 2

		# Find all users
		users = $party.all_battlers.select{ |b| 
			b.slots.include?(data.slot) ||
			b.slots.include?(data.slot+'1') ||
			b.slots.include?(data.slot+'2') 
		}

		# If too many users, need rows
		if users.count > 6
			btn.height = 106
		elsif users.count > 3
			btn.height = 77
		end


		# Draw all of the icons now
		tick = Sprite.new(@vp)
		tick.bitmap = $cache.icon("misc/tick")
		tick.move(@cx+10,@cy+10)
		@extra.push(tick)
		@cx += 28

		if users.empty?
			tick.bitmap = $cache.icon("misc/cross") if users.empty?
			icon = Label.new(@vp)
			icon.font = $fonts.pop_text
			icon.text = "No Users In Party"
			icon.move(@cx+10,@cy+7)
			@extra.push(icon)
			return
		end

		idx = 0

		users.each{ |u|
			icon = Label.new(@vp)
			icon.icon = $cache.icon("faces/#{u.id}")
			icon.font = $fonts.pop_text
			icon.text = u.equip_result(data)
			icon.move(@cx+10,@cy+7)
			@extra.push(icon)

			idx += 1

			if (idx == 3 || idx == 6) && users.count > idx
				@cx = ocx + 32
				@cy += 30
			else
				@cx += icon.width
			end
		}

		@cy += 46
		@cx = ocx

	end

	def add_mana(item)

		#data = $data.items[gear]

		btn = add_part_box('users',300,46)

		ocx = @cx

		@cx += 4
		@cy += 2

		# Find all users
		users = [$party.get('boy'),$party.get('ing'),$party.get('hib')]

		# Draw all of the icons now
		tick = Sprite.new(@vp)
		tick.bitmap = $cache.icon("misc/tick")
		tick.move(@cx+10,@cy+10)
		@extra.push(tick)
		@cx += 28

		users.each{ |u|
			icon = Label.new(@vp)
			icon.icon = $cache.icon("faces/#{u.id}")
			icon.font = $fonts.pop_text
			icon.text = '+'
			icon.move(@cx+10,@cy+7)
			@extra.push(icon)
			@cx += 80
		}

		@cy += 46
		@cx = ocx

	end

	def add_compare2(gear,slot,user)

		data = $data.items[gear]
		#return if gear != nil && data.stats == ''

		btn = add_part_box('user',300,46)

		# Find all users
		users = $party.all_battlers.select{ |b| b.slots.include?(@slot) }

		res = user.equip_result_full(data,@slot)

     	stat = Label.new(@vp)
        stat.icon = $cache.icon("faces/#{user.id}")
        stat.font = $fonts.pop_text
        stat.text = "#{res[0]} -> #{res[1]} (#{res[2]})"
        @extra.push(stat)
     	stat.move(@cx+10,@cy+7)

     	@cy += 46

	end

	def add_compare(stat,old,now,change)

		#log_scr(stat)

		btn = add_part_box(stat,300,46)
		if change < 0
			btn.wallpaper = $cache.menu_wallpaper('red')
		elsif change > 0
			btn.wallpaper = $cache.menu_wallpaper('green')
		end

		row = Label.new(@vp)
        row.icon = $cache.icon("stats/#{stat}")
        row.font = $fonts.pop_text
        #log_scr(res)
       	row.text = "#{old} -> #{now} (#{change})"
        @extra.push(row)
     	row.move(@cx+10,@cy+9)

     	@cy += 46

	end

	def add_nochange

		btn = add_part_box('nochange',300,46)

		row = Label.new(@vp)
        row.icon = $cache.icon("stats/def")
        row.font = $fonts.pop_text
        #log_scr(res)
	    row.text = 'No change'
        @extra.push(row)
     	row.move(@cx+10,@cy+9)

     	@cy += 46

	end

	def add_stock(id)

		btn = add_part_box('stock',300,46)

		row = Label.new(@vp)
        row.icon = $cache.icon("misc/items")
        row.font = $fonts.pop_text
	    row.text = "Inventory: #{$party.item_number(id)}"
        @extra.push(row)
     	row.move(@cx+10,@cy+9)

     	@cy += 46

	end

	def add_difficulty(diff)

		# Create new things
		btn = add_part_box(diff,500,116)

     	cont = Label.new(@vp)
     	cont.font = $fonts.list
     	cont.shadow = $fonts.list_shadow
     	cont.icon = $cache.icon("misc/diff-#{diff}")
     	cont.gradient = true
     	cont.text = diff_name(diff)
     	@contents.push(cont)
     	cont.move(@cx+10,@cy+7)

     	stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/attack")
        stat.font = $fonts.pop_text
        stat.text = "Enemies do 25% less damage"
        @extra.push(stat)
        stat.move(@cx+22,@cy+34)

        stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/targets")
        stat.font = $fonts.pop_text
        stat.text = "Enemies respawn"
        @extra.push(stat)
        stat.move(@cx+22,@cy+57)

        stat = Label.new(@vp)
        #stat.fixed_width = 250
        stat.icon = $cache.icon("stats/restore")
        stat.font = $fonts.pop_text
        stat.text = "Health is not restored when gaining levels"
        @extra.push(stat)
        stat.move(@cx+22,@cy+80)

     	# Position
     	
     	

     	choose(@boxes[0].name) if @boxes.count == 1

     	# Next
     	if @layout == :vertical
     		@cy += btn.height + 5
     	end

	end

	def add_party_mem(box,id)

		char = $party.get(id)

		name = "- Empty -"
		name = char.name if char
		name += " - Lvl #{char.level.to_s}" if char

		# Create new things
		btn = add_part_box(box,260,80)

		cont = Label.new(@vp)
	    cont.font = $fonts.list
	    cont.shadow = $fonts.list_shadow
	    cont.gradient = true
	    cont.text = name
	    @contents.push(cont)
	    cont.move(@cx+15,@cy+7)

		if char == nil



		else

	     	port = Sprite.new(@vp)
			port.bitmap = $cache.face_small(id)
			port.src_rect.height = port.height() 
			@extra.push(port)
			port.move(@cx+btn.width-port.width-9,@cy+70-port.height)
			port.z += 50




			mp_bar = Bar.new(@vp,140,9)
			@extra.push(mp_bar)
			mp_bar.opacity = 200
			mp_bar.for(:mp)
			mp_bar.move(@cx+20,@cy+42)

			mp_label = Sprite.new(@vp)
			@extra.push(mp_label)
			mp_label.bitmap = $cache.menu_char("label-mp")
			mp_label.opacity = 200
			mp_label.move(@cx+21,@cy + 35)
			mp_label.z += 50


			hp_bar = Bar.new(@vp,140,9)
			@extra.push(hp_bar)
			hp_bar.opacity = 200
			hp_bar.for(:hp)
			hp_bar.move(@cx+20,@cy+59)

			hp_label = Sprite.new(@vp)
			@extra.push(hp_label)
			hp_label.bitmap = $cache.menu_char("label-hp")
			hp_label.opacity = 200
			hp_label.move(@cx+21,@cy + 52)
			hp_label.z += 50

			
	     	choose(@boxes[0].name) if @boxes.count == 1

	     end

     	# Next
		@cy += btn.height + @spacing #3

	end

	def add_item_eater(id,item)

		char = $party.get(id)

		name = char.name

		# Create new things
		btn = add_part_box(id,145,83)

		cont = Label.new(@vp)
	    cont.font = $fonts.list
	    cont.shadow = $fonts.list_shadow
	    cont.gradient = true
	    cont.text = name
	    @contents.push(cont)
	    cont.move(@cx+10,@cy+7)

		if char == nil



		else

	     	port = Sprite.new(@vp)
			port.bitmap = $cache.face_small(id)
			port.bitmap = $cache.face_small(id+'-d') if char.down?
			port.src_rect.height = port.height() 
			@extra.push(port)
			port.move(@cx+btn.width-port.width-9,@cy+70-port.height)
			port.z += 50

			mp_bar = Bar.new(@vp,121,9)
			@bars.push(mp_bar)
			mp_bar.opacity = 200
			mp_bar.for('boy')
			case char.id 
				when 'boy','phy','ing'
					mp_bar.for(char.id)
				else
					mp_bar.hide
			end
			mp_bar.max = char.maxmp
			mp_bar.value = char.mp
			mp_bar.target = char.mp + char.mp_from_item(item)
			mp_bar.move(@cx+12,@cy+46)
			mp_bar.update
			mp_bar.z += 52

			mp_label = Sprite.new(@vp)
			@extra.push(mp_label)
			mp_label.opacity = 200
			case char.id 
				when 'boy'
					mp_label.bitmap = $cache.menu_char("label-sp")
				when 'phy'
					mp_label.bitmap = $cache.menu_char("label-rp")
				when 'ing'
					mp_label.bitmap = $cache.menu_char("label-mp")
				else
					mp_label.hide
			end			
			mp_label.move(@cx+13,@cy + 39)
			mp_label.z += 53



			hp_bar = Bar.new(@vp,121,9)
			@bars.push(hp_bar)
			hp_bar.opacity = 200
			hp_bar.for(:hp)
			hp_bar.max = char.maxhp
			hp_bar.value = char.hp
			hp_bar.target = char.hp + char.hp_from_item(item)
			hp_bar.move(@cx+12,@cy+61)
			hp_bar.update
			hp_bar.z += 52

			hp_label = Sprite.new(@vp)
			@extra.push(hp_label)
			hp_label.bitmap = $cache.menu_char("label-hp")
			hp_label.opacity = 200
			hp_label.move(@cx+13,@cy + 54)
			hp_label.z += 53
			
	     	choose(@boxes[0].name) if @boxes.count == 1

	     end

     	# Next
		@cy += btn.height + @spacing + 5

	end

	def add_part_box(name,w,h)
		btn = Box.new(@vp,w,h)
     	btn.skin = $cache.menu_common("skin-plain")
     	btn.wallpaper = $cache.menu_wallpaper('diamonds')
     	#btn.wallpaper = $cache.menu_wallpaper(["blue",'green','orange','diamonds'].sample)
     	btn.name = name
     	@boxes.push(btn)
     	btn.move(@cx,@cy)
     	return btn
	end

	def diff_name(diff)
		case diff
			when 'easy'
				return "Bunny Protector - Easy Mode"
			when 'mid'
				return "Villain - Normal Mode"
			when 'hard'
				return "Super Villain - Expert Mode"
		end
	end

	def get_box(option)
		return @boxes.select{ |b| b.name == option }[0]
	end

	def update
		return if !@active
		return if @boxes.empty?

		@glow.move(@selected_box.x+6,@selected_box.y+6)

		@boxes.each{ |b| b.update }
		@bars.each{ |e| e.update }

		if @boxes.count > 1 && $input.down?
			sx = @selected_box.x + @selected_box.width/2		
			sy = @selected_box.y + @selected_box.height
			search(sx,sy,1,3)
		end

		if @boxes.count > 1 && $input.up?
			sx = @selected_box.x + @selected_box.width/2		
			sy = @selected_box.y
			search(sx,sy,1,-3)
		end

		if @boxes.count > 1 && $input.right?		
			sx = @selected_box.x + @selected_box.width
			sy = @selected_box.y + @selected_box.height/2	
			search(sx,sy,3,1)
		end

		if @boxes.count > 1 && $input.left?
			sx = @selected_box.x
			sy = @selected_box.y + @selected_box.height/2
			search(sx,sy,-3,1)
		end


		pos = $mouse.position
		@boxes.each{ |b| 

			next if b == @selected_box
			next if pos[0] < b.x
		    next if pos[1] < b.y
		    next if pos[0] > b.x + b.width
		    next if pos[1] > b.y + b.height
			choose(b.name)
			break

		}

	end

	def search(sx,sy,x,y)

		cx = sx
		cy = sy

		# Start moving until find something
		while true

			cx += x
			cy += y

			@boxes.each{ |box|
				next if box == @selected_box 
				if box.window.within?(cx,cy)
					return choose(box.name)
				end
			}

			cy = 0 if cy > 480
			cx = 0 if cx > 640
			cy = 480 if cy < 0
			cx = 640 if cx < 0

		end

	end

	def open

		@glow.show
		@contents.each{ |i| i.show }
		@extra.each{ |i| i.show }
		@bars.each{ |i| i.show }
		@boxes.each{ |i| i.show }

	end

	def close

		@glow.hide
		@contents.each{ |i| i.hide }
		@extra.each{ |i| i.hide }
		@bars.each{ |i| i.hide }
		@boxes.each{ |i| i.hide }

	end

	def choose(target,mute=false)

		sys('select') if !mute #if @selected != target

		res = @boxes.find{ |b| b.name == target }
		return if res == nil

		@selected = target
		@selected_box = @boxes.find{ |b| b.name == target }

		# Find the icon if this is journal
		@idx = nil
		if !@boxes.select{ |b| b.name == target }.empty?

			idx = 0
			@boxes.each{ |b|
				break if b.name == target
				idx += 1
			}

			@idx = idx

		end

		glowon = @selected_box
		@selected_box.flash_light

		@glow.bitmap = Bitmap.new(glowon.width-12,glowon.height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow-#{$menu.char}"))
		@glow.move(glowon.x+6,glowon.y+6)

	end

	def get_chosen
		return @selected
	end

end"â#==============================================================================
# Ui_Info
#==============================================================================

class Ui_Info < SpriteGroup

	def initialize(vp,message)
		super()

		@message = message
		@hiding = false

		# Map
		@map = Label.new(vp)
		@map.font = $fonts.pop_type
		@map.icon = $cache.icon("items/map")
		@map.text = $map.nice_name
		add(@map,0,0)

		@icon = Sprite.new(vp)
		@icon.bitmap = $cache.icon("misc/coins")
		add(@icon,610,0)

		@gold = Label.new(vp)
		@gold.font = $fonts.pop_type
		@gold.fixed_width = 200
		@gold.align = 2
		@gold.text = $party.gold.to_s
		add(@gold,410,0)

		move(0,415)

		@visible_gold = $party.gold
		@visible_map = $map.nice_name

		refresh

	end

	def dispose
		@map.dispose
		@gold.dispose
	end

	def hide
		super
		@hiding = true
	end

	def show
		super
		@hiding = false
	end

	def update
		super

		if (@message.busy? && @message.mode == :vn) || @hiding
			@gold.opacity -= 5
			@icon.opacity -= 5
			@map.opacity -= 5
		else
			@gold.opacity += 5
			@icon.opacity += 5
			@map.opacity += 5
		end

		refresh if @visible_gold != $party.gold || @visible_map != $map.name
	end

	def refresh
		@visible_gold = $party.gold
		@visible_map = $map.nice_name

		@map.text = @visible_map
		@gold.text = @visible_gold.to_s

	end

end"_#==============================================================================
# Ui_Message
#==============================================================================

class Ui_Message

  # Consts
  MIN_WIDTH = 200
  MAX_WIDTH = 400
  MAX_WIDTH_VN = 480
  TAB_WIDTH = 35

  VN_WIDTH = 520

  MIN_HEIGHT_FACE = 80

  SPACING = 7
  LINE_HEIGHT = 27
  LINE_HEIGHT_BIG = 33
  PADDING_X = 21
  PADDING_Y = 16

  CHOICE_DELAY = 30

  SPEED_1 = 9
  SPEED_2 = 7
  SPEED_3 = 5
  SPEED_4 = 3
  SPEED_5 = 2

  attr_reader :last_choice
  attr_accessor :force_name
  attr_accessor :force_vn

  attr_reader :mode
  
  #--------------------------------------------------------------------------
  # Prepare
  #--------------------------------------------------------------------------
  def initialize(vp)

    @vp = vp

    # Create the pieces but do nothing besides
    @state = :idle

    # Hold on to the convo
    @text = ""

    @scratch = Bitmap.new(400,50)
    
    @lines = []
    @line_height = LINE_HEIGHT

    # Settings
    @color = nil
    @font = $fonts.message
    @font_shadow = $fonts.message_shadow

    # Text display
    @text_delay = SPEED_4
    @normal_speed = SPEED_4
    @wait_frames = 0
    @next_char = 0

    @choice_delay = CHOICE_DELAY # Make choice wait before allowing click

    @cx = 0
    @cy = 0
    
    @line_idx = nil
    @word_idx = nil
    @char_idx = nil

    @width = 0
    @height = 0

    @mode = :speaker # speaker, system or vn
    @speaker = nil
    @force_name = nil
    @force_vn = false

    @vn_port = Sprite.new(vp)
    @vn_port.opacity = 0

    @sprites = SpriteGroup.new

    @box = Box.new(vp)
    @box.skin = $cache.menu_common("skin")
    @box.wallpaper = $cache.menu_wallpaper("diamonds")
    #@box.wallpaper = $cache.menu_wallpaper("fangder")
    @box.scroll(0.1,0.1)

    # Setup sprites    
    @textbox = Sprite.new(vp)
    @textbox.z += 50

    @lastchar = Sprite.new(vp)
    @lastchar.z += 50

    @namebox = Sprite.new(vp)
    @namebox.bitmap = Bitmap.new(220,40)
    @namebox.bitmap.hskin($cache.menu("Common/namebox"))

    @nametext = Sprite.new(vp)
    @nametext.bitmap = Bitmap.new(220,40)
    @nametext.bitmap.font = $fonts.namebox
    @nametext.bitmap.draw_text(0,0,220,40,"texter")

    #@next = Sprite.new(vp)
    #@next.bitmap = $cache.menu("Common/next")
    
    @face = Sprite.new(vp)
    @face.z += 10
    
    @tail = Sprite.new(vp)
    @tail.bitmap = $cache.menu("Common/tail")


    # Group system
    @sprites.add(@box)
    @sprites.add(@textbox)
    @sprites.add(@lastchar)

    @sprites.add(@namebox,20,-@namebox.height+16)
    @sprites.add(@nametext,40,-@namebox.height+19)

    #@sprites.add(@next)
    @sprites.add(@face)
   # @sprites.add(@tail)

    @sprites.opacity = 0

    @sparks = []

    # Draw to textbox
    @text_bmp = nil

    @grid = nil
    @choices = []
    @last_choice = ''

  end

  def dispose
    @box.dispose
    @textbox.dispose
    @lastchar.dispose
    @namebox.dispose
    @nametext.dispose
    @face.dispose
    @tail.dispose
    @sparks.each{ |s| s.dispose }
  end

  def wallpaper=(w)
    @box.wallpaper = $cache.menu_wallpaper(w)
    if w == 'fangder'
      @box.alpha = 255
    else
      @box.alpha = 230
    end
  end
  
  #--------------------------------------------------------------------------
  # Frame Update
  #--------------------------------------------------------------------------
  def update

    @grid.update if @grid

    if @mode == :message

      @speaker = plr if !@speaker

      # Put over speaker
      x = @speaker.screen_x - @width/2 - 10
      y = @speaker.screen_y - @height - @speaker.gfx_height - 22 + @speaker.faceoff

      # Hiding the tail?
      h = false

      # LIMIT TO BE ON SCREEN
      if x < 7
        x = 7 
        #h = true
      end
      if y < 46
        #y = 290
        #h = true
      end
      if x > 640-@width-10
        x = 640-@width-10
        #h = true
      end
      if y > 480-@height-10
        y = 480-@height-10
        h = true
      end
      # @tail.bitmap = $cache.menu("Common/tail2") if h == true
      # @tail.bitmap = $cache.menu("Common/tail") if h == false

      @sprites.move(x,y)

      x = @speaker.screen_x - 12# - @width/2
      y = @speaker.screen_y - @speaker.gfx_height - 22  + @speaker.faceoff # - @height

      @tail.move(x,y)      

    end

    @tail.opacity = @sprites.opacity

    @box.update
    @sparks.delete_if { |s| s.done? }
    @sparks.each{ |s| s.update }
    
#~     if Input.press?(:SHIFT)
#~       @state = :closing
#~       @show_next = false
#~     end      
    
    # Skip to end of this text
    # if $input.action?
    #   @skip_all = true
    # end



    case @state

      when :closed
        #nothing

      when :opening
        @state = :texting if self.zoom_y == 1.0

      when :closing
        @state = :idle

      when :texting
        @next_char -= 1
        if @next_char <= 0
          #log_err "DOING"
          update_message
        end
        redraw

        if $input.action? || $input.click?
      
          @super_skipping = true
          while @state == :texting

            update_message           
          end
          @super_skipping = false
          redraw
          
        end
        
      when :waiting
        update_waiting

        # Choices in here too

      #when :pausing
      #  check_input_next
      when :choice
        @choice_delay -= 1
        check_input_choice
      when :done
        check_input_done
        
    end

    # skipping
    # while @state == :texting && $input.action?
    #   @next_char > 0 ? @next_char -= 1 : update_message
    # end

  end

  def add_choice(choice)
    @choices.push(choice)
    @choice_delay = CHOICE_DELAY
  end

  #--------------------------------------------------------------------------
  # Show Convo
  #--------------------------------------------------------------------------
  def start(text, choices = nil)

    $tweens.clear(@sprites)

    # Clear previous sparks
    @sparks.each { |s| s.dispose }
    @sparks = []

    @mode = :message

    # Reset
    @face.bitmap = nil
    #@vn_port.bitmap = nil
    @vn_port.do(to("opacity",0,-11))
    @speaker = nil
    @line_idx = 0
    @word_idx = -1
    @cx = PADDING_X
    @cy = PADDING_Y
    @text_delay = @normal_speed

    @tail.show

    return log_err "Must specify speaker" if !text.include?(':')
    text_data = text.split(":")

    # Read data to get name and text
    speaker = text_data[0]
    
    if speaker.include?("x-")
      @tail.hide
      @mode = :x
      speaker = speaker.sub("x-",'')
    end

    if speaker.include?("z-")
      @font = $fonts.message_big
      @font_shadow = $fonts.message_big_shadow
      @line_height = LINE_HEIGHT_BIG
      speaker = speaker.sub("z-",'')
    elsif speaker.include?("t-")
      @font = $fonts.message_tiny
      @font_shadow = $fonts.message_tiny_shadow
      speaker = speaker.sub("t-",'')
    else
      @font = $fonts.message
      @font_shadow = $fonts.message_shadow
      @line_height = LINE_HEIGHT
    end

    # Figure things out from speaker
    #speaker = gev(speaker.to_i).name if speaker.numeric? # This is cut so you can just do 25: Text, instead of npc2, npc3
    from_this = false
    if ['this','me','This'].include?(speaker)
      from_this = true
      speaker = this.name
    end
    name = speaker.gsub(/\A[\d_\W]+|[\d_\W]+\Z/, '') # Remove numbers

    # Special allowance for names of ???
    name = "???" if speaker.include?("???")

    # Check the mode
    if speaker.include?("vn-") || @force_vn
      speaker = speaker.sub("vn-",'')
      name = name.sub("vn-",'')
      @mode = :vn

      @tail.hide

      # Hack to hide vn face on gameover
      if !$scene.is_a?(Scene_GameOver)

        # Set vn face
        @vn_port.bitmap = $cache.face_vn(speaker)
        @vn_port.x = ($game.width - @vn_port.width)/2
        @vn_port.y = $game.height - @vn_port.height
        #@vn_port.opacity = 0
        $tweens.clear(@vn_port)
        @vn_port.do(go("opacity",255,400,:quad_in_out))
        #speaker = nil

      end

    end

    # System message
    if speaker.split("-")[0] == 'sys' || speaker.split("-")[0] == 'top'
      @mode = speaker.split("-")[0].to_sym
      if speaker.split("-").count > 1
        @box.wallpaper = $cache.menu_wallpaper(speaker.split("-")[1])
      end
      speaker = nil
      name = ''      
      @tail.hide
    end
    
    # If in party, show as player and change player graphic
    if @mode != :vn
      if speaker != nil && $party.all.include?(speaker.split('-')[0]) && (@mode == :message || @mode==:x)
        @speaker = $player
        $player.looklike(name.split('-')[0])
      elsif speaker != nil
        if from_this
          @speaker = this
        else
          @speaker = gev(speaker.split("-")[0])
        end
        @mode = :sys if @speaker == nil
      end
    end

    # Force name to not have the number
    name.delete!('123456789')

    # Get face and name of player characters
    if $data.actors.has_key?(name.split('-')[0])
      @face.bitmap = $cache.face(name) if @mode == :message || @mode == :x
      name = $data.actors[name.split('-')[0]].name
    end

    # If forcing to speak from a number, switch to name now
    if speaker != nil && speaker.numeric?
      name = gev(speaker.to_i).name
      name = name.gsub(/\A[\d_\W]+|[\d_\W]+\Z/, '') # Remove numbers
    end

    build_namebox(name.split("-")[0])

    # Chance wallpaper as needed
    build_wallpaper(name.split("-")[0])   

    # Force split the lines
    @lines = split_text(text_data[1]) 

    # Textbox size
    @width = max_width + PADDING_X * 2
    if (@namebox.width + 44) > @width
      @width = @namebox.width + 44 
    end
    @height = (@lines.count * @line_height) + PADDING_Y * 2

    # Position the face
    if @face.bitmap
      @width += @face.width 
      @height = MIN_HEIGHT_FACE  + PADDING_Y * 2
      #fx = -10 + max_width + PADDING_X + PADDING_X # OLD, NOT SURE WHAT IT WAS TRYING TO DO
      fx = -10 + @width - @face.width
      fy = 7 + @height - @face.height - PADDING_Y
      @sprites.change(@face,fx,fy)
      @face.ox = 15
      @face.do(go("ox",-15,500,:qio))
    end

    if @mode == :vn
      @width = VN_WIDTH
      @height = (3 * @line_height) + PADDING_Y * 2
    end

    # Prepare the sprites  
    @box.resize(@width,@height)
    @textbox.bitmap = Bitmap.new(@width,@height)
    @text_bmp = Bitmap.new(@width,@height)
    
    @text_bmp.font = @font
    @textbox.bitmap.font = @font

    # Point tale x at speaker and y under box
    # Would need to be put in update
    @sprites.change(@tail,@width/2-2,@height)
    #@sprites.change(@next,@width/2,@height-20)
    $tweens.clear(@sprites)
    @sprites.do(go("opacity",255,500,:quad_in_out))
    $tweens.clear(@tail)
    @tail.do(go("opacity",255,500,:quad_in_out))
    
    #@sprites.do(go("y",-25,500,:quad_in_out))

    # Start writing    
    @state = :texting

    # Position for system messages
    if @mode == :vn
      @sprites.move(($game.width-@width)/2,320)
    end

    if @mode == :x
      @sprites.move(($game.width-@width)/2,320)
    end

    if @mode == :sys
      @sprites.move(($game.width-@width)/2,220)
    end
        
    if @mode == :top
      @sprites.move(($game.width-@width)/2,50)
    end

  end

  def build_namebox(name)

      name = @force_name if @force_name != nil

      # Create the namebox
      @nametext.bitmap.clear
      @namebox.bitmap.clear

      return if name == 'abc'
      return if name == ''
      return if name == nil

      size = $fonts.size(name,@nametext.bitmap.font)
      @namebox.bitmap = Bitmap.new(size.width+40,40)
      @namebox.bitmap.hskin($cache.menu("Common/namebox"))
      @nametext.bitmap.draw_gtext(0,0,220,35,name,1)

  end

  def build_wallpaper(name)

    if $scene.is_a?(Scene_Battle)
      #$scene.hud.message.wallpaper = 'diamonds'
      return
    end

    case name

      when '???'
        wallpaper = 'fangder'

      when 'Chester'
        wallpaper = 'wizard'

      else
        wallpaper = 'diamonds'

    end

  end

  #--------------------------------------------------------------------------
  # * Update Message
  #--------------------------------------------------------------------------
  def update_message

    skip_wait_test = false
    
    # if the current word is empty, get the next one and see if it fits
    if @word == nil || @char_idx > @word.length
      next_word
      skip_wait_test = true
    end
        
    # if not texting then don't go
    return unless @state == :texting
            
    # Add the next character to the final word
    @char_idx += 1

    # Play a lovely character sound
    sys('talk2',0.15) if !@super_skipping
    
    # Wait before drawing another character
    @next_char = @text_delay if !skip_wait_test

    # Show the behind char anim
        # Spawn spark
    

    txt = @word.delete('*^')[0..@char_idx-1]
    size = @scratch.text_size(txt)

    #return if size.width < 10
    
    x = @sprites.x + @cx+size.width
    y = @sprites.y + @cy

    return if @super_skipping #|| (@char_idx >= @word.length-1 && @char_idx > 0)

    sprk = Spark.new("message.28",x-4,y+16,@vp) # Faster with higher opacity perhaps
    #sprk.center()
    #sprk.blend_type = 1
    sprk.opacity = 30
    @sparks.push(sprk)
    
    # AUTO PAUSE AFTER SENTENCE HERE
    #(@wait_frames = @text_delay * 5; @state = :waiting) if @word.empty? && @dodotpause && @wordlength > 1
    

  end

  def redraw

    @textbox.bitmap.clear    
    @textbox.bitmap.blt(0,0,@text_bmp,@text_bmp.rect)

    return if @word == nil

    @scratch.font.bold = @word.include?("*")
    @scratch.font.italic = @word.include?("^")

    @textbox.bitmap.font.bold = @word.include?("*")
    @textbox.bitmap.font.italic = @word.include?("^")

    #txt = @word[0..@char_idx-1]
    txt = @word.delete('*^')[0..@char_idx-1]
    txt2 = @word.delete('*^')[@char_idx..@char_idx]

    size = @scratch.text_size(txt)

    # SHADOW HERE FOR THE WORD IN PROGRESS

    @textbox.bitmap.draw_gtext(@cx,@cy,300,@line_height,txt)

    # Half draw the final
    return if @char_idx >= @word.length
    return

    # Offset the y here to animate
    #r = rand(4)
    r = 0
    op = 220 - @next_char * 50

    @textbox.bitmap.font = @font_shadow
    @textbox.bitmap.font.color.alpha = op
    @textbox.bitmap.draw_text(@cx+r+size.width+2,@cy+r+2,100,@line_height,txt2)

    @textbox.bitmap.font.color.alpha = 255


    @textbox.bitmap.font = @font
    @textbox.bitmap.font.color.alpha = op
    @textbox.bitmap.draw_gtext(@cx+r+size.width,@cy+r,100,@line_height,txt2)

    @textbox.bitmap.font.color.alpha = 255


    # Maybe last char so this can redraw fast, maybe don't even need


  end

  def redraw_last


  end

  #--------------------------------------------------------------------------
  # * Pop down a line
  #--------------------------------------------------------------------------
  def next_line
    @line_idx += 1
    @word = nil
    if @line_idx >= @lines.count
      # If choices, open them now
      if !@choices.empty?
        open_choices
      else
        @state = :done
        #@box.skin = $cache.menu_common("skin-gold")
      end
    else
      @word_idx = 0
      @cy += @line_height
      @cx = PADDING_X
    end
  end

    #--------------------------------------------------------------------------
  # * Next word
  #--------------------------------------------------------------------------
  def next_word



    # blit last word onto the main bmp
    if @word != nil

      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')

      txt = @word.delete('*^')[0..@char_idx]

      @text_bmp.font = @font_shadow
      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')
      @text_bmp.draw_text(@cx+2,@cy+2,300,@line_height,txt)

      @text_bmp.font = @font
      @text_bmp.font.bold = @word.include?('*')
      @text_bmp.font.italic = @word.include?('^')
      @text_bmp.draw_gtext(@cx,@cy,300,@line_height,txt)

      # Step cursor
      @cx += word_width(@word)

    end

    @word_idx += 1
    @char_idx = 0
    
    if @word_idx >= @lines[@line_idx].count
      next_line
      return if @line_idx >= @lines.count
    end

    @word = @lines[@line_idx][@word_idx]

    return if @word == nil

    #Check for vars
    if @word.include?("&")
      @word.sub!("&","")
      if @word == 'forth-lvl'
        case $state.varval(@word)
          when 2; @word = 'two.'
          when 3; @word = 'three.'
          when 4; @word = 'four.'
          when 5; @word = 'five.'
          when 6; @word = 'six.'
          when 7; @word = 'seven.'
          when 8; @word = 'eight.'
          when 9; @word = 'nine.'
          when 10; @word = 'ten.'
        end
      else
        @word = $state.varval(@word).to_s
      end
    end 

    # CHECK FOR COMMANDS
    if @word.include?('$')
      cmd = @word.split(".")
      wrd = cmd[0]

      # check for command words
      case wrd
      
        when "$n" # New line
          next_line
          
        when "$w" # wait quarter second or custom
          @wait_frames = cmd.size > 1 ? cmd[1].to_i : 15
          @state = :waiting
                    
        when "$s"
          if cmd[1] == 'n' || cmd[1] == 'r'
            @text_delay = @normal_speed
          else
            @text_delay = SPEED_1 if cmd[1] == '1'
            @text_delay = SPEED_2 if cmd[1] == '2'
            @text_delay = SPEED_3 if cmd[1] == '3'
            @text_delay = SPEED_4 if cmd[1] == '4'
            @text_delay = SPEED_5 if cmd[1] == '5'          
          end
                    
        when "$sfx" # play sound
          sfx(cmd[1])
          
        when "$m"
          
          case cmd[1]
            when 'stop'
              Audio.bgm_stop            
            when 'fade'
              Audio.bgm_fade(750)                   
            else
              Audio.bgm_play(cmd[1])            
          end
          
        when "$nw" # @^ (No wait for input)
          @state = :closing
          @show_next = false
          
        when "$end"
          @word = nil
          @show_next = false
          return force_close
          
      end
        
      @word = nil
      next_word if @state != :waiting        

    end

  end  

  def open_choices
    @state = :choice
    @grid = Ui_Grid.new(@vp)
    @grid.move(@box.x,@box.y+@box.height+72)
    @grid.move(@box.x,@box.y+@box.height+112) if @mode == :top
    @choices.each{ |c|
      data = c.split(": ")
      @grid.add_choice(data[0],data[1],@box.width)
    }
  end

  #--------------------------------------------------------------------------
  # * Update waiting
  #--------------------------------------------------------------------------
  def update_waiting
    @wait_frames -= 1
    # @wait_frames = 0 if @skip_all #|| Graphics.frame_rate == 120
    @state = :texting if (@wait_frames < 1)
  end

  #--------------------------------------------------------------------------
  # * Wait for input after text is done
  #--------------------------------------------------------------------------
  def check_input_done
    if $input.action? || $input.click?
      sys('next')
      #self.slide_zy(0.0)
      @state = :closing
      @textbox.bitmap.clear
      $tweens.clear(@sprites)
      @sprites.opacity = 0
      @box.skin = $cache.menu_common("skin")
      $tweens.clear(@vn_port)
      @vn_port.do(to("opacity",0,-11))
      @tail.opacity = 0
      @tail.hide
      #@sprites.do(go("opacity",-255,100,:quad_in_out))

      @sparks.each { |s| s.dispose }
      @sparks = []

    end
  end

  def force_close

      @state = :closing
      @textbox.bitmap.clear
      $tweens.clear(@sprites)
      @sprites.opacity = 0
      @box.skin = $cache.menu_common("skin")
      $tweens.clear(@vn_port)
      @vn_port.do(to("opacity",0,-11))
      @tail.opacity = 0
      @tail.hide

      @sparks.each { |s| s.dispose }
      @sparks = []

    end

  #--------------------------------------------------------------------------
  # * Wait for input or choice
  #--------------------------------------------------------------------------
  def check_input_choice
    return if @choice_delay > 0
    if $input.action? || $input.click?
#      sys('next')
      #self.slide_zy(0.0)

      @last_choice = @choices[@grid.idx].split(":")[0]
      @choices = []

      @grid.dispose
      @grid = nil
      @state = :closing
      @textbox.bitmap.clear
      @sprites.opacity = 0
      @tail.opacity = 0
      @tail.hide
      @box.skin = $cache.menu_common("skin")

      #@sprites.do(go("opacity",-255,300,:quad_in_out))
    end
  end

  #--------------------------------------------------------------------------
  # Calculate size
  #--------------------------------------------------------------------------
  def word_width(word)
      return TAB_WIDTH if word == "$t"
      return 0 if word.include?("$")
      @scratch.font = @font
      @scratch.font.bold = word.include?('*')
      @scratch.font.italic = word.include?('^')
      return @scratch.text_size(word.delete('*^')).width + SPACING
  end

  def max_width
    max = 0
    @lines.each{ |line|
      width = line.inject(0) { |t,w| t + word_width(w) }
      max = width if width > max
    }
    return max - SPACING
  end

  def split_text(text)

    # Split all text into lines
    # Then calc widths and that

    total_width = text.split(" ").inject(0) { |t, w| t + word_width(w) }

    # use total width to split into lines

    # If there is a forced newline, there will be no autosizing
    if text.include?("$n")
      return text.split("$n").map { |i| i = i.split(" ") }  
    end

    # If less than split width, just one line
    if total_width < MIN_WIDTH #&& total_width < @namebox.width + 44
      return [text.split(" ")]
    end


    # figure max widths for the mode
    if @mode == :vn
      max_limit = MAX_WIDTH_VN
    else
      max_limit = MAX_WIDTH
    end
    
    # If width is less than max * 2, we are splitting at the first word after half point
    if @mode != :vn && total_width < (max_limit * 1.8) - 40
      limit = (total_width / 2) + 40
      # If long namebox, allow the text to go wider
      limit = @namebox.width + 44 if @namebox.width + 44 > limit
      cursor = 0
      lines = [[]]
      text.split(" ").each{ |word|
        if !lines[-1].empty? && cursor + word_width(word) >= limit 
          lines.push([])
          cursor = 0
        end
        cursor += word_width(word)
        lines[-1].push(word)
      }
      return lines
    end


    # Else we are autosizing max width
    lines = [[]]
    limit = max_limit
    # If long namebox, allow the text to go wider
    limit = @namebox.width + 44 if @namebox.width + 44 > limit
    cursor = 0
    text.split(" ").each{ |word|
      if !lines[-1].empty? && cursor + word_width(word) > limit
        # Don't go beyond first line
        if lines.count == 1
          limit = cursor
        end
        cursor = 0
        lines.push([])
      end
      cursor += word_width(word)
      lines[-1].push(word)
    }
    return lines

  end

  #--------------------------------------------------------------------------
  # Misc
  #--------------------------------------------------------------------------
  def clear() end
  def busy?() return @state != :idle end

end

"o


class Ui_Popper < SpriteGroup

	attr_accessor :title
	attr_accessor :middle

	def initialize(vp)
		super()		

		@vp = vp

		@middle = false

		# Resize to whatever is needed
		@window = Box.new(vp,300,54)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	@window.scroll(0.2,0.2)
    	add(@window)

    	@before = Label.new(vp)
    	@before.font = $fonts.message
    	add(@before,16,10)

    	@after = Label.new(vp)
    	@after.font = $fonts.message
    	add(@after,106,10)

	end

	def center(x,y)
		move(x-@window.width/2,y+60)
	end

	def dispose

		self.sprites.each{ |s|
			s[0].dispose
		}

	end

	def update
		@window.update
	end

	def color=(c)
		@window.wallpaper = $cache.menu_wallpaper(c)
	end

	def setup(a,ia,b,ib)

		data = $data.items[id]

		@before.text = a
		@before.icon = ia
		
		@after.text = b
		@after.icon = ib


		tw = @before.width + @after.width

		@window.resize(tw+26,54)
		
		change(@after,@before.x + @before.width+10,10)

		if @middle
			center(320,130)
		else
			center(320,230)
		end

		# Launch sparks?
		#sprk = $scene.add_spark("redstar",420,300,@vp)
		#

		# Animate in
		self.opacity = 0
		self.do(go("opacity",255,250,:qio))
		self.do(seq(go("y",-15,100,:qio),go("y",40,300,:bounce_o)))


	end

end"≠

class Ui_Shop < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@vp = vp

		# Left side window
		@window = Box.new(vp,300,242)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	add(@window,0,0)

		# Left side list
		@list = List.new()
		add(@list,6,6)

		@list.per_page = 9
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 35	

		@list.change = Proc.new{ |option| self.select(option) }
		
		data = []
		data.push('covey')
		data.push('covey')
		data.push('covey')

		@list.setup(data)

		@box = Item_Box.new(vp)
		@box.item('covey')
		add(@box,300,20)
		

		#@list.opacity = 0
		#@window.opacity = 0

		move(10,64)

@list.refresh
	end

	def dispose

		

	end

	def update
		@list.update
	end

	def setup()

		

	end

	def start_selling

	end

	def select(op)

	end


end"·
#==============================================================================
# ** Mnu_Base
#==============================================================================

class Mnu_Base

	attr_reader :left, :right, :other

	def initialize(vp)

		@closing = false
		@close_soon = false
		@close_delay = 0

		@left = []
		@right = []
		@other = []

		@title = Page_Title.new(vp)
		@left.push(@title)

		@tabs = Page_Tabs.new(vp)
		@tabs.change = Proc.new{ |option| self.tab(option) }
		@left.push(@tabs)

		@subtitle = Label.new(vp)
		@subtitle.font = $fonts.subtitle
		@subtitle.move(116,72)
		@left.push(@subtitle)


		@menu = List_Common.new(vp)
		@menu.list.select = Proc.new{ |option| self.select(option) }
		#@menu.list.cancel = Proc.new{ |option| self.cancel(option) }
		@menu.list.change = Proc.new{ |option| self.change(option) }
		@left.push(@menu)

		 @info = Info_Box.new(vp)
		 @left.push(@info)

		# Anything else is per page

		

	end

	def remove_menu
		@menu.dispose
		self.left.delete(@menu)
	end

	def remove_info
		@info.dispose
		self.left.delete(@info)
	end

	def dispose
		(@left + @right + @other).each{ |i| i.dispose }
	end

	def update

		if !@close_soon
			(@left + @right + @other).each{ |i| i.update }
		end

		if @close_soon && !@closing
			@close_delay -= 1
			if @close_delay <= 0
				close
			end
		end

		return if @close_soon

		# If anim in done, change state
		if $input.cancel? || $input.rclick?
			close_now
			$scene.queue_menu("Main")
		end
	end

	def close

		@left.each{ |a| $tweens.clear(a) }
		@right.each{ |a| $tweens.clear(a) }
		@other.each{ |a| $tweens.clear(a) }

		dur = 200
		dist = 30

		@closing = true
		#(@left + @right + @other).each{ |i| i.opacity = 0 }
		@left.each{ |i| i.do(go("opacity",-255,dur,:qio))}
		@left.each{ |i| i.do(go("x",-dist,dur,:qio))}
		@right.each{ |i| i.do(go("opacity",-255,dur,:qio))}
		@right.each{ |i| i.do(go("x",dist,dur,:qio))}
		@other.each{ |i| i.do(go("opacity",-255,dur,:qio))}
		self.do(delay(dur))

	end

	def open

		dur = 200
		dist = 30

		# Hide everything, animate in
		(@left + @right + @other).each{ |i| i.opacity = 0 }
		@left.each{ |i| i.do(go("opacity",255,dur,:qio))}
		@left.each{ |i| i.x -= dist; i.do(go("x",dist,dur,:qio))}
		@right.each{ |i| i.do(go("opacity",255,dur,:qio))}
		@right.each{ |i| i.x += dist; i.do(go("x",-dist,dur,:qio))}
		@other.each{ |i| i.do(go("opacity",255,dur,:qio))}
		self.do(delay(dur))
	end

	def close_soon(d=10)
		sys('cancel')
		@close_soon = true
		@close_delay = d
	end

	def close_now
		sys('cancel')
		@close_soon = true
		@close_delay = 0
	end

	def done?
		return @closing && $tweens.done?(self)
	end

end"≤
#==============================================================================
# ** Mnu_Char
#==============================================================================

class Mnu_Char < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change($menu.char)
		@subtitle.text = "Master of deception"

		@menu.dispose
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(15,113)

		char = $party.get($menu.char)
		
		@grid.add_wide("Equip","Change Equipment",char.weapon_icon)
		@grid.add_wide("Skills","Use Skills","skills/sparkle")
		@grid.add_wide("Status","View Status","misc/primary")
		@grid.add_wide("Profile","View Profile","misc/profile")
		@grid.add_wide("Leader","Set as Leader","faces/#{$menu.char}")
		
		@grid.add_wide("Boyle","Cheeki Chasing","items/creature") if $menu.char == 'boy' #&& !$progress.creatures.empty?
		@grid.add_wide("Ingrid","Witchery","misc/coven") if $menu.char == 'ing'
		@grid.add_wide("Nightwatch","Night Watch","items/great-moon") if $menu.char == 'mys' || $menu.char == 'rob'
		#@grid.add_wide("Hiberu","Dream Books","items/potion-red") if $menu.char == 'hib'
		#@grid.add_wide("Rowen","Gadget Building","items/potion-red") if $menu.char == 'row'
		@grid.add_wide("Phye","Demon Hunting","misc/phy-baal") if $menu.char == 'phy'

		@grid.choose($menu.char_cursor,true)

		self.left.push(@grid)

		# Fade and slide in
		dist = 30
		@grid.all.each{ |b|
			b.x -= dist
			b.opacity = 0
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def dispose
		super
		@grid.dispose
	end

	def update
		

		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Char")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Char")
			close_soon(0)
		end

		super

		@grid.update	

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close_now
		end

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end
		
	end

	def choose(option)

		if option == "Leader"
			$party.leader = $menu.char
		else
			$scene.queue_menu(option)
		end

		$menu.char_cursor = option
		@grid.selected_box.flash_heavy
		self.close_soon

	end

	def close
		super

		@grid.hide_glow

		# Fade and hide grid
		dist = 30
		@grid.all.each{ |b|
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
	end

end"`#==============================================================================
# ** Mnu_Healing
#==============================================================================

class Mnu_Healing < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('items')
		@subtitle.text = "Choose target of item"

		remove_menu
		remove_info

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@grid = Ui_Grid.new(vp)
		self.left.push(@grid)
		setup_grid

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.item($menu.use_item)
		self.right.push(@item_box)

		@item_grid = Ui_Grid.new(vp)
		@item_grid.move(@item_box.x,@item_box.y + @item_box.height)
		@item_grid.add_stock($menu.use_item)
		@item_grid.disable
		self.right.push(@item_grid)

		open

		# Fade and slide in
		dist = 30
		@grid.all.each{ |b|
			b.x -= dist
			b.opacity = 0
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}
		@item_grid.all.each{ |b|
			b.x += dist
			b.opacity = 0
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}

	end

	def setup_grid

		@grid.clear

		cx = 12
		cy = 120

		sx = 151
		sy = 90

		@grid.move(cx,cy)

		@grid.add_item_eater($party.active[0],$menu.use_item)

		cx += sx
		@grid.move(cx,cy)

		if $party.active.count > 1
			@grid.add_item_eater($party.active[1],$menu.use_item)
		end

		cx = 12
		cy += sy
		@grid.move(cx,cy)

		if $party.active.count > 2
			@grid.add_item_eater($party.active[2],$menu.use_item)
		end

		cx += sx
		@grid.move(cx,cy)

		if $party.active.count > 3
			@grid.add_item_eater($party.active[3],$menu.use_item)
		end

		cx = 12
		cy += sy
		@grid.move(cx,cy)

		if $party.reserve.count > 0
			@grid.add_item_eater($party.reserve[0],$menu.use_item)
		end

		cx += sx
		@grid.move(cx,cy)

		if $party.reserve.count > 1
			@grid.add_item_eater($party.reserve[1],$menu.use_item)
		end

		cx = 89
		cy += sy
		@grid.move(cx,cy)

		if $party.reserve.count > 2
			@grid.add_item_eater($party.reserve[2],$menu.use_item)
		end

	end

	def update

		ex = true
		@grid.bars.each{ |b|
			ex = false if !$tweens.done?(b)
		}

		if ex && $party.item_number($menu.use_item) == 0
			$scene.queue_menu("Items")
			close_now
		end

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Items")
			close_now
		end

		# Get chosen grid option
		if ex && $input.action? || $input.click?
			choose(@grid.get_chosen)
		end

		super		

	end

	def choose(option)	

		@grid.bars.each{ |b|
			return if !$tweens.done?(b)
		}

		# Is it even going to do anything?
		if $party.get(option).mp_from_item($menu.use_item) == 0
			if $party.get(option).hp_from_item($menu.use_item) == 0
				sys('deny')
				return
			end
		end

		#sys('quest')
		first = $data.items[$menu.use_item].action.split("/n")[0]
		#log_info(first)
		if first.include?('heal')
			sys('eat')
		elsif first.include?('mana')
			sys('drink')
		end

		# If cassia, do special sound

		$party.lose_item($menu.use_item)
		@item_grid.clear
		@item_grid.move(@item_box.x,@item_box.y + @item_box.height)
		@item_grid.add_stock($menu.use_item)

		# Heal mana
		if $party.get(option).mp_from_item($menu.use_item) > 0
			idx = $party.all.index(option)*2
			change = $party.get(option).mp_from_item($menu.use_item)
			@grid.bars[idx].do(go("value",change,250,:qio))	
			@grid.bars[idx].do(go("target",change,250,:qio))		
		end

		# Heal hp
		if $party.get(option).hp_from_item($menu.use_item) > 0
			idx = $party.all.index(option)*2+1
			change = $party.get(option).hp_from_item($menu.use_item)
			@grid.bars[idx].do(go("value",change,250,:qio))		
			@grid.bars[idx].do(go("target",change,250,:qio))		
		end		
		
		$party.get(option).use_item($menu.use_item)	

		setup_grid if $menu.use_item == 'cassia'
		
	end


	def close
		super

		@grid.hide_glow

		# Fade and hide grid
		dist = 30
		@grid.all.each{ |b|
			next if b.disposed?
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		@item_grid.all.each{ |b|
			next if b.disposed?
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
	end

end"#==============================================================================
# ** Mnu_Help
#==============================================================================

class Mnu_Help < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('help')
		@subtitle.text = "HELP HELP"

		@menu.list.type = :misc

		data = []
		$data.help.values.each{ |h|
			data.push([h.id,h.name,h.icon])
		}

		@page = Right_Journal.new(vp)
		@right.push(@page)

		@menu.list.setup(data)		

		open

		#change(data[0]) if !data.empty?

	end

	def update
		super

		# Inputs maybe?

		# Probably for using healing items?

	end

	def change(option)

		option = option[0]

		#return

		@page.clear

		# Change page to show this quest
		#@info.title.text = option

		@page.title = $data.help[option].name
		@page.description = $data.help[option].description

		#@page.add_reqs($data.quests[option].req)
		#@page.add_zone($data.quests[option].location)

	end

	def select(option)	
		
	end


end"b#==============================================================================
# ** Mnu_Items
#==============================================================================

class Mnu_Items < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('items')
		#@subtitle.text = "Various items of collection"

		@tabs.push("all")
		@tabs.push("usable")
		@tabs.push("keys")
		@tabs.push("shop")

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.hide
		self.right.push(@item_box)

		# Party grid hahahha
		@grid = Ui_Grid.new(vp)
		@grid.move(@item_box.x,@item_box.y + @item_box.height + 3)
		$party.active.each{ |m|
			@grid.add_active(m)
		}
		@grid.cx = @item_box.x
		$party.reserve.each{ |m|
			@grid.add_reserve(m)
		}
		@grid.disable
		#@grid.hide
		self.right.push(@grid)

		tab('all')

		open

	end

	def update

		return if !$tweens.done?(@port)
		super		
	end

	def tab(option)

		# Reload the quest list limited to this tab
		data = $party.items.keys

		if option == 'all'
			data = data.select{ |q| $data.items[q].tab != 'gear' }
		end

		if option == "usable"
			data = data.select{ |q| $data.items[q].tab == 'usable' }
		end

		if option == "keys"
			data = data.select{ |q| $data.items[q].tab == 'keys' }
		end

		if option == "shop"
			data = data.select{ |q| $data.items[q].tab == 'shop' }
		end

		@menu.list.setup(data)
		@menu.list.slide

		change(data[0])

	end

	def change(option)

		#@item_box.show
		
		@item_box.item(option)
		@item_box.center(472,260)#+@menu.list.page_idx*@menu.list.row_height)

		item = $data.items[option]

		@grid.all.each{ |i| $tweens.clear(i) }
		@grid.clear

		@grid.move(@item_box.x,@item_box.y + @item_box.height)

		# If gear, show the +-
		if item.is_a?(GearData)
			@grid.add_users(option)
		end

		#if item.is_a?(UsableData)

			# If healing, show results
		#	if item.action.include?('mana')
				#@grid.add_mana(option)
		#	end

		#end

		@grid.disable

		if @last_option != option
			@last_option = option

			$tweens.clear(@item_box)

			@item_box.y -= 7
			@item_box.do(go("y",7,150,:qio))

			@grid.all.each{ |i|
				next if i.disposed?
				i.y -= 7
				i.do(go("y",7,150,:qio))
			}
		end
		
	end

	def select(option)	

		return if !$data.items[option].is_a?(UsableData)

		scope = $data.items[option].scope
		
		# If item needs a target, do it
		case scope

			when 'ally', 'down'
				$menu.use_item = option
				$scene.queue_menu("Healing")
				close_soon

			when 'common'
				if option == 'witch-teleport' && $map.id == 94
					sys('deny')
					return
				end
				if option == 'witch-teleport' && !$party.all.include?('ing')
					sys('deny')
					return
				end
				$menu.common_event = $data.items[option].action.split("=>")[1].to_i
				close_soon

		end

	end

	def close

		super

		# Fade and hide grid
		dist = 30
		@grid.all.each{ |b|
			next if b.disposed?
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
	end

end"3#==============================================================================
# ** Mnu_Journal
#==============================================================================

class Mnu_Journal < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('journal')

		@tabs.push("all")
		@tabs.push("main")
		@tabs.push("side")

		@menu.list.type = :quest
		@menu.list.setup($progress.quests.reverse)

		@page = Right_Journal.new(vp)
		self.right.push(@page)

		open

		# Open first
		change($progress.quests[-1]) if !$progress.quests.empty?

	end

	def update
		super
	end

	def tab(option)

		# Reload the quest list limited to this tab
		data = $progress.quests.reverse

		if option == "main"
			data = data.select{ |q| $data.quests[q].type == 'main' }
		end

		if option == "side"
			data = data.select{ |q| $data.quests[q].type != 'main' }
		end

		@menu.list.setup(data)
		@menu.list.slide

	end

	def change(option)

		@page.clear

		if !$data.quests.has_key?(option)
			log_err("MISSING QUEST: #{option}")
			return
		end

		@page.title = $data.quests[option].name
		@page.description = $data.quests[option].description

		@page.add_reqs($data.quests[option].req)
		@page.add_zone($data.quests[option].location)

	end

	def select(option)

	end

end"ä#==============================================================================
# ** Mnu_Main
#==============================================================================

class Mnu_Main

	def initialize(vp)

		@vp = vp
		@closing = false
		@close_soon = false
		@close_delay = 0

		@chars = []

		# Active Characters

		charbox = Char_Box_Large.new(vp,$party.active[0])
		charbox.box.name = "C.0"
		charbox.move(200,15)
		@chars.push(charbox)

		if $party.active.count > 1
			charbox = Char_Box_Large.new(vp,$party.active[1])
			charbox.box.name = "C.1"
			charbox.move(420,15)
			@chars.push(charbox)
		end

		if $party.active.count > 2
			charbox = Char_Box_Large.new(vp,$party.active[2])
			charbox.box.name = "C.2"
			charbox.move(200,198)
			@chars.push(charbox)
		end

		if $party.active.count > 3
			charbox = Char_Box_Large.new(vp,$party.active[3])
			charbox.box.name = "C.3"
			charbox.move(420,198)
			@chars.push(charbox)
		end

		# Reserve Characters

		if $party.reserve.count > 0
			charbox = Char_Box_Small.new(vp,$party.reserve[0])
			charbox.box.name = "R.0"
			charbox.move(200,381)
			@chars.push(charbox)
		end

		if $party.reserve.count > 1
			charbox = Char_Box_Small.new(vp,$party.reserve[1])
			charbox.box.name = "R.1"
			charbox.move(347,381)
			@chars.push(charbox)
		end

		if $party.reserve.count > 2
			charbox = Char_Box_Small.new(vp,$party.reserve[2])
			charbox.box.name = "R.2"
			charbox.move(492,381)
			@chars.push(charbox)
		end

		# Special Positioning
		if $party.active.count == 1
			@chars[0].move(310,140)
		end

		if $party.active.count == 2
			@chars[0].move(200,140)
			@chars[1].move(420,140)
		end

		if $party.reserve.count == 0 && $party.active.count > 2
			@chars[0].move(200,50)
			@chars[1].move(420,50)
			@chars[2].move(200,233)
			@chars[3].move(420,233) if $party.active.count > 3
		end


		if $party.reserve.empty?
			@data = ['Journal','Items','Progress',
  	 			     'Options','Help','Quit','Load','Save']
  	 		@cy = 36
		else
			@data = ['Journal','Items','Party','Progress',
  	 			     'Options','Help','Quit','Load','Save']
  	 		@cy = 15
  	 	end

  	 	cy = @cy
		

		@buttons = []
		@texts = []
		@icons = []

		@data.each{ |item|

			btn = Box.new(vp,170,45)
	     	btn.skin = $cache.menu_common("skin-plain")
	     	btn.wallpaper = $cache.menu_wallpaper("diamonds")
	     	btn.move(15,cy)
	     	btn.name = item
	     	@buttons.push(btn)

	     	text = Label.new(vp)
	     	text.font = $fonts.list
	     	text.shadow = $fonts.list_shadow
	     	text.gradient = true
	     	text.text = item
	     	text.move(94,cy+7)
	     	@texts.push(text)

	     	icon = Sprite.new(vp)
	     	icon.bitmap = $cache.menu("Icons/"+item)
	     	icon.move(-4+28,cy-12)
	     	#icon.src_rect = Rect.new(68,0,120,50)
	     	icon.z += 50
	     	@icons.push(icon)

	     	cy += 51

     	}

     	@glow = Sprite.new(vp)
     	@glow.bitmap = Bitmap.new(@buttons[0].width-12,@buttons[0].height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow-#{$menu.char}"))
     	@glow.do(pingpong("opacity",-100,300,:quad_in_out))

     	@idx = 0
     	@sr = 0

     	@boxes = @buttons + @chars.map{ |c| c.box }

     	# Everything fade in
     	(@chars + @buttons+@texts+@icons).each{ |c|
     		c.opacity = 0
     		c.do(go("opacity",255,200,:linear))
     	}

     	dist = 30
     	@chars.each{ |c| 
     		c.x += dist
     		c.do(go("x",-dist,200,:qio))
     	}

     	(@buttons+@texts+@icons).each{ |c|
			c.x -= dist
     		c.do(go("x",dist,200,:qio))
     	}

     	self.do(delay(200))
     	
     	@selected = $menu.menu_cursor #{}"Journal"
     	@selected_box = nil
     	choose(@selected,false)

	end

	def dispose

		@chars.each{ |c| c.dispose } 

		@glow.dispose
		@icons.each{ |i| i.dispose }
		@texts.each{ |i| i.dispose }
		@buttons.each{ |i| i.dispose }

	end

	def update

		@glow.move(@selected_box.x+6,@selected_box.y+6)
		return if !$tweens.done?(@chars[0])


		#@menu.update
		@chars.each{ |c| c.update }
		@boxes.each{ |b| b.update }

		@glow.move(@selected_box.x+6,@selected_box.y+6)


		if $input.action? || $input.click?
			select(@selected)
		end

		if $input.cancel? || $input.rclick?
			close_soon
		end

		if @close_soon && !@closing
			@close_delay -= 1
			if @close_delay <= 0
				close
			end
		end

		return if @closing || @close_soon

		# Just remember selected I would suppose
		box = @selected_box
			
		if $input.right?		
			sx = box.x + box.width
			sy = box.y + box.height/2	
			search(sx,sy,3,1)
		end

		if $input.left?
			sx = box.x
			sy = box.y + box.height/2
			search(sx,sy,-3,1)
		end

		if $input.down?
			sx = box.x + box.width/2		
			sy = box.y + box.height
			search(sx,sy,1,3)
		end

		if $input.up?
			sx = box.x + box.width/2		
			sy = box.y
			search(sx,sy,1,-3)
		end

		pos = $mouse.position
     

		# Mousing
		@boxes.each{ |b| 

			next if b == @selected_box
			next if pos[0] < b.x
		    next if pos[1] < b.y
		    next if pos[0] > b.x + b.width
		    next if pos[1] > b.y + b.height
			choose(b.name)
			break

		}

	end

	def search(sx,sy,x,y)

		before = @selected

		cx = sx
		cy = sy

		# Start moving until find something
		while true

			cx += x
			cy += y

			@boxes.each{ |box|
				if box.window.within?(cx,cy)
					return choose(box.name)
				end
			}

			cy = 0 if cy > 480
			cx = 0 if cx > 640
			cy = 480 if cy < 0
			cx = 640 if cx < 0

		end

	end

	def choose(target,dosound=true)

		sys('select') if dosound

		@selected = target

		@sr = 0


		idx2 = 0
		@icons.each{ |i|
			i.src_rect = Rect.new(36,0,120,50)
			i.y = @cy+10+(idx2*51)-23
			#i.x = @buttons[idx2].x
			#i.do(go("y"))
			$tweens.clear(i) if dosound
			idx2 += 1
		}


		# Find the icon if this is journal
		@idx = nil
		if !@buttons.select{ |b| b.name == target }.empty?

			idx = 0
			@buttons.each{ |b|
				break if b.name == target
				idx += 1
			}

			@idx = idx

			@icons[idx].do(go("y",-12,250,:quad_in_out))
			self.do(go("srcrecter",12,250,:quad_in_out))

		end

		@selected_box = @boxes.find{ |b| b.name == target }

		@chars.each{ |c| c.deselect }

		# If selected in chars list
		if @chars.map{ |c| c.box }.include?(@selected_box)
			i = @chars.map{ |c| c.box }.index(@selected_box)			
			@chars[i].select
		end

		glowon = @selected_box

		@selected_box.flash_light

		@glow.bitmap = Bitmap.new(glowon.width-12,glowon.height-12)
     	@glow.bitmap.borderskin($cache.menu_common("skin-glow-#{$menu.char}"))
		@glow.move(glowon.x+6,glowon.y+6)

	end

	def srcrecter
		return @sr
	end

	def srcrecter=(y)
		if @idx == nil
			$tweens.clear(self)
			return
		end
		@sr = y
		@icons[@idx].src_rect = Rect.new(36,0,120,50+y)
	end

	def select(option)

		case option
			when "Journal", "Items", "Party","Progress", "Options", "Help", "Quit", "Load", "Save"
				$scene.queue_menu(option)
			else
				# C.1
				num = option.split(".")[1].to_i
				if option.include?("C")
					$menu.char = $party.active[num]
				else # Reserve
					$menu.char = $party.reserve[num]
				end
				$scene.queue_menu("Char")

		end

		sys('action')
		@selected_box.flash_heavy
		$menu.menu_cursor = option

		close_soon

	end

	def close_soon(delay=10)
		@close_soon = true
		@close_delay = delay
	end

	def close

		@closing = true

		     	# Everything fade in
     	(@chars + @buttons+@texts+@icons).each{ |c|
     		c.do(go("opacity",-255,200,:linear))
     	}

     	dist = 30
     	@chars.each{ |c| 
     		c.do(go("x",dist,200,:qio))
     	}

     	(@buttons+@texts+@icons).each{ |c|
     		c.do(go("x",-dist,200,:qio))
     	}

     	@glow.hide
     	self.do(delay(200))

	end


	def closing?
		return @closing
	end

	def done?
		return @closing && $tweens.done?(self)
	end

end"*
class Mnu_Options < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('options')
		@subtitle.text = "Left and Right to change"

		@menu.list.type = :misc
		build_list		

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def build_list

		idx = @menu.list.page_idx

		data = []
		if $settings.fullscreen
			data.push(["fullscreen","Fullscreen: On","misc/window"])
		else
			data.push(["fullscreen","Fullscreen: Off","misc/window"])
		end
		data.push(["music","Music Vol: #{($settings.music_vol*100).to_i.to_s}%","misc/music"])
		data.push(["sound","Sound Vol: #{($settings.sound_vol*100).to_i.to_s}%","misc/sound"])
		if $settings.effects
			data.push(["effects","Graphic Effects: On","misc/effects"])
		else
			data.push(["effects","Graphic Effects: Off","misc/effects"])
		end
		if $settings.mouse
			data.push(["mouse","Mouse Control: On","misc/mouse"])
		else
			data.push(["mouse","Mouse Control: Off","misc/mouse"])
		end
		if $settings.tutorial
			data.push(["tutorial","Tutorial: On","misc/tuto"])
		else
			data.push(["tutorial","Tutorial: Off","misc/tuto"])
		end
		if $settings.bottombar
			data.push(["bottombar","Bottom Bar: On","misc/bottombar"])
		else
			data.push(["bottombar","Bottom Bar: Off","misc/bottombar"])
		end
		#data.push(["credits","View Credits >","misc/credits"])	

		@menu.list.setup(data,idx)

	end

	def update
		super

		left = $input.left?
		right = $input.right?

		# Check mouse actions for this?

		if left || right

			sys("select")

			case @menu.list.current[0]
				when "fullscreen"
					$game.flip_window
				when "music"
					if left
						$settings.music_vol -= 0.1
					else
						$settings.music_vol += 0.1
					end
					
					$settings.music_vol = 1.0 if $settings.music_vol > 1.0
					$settings.music_vol = 0.0 if $settings.music_vol < 0.0
					
				when "sound"
					if left
						$settings.sound_vol -= 0.1
					else
						$settings.sound_vol += 0.1
					end
					
					$settings.sound_vol = 1.0 if $settings.sound_vol > 1.0
					$settings.sound_vol = 0.0 if $settings.sound_vol < 0.0
					$audio.refresh_sound_volume

				when "effects"
					$settings.effects = !$settings.effects
				when "mouse"
					$settings.mouse = !$settings.mouse
				when "tutorial"
					$settings.tutorial = !$settings.tutorial
				when "bottombar"
					$settings.bottombar = !$settings.bottombar
				when "credits"
					# Nothing

			end

			build_list

		end

	end

	def change(option)
	end

	def select(option)	

		pos = $mouse.position.dup
		pos[0] -= 20

		sys("select")

		case option[0]
			when "fullscreen"
				$game.flip_window
			when "music"
				if pos[0].between?(205,245)
					$settings.music_vol -= 0.1
				elsif pos[0].between?(250,285)
					$settings.music_vol += 0.1
				end
				$settings.music_vol = 1.0 if $settings.music_vol > 1.0
				$settings.music_vol = 0.0 if $settings.music_vol < 0.0
			when "sound"
				if pos[0].between?(205,245)
					$settings.sound_vol -= 0.1
				elsif pos[0].between?(250,285)
					$settings.sound_vol += 0.1
				end
				$settings.sound_vol = 1.0 if $settings.sound_vol > 1.0
				$settings.sound_vol = 0.0 if $settings.sound_vol < 0.0
				$audio.refresh_sound_volume
			when "effects"
				$settings.effects = !$settings.effects
			when "mouse"
				$settings.mouse = !$settings.mouse
			when "tutorial"
				$settings.tutorial = !$settings.tutorial
			when "bottombar"
				$settings.bottombar = !$settings.bottombar
			when "credits"

		end

		build_list

	end

end" 

class Mnu_Party < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('party')
		@subtitle.text = "Change up your party members"

		remove_menu
		remove_info

		@first = nil

		@active = Sprite.new(vp)
		@active.bitmap = $cache.menu_tab('active')
		@active.move(130,110)
		@left.push(@active)

		@reserve = Sprite.new(vp)
		@reserve.bitmap = $cache.menu_tab('reserve')
		@reserve.move(436,110)
		@right.push(@reserve)

		@reserve = Sprite.new(vp)
		@reserve.bitmap = $cache.menu_common('switch')
		@reserve.move(293,285)
		@right.push(@reserve)
		
		@grid = Ui_Grid.new(vp)
		@other.push(@grid)
		setup_grid


		open

		dist = 30
		@grid.all.each{ |a|
			if a.x > 320
				a.x += dist
				a.do(go('x',-dist,200,:qio))
			else
				a.x -= dist
				a.do(go('x',dist,200,:qio))
			end
			a.opacity = 0
			a.do(go("opacity",255,200,:qio))
		}

	end

	def setup_grid
		
		@grid.move(30,138)

		@grid.add_party_mem('a.0',$party.active[0])
		@grid.get_box('a.0').wallpaper = $cache.menu_wallpaper('red')
		if $party.active.count > 1
			@grid.add_party_mem('a.1',$party.active[1])
		end
		if $party.active.count > 2
			@grid.add_party_mem('a.2',$party.active[2])
		end
		if $party.active.count > 3
			@grid.add_party_mem('a.3',$party.active[3])
		end

		@grid.cx = 344
		@grid.cy = 138

		@grid.add_party_mem('r.0',$party.reserve[0])
		if $party.reserve.count > 1
			@grid.add_party_mem('r.1',$party.reserve[1])
		end
		if $party.reserve.count > 2
			@grid.add_party_mem('r.2',$party.reserve[2])
		end
		if $party.reserve.count > 3
			@grid.add_party_mem('r.3',$party.reserve[3])
		end

	end

	def dispose
		@grid.dispose
	end

	def update
		super

		@grid.update

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end

	end

	def choose(option)

		if option == 'a.0'
			sys('deny')
			return
		end
		if @first == nil
			sys('action')
			@first = option
			@grid.get_box(option).wallpaper = $cache.menu_wallpaper('blue')
		else
			sys('tab')
			$party.swap(@first,option)
			@first = nil			
			@grid.clear
			setup_grid
			@grid.choose(option)
		end
	end

	def change(option)

		@page.clear


	end

	def select(option)	
		
	end

	def close
		super

		@grid.hide_glow
		dist = 30
		@grid.all.each{ |a|
			next if a.disposed?
			if a.x > 320
				a.do(go('x',dist,200,:qio))
			else
				a.do(go('x',-dist,200,:qio))
			end
			a.do(go("opacity",-255,200,:qio))
		}

	end

end"U#==============================================================================
# ** Mnu_Progress
#==============================================================================

class Mnu_Progress < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Progress')
		@title.icon($menu.char)
		@subtitle.text = "1 MILLION PERCENT!"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		cx = 28
		cy = 124

		lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/level")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Quests"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/level")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Main Quests: #{$progress.complete.count}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 26

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/xp")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Side Quests: 45/50"
	    lbl.move(cx,cy)
	    self.left.push(lbl)
		
		cx = 28
		cy += 28

		lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/primary")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Primary Stats"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/heal")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Max HP: #{@char.maxhp}  (#{@char.stat_pure('hp')} + #{@char.stat_gear('hp')})"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

end"ú#==============================================================================
# ** Mnu_Quit
#==============================================================================

class Mnu_Quit < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Quit')
		@subtitle.text = "Dare thee skulk?"

		@menu.dispose
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(15,113)

		char = $party.get($menu.char)
		
		@grid.add_wide("Continue","Continue",char.weapon_icon)
		@grid.add_wide("Save","Save and Quit","skills/sparkle")
		@grid.add_wide("Quit","Quit Without Saving","misc/primary")		

		self.left.push(@grid)

		# Fade and slide in
		dist = 30
		@grid.all.each{ |b|
			b.x -= dist
			b.opacity = 0
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}

		@port = Port_Full.new(vp)
		@port.shock
		self.right.push(@port)

		open

	end

	def dispose
		super
		@grid.dispose
	end

	def update

		super

		@grid.update	

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close_now
		end

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end
		
	end

	def choose(option)

		if option == "Continue"
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close_now
		elsif option == "Save"
			$scene.savequit = true
			$scene.queue_menu("Save")
		elsif option == "Quit"
			$game.quit
		end

		$menu.char_cursor = option
		@grid.selected_box.flash_heavy
		self.close_soon

	end

	def close
		super

		@grid.hide_glow

		# Fade and hide grid
		dist = 30
		@grid.all.each{ |b|
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
	end

end"‰#==============================================================================
# ** Mnu_Save
#==============================================================================

class Mnu_Save < Mnu_Base

	def initialize(vp)
		super(vp)

		@load = false

		@title.change('save')
		@subtitle.text = "Choose a file to save!"

		#@tabs.push("recent") # Could keep 10 auto saves?
		#@tabs.push("saves")
		#@tabs.push("autos") # Could keep 10 auto saves?

		# Saves can be named somehow
		# Grid pops up, "replace", "rename"?

		@menu.list.type = :file
		@menu.list.setup($files.save_file_list)
		@menu.list.down_one

		@page = Right_Page.new(vp)
		@right.push(@page)

		ids = ['boy','ing','mys','rob','hib','row','phy']

		@chars = []
		cx = 350
		ids.each{ |c|
			spr = Sprite.new(vp)

			spr.bitmap = $cache.character('Player/'+c)
			spr.src_rect = Rect.new(0,0,32,48)
			spr.x = cx
			spr.y = 252
			cx += 33

			@chars.push(spr)
			@right.push(spr)
		}

		@levels = []
		cx = 350
		ids.each_index{ |c|

			lbl = Label.new(vp)
			lbl.fixed_width = 30
			lbl.font = $fonts.save_tiny
			lbl.align = 1
			lbl.text = 23

			lbl.x = cx
			lbl.y = 295
			cx += 33

			@levels.push(lbl)
			@right.push(lbl)
		}

		@pic = Sprite.new(vp)		
		@pic.move(340,324)
		@right.push(@pic)

		open

		change(0)

	end

	def loadmode
		@title.change('load')
		@load = true
		@menu.list.up_one
	end

	def update

		# If anim in done, change state
		if $input.cancel? || $input.rclick?
			$scene.savequit = false
			close_now
			$scene.queue_menu("Main")
		end

		super


	end

	def change(option)

		# Load up the header
		header = $files.headers[option]


		if header == nil

			@page.title("- Empty -","misc/dots")
			@pic.bitmap = nil

		else

			header[:quest] = "NONE" if !header.has_key?(:quest)
			#header[:location] = "NONE"

			if header[:time].is_a?(String)
				time = header[:time]
			else
				time = build_time_string(header[:time])
			end

			@page.title("Save #{option} - #{time}","faces/#{header[:leader]}")

			# Find most recent main quest
			@page.descript("\""+header[:quest]+"\"")

			# Hide party members that don't exist
			chars = ['boy','ing','mys','rob','hib','row','phy']
			chars.each_index{ |c|
				if header.has_key?(:chars) && header[:chars].include?(chars[c])
					@chars[c].show
					@levels[c].text = header[:levels][c]
				else
					@chars[c].hide
					@levels[c].text = ''
				end
			}

		  begin
            @pic.bitmap = Bitmap.new("#{$appdata}//Av4-#{option}.png")
          rescue
          	@pic.bitmap = Bitmap.new(1,1)
          end 			

		end

	end

	def select(option)	

		#log_info(option)
		if @load
			if $files.save_exists?(option)
				$files.load_game(option)
			else
				sys('deny')
			end
		else
			if option == 0
				log_err("CAN'T OVERSAVE AUTOSAVE")
				return
			end
			$files.save_game(option)
			$scene.queue_menu(nil)
			close_soon
		end
		
	end
end"¬#==============================================================================
# ** Mnu_Shop
#==============================================================================

class Mnu_Shop < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Smith')
		@subtitle.text = "Armors and Weapons"

		#@tabs.change = Proc.new{ |tab| self.change_tab(tab) }

		@magic = false
		@tab = ''

		@menu.list.type = :shop
		@menu.list.setup($menu.shop)

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,250)
		self.right.push(@item_box)

		# Extra info grid
		@users = Ui_Grid.new(vp)
		@users.move(@item_box.x,@item_box.y + @item_box.height + 3)
		@users.disable
		# #@grid.hide
		self.right.push(@users)

		#change_tab("Items")
		change($menu.shop[0])

	end

	def setup(type)
		@title.change(type)
		case type
			when "Shop"
				@subtitle.text = "General Goods"
			when "Smith"
				@subtitle.text = "Armors and Weapons"
			when "Magic"
				@subtitle.text = "Enchantments"
			when "Chester"
				@magic = true
				@subtitle.text = "Learn Skills and Abilities"
				@menu.list.type = :chester
				@menu.list.refresh
				@item_box.type = :skill
				change($menu.shop[0])
		end
	end

	def sellmode
		@sellmode = true

		@menu.list.type = :sell

		# Show tabs
		@subtitle.hide
		@tabs.change = Proc.new{ |tab| self.change_tab(tab) }

		#@tabs.push("all")
		@tabs.push("usable")
		@tabs.push("gear")

		# Put all sellable items?
		change_tab("usable")



	end

	def update
		super
		
	end

	def change(option)

		#@info.title.text = option
		@item_box.item(option)
		@item_box.center(472,260)

		#@item_box.center(462,130+@menu.list.page_idx*@menu.list.item_height)
		@users.all.each{ |i| $tweens.clear(i) }
		@users.clear
		@users.move(@item_box.x,@item_box.y + @item_box.height)
		
		# Only if gear
		#

		data = $data.items[option]
		if data.is_a?(GearData)
			@users.add_users(option)
			#$party.all_battlers.select{ |b| b.slots.include?(data.slot) }.each{ |u|
			#	@users.add_compare(option,u)
			#}
		end

		if !@magic
			@users.clear
			@users.move(@item_box.x,@item_box.y + @item_box.height)
			@users.add_stock(option)
		end	

		if @last_option != option
			@last_option = option

			$tweens.clear(@item_box)

			@item_box.y -= 7
			@item_box.do(go("y",7,150,:qio))

			@users.all.each{ |i|
				next if i.disposed?
				$tweens.clear(i)
				i.y -= 7
				i.do(go("y",7,150,:qio))
			}

		end

	end

	def select(option)			

		if @magic

			item = $data.skills[option]

			if $party.magics >= item.price
				buy_chester_skill(option)
				$party.add_magics(-item.price)
				sys("magics")
				@info.refresh
				@menu.list.refresh
				close_soon
			else
				sys("deny")
			end

		else

			item = $data.items[option]

			if @sellmode

				# Buy
				$party.add_item(option,-1)
				$party.add_gold(item.price/2)
				sys('coins')
				@info.refresh
				@menu.list.refresh
				change_tab(@tab)

			else

				# Buy

				if $party.gold >= item.price
					$party.add_item(option)
					$party.add_gold(-item.price)
					sys("coins")
					@info.refresh
					@menu.list.refresh
				else
					sys("deny")
				end

			end

		end
	end

	def change_tab(tab)

		page_idx = @menu.list.page_idx

		# Change list to certain items only
		# This is for selling
		list = []
		$party.items.keys.each{ |item|
			next if $data.items[item].price == ''
			next if $data.items[item].tab != tab
			list.push(item) 
		}
		@menu.list.setup(list)

		if tab == @tab
			@menu.list.set_idx(page_idx,0)
		end
		@tab = tab

		change(list[@menu.list.idx])

	end

end"x#==============================================================================
# ** Mnu_Equip
#==============================================================================

class Mnu_Equip < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Equip')
		@title.icon($menu.char)

		@char = $party.get($menu.char)

		@subtitle.text = "Master of deception"

		@menu.opacity = 0
		@menu.move(15,192)
		#@menu.opacity = 0
		
		@menu.list.per_page = 7
		@menu.window.height -= 34
		@menu.list.active = false

		#@info.hide
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(15,115)
		 @char.slots.each{ |slot| 
		 	@grid.add_slot(slot,@char.equips[slot])
		 }
		self.left.push(@grid)


		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,290)
		@item_box.hide
		#self.right.push(@item_box)

		# Party grid hahahha
		@users = Ui_Grid.new(vp)
		@users.move(@item_box.x,@item_box.y + @item_box.height + 3)
		#@grid.add_compare('mid-arm-windshire')
		@users.disable
		#@grid.hide
		self.right.push(@users)

		@info.dispose
		self.left.delete(@info)

		# Selected slot
		@slot = nil

		dist = 30
		@grid.all.each{ |b|
			b.x -= dist
			b.opacity = 0
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}

		open

	end

	def dispose
		super
		@menu.dispose
	end

	def update		

		return if @closing

		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Equip")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Equip")
			close_soon(0)
		end

		@menu.update if @menu.list.active
		@grid.update if !@menu.list.active

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			cancel
		end
		
		super

	end

	# Grid
	def choose(option)

		if @char.id == 'mys' && !flag?('mys-can-equip')
			sys('deny')
			return
		end


		@slot = option

		# Rebuild the grid
		@grid.clear
		@grid.move(15,115)
		@grid.add_slot(@slot,@char.equips[@slot])

		@grid.disable

		# Populate the list

		# Find gear for this slot
		items = $party.items.keys.select{ |i|
			$data.items[i].is_a?(GearData) && $data.items[i].slot == @slot.delete('12')
		}
		items.push('remove') if @char.equips[@slot] != nil
		@menu.list.setup(items)

		# Bring in the list
		@menu.opacity = 0
		@menu.move(15,192)

		dur = 200
		dist = 30

		@menu.do(go("opacity",255,dur,:qio))
		@menu.x -= dist
		@menu.do(go("x",dist,dur,:qio))

		@menu.list.active = true

		@item_box.show
		change(items[0])

	end

	# Equip List
	def change(option)

		gear = option
		gear = nil if option == 'remove'

		# Change the item box to show this
		if option != 'remove'
			@item_box.item(option)
			@item_box.show
		else
			@item_box.hide			
		end

		# Get comparison
		result = @char.equip_result_mega(gear,@slot)
		stats = ['hp','mp','str','def','luk','eva','res']

		@users.clear
		@users.move(@item_box.x,@item_box.y + @item_box.height)
		(0..6).each{ |i|
			if result[2][i] != 0
				@users.add_compare(stats[i],result[0][i],result[1][i],result[2][i])			
			end
		}

		if @slot != 'minion'
			if result[2] == [0,0,0,0,0,0,0]
				@users.add_nochange
			end
		end
		
		
	end

	def select(option)	

		gear = option
		gear = nil if option == 'remove'

		# Replace the gear in the slot
		sys('equip2')
		@char.equip(@slot,gear)
		back_to_slots
		
	end

	 def cancel
	 	if @grid.active
	 		$scene.queue_menu("Char")
	 		$tweens.clear(@menu)
	 		#close_now
	 		start_close
	 	else
	 		back_to_slots
	 	end
	end

	def back_to_slots

		@menu.list.active = false

		dur = 200
		dist = 30

		@menu.do(go("opacity",-255,dur,:qio))
		@menu.do(go("x",-dist,dur,:qio))

		@grid.enable
		@grid.clear
		@grid.move(15,115)
		 @char.slots.each{ |slot| 
		 	@grid.add_slot(slot,@char.equips[slot])
		 }

		 @grid.choose(@slot,true)

		 @item_box.hide
		 @users.clear

	end

	def start_close
		

		dist = 30
		@grid.hide_glow
		@grid.all.each{ |b|
			next if b.disposed?
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
		close_soon(0)

		#super

	end

end"/#==============================================================================
# ** Mnu_Profile
#==============================================================================

class Mnu_Profile < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Profile')
		@title.icon($menu.char)
		@subtitle.text = "Master of deception"

		@char = $party.get($menu.char)
		profile = $data.profiles[$menu.char]

		remove_menu
		remove_info

		@box = Box.new(vp,350,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		spacing = 28
		
		data = []
		data.push(["faces/boy","Name: #{profile.name}"])
		data.push(["faces/boy","Home: #{profile.home}"])
		data.push(["faces/boy","Age: #{profile.age}"])
		data.push(["faces/boy","Biography:"])

		cx = 26
		cy = 125

		# Name
		lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon("faces/#{$menu.char}")
	    lbl.text = "Name: #{profile.name}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    # Age
	    lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon('misc/cooldown')
	    lbl.text = "Age: #{profile.age}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    # Home
	    lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon('misc/home')
	    lbl.text = "Home: #{profile.home}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    # Bio
	    lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon('misc/bio')
	    lbl.text = "Biography"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    area = Area.new(vp)
	    area.fixed_width = 310
    	area.font = $fonts.pop_text
    	area.text = profile.bio
    	area.move(cx+4,cy)
    	self.left.push(area)

    	cy += area.height - 2

    	# Hint
	    lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon('misc/credits')
	    lbl.text = "Tip"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    area = Area.new(vp)
	    area.fixed_width = 310
    	area.font = $fonts.pop_text
    	area.text = profile.tip
    	area.move(cx+4,cy)
    	self.left.push(area)

    	cy += area.height - 2

    	# Fact
	    lbl = Label.new(vp)
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.icon = $cache.icon('misc/fact')
	    lbl.text = "Fun Fact"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += spacing

	    area = Area.new(vp)
	    area.fixed_width = 310
    	area.font = $fonts.pop_text
    	area.text = profile.fact
    	area.move(cx+4,cy)
    	self.left.push(area)


		@port = Port_Full.new(vp)
		@port.happy
		self.right.push(@port)

		open

	end

	def update

		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Profile")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Profile")
			close_soon(0)
		end
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end".#==============================================================================
# ** Mnu_Skills
#==============================================================================

class Mnu_Skills < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Skills')
		@title.icon($menu.char)

		@subtitle.text = "Master of deception"

		@menu.list.type = :skill
		@menu.list.user = $menu.char
		@menu.list.setup($party.get($menu.char).all_skill_list)

		@port = Port_Full.new(vp)
		@port.angry
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.type = :skill
		@item_box.hide
		self.right.push(@item_box)

		@last_option = nil

		open

	end

	def update
		
		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Skills")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Skills")
			close_soon(0)
		end
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end

		super

	end

	def change(option)

		@item_box.skill(option)
		@item_box.center(472,260)#+@menu.list.page_idx*@menu.list.row_height)
		
		if @last_option != option
			@last_option = option
			$tweens.clear(@item_box)
			@item_box.y -= 7
			@item_box.do(go("y",7,150,:qio))
		end

	end

	def select(option)	
		
	end

end"ÿ#==============================================================================
# ** Mnu_Status
#==============================================================================

class Mnu_Status < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Status')
		@title.icon($menu.char)
		@subtitle.text = "Master of deception"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		cx = 28
		cy = 124

		lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/level")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Overall"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/level")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Level: #{@char.level}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 26

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/xp")
	    lbl.font = $fonts.pop_text
	    lbl.text = "XP: #{@char.xp} of #{@char.next_exp}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)
		
		cx = 28
		cy += 28

		lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/primary")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Primary Stats"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/heal")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Max HP: #{@char.maxhp}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	   	cy += 26

	   	# Only show mana for mana users
	   	if ['boy','ing','hib','phy'].include?(@char.id)
		   	
		   	lbl = Label.new(vp)
		   	if @char.id == 'boy'
				lbl.icon = $cache.icon("stats/darkness")
				type = "DP"
			elsif @char.id == 'phy'
				lbl.icon = $cache.icon("stats/rage")
				type = "RP"
			else
				lbl.icon = $cache.icon("stats/mana")
				type = "MP"
			end
		    lbl.font = $fonts.pop_text
		    lbl.text = "Max #{type}: #{@char.maxmp}"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		   	cy += 26

	    end 

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/str")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Strength: #{@char.str}  (#{@char.stat_pure('str')} + #{@char.stat_gear('str')})"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	   	cy += 26

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/def")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Defense: #{@char.def}  (#{@char.stat_pure('def')} + #{@char.stat_gear('def')})"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 28
		cy += 28

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/secondary")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Secondary Stats"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/luck")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Luck: #{@char.luk}%"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += 26

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/eva")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Evasion: #{@char.eva}%"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cy += 26

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/res")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Resist: #{@char.res}%"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def update

		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Status")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Status")
			close_soon(0)
		end
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end"q#==============================================================================
# ** Mnu_Boyle
#==============================================================================

class Mnu_Boyle < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Status')
		@title.icon($menu.char)
		@subtitle.text = "Gotta catch em"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		src = ["wyrmwood",'windshire','wasteland','royal','elvaria','shadow','other']
		names = ["Wyrmwood","Windshire","Wasteland","Royal","Elvaria","Shadow Isles","Ocean and Islands"]
		totals = [30,30,30,30,30,30,30]

		cx = 28
		cy = 123

		[0,1,2,3,4,5,6].each { |i|

			next if !$progress.creatures.has_key?(src[i])

			lbl = Label.new(vp)
			lbl.icon = $cache.icon("misc/zone-#{src[i]}")
		    lbl.font = $fonts.list
		    lbl.shadow = $fonts.list_shadow
		    lbl.text = names[i]
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 44
		    cy += 25

		    found = $progress.creatures[src[i]]

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("stats/creature")
		    lbl.font = $fonts.pop_text
		    if $party.passive_cheekis
		    	lbl.text = "#{found} of #{totals[i]} Caught"
		    else
		    	lbl.text = "#{found} Caught"
		    end
		    lbl.move(cx,cy)
		    self.left.push(lbl)



	    cx = 28
		cy += 22

			}

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def update
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end" "P#==============================================================================
# ** Mnu_Ingrid
#==============================================================================

class Mnu_Ingrid < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Status')
		@title.icon($menu.char)
		@subtitle.text = "The Witching Hour"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		spacing = 28

		# Potion making

		cx = 28
		cy = 126

		lbl = Label.new(vp)
		lbl.icon = $cache.icon("misc/potions")
	    lbl.font = $fonts.list
	    lbl.shadow = $fonts.list_shadow
	    lbl.text = "Potion Brewing"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += 30

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("stats/level")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Recipes Known: #{@char.level}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    cx = 34
	    cy += spacing

	    lbl = Label.new(vp)
		lbl.icon = $cache.icon("items/potion-blue")
	    lbl.font = $fonts.pop_text
	    lbl.text = "Potions Made: #{@char.level}"
	    lbl.move(cx,cy)
	    self.left.push(lbl)

	    # Guild

	    cx = 28
		cy += 32

		# In a guild
		if $progress.guild_id != nil

			lbl = Label.new(vp)
			lbl.icon = $cache.icon("items/witch-hat")
		    lbl.font = $fonts.list
		    lbl.shadow = $fonts.list_shadow
		    lbl.text = "Witch Coven"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 34
		    cy += 30

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("stats/level")
		    lbl.font = $fonts.pop_text
		    lbl.text = "Coven In: Potioneers"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		   	cx = 34
		    cy += spacing

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("stats/level")
		    lbl.font = $fonts.pop_text
		    lbl.text = "Guild Level: #{@char.level}"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 28
			cy += 32

		end

	    # Attraction
	    if $progress.attract_boy > 0

			lbl = Label.new(vp)
			lbl.icon = $cache.icon("misc/attract-get")
		    lbl.font = $fonts.list
		    lbl.shadow = $fonts.list_shadow
		    lbl.text = "Attraction"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 34
		    cy += 30

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("faces/boy")
		    lbl.font = $fonts.pop_text
		    lbl.text = "Boyle: #{$progress.attract_boy}"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 34
	    	cy += spacing

		end

		# Hi'beru joined
		if flag?('ch5-dream-healing-complete')

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("faces/hib")
		    lbl.font = $fonts.pop_text
		    lbl.text = "Hi'beru: #{$progress.attract_hib}"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 34
		    cy += spacing

		end

		# Phye joined
		if flag?('ulrock-phye-in-party')

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("faces/phy")
		    lbl.font = $fonts.pop_text
		    lbl.text = "Phye: #{$progress.attract_phy}"
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		end

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def update
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end"‰#==============================================================================
# ** Mnu_Nightwatch
#==============================================================================

class Mnu_Nightwatch < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Status')
		@title.icon($menu.char)
		@subtitle.text = "Master of deception"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		src = ['mouse','cat','rabbit','racoon','squirrel']
		titles = ['Midnight Mouse','Creeping Cat','Racing Rabbit','Rascal Racoon','Militant Squirrel']

		cx = 28
		cy = 126

		(0..$progress.night_rank-1).each{ |i|

			lbl = Label.new(vp)
			lbl.icon = $cache.icon("misc/nw-#{src[i]}")
		    lbl.font = $fonts.list
		    lbl.shadow = $fonts.list_shadow
		    lbl.text = titles[i]
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 44
			cy += 28

		    lbl = Label.new(vp)
			lbl.icon = $cache.icon("stats/xp")
		    lbl.font = $fonts.pop_text
		    if i == $progress.night_rank-1
		    	lbl.text = "Progress: #{$progress.night_xp % 100}%"
		    else
				lbl.text = "Progress: 100%"
		    end
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 28
			cy += 28

		}

		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def update
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end"ä#==============================================================================
# ** Mnu_Phye
#==============================================================================

class Mnu_Phye < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('Status')
		@title.icon($menu.char)
		@subtitle.text = "Master of deception"

		@char = $party.get($menu.char)

		remove_menu
		remove_info

		@box = Box.new(vp,300,350)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper("diamonds")
		@box.move(15,115)
		self.left.push(@box)

		src = ['arinya','kubaba','baal','crystalis','icetooth']
		titles = ['Arinya','Kubaba','Baal the Brute','Crystalis','Icetooth']

		cx = 28
		cy = 128

		(0..4).each{ |i|

			lbl = Label.new(vp)
			lbl.icon = $cache.icon("misc/phy-#{src[i]}")
		    lbl.font = $fonts.list
		    lbl.shadow = $fonts.list_shadow
		    lbl.text = titles[i]
		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 44
			cy += 28

		    lbl = Label.new(vp)
			lbl.font = $fonts.pop_text
		    if !$progress.demons.include?(src[i])
		    	lbl.icon = $cache.icon("stats/phy-not")
		    	lbl.text = "Status: At Large"
		    else
		    	lbl.icon = $cache.icon("stats/phy-done")
				lbl.text = "Status: Decimated"
		    end

		    lbl.move(cx,cy)
		    self.left.push(lbl)

		    cx = 28
			cy += 26

		}

		# The swords!
		swords = Sprite.new(vp)
		swords.bitmap = $cache.menu_common("phy-sword-#{$progress.demons.count}")
		swords.move(45,415)
		self.left.push(swords)


		@port = Port_Full.new(vp)
		self.right.push(@port)

		open

	end

	def update
		
		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			$scene.queue_menu("Char")
			close_now
		end
		
		super
		
	end

end" "°

class Char_Box_Large < SpriteGroup

	attr_accessor :box

	def initialize(vp,char)

		super()

		@char = $party.get(char)

		@box = Box.new(vp,205,168)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper(char)
		add(@box)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_large(char)
		#@port.src_rect.width = 155
		add(@port,205-@port.width-9,168-@port.height-8)
		@port.z += 50

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient")
		@gradient.opacity = 160
		add(@gradient,9,100)
		@gradient.z += 50

		@name = Sprite.new(vp)
	    @name.bitmap = $cache.menu_char(char)
	    add(@name,11,12)
	    @name.z += 50
	    #@name.opacity = 100

		@lvl_label = Sprite.new(vp)
		@lvl_label.bitmap = $cache.menu_char("label-lv")
		@lvl_label.opacity = 200
		add(@lvl_label,20,41)
		@lvl_label.z += 50

		@lvl_value = Sprite.new(vp)
		@lvl_value.bitmap = build_value_bmp(@char.level)
		@lvl_value.opacity = 200
		add(@lvl_value,40,40)
		@lvl_value.z += 50


		@mp_bar = Bar.new(vp,180,9)
		add(@mp_bar,11,112)
		@mp_bar.opacity = 180
		@mp_bar.for(:mp)
		@mp_bar.value = @char.mp
		@mp_bar.max = @char.maxmp
		@mp_bar.z += 50

		@mp_label = Sprite.new(vp)
		@mp_label.bitmap = $cache.menu_char("label-mp")
		@mp_label.opacity = 200
		add(@mp_label,12,105)
		@mp_label.z += 50

		@mp_value = Sprite.new(vp)
		@mp_value.bitmap = build_value_bmp(@char.mp)
		@mp_value.opacity = 200
		add(@mp_value,186-@mp_value.bitmap.width,105)
		@mp_value.z += 50

		case char
			when 'boy'
				@mp_label.bitmap = $cache.menu_char("label-sp")
				@mp_bar.for(char)
			when 'ing'
				@mp_bar.for(char)
			when 'phy'
				@mp_label.bitmap = $cache.menu_char("label-rp")
				@mp_bar.for(char)
			else
				@mp_bar.hide
				@mp_label.hide
				@mp_value.hide
		end


		@hp_bar = Bar.new(vp,180,9)
		add(@hp_bar,11,130)
		@hp_bar.opacity = 180
		@hp_bar.value = @char.hp
		@hp_bar.max = @char.maxhp
		@hp_bar.for(:hp)
		@hp_bar.z += 50

		@hp_label = Sprite.new(vp)
		@hp_label.bitmap = $cache.menu_char("label-hp")
		@hp_label.opacity = 200
		add(@hp_label,12,123)
		@hp_label.z += 50

		@hp_value = Sprite.new(vp)
		@hp_value.bitmap = build_value_bmp(@char.hp)
		@hp_value.opacity = 200
		add(@hp_value,186-@hp_value.bitmap.width,123)
		@hp_value.z += 50

		@xp_bar = Bar.new(vp,180,9)
		add(@xp_bar,11,148)
		@xp_bar.opacity = 180
		@xp_bar.value = @char.xp
		@xp_bar.max = @char.next_exp
		@xp_bar.for(:xp)
		@xp_bar.z += 50

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-xp")
		@xp_label.opacity = 200
		add(@xp_label,12,141)
		@xp_label.z += 50

		@xp_value = Sprite.new(vp)
		@xp_value.bitmap = build_value_bmp(@char.xp)
		@xp_value.opacity = 200
		add(@xp_value,186-@xp_value.bitmap.width,141)
		@xp_value.z += 50

	end

	def dispose
		@box.dispose
		@gradient.dispose
		@port.dispose
	end

	def update
		@box.update
	end

	def choose()

	end

	def select
		#$tweens.clear(self)
		@port.do(go("oy",6,100,:qio))
		@box.flash_light
	end

	def deselect
		#$tweens.clear(self)
		@port.do(to("oy",0,-2))
	end

end":

class Char_Box_Small < SpriteGroup

	attr_accessor :box

	def initialize(vp,char)

		super()

		@char = $party.get(char)

		@box = Box.new(vp,132,87)
		@box.skin = $cache.menu_common("skin")
		@box.wallpaper = $cache.menu_wallpaper(char)
		add(@box)

		@port = Sprite.new(vp)
		@port.bitmap = $cache.face_small(char)
		add(@port,123-@port.width,80-@port.height)
		@port.z += 50

		@gradient = Sprite.new(vp)
		@gradient.bitmap = $cache.menu_common("charbox-gradient-small")
		#@gradient.opacity = 10
		add(@gradient,7,46)
		@gradient.z += 50

		@name = Sprite.new(vp)
	    @name.bitmap = $cache.menu_char(char+'-s')
	    add(@name,10,9)
	    @name.z += 50

		@lvl_label = Sprite.new(vp)
		@lvl_label.bitmap = $cache.menu_char("label-lv")
		@lvl_label.opacity = 200
		add(@lvl_label,18,31)
		@lvl_label.z += 50

		@lvl_value = Sprite.new(vp)
		@lvl_value.bitmap = build_value_bmp(@char.level)
		@lvl_value.opacity = 200
		add(@lvl_value,38,30)
		@lvl_value.z += 50


		@xp_bar = Bar.new(vp,106,8)
		add(@xp_bar,11,64)
		@xp_bar.opacity = 180
		@xp_bar.value = @char.xp
		@xp_bar.max = @char.next_exp
		@xp_bar.for(:xp)
		@xp_bar.z += 50

		@xp_label = Sprite.new(vp)
		@xp_label.bitmap = $cache.menu_char("label-xp")
		@xp_label.opacity = 200
		add(@xp_label,12,56)
		@xp_label.z += 50

		@xp_value = Sprite.new(vp)
		@xp_value.bitmap = build_value_bmp(@char.xp)
		@xp_value.opacity = 200
		add(@xp_value,186-@xp_value.bitmap.width,141)
		@xp_value.z += 50

	end

	def dispose
		@box.dispose
		#@gradient.dispose
		#@port.dispose
	end

	def update
		@box.update
	end

	def setup(char)

	end

	def select
		#$tweens.clear(self)
		@port.do(go("oy",3,100,:qio))
		@box.flash_light
	end

	def deselect
		#$tweens.clear(self)
		@port.do(to("oy",0,-1))
	end

end"5
class Info_Box < SpriteGroup

	attr_accessor :title

	def initialize(vp)
		super()		

		@window = Box.new(vp,190,56)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@gold = Label.new(vp)
    	@gold.font = $fonts.pop_text
    	@gold.icon = $cache.icon("misc/coins")
    	@gold.text = "#{$party.gold}G"
    	add(@gold,12,15)

    	@magics = Label.new(vp)
    	@magics.font = $fonts.pop_text
    	@magics.icon = $cache.icon("misc/magics")
    	@magics.text = "#{$party.magics}"
    	add(@magics,100,15)

    	# @zone = Label.new(vp)
    	# @zone.font = $fonts.pop_text
    	# @zone.icon = $cache.icon("items/map")
    	# @zone.text = "Whisper Woods"
    	# add(@zone,100,15)
    	
    	move(15,416)

	end

	def dispose
		@window.dispose
		@gold.dispose
		@magics.dispose
		#@zone.dispose
	end

	def update
		@window.update
	end

    def refresh
        @gold.text = "#{$party.gold}G"
        @magics.text = "#{$party.magics}"
    end

end
" 
class Item_Box < SpriteGroup

	attr_accessor :title
    attr_accessor :type

	def initialize(vp)
		super()		

        @vp = vp
        @type = :item

		# Resize to whatever is needed
		@window = Box.new(vp,300,120)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.wallpaper = $cache.menu_wallpaper("diamonds")
    	add(@window)

    	@title = Label.new(vp)
    	@title.fixed_width = 250
    	@title.icon = $cache.icon("items/map")
    	@title.font = $fonts.pop_ttl
    	@title.text = "Active Quests:"
    	add(@title,16,10)

    	# @cat = Label.new(vp)
    	# @cat.fixed_width = 250
    	# @cat.font = $fonts.pop_type
    	# @cat.align = 0
    	# @cat.text = "POTION"
    	# add(@cat,226,13)

        @price = Label.new(vp)
        @price.fixed_width = 250
        @price.icon = $cache.icon("misc/coins")
        @price.font = $fonts.pop_type
        @price.align = 0
        @price.text = "256"
        add(@price,226,13)
        @price.hide


    	@desc = Area.new(vp)
    	@desc.font = $fonts.pop_text
    	@desc.text = "Missing Descriptor"
    	add(@desc,16,42)

        @stats = []
        @cy = 42    	
    	
    	move(0,0)

    	#item('unknown')

	end

    def show_price
        @price.show
    end

    def width
        return @window.width
    end

    def height
        return @window.height
    end


	def center(x,y)
		move(x-150,y-60)
	end

	def dispose

		self.sprites.each{ |s|
			s[0].dispose
		}

	end

	def update
		@window.update
	end

    def get_data(id)
        if @type == :item
          return $data.items[id]
        elsif @type == :skill
          return $data.skills[id]
        end
    end

    def base(data)

        #log_scr(data)
        return if data == nil

        # Set values
        @title.text = data.name
        @title.icon = $cache.icon(data.icon)
        @desc.text = data.description

        @price.text = data.price

        @stats.each{ |s| 
            s.dispose
            delete(s)
            s.dispose 
        }
        @stats = []
        @cy = 42 + @desc.height 

    end

    def newsize
        @window.resize(300,64 + @desc.height + @stats.count*20)
    end

    def stat(icon,text)

        stat = Label.new(@vp)
        stat.fixed_width = 250
        stat.icon = $cache.icon("stats/#{icon}")
        stat.font = $fonts.pop_text
        stat.text = text
        @stats.push(stat)
        add(stat,36,@cy)
        @cy += 22

    end

    def gains(stats,user)

        stat = Label.new(@vp)
        stat.fixed_width = 250
        stat.icon = $cache.icon("stats/str")
        stat.font = $fonts.pop_text
        stat.text = text
        @stats.push(stat)
        add(stat,36,@cy)
        @cy += 22

         stats.split("\n").each{ |action|
            
            dta = action.split("=>")

            case dta[0]

                when "str"
                    stat.text = "#{user.name}: #{user.stat('str')} -> #{dta[1]}"

                when "def"
                    stat.text = "#{user.name}: #{user.stat('str')} -> #{dta[1]}"

            end

        }

    end

    def stats(list)

        list.split("\n").each{ |action|
            
            dta = action.split("=>")

            case dta[0]

                when "heal"
                    stat("heal","Heal #{dta[1]} HP")
                when "heal-p"
                    stat("heal","Heal #{(dta[1].to_f*100).to_i}% HP")

                when "mana"
                    stat("mana","Restore #{dta[1]} MP")
                when "mana-p"
                    stat("mana","Restore #{(dta[1].to_f*100).to_i}% MP")

                when "revive"
                    stat("revive","Revive party member")

                when "str"
                    stat("str","#{dta[1]} Strength")

                when "def"
                    stat("def","#{dta[1]} Defense")

                when "luk"
                    stat("luk","#{dta[1]} Luck")

                when "eva"
                    stat("eva","#{dta[1]} Evasion")

                when "res"
                    stat("res","#{dta[1]} Resist")

            end
            #return if data == nil
            #stat("targets","Hit ALL")

        }

    end

    def mods(list)

        list.split("\n").each{ |action|
            
            dta = action.split("=>")

            case dta[0]

                when "hp"
                    stat("hp","#{(dta[1].to_f-1.0)*100}% Health")

                when "str"
                    stat("str","#{(dta[1].to_f-1.0)*100}% Strength")

                when "def"
                    stat("def","#{(dta[1].to_f-1.0)*100}% Defense")

            end

        }

    end

    # Shop display of items
	def item(id)

        return skill(id) if @type == :skill

        id = 'mid-arm-windshire' if id == "unknown"
        #log_sys(id)

        data = get_data(id)       
        base(data)

        if data.is_a?(GearData)
            stats(data.stats)
            mods(data.mods)
            #gains(data.stats,$party.get('boy'))
        elsif data.is_a?(KeyItemData)
            # Draw secret ingredient
            if id.include?('recipe-') || id.include?('potion-')                
                potion = id.sub('recipe-','')
                potion = potion.sub('potion-','')
                ing = $data.potions[potion].ingredient
                stat('phy-not',$data.items[ing].name)
            end
        elsif data.is_a?(UsableData)
            stats(data.action)
        elsif data.is_a?(SkillData)

        elsif data.is_a?(ShopData)

        end
		
		#@type.text = item.type

        newsize
        remove

	end

    # # Equip display of items
    # def equip(id)

    #     data = get_data(id)       
    #     base(data)

    #     stats(data.stats)

    #     # Now draw the comparison
    #     #stat("heal","Change 10 -> 15")
        
    #     #@type.text = item.type

    #     newsize
    #     remove

    # end

    # Battle display of skills, maybe different to menu display
	def skill(id)

        data = get_data(id)  

        return if data == nil

        base(data)

        if data.hits != 1
            stat("targets","Hits #{data.hits} Times")
        end

        case data.scope
            when 'rand'
                stat("targets","Targets a Random Enemy")
            when 'two'
                stat("targets","Targets 2 Enemies")
            when 'three'
                stat("targets","Targets 3 Enemies")
            when 'all'
                stat("targets","Targets All Enemies")
            when 'party'
                stat("targets","Targets All Allies")
        end

        newsize
        remove

	end

    def gear(id)

    end

end"A
class List_Common < SpriteGroup

	attr_accessor :list, :window

	def initialize(vp)
		super()

		# Left side window
		@window = Box.new(vp,300,292)
    	@window.skin = $cache.menu_common("skin-plain")
    	@window.color = Color.new(47,45,41)
    	add(@window)
    	
		# Left side list
		@list = List.new()

		@list.per_page = 8
		@list.item_width = 288
		@list.item_height = 34

		@list.item_space = 1
		add(@list,6,6)

		move(15,116)
		@list.refresh

	end

	def dispose
		@window.dispose
		@list.dispose
	end

	def update
		@list.update
	end

	def hide
		move(-1000,-1000)
	end

	# All the various data that can be shown
	def setup_items(category)
		case category

			when 'all'
				items = $party.items.keys.select{ |i|
					$data.items[i].is_a?(UsableData) # &&
				}

			when 'cards'
				items = $party.items.keys.select{ |i|
					$data.items[i].id.include?('card-')
				}
				

			when 'goods'
				items = $party.items.keys.select{ |i|
					$data.items[i].is_a?(ShopData) # &&
				}

			when 'usable'
				items = $party.items.keys.select{ |i|
					$data.items[i].is_a?(UsableData) # &&
				}

			else
				items = $party.items.keys.select{ |i|
					$data.items[i].is_a?(KeyItemData) # &&
				}

		end
		@list.setup(items)
	end

	def setup_gear(slot)

	end

end"0	#==============================================================================
# Tabs
#==============================================================================

class Page_Tabs < Sprite

  SPACING = 0

  attr_accessor :change

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize(vp)
    super(vp)

  	#@parent = nil
    @names = []
  	@gfx = []
    @gfx_on = []

    @ranges = []

  	@idx = 0

    @total_width = 0

    # Proc
    @change = nil

    move(116,75)

  end

  def push(name)
    @names.push(name)
    @gfx.push($cache.menu_tab(name))
    @gfx_on.push($cache.menu_tab(name+"-on"))
    refresh
  end

  def refresh

    return if @gfx.empty?

    # Calc width
    width = @gfx.inject(0){ |t,b| t += b.width + SPACING } - SPACING
    height = @gfx[0].height#@gfx.max_by{ |b| b.height }

    self.bitmap = Bitmap.new(width,height)

    @ranges = []

    # Draw the tabs
    cx = 0
    idx = 0
    @gfx.each{ |b|
      src = b
      src = @gfx_on[idx] if idx == @idx
      self.bitmap.blt(cx,0,src,src.rect)
      @ranges.push([cx,cx+b.width])
      cx += b.width + SPACING
      idx += 1
    }

    @total_width = cx

  end

  def update

    return if @names.empty?

  	# Check inputs and that
  	if $input.right?
      @idx += 1
      if @idx > @names.count - 1
        @idx = @names.count - 1
        return
      end
      change_tab
      refresh      
  	end

  	if $input.left? #&& @dynamo.done?
      @idx -= 1
      if @idx < 0
        @idx = 0
        return
      end
      change_tab
      refresh  
  	end

    pos = $mouse.position.dup

    #return if pos[0] > @total_width
    return if pos[0] < self.x

    pos[0] -= self.x



    # Check mouseover
    @ranges.each_index{ |i|

      next if i == @idx

      range = @ranges[i]

      next if pos[1] < self.y
      next if pos[1] > self.y + 20

      next if pos[0] < range[0]
      next if pos[0] > range[1]

      if $input.click?

        @idx = i
        change_tab
        refresh  

      end
      
    }

  end

  def change_tab
    sys('tab')
    @change.call(@names[@idx]) if @change
  end

 end"x
class Page_Title < SpriteGroup

	def initialize(vp)
		super()

		@web = Sprite.new(vp)
		@web.bitmap = $cache.menu_common("webber")
		add(@web,-40,-50)

		@icon = Sprite.new(vp)
		@icon.bitmap = $cache.menu("Icons/journal")
		add(@icon,0,-5)

		@title = Sprite.new(vp)
		@title.bitmap = $cache.menu("Titles/journal")
		add(@title,100,20)

		move(0,0)

	end

	def dispose
		@sprites.each{ |s| s[0].dispose }
	end

	def change(page)
		@icon.bitmap = $cache.menu("Icons/"+page)
		@title.bitmap = $cache.menu("Titles/"+page)
	end

	def icon(page)
		@icon.bitmap = $cache.menu("Icons/"+page)
	end

end"!#==============================================================================
# ** Part_Full
#==============================================================================

class Port_Full < Sprite

	def initialize(vp)
		super(vp)

		self.bitmap = $cache.face_menu("#{$menu.char}")
		self.x = 330

	end

	def normal() self.bitmap = $cache.face_menu("#{$menu.char}") end
	def shock() self.bitmap = $cache.face_menu("#{$menu.char}-w") end
	def sad() self.bitmap = $cache.face_menu("#{$menu.char}-s") end
	def happy() self.bitmap = $cache.face_menu("#{$menu.char}-h") end
	def angry() self.bitmap = $cache.face_menu("#{$menu.char}-a") end
	def confused() self.bitmap = $cache.face_menu("#{$menu.char}-c") end
	def xtra() self.bitmap = $cache.face_menu("#{$menu.char}-x") end

end"L
class Right_Journal < SpriteGroup

	def initialize(vp)
		super()
	
        # Right side journal
        @window = Box.new(vp,300,357)
        @window.skin = $cache.menu_common("skin-dry")
        @window.wallpaper = $cache.menu_wallpaper("journal-full-page")
        #@window.color = Color.new(47,45,41)
        add(@window,320,138)

    	# Quest Name
    	@page_title = Label.new(vp)
    	@page_title.fixed_width = 250
    	@page_title.font = $fonts.page_ttl
    	@page_title.text = "Board the Ferry"
    	add(@page_title,340,154)

    	# # SUBTEXTS!!!!!!!!!!

    	# cy = 180

    	# # ALWAYS DESCRIPTION

    	@txt_desc = Area.new(vp)
    	@txt_desc.fixed_width =  260
    	@txt_desc.font = $fonts.page_text
    	@txt_desc.text = "Rescue them guys in the briar woods"
    	add(@txt_desc,340,198)

    	# Subtitles ready for later
    	@sub_req = Sprite.new(vp)
    	@sub_req.bitmap = $cache.menu_page("reqs")
        add(@sub_req,340)

    	@sub_zone = Sprite.new(vp)
    	@sub_zone.bitmap = $cache.menu_page("location")
        add(@sub_zone,340)

    	# Text sprites

        @txt_req1 = Label.new(vp)
        @txt_req1.font = $fonts.page_text
        add(@txt_req1,340)

        @txt_req2 = Label.new(vp)
        @txt_req2.font = $fonts.page_text
        add(@txt_req2,340)

        @txt_req3 = Label.new(vp)
        @txt_req3.font = $fonts.page_text
        add(@txt_req3,340)

        @txt_req4 = Label.new(vp)
        @txt_req4.font = $fonts.page_text
        add(@txt_req4,340)

        @txt_req5 = Label.new(vp)
        @txt_req5.font = $fonts.page_text
        add(@txt_req5,340)

    	@txt_zone = Label.new(vp)
    	@txt_zone.font = $fonts.page_text
        add(@txt_zone,340)

    	# cy += 30

    	move(0,-22)

        clear

    end

    def dispose
        # Clear the extras!
        @window.dispose
        @page_title.dispose
        @txt_desc.dispose
        @sub_req.dispose
        @txt_req1.dispose
        @txt_req2.dispose
        @txt_req3.dispose
        @txt_req4.dispose
        @txt_req5.dispose
        @sub_zone.dispose
        @txt_zone.dispose
    end

    def title=(text)
        @page_title.text = text
    end

    def description=(text)
        @txt_desc.text = text
        @cy = @txt_desc.y + @txt_desc.height
    end

    def clear

    	# Clear the extras!
    	@sub_req.hide
    	@txt_req1.hide
        @txt_req2.hide
        @txt_req3.hide
        @txt_req4.hide
        @txt_req5.hide

    	@sub_zone.hide
    	@txt_zone.hide

    end

    def add_reqs(reqs)

        return if reqs == ''
        return if reqs == nil

        @sub_req.show
        @sub_req.move(340,@cy)
        @cy += 22

        #log_info(reqs)

        req_num = 1

        # Per req
        # Per req
        reqs.split("\n").each{ |req|

            txt_req = @txt_req1 if req_num == 1
            txt_req = @txt_req2 if req_num == 2
            txt_req = @txt_req3 if req_num == 3
            txt_req = @txt_req4 if req_num == 4
            txt_req = @txt_req5 if req_num == 5

            txt_req.show

            dta = req.split("=>")
            case dta[0] 
                when 'item'
                    item = $data.items[dta[1]]
                    icon = item.icon
                    name = item.name
                    num = $party.item_number(dta[1])

                    name += " #{num}/#{dta[2]}" if dta[2].to_i > 1    

                    if num >= dta[2].to_i
                        txt_req.font = $fonts.page_text_color
                    else
                        txt_req.font = $fonts.page_text
                    end

                when 'var'
                    icon = 'misc/profile'
                    num = $state.varval(dta[1])
                    name = "#{dta[3]} #{num}/#{dta[2]}"

                    if num >= dta[2].to_i
                        txt_req.font = $fonts.page_text_color
                    else
                        txt_req.font = $fonts.page_text
                    end

                when 'flag'
                    icon = 'misc/profile'
                    name = "#{dta[2]}"
                    
                when 'gold'
                    icon = 'misc/coins'
                    name = "#{dta[1]} gold"
            end


            txt_req.text = name
            txt_req.icon = $cache.icon(icon)
            txt_req.show
            #txt_req.move(340,@cy)
            txt_req.y = @cy
            @cy += txt_req.height

            req_num += 1
        }

    end

    def add_zone(zone)
        return if zone == ''
    	@sub_zone.show
    	@sub_zone.move(340,@cy)
    	@cy += 22
    	@txt_zone.icon = $cache.icon("items/map")
    	@txt_zone.text = zone
    	@txt_zone.show
    	@txt_zone.move(340,@cy)
    	@cy += @txt_zone.height
    end

end"ê
class Right_Page < SpriteGroup

	def initialize(vp)
		super()
	
        @vp = vp

		# Right side journal
		@window = Box.new(vp,300,357)
    	@window.skin = $cache.menu_common("skin-dry")
    	@window.wallpaper = $cache.menu_wallpaper("journal-full-page")
    	#@window.color = Color.new(47,45,41)
    	add(@window,320,138)

    	# Quest Name
    	@page_title = Label.new(vp)
    	@page_title.fixed_width = 250
        @page_title.icon = $cache.icon("potions/hypercurium")
        @page_title.icon_oy = -3
    	@page_title.font = $fonts.page_ttl
    	@page_title.text = "Title Text"
    	add(@page_title,340,154)

    	# # SUBTEXTS!!!!!!!!!!

    	# cy = 180

    	# # ALWAYS DESCRIPTION

    	@txt_desc = Area.new(vp)
    	@txt_desc.fixed_width =  260
    	@txt_desc.font = $fonts.page_text
    	@txt_desc.text = "Rescue them guys in the briar woods"
    	add(@txt_desc,340,198)


    	# cy += 30

    	move(0,-22)

        #clear

    end

    def dispose
        # Clear the extras!
        @window.dispose
        @page_title.dispose
        @txt_desc.dispose
    end

    def descript(txt)

        # Perhaps show a description here
        @txt_desc.text = txt
        @cy = @txt_desc.y + @txt_desc.height

        #move(0,0)

    end

    def title(text,icon)
        @page_title.icon = $cache.icon(icon)
        @page_title.text = text
    end

end"˛#==============================================================================
# ** Mnu_Chooser
#==============================================================================

class Mnu_Chooser < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('choose')
		#@title.change_icon("items")
		@subtitle.text = "Pick & Choose"

		@port = Port_Full.new(vp)
		self.right.push(@port)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.hide
		self.right.push(@item_box)

		#grant_items

		@menu.setup_items($menu.choose_cat)

		$menu.chosen = 'none'

		open

	end

	def update

		if $input.cancel? || $input.rclick?
			#absorb escape attempts
		end
		
		super
		# Keep checking if item box changed
		
	end

	def change(option)


		#@item_box.show
		
		@item_box.item(option)
		@item_box.center(472,260)#+@menu.list.page_idx*@menu.list.row_height)

		if @last_option != option
			@last_option = option
			$tweens.clear(@item_box)
			@item_box.y -= 7
			@item_box.do(go("y",7,150,:qio))
		end
		
	end

	def select(option)	
		option = 'none' if option == nil
		$menu.chosen = option
		$map.need_refresh = true
		#flag('have-chosen')
		#potion_state 'choose-item'
		self.close_soon
	end

end"Õ#==============================================================================
# ** Mnu_Potions
#==============================================================================

class Mnu_Potions < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change('potions')
		@subtitle.text = "Making potions"		

		@menu.list.type = :potion
		@menu.list.setup($party.potions)

		@item_box = Item_Box.new(vp)
		@item_box.center(472,260)
		@item_box.hide
		self.right.push(@item_box)

		open

	end

	def update
		super

	end

	def change(option)

		#@item_box.show
		
		@item_box.item(option)
		@item_box.center(472,260)#+@menu.list.page_idx*@menu.list.row_height)

		if @last_option != option
			@last_option = option
			$tweens.clear(@item_box)
			@item_box.y -= 7
			@item_box.do(go("y",7,150,:qio))
		end
		
	end

	def select(option)	
		$menu.chosen = option
		$party.potion_state = 'choose-recipe'
		self.close_soon
	end

end"ı#==============================================================================
# ** Mnu_GameOver
#==============================================================================

class Mnu_GameOver < Mnu_Base

	def initialize(vp)
		super(vp)

		@title.change($menu.char)
		@subtitle.text = "Master of deception"

		@title.y = -500
		@subtitle.y = -500

		remove_info

		@menu.dispose
		self.left.delete(@menu)
		
		@grid = Ui_Grid.new(vp)
		@grid.move(45,143)

		char = $party.get($menu.char)
		
		@grid.add_midwidth("Continue","Continue Autosave",char.weapon_icon)
		@grid.add_midwidth("Load","Load Game","skills/sparkle")
		@grid.add_midwidth("Quit","Quit Game","misc/primary")

		#@grid.choose($menu.char_cursor)

		self.left.push(@grid)

		# Fade and slide in
		dist = 30
		@grid.all.each{ |b|
			b.x -= dist
			b.opacity = 0
     		b.do(go("x",dist,200,:qio))
     		b.do(go("opacity",255,200,:qio))
		}

		open

	end

	def dispose
		super
		@grid.dispose
	end

	def update
		

		if $input.right? || $input.mclick?
			$menu.char = $party.get_next($menu.char)
			$scene.queue_menu("Char")
			close_soon(0)
		end

		if $input.left?
			$menu.char = $party.get_prev($menu.char)
			$scene.queue_menu("Char")
			close_soon(0)
		end

		super

		@grid.update	

		# Cancel out of grid
		if $input.cancel? || $input.rclick?
			@left.each{ |a| $tweens.clear(a) }
			@right.each{ |a| $tweens.clear(a) }
			@other.each{ |a| $tweens.clear(a) }
			close_now
		end

		# Get chosen grid option
		if $input.action? || $input.click?
			choose(@grid.get_chosen)
		end
		
	end

	def choose(option)

		$scene.hide_char if option == "Load"
		$scene.queue_menu(option)

		$menu.char_cursor = option
		@grid.selected_box.flash_heavy
		self.close_soon

	end

	def close
		super

		@grid.hide_glow

		# Fade and hide grid
		dist = 30
		@grid.all.each{ |b|
     		b.do(go("x",-dist,200,:qio))
     		b.do(go("opacity",-255,200,:qio))
		}
		
	end

end"*
class Mnu_Load_Title < Mnu_Save

	def initialize(vp)
		super(vp)
		loadmode
		remove_info
	end

	def update

		# Use up inputs
		if $input.cancel? || $input.rclick?
			$scene.show_logo
			$scene.show_char
			$scene.next_menu = "Title"
			close_soon
		end

		super

	end

end"e
class Mnu_Options_Title < Mnu_Options

	def initialize(vp)
		super(vp)
		@port.dispose
		@right.delete(@port)
		#@title.y = -1000
		#@subtitle.y = -1000
		remove_info
	end

	def update

		# Use up inputs
		if $input.cancel? || $input.rclick?
			$scene.show_logo
			$scene.next_menu = "Title"
			close_soon
		end

		super

	end

end"y#==============================================================================
# ** Mnu_Title
#==============================================================================

class Mnu_Title

	def initialize(vp)

		@vp = vp
		@closing = false
		@close_soon = false
		@close_delay = 0

		@data = ['new','continue','options','quit']
		cx = 135
		cy = 110

		@buttons = []

		@data.each{ |item|

			btn = Sprite.new(@vp)
	     	btn.bitmap = $cache.title("btn-#{item}")
	     	btn.ox = btn.bitmap.width / 2
	     	btn.move(cx,cy)
	     	@buttons.push(btn)

	     	cy += 40

     	}

     	@selected = 0
     	choose(0)

	end

	def dispose

		@buttons.each{ |i| i.dispose }

	end

	def update

		if @close_soon && !@closing
			@close_delay -= 1
			if @close_delay <= 0
				close
			end
		end

		if $input.down?
			choose(@selected + 1)
		end

		if $input.up?
			choose(@selected - 1)
		end

		# Check mouseover buttons
		@buttons.each{ |b| 
			if b.within?($mouse.position[0],$mouse.position[1],b.width/2)
				choose(@buttons.index(b))
			end
		}

		if $input.action? || $input.click?
			case @selected
				when 0
					$scene.next_menu = "New"
					close_soon

				when 1
					$scene.hide_logo
					$scene.hide_char
					$scene.next_menu = "Continue"
					close_soon

				when 2
					$scene.hide_logo
					$scene.next_menu = "Options"
					close_soon

				when 3
					$game.quit
			end
		end

	end

	def choose(idx)
		if idx > @buttons.count - 1
			idx = 0
		end
		if idx < 0
			idx = @buttons.count - 1
		end
		@selected = idx
		@buttons.each{ |b| b.opacity = 150 }
		@buttons[@selected].opacity = 255
	end

	def close_soon(delay=10)
		@close_soon = true
		@close_delay = delay
	end

	def close

		@closing = true

		# Everything fade out
     	(@buttons).each{ |c|
     		c.do(go("opacity",-255,200,:linear))
     	}

     	dist = 30
     	(@buttons).each{ |c|
     		c.do(go("x",-dist,200,:qio))
     	}

     	self.do(delay(200))

	end

	def closing?
		return @closing
	end

	def done?
		return @closing && $tweens.done?(self)
	end

end"†#==============================================================================
# ** Game_Battler (part 1)
#==============================================================================

class Game_Battler
 
  attr_reader :id, :name, :level

  attr_accessor :action, :skill_id, :item_id
  attr_accessor :target
  attr_accessor :scope, :target_idx
  attr_accessor :ev, :view

  attr_reader :hp, :mp, :xp

  attr_reader :gold # Enemy drop

  attr_reader :slots, :equips

  attr_writer :slots

  #-------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    @type = :actor

    @transform = nil

    # Current values
    @hp = 0
    @mp = 0

    @restype = nil#data.resource

    # Enemy values and also bonus for player
    @stat_plus = {}
    @stat_mods = {}
   
    @xp = 0
    @level = 1

    @equips = {}

    @states = []
    @states_counter = {}

    @skills = []
    @cooldowns = {}

    # Skill selection
    @action = nil
    @skill_id = nil
    @item_id = nil

    @target = nil
    @scope = nil # <-- Scope?
    @target_index = -1

    @ev = nil # Mid battle hold event number for easy access
    @view = nil # Hold charview for quick access

    @form = nil # <- fox or frog or etc, maybe for battler? turn enemy to frog he shoot water at you? interesting


  end

  def init_actor(id)

    @type = :actor

    data = $data.actors[id]
    @id = id

    @looklike = id

    @name = data.name

    @slots = data.slots.split(" | ")

    # Prepare equipment slots
    @slots.each{ |s|
      @equips[s] = nil
    }
    
    @actions = data.actions.split(" | ")

    # Add actions as skills, maybe not now, only when checking
    #@actions.each{ |a| @skills.push(a) }

    # Prepare stat mods per character
    if data.mods != ""
      data.mods.split("\n").each{ |m|
        md = m.split("=>")
        @stat_mods[md[0]] = md[1].to_f
      }
    end

    recover_all

  end

  def init_enemy(id)

    @type = :enemy

    data = $data.enemies[id]
    @id = id

    @name = data.name

    @xp = data.xp
    @gold = data.gold

    @actions = data.actions.split(" | ")

    # Get stat plus per enemy
    if data.stats != ""
      data.stats.split("\n").each{ |m|
        md = m.split("=>")
        @stat_plus[md[0]] = md[1].to_i
      }
    end

    recover_all

  end

  def init_ally(id)

    @type = :ally

    data = $data.enemies[id]
    @id = id

    @name = data.name

    @xp = data.xp

    @actions = data.actions.split(" | ")

    # Get stat plus per enemy
    if data.stats != ""
      data.stats.split("\n").each{ |m|
        md = m.split("=>")
        @stat_plus[md[0]] = md[1].to_i
      }
    end

    recover_all

  end

  def init_minion(id)

    @type = :minion

    data = $data.actors[id]
    @id = id

    @name = data.name
    
    @actions = data.actions.split(" | ")

    # Prepare stat mods per character
    if data.mods != ""
      data.mods.split("\n").each{ |m|
        md = m.split("=>")
        @stat_mods[md[0]] = md[1].to_i
      }
    end

    recover_all

  end

  def is_good?
    return !is_enemy?
  end
  
  def is_actor?
    return @type == :actor
  end

  def is_minion?
    return @type == :minion
  end

  def is_enemy?
    return @type == :enemy
  end

  def get_actions
    if @transform
      return $data.actors[@transform].actions.split(" | ")
    end

    if @id == 'hib'

      case @equips['book']
        when 'hib-book-ice'
          return ['chant','bk-ice-1','bk-ice-2','items']
        when 'hib-book-dmg'
          return ['chant','bk-dmg-1','bk-dmg-2','items']
        when 'hib-book-heal'
          return ['chant','bk-heal-1','bk-heal-2','items']
        when 'hib-book-help'
          return ['chant','bk-help-1','bk-help-2','items']
        when 'hib-book-sleep'
          return ['chant','bk-sleep-1','bk-sleep-2','items']
      end

    elsif @id == 'row'

      # If sword sing don't cut it
      return @actions

    else

      return @actions

    end


  end



  #--------------------------------------------------------------------------
  # * Transform into something
  #--------------------------------------------------------------------------
  
  def get_transform
    return @transform
  end

  def transform(into)

    # Robin Ing Team hack
    if into == 'robin'
      into = ['chicken','goat','goat','goat','bear','bear','squirrel'].sample
    end

    @transform = 'x-'+into
    @transform = nil if into == 'nil'

    if @transform != nil
      ev.character_name = "Player/#{@id}-#{@transform}"
    else
      ev.character_name = "Player/#{@id}-idle"
    end

  end

  def fall
    ev.character_name = "Player/#{@id}-down"
  end

  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    if ['ing','hib'].include?(@id)
      @mp = maxmp
    end
   # for i in @states.clone
   #   remove_state(i)
   # end
  end
  
  def damage(amount)
    @hp -= amount
    @hp = 0 if @hp < 0
  end

  def heal(amount)
    @hp += amount
    @hp = maxhp if @hp > maxhp
  end

  def gain_mana(amount)
    @mp+=amount
    @mp = maxmp if @mp > maxmp
  end

  def lose_mana(amount)
    @mp-=amount
    @mp = 0 if @mp < 0
  end



  # perhamps cut these things
  def down?
    @hp <= 0 
  end
  
  def attackable?
    return !down?
  end

  def can_attack?

    # Any states stopping this?
    return false if !@states.select{ |s| $data.state[s].stun }.empty?

    return !down?

  end


  def resource

    case id
      when 'boy'
        return :sp
      when 'ing','hib'
        return :mp
      when 'phy'
        return :rp
      else
        return nil
    end

  end


  # Return priority of current attack
  def attack_priority

    if @action == "items"
      return $data.items[@item_id].priority
    else
      return $data.skills[@skill_id].priority
    end

  end


  def attack_sfx

    if @transform

      case @transform

        when 'x-fox'
          sfx ['mys1','mys2'].sample

      end

      return

    end

    # Normal noise
    case @id

      # Players
      when 'mys'

      # Minions
      when 'minion-fang'
        sfx ['fang-1','fang-2'].sample
      when 'minion-colby'
        sfx 'rat'        





      # Enemies      



    end

  end

end
"
class Game_Battler


  def refresh_stat_mods

      data = $data.actors[@id]

      if data.mods != ""
      data.mods.split("\n").each{ |m|
        md = m.split("=>")
        @stat_mods[md[0]] = md[1].to_f
      }
    end

    log_info("New stat mods for #{@name}")

  end

  # For displays
  def hp_percent
    return @hp / maxhp
  end

  def mp_percent 
    return @mp / maxmp
  end

  #--------------------------------------------------------------------------
  # * Stat Calcs
  #--------------------------------------------------------------------------

  def maxhp
    val = stat('hp')
    #return 1 if val < 1
    return val
  end

  def maxmp
    if @id == 'boy'
      $party.boy_mp_bonus = 0 if $party.boy_mp_bonus == nil
      return 20 + $party.boy_mp_bonus
    else
      stat('mp')
    end
  end

  def str
  	stat('str')
  end

  def def
    stat('def')
  end

  #--------------------------------------------------------------------------
  # * Secondary Calculated Stats
  #--------------------------------------------------------------------------
  
  def luk
    stat('luk')
  end

  def eva
    stat('eva')
  end

  def res
    stat('res')
  end

  def stat_list

    return [maxhp,maxmp,str,self.def,luk,eva,res]

  end

  def grant_stat(stat,amount)
    @stat_plus[stat] = 0 if !@stat_plus.has_key?(stat)
    @stat_plus[stat] += amount
  end

  def ungrant_stat(stat,amount)
    @stat_plus[stat] = 0 if !@stat_plus.has_key?(stat)
    @stat_plus[stat] -= amount
  end

  #--------------------------------------------------------------------------
  # * Item Usage
  #-------------------------------------------------------------------------- 

  def hp_from_item(item)

    # Can't heal if down, unless cassia
    if @hp == 0
      return item == 'cassia' ? 1 : 0
    end
    return 0 if item == 'cassia' && @hp > 0


    # Do it
    plus = 0
    $data.items[item].action.split("\n").each{ |actn|

      dta = actn.split('=>')
      case dta[0]
        when 'heal'
          plus += dta[1].to_i
        when 'heal-p'
          plus += dta[1].to_f * maxhp
      end
    }
    plus = (maxhp - hp) if plus > (maxhp - hp)
    return plus

  end

  def mp_from_item(item)

    # Could change this if boyle gets a mana upgrade
    return 0 if @id == 'boy'

    # Do it
    plus = 0
    $data.items[item].action.split("\n").each{ |actn|

      dta = actn.split('=>')
      case dta[0]
        when 'mana'
          plus += dta[1].to_i
        when 'mana-p'
          plus += dta[1].to_f * maxmp
      end
    }
    plus = (maxmp - mp) if plus > (maxmp - mp)
    return plus

  end

  def use_item(item)
    @hp += hp_from_item(item)
    @mp += mp_from_item(item)
  end

  #--------------------------------------------------------------------------
  # * Stat values
  #--------------------------------------------------------------------------
 
  def stat(stat)
    val = 0
    val += stat_base(stat) # Player base stat from level
    val *= stat_base_mod(stat) # Modify per actor
    val += stat_plus(stat) # Enemy stat or player bonus stat
    val += stat_from_equip(stat) 
    val *= stat_mod_from_equip(stat) 
    val += stat_from_states(stat)   
    val *= stat_mod_from_states(stat)   
    val *= stat_mod_from_difficulty(stat) 
    return val.to_i
  end

  # For menu display
  def stat_pure(stat)
    val = 0
    val += stat_base(stat) # Player base stat from level
    val *= stat_base_mod(stat) # Modify per actor
    val += stat_plus(stat) # Enemy stat or player bonus stat
    return val.to_i
  end

  def stat_gear(stat)
    return stat(stat) - stat_pure(stat)
  end

  def stat_base(stat)
    #return 1
    return 0 if !is_good?
    $data.numbers["#{stat}-base"].value + ($data.numbers["#{stat}-per"].value * (@level-1))
  end

  def stat_base_mod(stat)
    @stat_mods[stat] || 1.0
  end

  def stat_plus(stat)
    @stat_plus[stat] || 0
  end  

  def stat_from_equip(stat)
    total = 0
    @equips.values.each{ |e|
      #log_info(e)
      next if e == nil
      $data.items[e].stats.split("/n").each{ |s|
        dta = s.split("=>")
        if dta[0] == stat
          total += dta[1].to_i
        end
      }
    }
    return total
  end

  def stat_mod_from_equip(stat)
    total = 1.0
    @equips.values.each{ |e|
      #log_info(e)
      next if e == nil
      $data.items[e].mods.split("/n").each{ |s|
        #log_info(s)
        dta = s.split("=>")
        if dta[0] == stat
          total *= dta[1].to_f
        end
      }
    }
    return total
  end

  def stat_from_states(stat)
    total = 0
    #@states.each{ |e|
      
    #}
    return total
  end

  def stat_mod_from_states(stat)
    return 1.0
  end

  # MAYBE
  def stat_mod_from_difficulty(stat)
    return 1.0 if is_good?
    return 0.9 if $party.difficulty == 'easy'
    return 1.0 if $party.difficulty == 'normal'
    return 1.1 if $party.difficulty == 'hard'
    return 1.0
  end

end"
class Game_Battler


  #--------------------------------------------------------------------------
  # * States
  #--------------------------------------------------------------------------

  def state?(state_id)
    return @states.include?(state_id)
  end

  def states
    return @states
  end

  def add_state(state_id)
    @states.push(state_id)
    @states_counter[state_id] = 0
    ev.icons = @states if ev
  end

  def remove_state(id)
    @states.delete(id)
  end

  def clear_states
    @states = []
    ev.icons = @states if ev
  end

  #--------------------------------------------------------------------------
  # * Determine [Slip Damage] States
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end

  #--------------------------------------------------------------------------
  # * Remove Battle States
  #--------------------------------------------------------------------------
  def remove_states_battle

    # Break transforms
    @transform = nil

    # Remove states
    @states.delete_if{ |s| $data.states[s].rmv_battle }

    ev.icons = @states if ev
    
  end

  #--------------------------------------------------------------------------
  # * State Removed by Shock
  #--------------------------------------------------------------------------
  def remove_states_shock
    @states.delete_if{ |s| $data.states[s].rmv_shock }
  end

  #--------------------------------------------------------------------------
  # * Natural Removal of States
  #--------------------------------------------------------------------------
  def remove_states_turn
    
    # Add a turn to the counter
    @states_counter.values.each{ |v| v += 1 }

    # If done
    @states.delete_if{ |s| 
      @states_counter[s] >= $data.states[s].rmv_turn 
    }

    ev.icons = @states if ev

  end

 end"äclass Game_Battler

  def learn(skill)
  	@skills.push(skill)
  end

  def unlearn(skill)
    @skills.delete(skill)
  end

  def replace_skill(os,ns)

    # Find pretty close old skill
    idx = 0
    @skills.each_index{ |i|
      if @skills[i].include?(os)
        idx = i
      end
    }

    @skills[idx] = ns

  end

  def has_skill?(skill)
    return @skills.include?(skill)
  end

  def skill_list(action)
    result = @skills.select{ |s| $data.skills[s].book == action }
    if action == "team"
      result = result.select{ |s|
        $party.active.include?(s.split("-")[1]) && !$party.get(s.split("-")[1]).down?
      }
    end
    return result
  end

  def all_skill_list
    result = @skills
    return result
  end


  def skills_for(action)

    return @skills.select{ |s| 
      #log_info s
      $data.skills[s].id == action || 
      $data.skills[s].book == action
    }
  end

  def choose_action

    targets = is_enemy? ? $party.attackable_battlers : $battle.attackable_enemies

  	@action = 'attack'

    if @actions.count == 1

      @skill_id = @actions[0]

    elsif @actions.count == 2

      if rand < 0.65
        @skill_id = @actions[0]
      else
        @skill_id = @actions[1]
      end

    elsif @actions.count == 3

      if rand < 0.65
        @skill_id = @actions[0]
      else
        if rand < 0.5
          @skill_id = @actions[1]
        else
          @skill_id = @actions[2]
        end
      end

    elsif @action.count == 4

      if rand < 0.5
        @skill_id = @actions[0]
      else
        if rand < 0.6
          if rand < 0.5
            @skill_id = @actions[1]
          else
            @skill_id = @actions[2]
          end
        else
          @skill_id = @actions[3]
        end
      end

    end

    #log_sys @skill_id
    sk = $data.skills[@skill_id]

    @scope = sk.scope

    if @scope == 'rand' || @scope == 'one'
      @target = targets.sample
    end

  end  

  def set_action(skill)
    @action = 'attack'
    @skill_id = skill
  end

  def reduce_cooldowns
    @cooldowns.each_key{ |k| 
      @cooldowns[k] -= 1
    }
    @cooldowns.delete_if{ |k,v| v <= 0 }
  end

  def get_cooldown(skill_id)
    return 0 if !@cooldowns.has_key?(skill_id)
    return @cooldowns[skill_id]
  end

  def clear_cooldowns
    @cooldowns = {}
  end

  def apply_cooldown(skill_id)

    # Revert to source attack
    if ['tcf-mermaid','tcf-gyendal','tcf-hercules','tcf-cyclops'].include?(skill_id)
      skill_id = 'team-boy'
    end
    if ['ntmr-ghost','ntmr-ing','ntmr-spider','ntmr-mutton'].include?(skill_id)
      skill_id = 'team-hib'
    end

    return if $data.skills[skill_id].cooldown == nil
    @cooldowns[skill_id] = $data.skills[skill_id].cooldown
  end

  def can_use_skill?(skill_id)

    # Not enough mana
    if $data.skills[skill_id].cost > @mp
      return false
    end

    # Currently on cooldown
    if @cooldowns.has_key?(skill_id) && @cooldowns[skill_id] > 0
      return false
    end
    
    # Other requirements, such as under X% hp

    return true

  end

end"¡
class Game_Battler

	def equip(slot,new_equip)

		if @equips[slot] != nil # Remove existing
			$party.add_item(@equips[slot])
			@equips[slot] = nil
		end

		if new_equip != nil
			$party.lose_item(new_equip)
			@equips[slot] = new_equip
		end

	end

	def force_equip(slot,new_equip)
		@equips[slot] = new_equip
	end

	def equip_list
		list = []
		@slots.each{ |s|
			list.push(@equips[s])
		}
		return list
	end

	def slot(s)
		return @equips[s]
	end

	def weapon_icon
		if @equips[@slots[0]] == nil
			return 'misc/unknown'
		else
			return $data.items[@equips[@slots[0]]].icon
		end
	end



	# Compare all stat changes, prepare a list of actual changes
	# Include slot in case this is a removal
	def equip_result_mega(new_equip,slot)

		# hp, mp, str, def, eva, luk, res
		before = stat_list
		old = @equips[slot]
		@equips[slot] = new_equip
		after = stat_list
		@equips[slot] = old

		change = after.dup
		change.each_index{ |i| change[i] -= before[i] }

		return [before,after,change]

	end

	# def equip_result_single(new_equip)

	# 	slot = $data.items[new_equip]

	# end


	def equip_result(new_equip)
		# What is the stat
		return ' ' if new_equip.stats == nil || new_equip.stats == ''
		type = new_equip.stats.split("\n")[0].split("=>")[0]
		slot = new_equip.slot
		old = @equips[slot]
		before = stat(type)
		@equips[slot] = new_equip.id
		after = stat(type)
		@equips[slot] = old
		res = (after - before).to_i.to_s
		if after-before >= 0
			res = "+#{res}"
		end
		return res
	end

	def equip_result_full(new_equip,slot)
		
		# What is the stat
		# Check old and new
		type = new_equip.stats.split("\n")[0].split("=>")[0]

		old = @equips[slot]
		before = stat(type)
		@equips[slot] = new_equip.id
		after = stat(type)
		@equips[slot] = old
		
		res = (after - before).to_i.to_s
		if after-before >= 0
			res = "+#{res}"
		end
		return [before,after,res]
		
	end

end"⁄
class Game_Battler

  #--------------------------------------------------------------------------
  # * XP Calcs
  #--------------------------------------------------------------------------
  def exp_percent
    return @xp / next_exp
  end

  def level_up?
  	if @xp > next_exp
  		while @xp > next_exp
	  		@xp -= next_exp
	  		@level += 1
        # If boyle, level up minions
        if @id == 'boy'
          ['cannon','rat','crab','crow','fang','skull','magic'].each{ |m|
            $party.get('minion-'+m).set_level(@level)
          }
        end
	  	end
  		return true
  	end
  	return false
  end

  def set_level(lvl)
    @level = lvl
  end

  def grant_level(reset_xp = true)
    @level += 1
    @xp = 0 if reset_xp
  end

  def gain_xp(gain)
  	# Add trinket access to xp here if smart
  	@xp += gain
  end
  
  def next_exp 
     return xp_for_level(@level+1)
  end

  def xp_for_level(i)

  	base = $data.numbers['xp-base'].value
  	inflation = $data.numbers['xp-inflation'].value

  	# Different calc above 40, taper off to increase by 1 per level by 50

	pow_i = 2.4 + inflation / 100.0
    n = base * ((i + 3) ** pow_i) / (5 ** pow_i)
    return n.to_i

  end

end"!
class Attack_Result

	attr_accessor :target
	
	attr_accessor :damage
	attr_accessor :critical

	attr_accessor :heal

	attr_accessor :evade
	attr_accessor :resist

	attr_accessor :gain_mana

	attr_accessor :state_add
	attr_accessor :state_remove

	attr_accessor :transform

	attr_accessor :empower
	attr_accessor :steal
	attr_accessor :pocket
	attr_accessor :escape

end

class Attack_Round

	attr_accessor :anim
	attr_accessor :text

	attr_accessor :skill

end

class Attack_Plan

	def initialize

		@attacks = []
		@cancel = false

	end

	def add(attack)
		@attacks.push(attack)
	end

	def next_attack
		return @attacks.shift
	end

	def cancel
		@cancel = true
	end

	def done?
		return true if @cancel
		return @attacks.empty?
	end

end"∑#==============================================================================
# ** Game_Character (part 1)
#------------------------------------------------------------------------------
#  This class deals with characters. It's used as a superclass for the
#  Game_Player and Game_Event classes.
#==============================================================================

class Game_Character
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  
  attr_accessor   :x                        # map x-coordinate (logical)
  attr_accessor  :y                        # map y-coordinate (logical)
  attr_reader   :real_x                   # map x-coordinate (real * 128) # For precision
  attr_reader   :real_y                   # map y-coordinate (real * 128)
  
  
  # Graphics

  attr_accessor   :character_name           # character file name

  attr_accessor   :opacity                  # opacity level
  
  
  attr_accessor :direction                # direction
  attr_accessor :showdir

  attr_reader :direction_fix

  attr_accessor :force_pattern # For random pattern feature

  attr_accessor   :pattern                  # pattern
  attr_reader   :move_route_forcing       # forced move route flag
  attr_reader   :through                  # through
  attr_reader   :sthrough                  # sthrough - special through for fang, ignore events
  attr_accessor :animation_id             # animation ID
  attr_accessor :transparent              # transparent flag
  attr_accessor :ignore_movement          # ignore movement when finding path
  attr_accessor :step_anime               # stop animation
  
  attr_accessor :fxtrail

  attr_accessor :cool_jumps, :spin_jumps, :flat_jumps
  
  # Custom
  attr_accessor :off_x, :off_y
  attr_accessor :zoom

  attr_accessor :color
  attr_accessor :flash_dur # flash always white?
  attr_accessor :pulse_colors
  attr_accessor :icons

  attr_accessor :move_type

  attr_accessor :move_speed 
   
  
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @character_name = ""
    

    @direction = 2
    @showdir = 4
    @lockdir = 0

    @force_pattern = nil

    @move_angle = 0

    @prev_terrain = 0


    @off_x = 0
    @off_y = 0
    @zoom = 1.0

    @cool_jumps = false
    @spin_jumps = false
    @flat_jumps = false

    @fxtrail = nil

    @pattern = 0

    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0

    @move_type = 0
    @move_speed = 3
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0

    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0 #how long has paused for between steps

    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
    @ignore_movement = false

    @opacity = 255

    @flash_dur = nil
    @pulse_colors = []
    
    @icons = []

  end

  # For offsets > 32, snap the position and remove offset
  def snap_offset
    @y += @off_y / 32
    @x += @off_x / 32
    @real_x = @x * 128
    @real_y = @y * 128
    @off_y = 0#@off_y % 32
    @off_x = 0#@off_x % 32
  end

  #--------------------------------------------------------------------------
  # * Determine if Moving
  #--------------------------------------------------------------------------
  def moving?
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # * Determine if Jumping
  #--------------------------------------------------------------------------
  def jumping?
    @showdir = [2,4,6,8].sample if @jump_count > 0 && @spin_jumps
    return @jump_count > 0
  end

  #--------------------------------------------------------------------------
  # * Straighten Position
  #--------------------------------------------------------------------------
  def straighten
    # If moving animation or stop animation is ON
    if @walk_anime or @step_anime
      # Set pattern to 0
      @pattern = 0
    end
    # Clear animation count
    @anime_count = 0
    # Clear prelock direction
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # * Force Move Route
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # Save original move route
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end

    # Change move route
    @move_route = move_route
    @move_route_index = 0
    # Set forced move route flag
    @move_route_forcing = true
    # Clear prelock direction
    @prelock_direction = 0
    # Clear wait count
    @wait_count = 0
    # Move cutsom
    move_type_custom
    
  end

  def at?(x,y)
    return self.x == x && self.y == y
  end

  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d) #d0 = jump

    #return true if self != $player

    # Get new coordinates
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)

    return false if self != $player && $player.at?(new_x,new_y) && !@through
       
    # If coordinates are outside of map
    return false unless $map.valid?(new_x, new_y)
    return true if @through
    
    # If enemy, check if I shall pass
    if self.is_a?(Game_Event) && self.monster != nil
      return false unless $map.passable?(x, y, d, self) # From
      return false  unless $map.passable?(new_x, new_y, 10 - d,self,true) # To
    else
      return false unless $map.passable?(x, y, d, self) # From
      return false  unless $map.passable?(new_x, new_y, 10 - d,self) # To
    end


    # end
    return true

  end
  
  #--------------------------------------------------------------------------
  # * Determine if Can Fight 
  #--------------------------------------------------------------------------
  def canfight?()

    d = 2 if @x == $player.x and @y == $player.y - 1
    d = 8 if @x == $player.x and @y == $player.y + 1
    d = 4 if @y == $player.y and @x == $player.x + 1
    d = 6 if @y == $player.y and @x == $player.x - 1
    
    return passable?(x,y,d)

  end

  #--------------------------------------------------------------------------
  # * Lock
  #--------------------------------------------------------------------------
  def lock
    return if @locked
    @prelock_direction = @direction
    turn_toward_player
    @locked = true
  end

  #--------------------------------------------------------------------------
  # * Determine if Locked
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end

  #--------------------------------------------------------------------------
  # * Unlock
  #--------------------------------------------------------------------------
  def unlock
    return if !@locked

    # Clear locked flag
    @locked = false
    # If direction is not fixed
    unless @direction_fix
      # If prelock direction is saved
      if @prelock_direction != 0
        # Restore prelock direction
        case @prelock_direction
          when 2
            turn_down
          when 4
            turn_left
          when 6
            turn_right
          when 8
            turn_up
        end
        #@direction = @prelock_direction

      end
    end
  end

  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x 
    @y = y 
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end

  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    # Get screen coordinates from real coordinates and map display position
    return  @off_x + (@real_x - $scene.map.display_x + 3) / 4 + 16
  end

  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    # Get screen coordinates from real coordinates and map display position
    y = (@real_y - $scene.map.display_y + 3) / 4 + 32
    # Make y-coordinate smaller via jump count
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    if @flat_jumps
      return @off_y + y - (@jump_peak * @jump_peak - n * n) / 6
    else
      return @off_y + y - (@jump_peak * @jump_peak - n * n) / 2
    end
  end
  #--------------------------------------------------------------------------
  # * Get Screen Z-Coordinates
  #     height : character height
  #--------------------------------------------------------------------------
  def screen_z(height = 0)

    return 0 if @below2
    return 1 if @below
    return 999 if @above

    # Get screen coordinates from real coordinates and map display position
    z = (@real_y - $scene.map.display_y + 3) / 4 + 32

    # If height exceeds 32, then add 31
    return z #+ ((height > 32) ? 31 : 0)


  end

  def gfx_width
    if @character_name.include?('Prop')
      $cache.character(@character_name).width
    else  
      $cache.character(@character_name).width / 4
    end
  end

  def gfx_height
    if @character_name.include?('Prop')
      $cache.character(@character_name).height
    else  
      $cache.character(@character_name).height / 4
    end
  end

  #--------------------------------------------------------------------------
  # * Get Thicket Depth
  #--------------------------------------------------------------------------
  def bush_depth
    return 0 if @always_on_top
    return 0 if jumping?
    dx = ((@x * 128) - @real_x).abs
    #log_info(dx) if dx > 0
    return 12 if $scene.map.bush?(@x, @y) && dx < 24
    return 0
  end

  #--------------------------------------------------------------------------
  # * Get Terrain Tag
  #--------------------------------------------------------------------------
  def terrain_tag() return $scene.map.terrain_tag(@x, @y) end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update(mini=false)

    # mini is just for player to make sure anim finishes

    # Update facing dir
    @lockdir -= 1
    if @lockdir <= 0
      @showdir = @direction
    end

    # Reset animation on 
    @pattern = 0 if mini

    return if mini && !jumping? # Force jumps to finish

    # Mouse pathfinding
    run_path if @runpath == true    
    
    # Branch with jumping, moving, and stopping
    if jumping?
      update_jump
    elsif moving?
      update_move
      if !moving?
        @move_angle = 0
      end
    else
      update_stop
    end

    # If animation count exceeds maximum value
    # * Maximum value is move speed * 1 taken from basic value 18
    if @anime_count > 18 - @move_speed * 2
      # If stop animation is OFF when stopping
      if not @step_anime and @stop_count > 0
        # Return to original pattern
        @pattern = @original_pattern
      # If stop animation is ON when moving
      else
        # Update pattern
        @pattern = (@pattern + 1) % 4
      end
      # Clear animation count
      @anime_count = 0
    end


    # If waiting
    if @wait_count > 0
      # Reduce wait count
      @wait_count -= 1
      return
    end


    # If move route is forced
    if @move_route_forcing
      # Custom move
      move_type_custom
      return
    end

    # When waiting for event execution or locked
    if @starting or lock?
      # Not moving by self
      return
    end

    # If stop count exceeds a certain value (computed from move frequency)
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # Branch by move type
      case @move_type
        when 1  # Random
          move_type_random
        when 2  # Approach
          move_type_toward_player
        
        when 3  # Custom
          move_type_custom

        when 4  # Avoid
          move_type_avoid_player          
      end
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (jump)
  #--------------------------------------------------------------------------
  def update_jump
    # Reduce jump count by 1
    @jump_count -= 1
    @jump_count += 0.5 if @cool_jumps
    # Calculate new coordinates
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)

    # Run in air for cool jumps
    if @cool_jumps && !@spin_jumps

      # If move animation is ON
      if @walk_anime
        # Increase animation count by 1.5
        @anime_count += 3
      # If move animation is OFF, and stop animation is ON
      elsif @step_anime
        # Increase animation count by 1
        @anime_count += 2
      end

    end

  end

  #--------------------------------------------------------------------------
  # * Update frame (move)
  #--------------------------------------------------------------------------
  def update_move

    #if moving?

    #end
    

    # Convert map coordinates from map move speed into move distance
    distance = 2 ** @move_speed 

    #LADDER
    if terrain_tag == 3

      # turn to get on ladder
      if @direction == 2 #&& @prev_terrain != 3
        @showdir = 4
        @direction = 8
        @lockdir = 4
     else
        @direction = 8
        #@showdir = 8
      end
      @move_angle += 0.2
      # Convert map coordinates from map move speed into move distance
      if $party.leader != 'mys'
        distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs
      end

      #sfx("step") if (2.4-@move_angle).abs < 0.2 && (@prev_terrain == 4 || @prev_terrain == 3)
      #sfx("step") if (4.8 - @move_angle).abs < 0.21

    elsif terrain_tag == 5 && @prev_terrain == 3
      #@showdir = 8
      #@direction = 8

      @move_angle += 0.2

      if @move_angle < 3.14
        @showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 1.8 ** @move_speed * (Math.sin(@move_angle)).abs
      else
        #if @lockdir > 0
          @direction = 2
          @showdir = 4
          @lockdir = 2
       # end
        distance = 2 ** @move_speed 
      end

      #sfx("step") if @move_angle == 2.4 && @prev_terrain != 3


    elsif terrain_tag == 2 # Stairs

      #@showdir = 8
      #@direction = 8

      @move_angle += 0.15

      #if @move_angle < 3.14
        #@showdir = 8
      # Convert map coordinates from map move speed into move distance
        distance = 2.0 ** @move_speed * (Math.sin(@move_angle)).abs
      #end

      #Audio.se_play("Audio/SE/step.ogg") if @move_angle == 2.4 && @prev_terrain != 3


    else
      @move_angle = 0
    end

    distance = 28 if self == $player && $settings.debug_power_test && !$keyboard.state?(VK_SHIFT)

    # If logical coordinates are further down than real coordinates
    if @y * 128 > @real_y
      @real_y = [@real_y + distance, @y * 128].min
    end
    # If logical coordinates are more to the left than real coordinates
    if @x * 128 < @real_x
      @real_x = [@real_x - distance, @x * 128].max
    end
    # If logical coordinates are more to the right than real coordinates
    if @x * 128 > @real_x
      @real_x = [@real_x + distance, @x * 128].min
    end
    # If logical coordinates are further up than real coordinates
    if @y * 128 < @real_y
      @real_y = [@real_y - distance, @y * 128].max
    end

    # If move animation is ON
    if @walk_anime
      # Increase animation count by 1.5
      @anime_count += 1.5
    # If move animation is OFF, and stop animation is ON
    elsif @step_anime
      # Increase animation count by 1
      @anime_count += 1
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update (stop)
  #--------------------------------------------------------------------------
  def update_stop

    @prev_terrain = terrain_tag if @prev_terrain != terrain_tag

    # If stop animation is ON
    if @step_anime
      # Increase animation count by 1
      @anime_count += 1
    # If stop animation is OFF, but current pattern is different from original
    elsif @pattern != @original_pattern
      # Increase animation count by 1.5
      @anime_count += 1.5
    end
    # When waiting for event execution, or not locked
    # * If lock deals with event execution coming to a halt
    unless @starting or lock?
      @stop_count += 1
    end
  end
  
  #--------------------------------------------------------------------------
  # * Move Type : Random
  #--------------------------------------------------------------------------
  def move_type_random
    # Branch by random numbers 0-5
    case rand(6)
      when 0..3  # Random
        move_random
      when 4  # 1 step forward
        move_forward
      when 5  # Temporary stop
        @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end

    # What if they follow more aggressively on harder difficulty?

    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_toward_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end

  end

    #--------------------------------------------------------------------------
  # * Move Type : Avoid
  #--------------------------------------------------------------------------
  def move_type_avoid_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # Get absolute value of difference
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # If separated by 20 or more tiles matching up horizontally and vertically
    if sx + sy >= 20
      # Random
      move_random
      return
    end

    # What if they follow more aggressively on harder difficulty?
    # Branch by random numbers 0-5
    case rand(6)
    when 0..3  # Approach player
      move_away_from_player
    when 4  # random
      move_random
    when 5  # 1 step forward
      move_forward
    end
  end

  #--------------------------------------------------------------------------
  # * Move Type : Custom
  #--------------------------------------------------------------------------
  def move_type_custom
    # Interrupt if not stopping
    return if jumping? or moving?

    # Loop until finally arriving at move command list
    while @move_route_index < @move_route.list.size

      # Acquiring move command
      command = @move_route.list[@move_route_index]

      # If command code is 0 (last part of list)
      if command.code == 0

        # Restart
        @move_route_index = 0 if @move_route.repeat

        # If [repeat action] option is OFF
        if !@move_route.repeat
          # If move route is forcing
          if @move_route_forcing

            # Release forced move route
            @move_route_forcing = false

            # Restore original move route
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # Clear stop count
          @stop_count = 0
        end
        return
      end

      # COL 1

      # During move command (from move down to jump)
      if command.code <= 14
        # Branch by command code
        case command.code
          when 1; move_down
          when 2  # Move left
            move_left
          when 3  # Move right
            move_right
          when 4  # Move up
            move_up
          when 5  # Move lower left
            move_lower_left
          when 6  # Move lower right
            move_lower_right
          when 7  # Move upper left
            move_upper_left
          when 8  # Move upper right
            move_upper_right
          when 9  # Move at random
            move_random
          when 10  # Move toward player
            move_toward_player
          when 11  # Move away from player
            move_away_from_player
          when 12  # 1 step forward
            move_forward
          when 13  # 1 step backward
            move_backward
          when 14  # Jump
            jump(command.parameters[0], command.parameters[1])
        end
        # If movement failure occurs when [Ignore if can't move] option is OFF
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end

      # If waiting
      if command.code == 15
        # Set wait count
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end

      # COL 2

      # If direction change command
      if command.code >= 16 and command.code <= 26
        # Branch by command code
        case command.code
        when 16  # Turn down
          turn_down
        when 17  # Turn left
          turn_left
        when 18  # Turn right
          turn_right
        when 19  # Turn up
          turn_up
        when 20  # Turn 90¬∞ right
          turn_right_90
        when 21  # Turn 90¬∞ left
          turn_left_90
        when 22  # Turn 180¬∞
          turn_180
        when 23  # Turn 90¬∞ right or left
          turn_right_or_left_90
        when 24  # Turn at Random
          turn_random
        when 25  # Turn toward player
          turn_toward_player
        when 26  # Turn away from player
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end

      # COL 3

      # If other command
      if command.code >= 27
        # Branch by command code
        case command.code
        
        when 29  # Change speed
          @move_speed = command.parameters[0]
        when 30  # Change freq
          @move_frequency = command.parameters[0]
        when 31  # Move animation ON
          @walk_anime = true
        when 32  # Move animation OFF
          @walk_anime = false
        when 33  # Stop animation ON
          @step_anime = true
        when 34  # Stop animation OFF
          @step_anime = false
        when 35  # Direction fix ON
          @direction_fix = true
        when 36  # Direction fix OFF
          @direction_fix = false
        when 37  # Through ON
          @through = true
        when 38  # Through OFF
          @through = false
        when 39  # Always on top ON
          @always_on_top = true
        when 40  # Always on top OFF
          @always_on_top = false
        when 41  # Change Graphic
          @character_name = command.parameters[0]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # Change Opacity
          @opacity = command.parameters[0]
        when 43  # Change Blending
          @blend_type = command.parameters[0]
        when 44  # Play SE
          $game_system.se_play(command.parameters[0])
        when 45  # Script
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end


    end


  end

  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    # Clear stop count
    @stop_count = 0
  end



    #--------------------------------------------------------------------------
  # * Move Down
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)

    @move_angle = 0

    # Turn down
    if turn_enabled
      turn_down
    end
    # If passable
    if passable?(@x, @y, 2)

      # Turn down
      turn_down

      # Remove from cache
      $scene.map.cache_clear(@x,@y,self)

      # Update coordinates
      @y += 1

      $scene.map.cache_push(@x,@y,self)

      # Add to cache

      # Increase steps
      increase_steps
      # If impassable

      if self == $player && $party.leader != 'ship'

        tt = terrain_tag

        $audio.queue('ladder/ladder1',10,0.15) if tt == 3 || tt == 5
        $audio.queue('ladder/ladder2',24,0.15) if tt == 3

         #$audio.queue('walk',4,0.5) if self == $player
         $audio.queue("steps/foot#{rand(8)}",12,0.4) if tt != 3
         $audio.queue('steps/foot5',12,0.6) if tt == 2

      end

    else
      # Determine if touch event is triggered IF ENEMY ONLY
      check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Left
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)

    @move_angle = 0

    # Turn left
    if turn_enabled
      # If facing right, turn down for just second
      turn_left
    end
    # If passable
    if passable?(@x, @y, 4)
      # Turn left
      turn_left

      # Remove from cache
      $scene.map.cache_clear(@x,@y,self)

      # Update coordinates
      @x -= 1

      $scene.map.cache_push(@x,@y,self)

      # Increase steps
      increase_steps

      if self == $player && $party.leader != 'ship'
        tt = terrain_tag
        $audio.queue("steps/foot#{rand(8)}",12,0.4) if tt != 3
        $audio.queue('steps/foot5',12,0.6) if tt == 2
      end
    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Right
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)

    @move_angle = 0

    # Turn right
    if turn_enabled
      turn_right
    end
    # If passable
    if passable?(@x, @y, 6)
      # Turn right
      turn_right

      # Remove from cache
      $scene.map.cache_clear(@x,@y,self)

      # Update coordinates
      @x += 1

      $scene.map.cache_push(@x,@y,self)

      # Increase steps
      increase_steps

      if self == $player && $party.leader != 'ship'
        tt = terrain_tag
        $audio.queue("steps/foot#{rand(8)}",12,0.4) if tt != 3
        $audio.queue('steps/foot5',12,0.6) if tt == 2
      end

    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # * Move up
  #     turn_enabled : a flag permits direction change on that spot
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)

    @move_angle = 0

    # Turn up
    if turn_enabled
      turn_up
    end
    # If passable
    if passable?(@x, @y, 8)
      # Turn up
      turn_up

      # Remove from cache
      $scene.map.cache_clear(@x,@y,self)

      # Update coordinates
      pt = terrain_tag
      @y -= 1

      $scene.map.cache_push(@x,@y,self)

      # Increase steps
      increase_steps

      if self == $player && $party.leader != 'ship'

        tt = terrain_tag
        $audio.queue('ladder/ladder1',10,0.15) if tt == 3 && pt == 3
        $audio.queue('ladder/ladder1',24,0.15) if tt == 4
        $audio.queue('ladder/ladder1',24,0.15) if tt == 3

        $audio.queue("steps/foot#{rand(8)}",12,0.4) if tt != 3
        $audio.queue('steps/foot5',12,0.6) if tt == 2

      end

    else
      # Determine if touch event is triggered
      check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Left
  #--------------------------------------------------------------------------
  def move_lower_left
    # If no direction fix
    unless @direction_fix
      # Face down is facing right or up
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # When a down to left or a left to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # Update coordinates
      @x -= 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Lower Right
  #--------------------------------------------------------------------------
  def move_lower_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face down if facing up
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # When a down to right or a right to down course is passable
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # Update coordinates
      @x += 1
      @y += 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Left
  #--------------------------------------------------------------------------
  def move_upper_left
    # If no direction fix
    unless @direction_fix
      # Face left if facing right, and face up if facing down
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # When an up to left or a left to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # Update coordinates
      @x -= 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move Upper Right
  #--------------------------------------------------------------------------
  def move_upper_right
    # If no direction fix
    unless @direction_fix
      # Face right if facing left, and face up if facing down
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # When an up to right or a right to up course is passable
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # Update coordinates
      @x += 1
      @y -= 1
      # Increase steps
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # * Move at Random
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # Move down
      move_down(false)
    when 1  # Move left
      move_left(false)
    when 2  # Move right
      move_right(false)
    when 3  # Move up
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * Move toward Player
  #--------------------------------------------------------------------------
  def move_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move towards player, prioritize left and right directions
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # If vertical distance is longer
    else
      # Move towards player, prioritize up and down directions
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Move away from Player
  #--------------------------------------------------------------------------
  def move_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # Get absolute value of difference
    abs_sx = sx.abs
    abs_sy = sy.abs
    # If horizontal and vertical distances are equal
    if abs_sx == abs_sy
      # Increase one of them randomly by 1
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # If horizontal distance is longer
    if abs_sx > abs_sy
      # Move away from player, prioritize left and right directions
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # If vertical distance is longer
    else
      # Move away from player, prioritize up and down directions
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Forward
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # * 1 Step Backward
  #--------------------------------------------------------------------------
  def move_backward
    # Remember direction fix situation
    last_direction_fix = @direction_fix
    # Force directino fix
    @direction_fix = true
    # Branch by direction
    case @direction
    when 2  # Down
      move_up(false)
    when 4  # Left
      move_right(false)
    when 6  # Right
      move_left(false)
    when 8  # Up
      move_down(false)
    end
    # Return direction fix situation back to normal
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # * Jump
  #     x_plus : x-coordinate plus value
  #     y_plus : y-coordinate plus value
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # If plus value is not (0,0)
    if x_plus != 0 or y_plus != 0
      # If horizontal distnace is longer
      if x_plus.abs > y_plus.abs
        # Change direction to left or right
        x_plus < 0 ? turn_left : turn_right
      # If vertical distance is longer, or equal
      else
        # Change direction to up or down
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # Calculate new coordinates
    new_x = @x + x_plus
    new_y = @y + y_plus
    # If plus value is (0,0) or jump destination is passable
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # Straighten position
      straighten
      # Update coordinates
      @x = new_x
      @y = new_y
      # Calculate distance
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # Set jump count
      @jump_peak = 10 + distance - @move_speed 
      @jump_peak += distance if @cool_jumps
      @jump_count = @jump_peak * 2
      # Clear stop count
      @stop_count = 0
    end
  end

  #--------------------------------------------------------------------------
  # * Turns
  #--------------------------------------------------------------------------
  def turn_down() 
    return if @direction_fix 
    return if terrain_tag == 3 #on ladder
    return if terrain_tag == 4 #&& @previous_terrain == 3
    if @direction == 8
        @showdir=4
        @direction = 2
        @lockdir = 6
      else
        @direction = 2 
      end  


  end


  def turn_left() 
    return if @direction_fix 
      if @direction == 6
        @showdir=2
        @direction =4
        @lockdir = 7
      else
        @direction = 4 unless @direction_fix 
      end
    
  end

  def turn_right() 
    return if @direction_fix 
    if @direction == 4
        @showdir=2
        @direction = 6
        @lockdir = 7
    else
      @direction = 6 unless @direction_fix 
    end
  end



  def turn_up() 
    return if @direction_fix 
    if @direction == 2
        @showdir=6
        @direction = 8
        @lockdir = 6
      else
        @direction = 8 unless @direction_fix 
      end  

  end
  
  #--------------------------------------------------------------------------
  # * Turn 90¬∞ Right
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90¬∞ Left
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 180¬∞
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn 90¬∞ Right or Left
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # * Turn at Random
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Towards Player
  #--------------------------------------------------------------------------
  def turn_toward_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards player
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards player
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # * Turn Away from Player
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # Get difference in player coordinates
    sx = @x - $player.x
    sy = @y - $player.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left away from player
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down away from player
      sy > 0 ? turn_down : turn_up
    end
  end

  #--------------------------------------------------------------------------
  # * Turn Towards Event
  #--------------------------------------------------------------------------
  def turn_toward_event(event_id)
    # Get difference in player coordinates
    evt = $map.events[event_id]
    return if evt == nil
    sx = @x - evt.x
    sy = @y - evt.y
    # If coordinates are equal
    if sx == 0 and sy == 0
      return
    end
    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_right : turn_left
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end

  def turn_toward_pos(x,y)

    sx = @x - x
    sy = @y - y

    # If coordinates are equal
    return if sx == 0 and sy == 0

    # If horizontal distance is longer
    if sx.abs > sy.abs
      # Turn to the right or left towards event
      sx > 0 ? turn_left : turn_right
    # If vertical distance is longer
    else
      # Turn up or down towards event
      sy > 0 ? turn_up : turn_down
    end
  end
  #   #--------------------------------------------------------------------------
#   # * Frame Update (run_path)
#   #--------------------------------------------------------------------------
  def run_path

    return if moving?

    step = @map[@x,@y]
    if step == 1 # AT TARGET POS
      @map = nil
      @runpath = false
      return
    end
      
    # maybe cut the step != 0, would be broken if there

    dir = rand(2)
    case dir
    when 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_up if @map[@x,@y-1] == step - 1 and step != 0
    when 1
      move_up if @map[@x,@y-1] == step - 1 and step != 0
      move_left if @map[@x-1,@y] == step - 1 and step != 0
      move_down if @map[@x,@y+1] == step - 1 and step != 0
      move_right if @map[@x+1,@y] == step - 1 and step != 0
    end
  end

  #--------------------------------------------------------------------------
  # * Find Path
  #--------------------------------------------------------------------------
  def find_path(x,y)
    sx, sy = @x, @y
    @tx, @ty = x, y
    tx, ty = x,y
    result = setup_map(sx,sy,tx,ty)
    @runpath = result[0]
    @map = result[1]
    @map[sx,sy] = result[2] if result[2] != nil
  end
  #--------------------------------------------------------------------------
  # * Clear Path
  #--------------------------------------------------------------------------
  def clear_path
    @map = nil
    @runpath = false
  end
  #--------------------------------------------------------------------------
  # * Setup Map
  #--------------------------------------------------------------------------
  def setup_map(sx,sy,tx,ty) #tx and ty in params for external call

    map = Table.new($map.width, $map.height)

    update_counter = 0
    map[tx,ty] = 1
    old_positions = [[tx, ty]]
    new_positions = []

    depth = 2

    depth.upto(100){ |step|
      while !old_positions.empty?

        x,y = old_positions.shift

        if x == sx and y == sy
          #log_scr("WINWINWINW")
          return [true, map, step-1] 
        end

        if map[x,y + 1] == 0 and passable?(x, y, 2) 
          #log_err "IN"
          map[x,y + 1] = step
          new_positions.push([x,y + 1])
        end

        if map[x - 1,y] == 0 and passable?(x, y, 4) 
          map[x - 1,y] = step
          new_positions.push([x - 1,y])
        end

        if map[x + 1,y] == 0 and passable?(x, y, 6) 
          map[x + 1,y] = step
          new_positions.push([x + 1,y])
        end

        if map[x,y - 1] == 0 and passable?(x, y, 8) 
          map[x,y - 1] = step
          new_positions.push([x,y - 1])
        end

      end

      old_positions = new_positions
      new_positions = []

      #log_info (old_positions)
    }
      
    log_err "No Path Found"
    return [false, nil, nil]     

  end


end
"üW#==============================================================================
# ** Game_Event
#==============================================================================

class Game_Event < Game_Character

  attr_reader   :trigger   
  attr_reader   :list          
  attr_reader   :starting  
  
  attr_reader   :name
  attr_reader   :event
  attr_reader   :icon

  attr_accessor :random, :voll

  attr_reader :above
  attr_reader :below
  attr_reader :below2 # For things that are below below, aka very below
  attr_reader :bridge # Behave like a bridge for passability
  attr_reader :faceoff # How far offset is the face for message box
  attr_reader :ysnp # Don't walk past blockers

  attr_reader :page_idx

  attr_reader :deleted, :disabled, :erased

  attr_reader :monster

  attr_reader :save

  attr_reader :width, :height

  attr_reader :turn
      

  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------

  def initialize(event)
    super()

    @event = event
    @id = event.id

    # Hold a random number to be used with @r1, var for @v1
    @random = 0 
    @voll = 0

    # Auto saveloc
    @save = false
    
    @erased = false
    @disabled = $state.disable?(@id)
    @deleted = $state.delete?(@id)

    @starting = false
    @through = true
    @sthrough = false
    @above = false
    @below = false
    @below2 = false
    @bridge = false
    @stairs = false
    @ysnp = false
    @faceoff = 0

    @width = 1
    @height = 1

    @page = nil
    @page_idx = -1

    # Name breakdown
    name = @event.name

    clone_ev = nil
    
    # Clone map clone
    if name.include?('::')
      clone = name.delete('::')
      name = $data.clones[clone].name
      clone_ev = $data.clones[clone]
    elsif name.include?(':')
      clone = name.delete(':')
      clone_ev = $scene.map.event_by_name(clone).event
      name = clone_ev.name
    end

    if name == '' || name == '#'
      @icon = nil
      @name = 'nil'
    else
      data = name.split('#').first.split('.')
      if data.size > 1
        @icon = data[0].strip
        @name = data[1].strip
      else
        @icon = @name = data[0].strip
      end
    end   
    
    # Set pages from clone or event
    if clone_ev
      @pages = clone_ev.pages
    else
      @pages = @event.pages 
    end

    # Restore saved location if relevant
    if $state.loc?(@id)
      loc = $state.getloc(@id)
      moveto(loc[0],loc[1])
    else
      moveto(@event.x, @event.y)
    end
    
    refresh
  end

  def force_clone(src)
      unlock
      clone_ev = $data.clones[src]
      @pages = clone_ev.pages
      refresh
  end

  #--------------------------------------------------------------------------
  # * Clear Starting Flag
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end

  def icon
    return nil if @erased || @disabled || @deleted
    return @icon
  end

  def collide?(x,y)
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  def at?(x,y)
    # Include width and height
    return false if x < @x
    return false if y < @y
    return false if x > @x + @width - 1
    return false if y > @y + @height - 1
    return true
  end

  def mousein
    x,y = *$mouse.position
    #y += 8
    return false if x < screen_x - 16 #+ self.off_x
    return false if x > screen_x + 16 + ((@width-1)*32) #+ self.off_x
    return false if y > screen_y + ((@height-1)*32) #+ self.off_y
    return false if y < screen_y - 32 #+ self.off_y
    return true
  end

  #--------------------------------------------------------------------------
  # * Determine if Over Trigger
  #    is this event under player
  #--------------------------------------------------------------------------
  def over_trigger?
    # If not through situation with character as graphic
    if @character_name != "" and not @through
      # Starting determinant is face
      return false
    end
    # If this position on the map is impassable
    unless $map.passable?(@x, @y, 0)
      # Starting determinant is face
      return false
    end
    # Starting determinant is same position
    return true
  end

  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  def start  
    return if @erased || @deleted || @disabled
    return if !@list || @list.size < 1
    refresh
    @starting = true    

  end

  def stop

    $player.looklike($party.leader)
    
    # Enable the second state if there is one
    state(@id,"second_#{@page_idx}") if !is_second?(@page)

  end

  def find_page
    return nil if @erased || @deleted
    page = @pages.count-1
    while page >= 0
      return page if conditions_met?(page)
      page -= 1
    end
  end

  def conditions_met?(idx)
        #return false if page == 0

        page = @pages[idx]
      
        # DANHAX - check super conditions
        page.list.each{ |line|
      
          if line.code == 108
            comment = line.parameters[0]
            if comment[0] == '?'[0]
              data = comment.split(' ')
              if !condition_applies?(data,idx)
                return false
              end
            end
          end        
        }  

        return true
  end

  # Can also be called by script
  def condition_applies?(cond,idx)
      # cond is [code,data1.....]

    case cond[0]

      # Potion
      when '?potion'
        return false if $party.potion_state != cond[1]

      # Second
      when '?second'
        return false if !conditions_met?(idx-1)
        return false if !state?(@id,"second_#{idx-1}")
       

      # Flag
      when '?flag'
          return true if $debug.disable_flags
          return false if !flag?(cond[1])
      when '?nflag'
          return false if flag?(cond[1])

      # vars
      when '?var'
          return false if !var?(cond[1],cond[2].to_i)
              
      # Progress
      when '?before'
        return false if !$progress.before?(cond[1])
      when '?progress'
        return false if !$progress.progress?(cond[1])
      when '?after'
        return false if !$progress.beyond?(cond[1])

      # States
      when '?state'
        if cond.count > 2
          return false if !$state.state?(gid(cond[1]),cond[2])
        else
          return false if !$state.state?(@id,cond[1])
        end

      when '?nstate'
        if cond.count > 2
          return false if $state.state?(gid(cond[1]),cond[2])
        else
          return false if $state.state?(@id,cond[1])
        end

      # Active Quest
      when '?active'
        return false if !$progress.active?(cond[1])
      when '?inactive'
        return false if $progress.active?(cond[1])
      when '?complete'
        return false if !$progress.complete?(cond[1])
      when '?incomplete'
        return false if $progress.complete?(cond[1])
      when '?quest'
        return false if !$progress.quest?(cond[1])
      when '?anyquest' # Any of these 3 quests will allow
        return false if !$progress.quest?(cond[1]) && !$progress.quest?(cond[2]) && !$progress.quest?(cond[3])

      # Party member check
      when '?boyle', '?boy'
        return false if !$party.has_member?('boy')
      when '?ingrid', '?ing'
        return false if !$party.has_member?('ing')
      when '?myst', '?mys'
        return false if !$party.has_member?('mys')
      when '?robin', '?rob'
        return false if !$party.has_member?('rob')
      when '?hiberu', '?hib'
        return false if !$party.has_member?('hib')
      when '?rowen', '?row'
        return false if !$party.has_member?('row')
      when '?phye', '?phy'
        return false if !$party.has_member?('phy')

      when '?leader'
        return false if $party.leader != cond[1]

      # Inventory
      when '?gold'
        return false if !$party.has_gold?(cond[1].to_i)
      when '?ngold'
        return false if $party.has_gold?(cond[1].to_i)

      when '?item'
        cond[2] = 1 if cond.count < 3
        return false if !($party.item_number(cond[1]) >= cond[2].to_i)
      when '?nitem'
        cond[2] = 1 if cond.count < 3
        return false if ($party.item_number(cond[1]) >= cond[2].to_i)

      when '?chosen'
        return false if $menu.chosen_ev != @id
        return false if $menu.chosen == nil

      when '?partyloc'
        return false if !$party.party_loc_saved?


    end

    return true

  end

  def label_applies?(label)

    label.gsub!(' ',':')

    case label.split(":")[0]

      when '@else'
        return true
      
      when '@first'
        return false if state?(me,"second_#{this.page_idx}")
      when '@second'
        return false if !state?(me,"second_#{this.page_idx}")

      when '@gold'
        return false if $party.gold < label.split(":")[1].to_i

      when '@ngold'
        return false if $party.gold >= label.split(":")[1].to_i

      when '@flag'
        return false if !flag?(label.split(":")[1])
      when '@nflag'
        return false if flag?(label.split(":")[1])


      when '@var'
        return false if $state.varval(label.split(":")[2]) < label.split(":")[3].to_i

      # Direction
      when '@up'
        return false if $player.direction != 8
      when '@down'
        return false if $player.direction != 2
      when '@left'
        return false if $player.direction != 4
      when '@right'
        return false if $player.direction != 6

      # Char in party
      when '@boy'
        return false if !$party.has_member?('boy')    
      when '@ing'
        return false if !$party.has_member?('ing')
      when '@mys'
        return false if !$party.has_member?('mys')
      when '@rob'
        return false if !$party.has_member?('rob')
      when '@hib'
        return false if !$party.has_member?('hib')
      when '@row'
        return false if !$party.has_member?('row')
      when '@phy'
        return false if !$party.has_member?('phy')

      when '@ingonly'
        return false if !($party.active.count == 1)# && $party.active[0] == 'ing')


      # Choices
      when '@a', '@b', '@c', '@d'
        return false if label.split(":")[0] != $scene.hud.message.last_choice

      # Randoms
      when '@r1'
        return false if @random != 1
      when '@r2'
        return false if @random != 2
      when '@r3'
        return false if @random != 3
      when '@r4'
        return false if @random != 4
      when '@r5'
        return false if @random != 5
      when '@r6'
        return false if @random != 6
      when '@r7'
        return false if @random != 7

      # Volls
      when '@v1'
        return false if @voll != 1
      when '@v2'
        return false if @voll != 2
      when '@v3'
        return false if @voll != 3
      when '@v4'
        return false if @voll != 4
      when '@v5'
        return false if @voll != 5
      when '@v6'
        return false if @voll != 6
      when '@v7'
        return false if @voll != 7
      when '@v8'
        return false if @voll != 8

      # Custom witch recruit
      when '@bones' # bones the highest var
        return false if @state.varval('bones') < $state.varval('serpent')
        return false if @state.varval('bones') < $state.varval('chains')
      when '@serpent'
        return false if @state.varval('serpent') < $state.varval('bones')
        return false if @state.varval('serpent') < $state.varval('chains')
      when '@chains'
        return false if @state.varval('chains') < $state.varval('serpent')
        return false if @state.varval('chains') < $state.varval('bones')

    end

    return true

  end

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    @page_idx = find_page
    new_page = @pages[@page_idx] if @page_idx != nil
    setup_page(new_page) if new_page != @page
  end

  def force_refresh
    @page_idx = find_page
    new_page = @pages[@page_idx] if @page_idx != nil
    setup_page(new_page)
  end

  def is_second?(page)

    return if page == nil

    # DANHAX - check super conditions
    page.list.each{ |line|
  
      if line.code == 108
        comment = line.parameters[0]
        if comment[0] == '?'[0]
          data = comment.split(' ')
          return true if data[0] == '?second'
        end
      end        
    }  

    return false

  end  
  
  def setup_page(new_page)

    # Set @page as current event page
    @page = new_page
    if @page
      setup_page_settings
      read_comment_data
    else
      clear_page_settings
    end

    # Clear starting flag
    clear_starting
    
    # Auto event start determinant
    #check_event_trigger_auto

  end
  

  def clear_page_settings
      @character_name = ""
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
  end

  def setup_page_settings
    
    # Set each instance variable
    @character_name = @page.graphic.character_name
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    #XP - VX @opacity = @page.graphic.opacity
    #XP - VX @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil

    @save = false
    @sthrough = false
    @bridge = false
    if @stairs
      $scene.map.remove_forced_terrain(self,2)
      @stairs = nil
    end

    # Do things based on the name
    if @character_name == "!!!"
      @through = true
      @trigger = 1 if @trigger == 0
      if @pattern == 0 && @direction == 2
        @icon = 'T'
      end
    end

    # Change enemy gfx
    if @character_name == "!!Monster"
      @character_name = "Monsters/#{$battle.enemy_types[@pattern]}"
      @monster = @character_name.split("/")[1]
      @trigger = 2
    end

    if @character_name == "Common"
      @direction_fix = true
    end

    if @character_name.include?("Obj-Chests")
      @save = true
    end

  end
  
  def read_comment_data
    comment_data = []

    @list.each{ |line|
      next if line.code != 108
      if line.parameters[0].include?('#')
        comment_data.push(line.parameters[0].split(" "))
      end
    }

    comment_data.each{ |data|
      case data[0]

        when '#above'
          @above = true
          @below = false
        when '#below'
          @below = true
          @above = false
        when '#same'
          @below = false
          @above = false
        when '#below2'
          @below2 = true
        when '#bridge'
          @bridge = true

        when '#stairs'
          @stairs = true
          $scene.map.add_forced_terrain(self,2)

        when '#faceoff'
          @faceoff = data[1].to_i

        when '#floating'
          g = pingpong('off_y',8,1500,:qio)
          self.do(g)

        when '#floating-rock'
          g = go('off_y',6,600,:qio)
          self.do(repeat(seq(g,g.reverse)))

        when '#shaking'
          g = go('off_x',1,80,:qio)
          self.do(repeat(seq(g,g.reverse)))

        when '#drifting'
          pp = pingpong("off_y",10,1600,:qio)
          self.do(pp)
          a = go("off_x",5,800,:qo)
          b = go("off_x",-10,1600,:qio)
          c = go("off_x",5,800,:qio)
          s = seq(a,b,c)
          self.do(repeat(s))

        when '#drifting2'
          pp = pingpong("off_y",-10,1600,:qio)
          self.do(pp)
          a = go("off_x",-5,600,:qo)
          b = go("off_x",10,1400,:qio)
          c = go("off_x",-5,600,:qio)
          s = seq(a,b,c)
          self.do(repeat(s))


        when '#save'
          @save = true

        when '#sthrough'
          @sthrough = true

        when '#opacity'
          self.opacity = data[1].to_i
        when '#hide'
          self.opacity = 0

        when '#width'
          @width = data[1].to_i
        when '#height'
          @height = data[1].to_i
        when '#gfx'

          if @character_name == "!!Prop"
            @character_name = "Props/"+data[1]
          end

          if @character_name.include?("NPC")
            @character_name = "NPCs/"+@character_name.delete("NPC-")+"/"+data[1]
          end

        when "#prop"
          @character_name = "Props/#{data[1]}"
        when "#player"
          @character_name = "Player/#{data[1]}"
        when "#animal"
          @character_name = "Animals/#{data[1]}"
        when "#monster"
          @character_name = "Monsters/#{data[1]}"
        when "#object"
          @character_name = "Objects/#{data[1]}"
        when "#door"
          @character_name = "Doors/#{data[1]}"
        when "#icon"
          @character_name = "Icons/#{data[1]}"
          @icon = 'U' if @character_name.include?('bugs')
        when "#icon-item"
          @character_name = "Icons/items/"+self.name.to_s
          @icon = 'U' if @character_name.include?('bugs')
        when "#icon-potion"
          @character_name = "Icons/potions/"+self.name.to_s
          @icon = 'U' if @character_name.include?('bugs')

        when '#cardicon'
          cards = ['archer','arrow','begger','crown','dagger','false','gold','king','poison','thief']
          cards.each{ |c|
            if $state.state?(@id,'card-'+c)
              @character_name = "Icons/vault/card-#{c}"
            end
          }

        when "#cauldron"
          cauldron_graphic(self)

        when "#spark"
          ox = 0
          oy = 0
          ox = data[2].to_i if data.count > 2
          oy = data[3].to_i if data.count > 3
          $scene.add_spark(data[1],self.real_x/4+16+ox,self.real_y/4+16-10+oy,@id)

        when '#rand-pattern'
          @force_pattern = rand(3)

        when '#rand-dir'
          @direction = [2,4,6].sample

        when '#ox'
          @off_x = data[1].to_i
        when '#oy'
          @off_y = data[1].to_i
        when '#oxcloud'
          @off_x = $cloud

        when '#moblin'
          data.push(1) if data.count < 2
          $scene.add_moblin(self,data[1].to_i)

        when '#disable'
          disable

        when '#fxtrail'
          @fxtrail = data[1]

        when '#ysnp','#YSNP'
          @ysnp = true
          @monster = true

        when '#avoid'
          self.move_type = 4

        when '#T'
          @icon = 'T'
        when '#B'
          @icon = 'B'
        when '#U'
          @icon = 'U'
        when '#I'
          @icon = 'I'
        when '#S'
          @icon = 'S'
        when '#N'
          @icon = ''

        when '#turn'
          @turn = data[1].to_i

        when '#word'
          return if $word == nil
          @character_name = "Props/z#{$word[data[1].to_i,1]}"

      end
    }
    

  end

  #--------------------------------------------------------------------------
  # * Automatic Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # # If trigger is [touch from event] and consistent with player coordinates
    # if @trigger == 2 and @x == $player.x and @y == $player.y
    #   # If starting determinant other than jumping is same position event
    #   if not jumping? and over_trigger?
    #     start
    #   end
    # end

    # If trigger is [parallel process]
    # if @trigger == 4
    #   @interpreter = Interpreter.new()
    #   @interpreter.setup(@list, @event.id)
    #   @interpreter.special = true
    # end


    # If trigger is [auto run]

    if @trigger == 3

      start
      
    end

  end


  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?
      
    if $player.at?(x,y) and [1,2].include?(@trigger)
      start
    end

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super

    # Automatic event starting determinant
    check_event_trigger_auto if @starting == false

    # If parallel process is valid
    # if @interpreter != nil
    #   @interpreter.update
    # end

  end
    
  #--------------------------------------------------------------------------
  # * Save Position
  #--------------------------------------------------------------------------
  def saveloc
    $state.loc(@event.id)
  end

  #--------------------------------------------------------------------------
  # * Temporarily Erase
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    self.opacity = 0
    refresh
  end

  def disable
    @disabled = true
    $state.disable(@id)
    refresh
  end

  def enable
    @disabled = false
    $state.enable(@id)
    refresh
  end

  def delete
    self.x = 0
    self.y = 0
    @deleted = true
    $state.delete(@id)
    self.opacity = 0
    refresh
  end

end"<:#==============================================================================
# ** Interpreter
#==============================================================================

class Interpreter

  attr_accessor :common_event_id

  attr_accessor :wait_count

  attr_accessor :event_id
  
  attr_accessor :battlemap

  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #     main  : main flag
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main

    @common_event_id = 0
    
    # Depth goes up to level 100
    if depth > 100
      print("Common event call has exceeded maximum limit.")
      exit
    end
    
    # Clear inner situation of interpreter
    clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Reset
  #   Remove any queued items 
  #--------------------------------------------------------------------------
  def reset
    @list = nil
  end
  
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # map ID when starting up
    @event_id = 0                     # event ID
    @message_waiting = false          # waiting for message to end
    @move_route_waiting = false       # waiting for move completion
    @wait_count = 0                   # wait count
    @child_interpreter = nil          # child interpreter
    @branch = {}                      # branch data
  end

  #--------------------------------------------------------------------------
  # * Event Setup
  #     list     : list of event commands
  #     event_id : event ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    
    # Clear inner situation of interpreter
    clear
    
    # Remember map ID
    @map_id = $map.id
    
    # Remember event ID
    @event_id = event_id
    
    # Remember list of event commands
    @list = list
    
    # Initialize index
    @index = 0
    
    # Clear branch data hash
    @branch.clear
    
  end
  
  #--------------------------------------------------------------------------
  # * Current event (as event, not id)
  #--------------------------------------------------------------------------
  def event
    return $scene.map.events[@event_id]
  end
  
  #--------------------------------------------------------------------------
  # * Determine if Running
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  
  #--------------------------------------------------------------------------
  # * Starting Event Setup
  #--------------------------------------------------------------------------
  def setup_starting_event
    
    # Refresh map if necessary
    if $scene.map.need_refresh
      $scene.map.refresh
    end
    
    # If common event call is reserved
    if @common_event_id > 0
      
      # Set up event
      setup($data.commons[@common_event_id].list, 0)
      
      # Release reservation
      @common_event_id = 0
      
      return
      
    end
    
    # Loop (map events)
    $scene.map.starting_events.each{ |e| 

        # If not auto run
        #log_sys(e.trigger)
        # MAKES AUTORUN LOOP
        if e.trigger < 3          
          e.clear_starting
          e.lock          
        end
        
        # Set up event

        # Make sure autoruns don't run a second time if disabled
        return if e.disabled || e.deleted || e.erased

        setup(e.list, e.id) 
        
        return      
    }
    
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    
    # Initialize loop count
    @loop_count = 0
    
    # Loop
    loop do

      return if $scene.is_a?(Scene_GameOver)
      
      # Add 1 to loop count
      @loop_count += 1
      
      # If 100 event commands ran
      if @loop_count > 100
        # Call Graphics.update for freeze prevention
        Graphics.update
        @loop_count = 0
      end
      
      # If map is different than event startup time
      if $scene.map.id != @map_id
        # Change event ID to 0
        @event_id = 0
      end
      
      # If a child interpreter exists, run it then check if done
      if @child_interpreter != nil
        @child_interpreter.update
        @child_interpreter = nil if !@child_interpreter.running?  
        return if @child_interpreter != nil        
      end
      
      # If waiting for message to end
      return if @message_waiting

      # Misc hud busy
      return if $scene.is_a?(Scene_Menu)

      return if $scene.is_a?(Scene_Battle) && !battlemap
      return if $scene.busy?


      return if $scene.map.camera_moving?

      # If waiting for move to end
      if @move_route_waiting

        # If player is forcing move route
        if $player.move_route_forcing
          return
        end
        
        # Loop (map events)
        for event in $scene.map.events.values
          
          # If this event is forcing move route
          if event.move_route_forcing
            return
          end
          
        end
        
        # Clear move end waiting flag
        @move_route_waiting = false
        
      end

      
      # If waiting
      if @wait_count > 0
        # Decrease wait count
        @wait_count -= 1
        return
      end



      # If list of event commands is empty
      if @list == nil

 
        # If main map event
        if @main
          # Set up starting event
          setup_starting_event
        end
        
        # If nothing was set up
        if @list == nil
          return
        end
        
      end
      
      # If return value is false when trying to execute event command
      if execute_command == false
        return
      end
      
      # Advance index
      @index += 1
      
    end
  end

    #--------------------------------------------------------------------------
  # * Event Command Execution
  #--------------------------------------------------------------------------
  def execute_command
   
    # If last to arrive for list of event commands
    if @index >= @list.size - 1
      command_end
      return true
    end

    # Make event command parameters available for reference via @parameters
    @parameters = @list[@index].parameters

    # Check if this is a label marker
    # If it is check if applies, if so keep going,
    # Otherwise skip to next label
    if @list[@index].code == 108 && @parameters[0].include?('@')

      # Keep going until a label passes or end of events
      while true

        # No more commands, end it
        if @index >= @list.size - 1
          command_end
          return true
        end

        if @list[@index].code == 108 && this != nil
          break if this.label_applies?(@list[@index].parameters[0])
        end

        @index += 1

      end

    end

    # Branch by command code
    return true if @list[@index].code == 108
    return true if @list[@index].code == 509
    send("command_"+@list[@index].code.to_s)
    
  end
  #--------------------------------------------------------------------------
  # * End Event
  #--------------------------------------------------------------------------
  def command_end

    # Fix for going into battle mid event
    # Cut this or something, change all maps here to $scene.map?
    if $scene.map.events[@event_id] == nil
      @list = nil
      return
    end

    # Clear list of event commands
    @list = nil
    # If main map event and event ID are valid
    if @main and @event_id > 0
      # Unlock event
      $scene.map.events[@event_id].unlock
    end

    # Tell the even that it is stopping so it can mark second
    $scene.map.events[@event_id].stop 

  end

  # #--------------------------------------------------------------------------
  # # * Command Skip
  # #--------------------------------------------------------------------------
  # def command_skip
  #   # Get indent
  #   indent = @list[@index].indent
  #   # Loop
  #   loop do
  #     # If next event command is at the same level as indent
  #     if @list[@index+1].indent == indent
  #       # Continue
  #       return true
  #     end
  #     # Advance index
  #     @index += 1
  #   end
  # end
  # #--------------------------------------------------------------------------
  # # * Get Character
  # #     parameter : parameter
  # #--------------------------------------------------------------------------
  # def get_character(parameter)
  #   # Branch by parameter
  #   case parameter
  #   when -1  # player
  #     return $player
  #   when 0  # this event
  #     events = $map.events
  #     return events == nil ? nil : events[@event_id]
  #   else  # specific event
  #     events = $map.events
  #     return events == nil ? nil : events[parameter]
  #   end
  # end

  # #--------------------------------------------------------------------------
  # # * Calculate Operated Value
  # #     operation    : operation
  # #     operand_type : operand type (0: invariable 1: variable)
  # #     operand      : operand (number or variable ID)
  # #--------------------------------------------------------------------------
  # def operate_value(operation, operand_type, operand)
  #   # Get operand
  #   if operand_type == 0
  #     value = operand
  #   else
  #     value = $game_variables[operand]
  #   end
  #   # Reverse sign of integer if operation is [decrease]
  #   if operation == 1
  #     value = -value
  #   end
  #   # Return value
  #   return value
  # end


    def next_event_code
    @list[@index+1].code
  end

  def queue_text(txt)

  end

    #--------------------------------------------------------------------------
  # * Show Text
  #--------------------------------------------------------------------------
  def command_101

    message = []
    message.push(@list[@index].parameters[0])
    while next_event_code == 401
      @index += 1
      message.push(@list[@index].parameters[0])
    end

    message = message.join(' ')

    # If there is a choice next, add it
    while next_event_code == 101 && @list[@index+1].parameters[0].include?("@")
      @index+=1
      $scene.hud.message.add_choice(@list[@index].parameters[0])
    end

    $scene.hud.message.start(message)

    # If vn mode
    
    #$scene.hud.message.start_vn(message)
    
    # Return mouse to default cursor
    #$mouse.set_cursor('Default')
    
    # Continue
    return true

  end

  #--------------------------------------------------------------------------
  # * Wait
  #--------------------------------------------------------------------------
  def command_106
    @wait_count = @parameters[0]
    return true
  end

  # #--------------------------------------------------------------------------
  # # * Conditional Branch
  # #--------------------------------------------------------------------------
  # def command_111
    
  #   result = eval(@parameters[1])
  #   return true if result
  
  #   # Skip it
  #   @branch[@list[@index].indent] = result
  #   return command_skip
  
  # end
  # #--------------------------------------------------------------------------
  # # * Else
  # #--------------------------------------------------------------------------
  # def command_411
  #   # If determinant results are false
  #   if @branch[@list[@index].indent] == false
  #     # Delete branch data
  #     @branch.delete(@list[@index].indent)
  #     # Continue
  #     return true
  #   end
  #   # If it doesn't meet the conditions: command skip
  #   return command_skip
  # end
 
  # #--------------------------------------------------------------------------
  # # * Exit Event Processing
  # #--------------------------------------------------------------------------
  # def command_115
  #   command_end
  #   return true
  # end

  def command_117
    # Get common event
    common_event = $data.commons[@parameters[0]]
    # If common event is valid
    if common_event != nil
      # Make child interpreter
      @child_interpreter = Interpreter.new(@depth + 1)
      @child_interpreter.setup(common_event.list, @event_id)
    end
    # Continue
    return true
  end

  # #--------------------------------------------------------------------------
  # # * Set Move Route
  # #--------------------------------------------------------------------------
  def command_209
    # Get character
    character = get_character(@parameters[0])
    # If no character exists
    return true if character == nil

    # Force move route - pushes on top of auto movers
    character.force_move_route(@parameters[1])
    return true
  end
  
  # #--------------------------------------------------------------------------
  # # * Wait for Move's Completion
  # #--------------------------------------------------------------------------
    def command_210
      @move_route_waiting = true
      return true
    end

  #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    # Set first line to script
    script = @list[@index].parameters[0] + "\n"
    # Loop
    loop do
      # If next event command is second line of script or after
      if @list[@index + 1].code == 655
        # Add second line or after to script
        script += @list[@index + 1].parameters[0] + "\n"
      # If event command is not second line or after
      else
        # Abort loop
        break
      end
      # Advance index
      @index += 1
    end
    
    # Evaluation
    result = eval(script)

    return true

  rescue Exception => e

    line = e.message.split(":")[1].to_i      
    log_scr e.inspect.split(":in `")[0]
    log_scr e.inspect.split(":in `")[1]

    lc = 0
      script.split("\n").each{ |s|
        if lc == line
          s = "---> "+s
        end
        log_scr s
        lc+=1
      }

    # Continue
    return true
     
  end

end
"C#==============================================================================
# ** Game_Map
#==============================================================================

class Game_Map

  # Keep the zone? 
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :tileset  
  
  # Camera offsets
  attr_accessor :cam_ox, :cam_oy

  attr_accessor :need_refresh             # refresh request flag
  attr_reader   :map_name                 # name of the map
  attr_reader :interpreter
  attr_reader :id

  attr_reader :events
  attr_reader :map
  attr_reader :zone
  attr_accessor :cam_x, :cam_y

  attr_accessor :skip_music_change

  attr_reader :zone


  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize()

    @id = nil

    @interpreter = Interpreter.new(0,true)

    @cam_x = 0
    @cam_y = 0

    @cam_target = $player
    @cam_xy = [0,0]
    @cam_snap = true
    @cam_ox = 0
    @cam_oy = 0#-16
    @cam_dur = nil

    @cam_hy = 0 # Hiding

    @force_terrains = {}

    #self.do(pingpong("cam_ox",50,70,:quad_in_out))
    #self.do(pingpong("cam_oy",-70,350,:quad_in_out))

    @namecache = {}
    @ev_cache = {}

  end

  def name
    return @map_name
  end

  def nice_name
    name = @map_name
    if ['Indoor','Indoor2','Cave','Cave2'].include?(@map_name.split("#")[0].split("@")[0].rstrip)
      # Parent name
      name = find_parent_name(@id)
    end
    return name.split("#")[0].split("@")[0]
  end

  def resetup
    @zone = nil
    setup(@id)
    setup_audio
  end

  def hide
    @cam_hy = 50000
  end

  def show
    @cam_hy = 0
  end
  
  #--------------------------------------------------------------------------
  # * Setup
  #     map_id : map ID
  #--------------------------------------------------------------------------
  def setup(id)

    # If there was an old map, save the locs
    if @id != nil
      @events.values.each{ |e|
        next if !e.save
        $state.loc(e.id)
      }
      $scene.clear_sparks
    end
 
    # Put map ID in @map_id memory
    @id = id
    @namecache = {} # reset each map
    
    # Load map from file and set @map
    @map = load_data(sprintf("Data/Map%03d.rxdata", @id))
    @map_name = $data.mapinfos[id].name 
        
    # Hold onto the tileset
    @tileset = $data.tilesets[@map.tileset_id]        
    @passages = @tileset.passages 
    
    # Initialize displayed coordinates
    @cam_x = 0
    @cam_y = 0
    @target = $player
    
    @need_refresh = false
    

        # Disregard if battle map? or use battle zone?
    # Or various battle zones?

    # What is the zone
    autoplay = false
    newzone = get_zone(@id)
    newzone = "@" + newzone.split("@")[1]

    # if @map_name == 'Indoor'
    #   newzone = '@indoor'
    # end

    if newzone != @zone.id

      #$audio.minimize

      @zone = $data.zones[newzone]

      log_info "Changing Zone: #{newzone}"


      if @zone != nil
        
        $audio.change_mode(@zone.reverb)

        # Init tints and that
        $scene.change_weather(@zone.weather)
        $scene.change_fogs(@zone.fog)
        $scene.change_overlay(@zone.overlay)
        $scene.change_panoramas(@zone.panoramas)

        # Prep enemies for this zone
        $battle.change_enemies(@zone.enemies)
        $battle.change_maps(@zone.battles)

      end

    end

    # Always do overlay change
    $scene.change_overlay(@zone.overlay)

    # Clear forced terrains
    @force_terrains.clear
    $audio.clear_env

    # Set map event data
    @events = {}
    @map.events.keys.each{ |i|

      # Don't respawn
      next if $state.nospawn?(i)

      @events[i] = Game_Event.new(@map.events[i])

      # if @events[i].name == "STAIRS"
      #   @force_terrains[[@events[i].x,@events[i].y]] = 2
      # end

      # Restore loc
      if $state.loc?(i)
        loc = $state.getloc(i)
        @events[i].moveto(loc[0],loc[1])
        @events[i].direction = loc[2]
        @events[i].off_x = loc[3]
        @events[i].off_y = loc[4]
      end
    }

  end

  def add_forced_terrain(e,v)
    x = e.x
    y = e.y
    while x < e.x + e.width
      while y < e.y + e.height
        @force_terrains[[x,y]] = v
        y += 1
      end
      x += 1
      y = e.y
    end
  end

  def remove_forced_terrain(e)
     x = e.x
    y = e.y
    while x < e.x + e.width
      while y < e.y + e.height
        @force_terrains.delete([x,y])
        y += 1
      end
      x += 1
      y = e.y
    end
  end

  def setup_audio

    # Ignore if skip next
    if @skip_music_change
      @skip_music_change = false
      return
    end

    # Fadeout previous
    

    # Play music from the zone
    # No music at night
    $audio.music(@zone.music) if !flag?('night-time')
    $audio.atmosphere(@zone.atmosphere)

  end

  def dispose

  end
  
  def display_x
    # cam_x = @cam_x
    # cam_x = 0 if cam_x < 0
    # w = ($map.width * 128) - ($game.width * 4)
    # cam_x = w if cam_x > w
    return (@cam_x + (@cam_ox*4)).to_i
  end

  def display_y
    
    # cam_y = @cam_y
    # cam_y = 0 if cam_y < 0
    # h = ($map.height * 128) - ($game.height * 4)
    # cam_y = h if cam_y > h
    #log_sys (@cam_y + (@cam_oy*4)).to_i if rand(10) == 4
    return (@cam_y + (@cam_oy*4)).to_i
  end

  #--------------------------------------------------------------------------
  # * Get Tileset ID
  #--------------------------------------------------------------------------
  def tileset_id() return @map.tileset_id end
  def width() return @map.width end
  def height() return @map.height end
  def data() return @map.data end

  #--------------------------------------------------------------------------
  # * Camera
  #--------------------------------------------------------------------------
  def camera_to(ev,dur=nil)
    @cam_target = ev
    @cam_snap = false
    @cam_dur = dur
  end

  def camera_xy(x,y,dur=nil)
    @cam_xy = [x,y]
    @cam_target = nil
    @cam_snap = false
    @cam_dur=dur
  end

  def camera_moving?
    return !$tweens.done?(self)
  end

  def camera_snap
    @cam_snap = true
  end

  def refresh
    @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

  def start_common(id)
    @interpreter.common_event_id = id
  end

  # For moving events
  def cache_clear(x,y,ev)
    @ev_cache[[x,y]] = []
  end

  def cache_push(x,y,ev)
    return if ev == $player
    @ev_cache[[x,y]] = [] if !@ev_cache.has_key?([x,y])
    @ev_cache[[x,y]].push(ev)
  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    # Build event cache
    @ev_cache.clear
    @events.values.each{ |e|
      # Include size of the event
      sx = e.x
      sy = e.y
      (sx..sx+e.width-1).each{ |x| 
        (sy..sy+e.height-1).each{ |y|
          loc = [x,y]
          @ev_cache[loc] = [] if !@ev_cache.has_key?(loc)
          @ev_cache[loc].push(e)
        }
      }

    }

    # If common event is queued, start it
    if $menu.common_event != nil
      @interpreter.common_event_id = $menu.common_event
      $menu.common_event = nil
    end

    @interpreter.update #if @cam_snap
    return if $scene.is_a?(Scene_Menu)
    return if $scene.is_a?(Scene_GameOver)

    update_events

    # Refresh map if necessary
    if @need_refresh
      @events.values.each{ |e| e.refresh }
      @need_refresh = false
    end

    update_camera

    # Mouse update
    # Check what's under, change cursor etc etc, maybe not every frame? only if moving?
    update_mouse    

  end

  def update_events

    # Keep track of starting events and always update those
    @events.values.each{ |e| e.update }

    #  bx = 0#1
    #  by = 0#1

    # x1 = ((display_x/128) - bx).to_i
    # y1 = ((display_y/128) -by).to_i
    # x2 = x1 + 20 + (bx*2)
    # y2 = y1 + 15 + (by*2)

    # updaters = []
    # (x1..x2).each{ |x|
    #   (y1..y2).each{ |y|
    #     evs = events_at(x,y)
    #     if evs != nil
    #       updaters += evs 
    #     end    
    #   }
    # }

    # updaters.uniq.each{ |e| e.update }

  end

  def update_mouse

    if $scene.is_a?(Scene_GameOver) || $scene.hud.busy?
      $mouse.change_cursor('Default')
      return
    end

    if $mouse.y > 448
      $mouse.change_cursor('Default')
      return
    end

    # Mouse position
    mx, my = *$mouse.grid

    # Check 3 x 3 area, use offsets
    ev = event_at(mx,my)
    ev = event_at(mx,my+1) if ev == nil
    ev = event_at(mx,my-1) if ev == nil
    ev = event_at(mx+1,my) if ev == nil
    ev = event_at(mx-1,my) if ev == nil
    ev = event_at(mx-1,my-1) if ev == nil
    ev = event_at(mx-1,my+1) if ev == nil
    ev = event_at(mx+1,my-1) if ev == nil
    ev = event_at(mx+1,my+1) if ev == nil


    # What event is there
    if ev != nil && ev.mousein && ev.character_name != ''

      # Check actual mouse xy to see if inside

      case ev.icon

        when 'S'
          $mouse.change_cursor('Speak')
        when 'I'
          $mouse.change_cursor('Inspect')
        when 'U'
          $mouse.change_cursor('Use')
        when 'B'
          $mouse.change_cursor('Battle')
        when 'T'
          $mouse.change_cursor('Transfer')
        when 'C'
          $mouse.change_cursor('Coins')
        when 'R'
          $mouse.change_cursor('Read')
        else
          $mouse.change_cursor('Default')

      end

    else

      if $map.passable?(mx,my,$player.direction)
        $mouse.change_cursor('Default')
      else
        $mouse.change_cursor('Block')
      end

    end

  end

  def update_camera

    # if @target_x != @display_x
    #   @display_x += [(@target_x-@display_x) * 0.15,cam_speed].min
    # end

    # if @target_y != @display_y
    #   @display_y += [(@target_y-@display_y) * 0.15,cam_speed].min
    # end

    if @cam_target != nil
      new_target_x = @cam_target.real_x- (128 * 9.5)
      new_target_y = @cam_target.real_y- (128 * 7)
    else
      new_target_x = (@cam_xy[0] * 128) - (128 * 9.5)
      new_target_y = (@cam_xy[1] * 128) - (128 * 7)
    end


    # If the target has changed
    if !@cam_snap    

      if (new_target_x != @target_x) || (new_target_y != @target_y)

          @target_x = new_target_x
          @target_y = new_target_y

          #@target_x = 0 if @target_x < 0
          #@target_y = 0 if @target_y < 0

          dx = @target_x - @cam_x
          dy = @target_y - @cam_y

          # Check if close
          x_snap = dx.abs < 10
          y_snap = dy.abs < 10

          if !x_snap
            x_snap = true if @cam_x <= 0 && dx < 0
          end

          if !y_snap
            y_snap = true if @cam_y <= 0 && dy < 0
          end

          can_snap = true if x_snap && y_snap
          

          if can_snap

            @cam_x = @target_x
            @cam_y = @target_y
            @cam_snap = true

          else

            # slide it
            $tweens.clear(self)     

            # Compensate for cam_x or cam_y being off screen, that is, jump to 0
            if @cam_x + dx < 0
              dx = -@cam_x
            end

            if @cam_y + dy < 0
              dy = -@cam_y
            end
            

            dur = (dx.abs + dy.abs) / 2
            if @cam_dur != nil
              dur = @cam_dur
              @cam_dur = nil
            end

            # Limit movement if will go off edge of map

            self.do(go("cam_x",dx,dur,:qio))
            self.do(go("cam_y",dy,dur,:qio))


          end

        end

    end

    if @cam_snap

      @cam_x = new_target_x
      @cam_y = new_target_y

    end

    # Limit cam to screen
    # Maybe do this with display_x
    @cam_x = 0 if @cam_x < 0
    @cam_y = 0 if @cam_y < 0

    w = ($map.width * 128) - ($game.width * 4)
    if $settings.bottombar
      h = (($map.height+1) * 128) - (($game.height) * 4) # Add 32 for bottom bar
    else
      h = (($map.height) * 128) - (($game.height) * 4) # Add 32 for bottom bar
    end

    @cam_x = w if @cam_x > w
    @cam_y = h if @cam_y > h

  end
  #--------------------------------------------------------------------------
  # * Determine if Passable
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil, monster=false)

    return false unless valid?(x, y)

    # Change direction (0,2,4,6,8,10) to obstacle bit (0,1,2,4,8,0)
    bit = (1 << (d / 2 - 1)) & 0x0f

    # Loop all events
    evs = events_at(x,y)
    if evs != nil && (self_event == nil || !self_event.sthrough)
      evs.each{ |e| 
        if e != self_event #and e.at?(x,y)
           return true if e.bridge && [4,6].include?(d) && e.width > 1
           return true if e.bridge && [2,8].include?(d) && e.height > 1
           return false if e.bridge && [2,8].include?(d) && e.height == 1
           return false if e.bridge && [4,6].include?(d) && e.width == 1
           return false if !(e.through || e.above || e.below || e.sthrough)
           return false if (monster || e.ysnp) && e.name == "YSNP"
        end
      }
    end

    # Loop searches in order from top of layer
    [2, 1, 0].each{ |i|

      tile_id = data[x, y, i]

      if $party.leader == 'ship'
        return terrain_tag(x,y) == 7
      end

      # If obstacle bit is set
      return false if @passages[tile_id] & bit != 0
        
      # If obstacle bit is set in all directions
      return false if @passages[tile_id] & 0x0f == 0x0f
        
      # If priorities other than that are 0
      return true if @tileset.priorities[tile_id] == 0

    }

    # passable
    return true

  end

  #--------------------------------------------------------------------------
  # * Determine Thicket
  #--------------------------------------------------------------------------
  def bush?(x, y) return false
   ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x40 == 0x40 }.empty? end
  def counter?(x, y) ![0,1,2].select{ |i| @passages[data[x,y,i]] & 0x80 == 0x80 }.empty? end
  def terrain_tag(x, y)

    # Check in forced terrains
    if @force_terrains.has_key?([x,y])
      return @force_terrains[[x,y]]
    end

    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return 0
        elsif tile_id > 0   # @terrain_tags[tile_id] > 0
          return @tileset.terrain_tags[tile_id]
        end
      end
    end
    return 0
  
  end

  #--------------------------------------------------------------------------
  # * Event At
  #--------------------------------------------------------------------------
  def valid?(x, y) x >= 0 and x < width and y >= 0 and y < height end
  def event_at(x, y) 
    return nil if !@ev_cache.has_key?([x,y])
    return @ev_cache[[x,y]][0]
    #@events.values.find{ |e| e.at?(x,y) } 
  end
  def events_at(x, y) 
    return nil if !@ev_cache.has_key?([x,y])
    return @ev_cache[[x,y]]
    #@events.values.select{ |e| e.at?(x,y) } 
  end
  def lowest_event_at(x, y) nil end #events_at(x,y).min_by{ |e| e.y } end

  def find_other(name,id)
    @events.values.find{ |e| e.name == name && e.id != id }
  end  

  def starting_events() @events.values.select{ |e| e.starting } end

  def event_by_name(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.name == name }
    @namecache[name] = ev
    return ev
  end

  def event_by_evname(name)
    return @namecache[name] if @namecache.has_key?(name)
    ev = @events.values.find{ |e| e.event.name == name }
    @namecache[name] = ev
    return ev
  end

  def all_by_name(name)
     return @events.values.select{ |e| e.name == name }
  end

  #--------------------------------------------------------------------------
  # Find the zone name for this map
  #--------------------------------------------------------------------------
  def get_zone(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return map_zone_or_nil(id)
  end

  # Return zone name, parent map or @nil if top map
  def map_zone_or_nil(id)
    return $data.mapinfos[id].name if $data.mapinfos[id].name.include?('@')
    return '@nil' if $data.mapinfos[id].parent_id == 0
    return map_zone_or_nil($data.mapinfos[id].parent_id)
  end

end"À
class Moblin

	def initialize(ev,delay)

		@ev = ev
		@delay = delay
		@next = 1

	end

	def update

		@next -= 1
		if @next <= 0

			@next = @delay
			@ev.start

		end

	end

end"5#==============================================================================
# ** Game_Player
#==============================================================================

class Game_Player < Game_Character

  attr_accessor :transferring      # player place movement flag
  attr_accessor :trans_type 

  attr_accessor :next_common

  attr_reader :faceoff

  def initialize
    super
    looklike("boy")
    @transferring = false
    @xfer_data = nil
    @trans_type = :cross
    @static = false
    @next_common = nil

    @move_speed = 3.3

    @faceoff = 0 # Here to match event, possibly could have both in char
  end

  def move_speed=(v)
    if v == 3
      v = 3.3
    end
    @move_speed = v
  end

  def transfer(map,x,y,dir)
    w 5
    @transferring = true
    @xfer_data = [map,x,y,dir]
    w 5
  end

  def transfer_to(map,target,after=nil)
    w 5
    @transferring = true
    @xfer_data = [map,target,after]
    w 5
  end

  def name
    return "Player"
  end

  def looklike(char)
    self.character_name = "Player/#{char}"
  end

  def static
    @static = true
  end

  #--------------------------------------------------------------------------
  # * Passable Determinants
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    if DEBUG and Input.press?(Input::CTRL)
      return true
    end
    super
  end

  #--------------------------------------------------------------------------
  # * Same Position Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)

    return false if $map.interpreter.running?

    evs = $map.events_at(@x,@y)
    return false if evs == nil || evs.empty?
    #return false if evs == nil

    action = false

    evs.each{ |ev|
      if triggers.include?(ev.trigger)
          # If starting determinant is same position event (other than jumping)
          if not ev.jumping? and ev.over_trigger?
            ev.start
            action = true
          end

      end
    }

    return action

  end

  #--------------------------------------------------------------------------
  # * Front Envent Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
   
    return false if $map.interpreter.running?

    # Calculate front event coordinates
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    
    evs = $map.events_at(new_x,new_y)
    
    action = false

    if evs != nil
      evs.each{ |ev|

      # All event loops
      #ev = $map.event_at(new_x,new_y)
      if ev != nil

        if triggers.include?(ev.trigger) and ev.list.size > 1

            # If starting determinant is front event (other than jumping)
            if !ev.jumping? and !ev.over_trigger?
              ev.start
              action = true
            end

        end

      end

    }
  end

  return true if action == true

    # COUNTER CHECK

    # If front tile is a counter
    if $map.counter?(new_x, new_y)

      # Calculate 1 tile inside coordinates
      new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
      new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)

      # All event loops
      ev = $map.event_at(new_x,new_y)
      return false if ev == nil

      # If event coordinates and triggers are consistent
      if ev.x == new_x and ev.y == new_y and
         triggers.include?(ev.trigger) and ev.list.size > 1
        # If starting determinant is front event (other than jumping)
        if not ev.jumping? and not ev.over_trigger?
          ev.start
          return true
        end
      end
    end

    return false

  end

  #--------------------------------------------------------------------------
  # * Touch Event Starting Determinant
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
        
    return false if $map.interpreter.running?

    # All event loops
    evs = $map.events_at(x,y)
    return false if evs == nil || evs.empty?

    action = false

    evs.each{ |ev|

      # If event coordinates and triggers are consistent
      if ev.at?(x,y) and [1,2].include?(ev.trigger)
        # If starting determinant is front event (other than jumping)
        if !ev.jumping? and !ev.over_trigger?
            ev.start
            action = true
        end

      end
    }

    return action

  end

  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update

    return if @static

    return super if @move_route_forcing
    return super(true) if ($scene.busy?) || $debug.busy? # Still finish turn anim

    transfer_player if @transferring 

    return super(true) if $map.interpreter.running? # Still finish turn anim

      if @next_common != nil

        $map.start_common(@next_common)
        @next_common = nil

      end

    if @character_name != "Player/#{$party.leader}"
      self.character_name = "Player/#{$party.leader}"
    end

    # Try menu here
    if !moving? && $menu.menu_page != nil
      clear_path
      $game.queue = Scene_Menu.new
      return
    end

    # Unless Interpretter Running, Forcing a Route or Message Showing
    #if ($settings.bottombar == false || $mouse.y < 448) && ($input.click? || ($keyboard.state?(VK_LBUTTON) && rand > 0.8))
    if ($settings.bottombar == false || $mouse.y < 448) && $input.click?

        # Gets Mouse X & Y
        mx, my = *$mouse.grid

                
        # Turn Character in direction
        #turn_toward_pos(mx,my)
        
        # Run Pathfinding
        @event_at_path = $map.event_at(mx, my)
        @event_at_path = nil if @event_at_path && @event_at_path.through
        if @event_at_path == nil

          # If walk to empty pos, show fx
          if $map.passable?(mx,my,$player.direction)
            $audio.sys('walkto',0.7)
            $scene.add_spark('click',$mouse.x+($map.display_x/4),$mouse.y+($map.display_y/4))
          end

          find_path(mx, my)
          #@eventarray = @runpath ? $map.events_at(mx, my) : nil
        else

          # Flash target event
          flash(@event_at_path)
          $audio.sys('walkto',0.7)

          @turn_after_path = nil

          dx = @x - @event_at_path.x
          dy = @y - @event_at_path.y

          x = @event_at_path.x
          y = @event_at_path.y

          can_up = $map.passable?(x,y-1,2)
          can_down = $map.passable?(x,y+1,8)
          can_left = $map.passable?(x+1,y,4)
          can_right = $map.passable?(x-1,y,6)

          # Vile
          if dx.abs > dy.abs && (can_left || can_right)
            if can_left && can_right
              if dx > 0
                find_path(@event_at_path.x+1, @event_at_path.y)
                @turn_after_path = 'l'
              else
                find_path(@event_at_path.x-1, @event_at_path.y)
                @turn_after_path = 'r'
              end
            else
              if can_left
                find_path(@event_at_path.x+1, @event_at_path.y)
                @turn_after_path = 'l'
              elsif can_right
                find_path(@event_at_path.x-1, @event_at_path.y)
                @turn_after_path = 'r'
              end
            end
          end

          # Only if no path set
          if @turn_after_path == nil && (can_up || can_down)
            if can_up && can_down
              if dy > 0
                find_path(@event_at_path.x, @event_at_path.y+1)
                @turn_after_path = 'u'
              else 
                find_path(@event_at_path.x, @event_at_path.y-1)
                @turn_after_path = 'd'                
              end
            else
              if can_down
                find_path(@event_at_path.x, @event_at_path.y+1)
                @turn_after_path = 'u'
              elsif can_up
                find_path(@event_at_path.x, @event_at_path.y-1)
                @turn_after_path = 'd'
              end
            end
          end

          # NOTHING, try counter
          if $map.counter?(x,y-1)
            find_path(@event_at_path.x, @event_at_path.y-2)
            @turn_after_path = 'd'
          end
          if $map.counter?(x,y+1)
            find_path(@event_at_path.x, @event_at_path.y+2)
            @turn_after_path = 'u'
          end

        end
                
      end
    
    if @move_route_forcing == true
      clear_path
      @event_at_path = nil
    end

    # Clear path if any direction keys pressed
    clear_path if $input.dir4 != 0
    
    # Remember whether or not moving in local variables
    last_moving = moving?
    # If moving, event running, move route forcing, and message window
    # display are all not occurring
    unless moving? || $map.interpreter.running? || @move_route_forcing
      case $input.dir4
        when 2; move_down
        when 4; move_left
        when 6; move_right
        when 8; move_up
      end
    end

    # Remember coordinates in local variables
    last_real_x = @real_x
    last_real_y = @real_y

    super
   
    # If not moving
    unless moving?
      
      # If player was moving last time
      if last_moving
        # Event determinant is via touch of same position event
        result = check_event_trigger_here([1,2])
      end

      # If C button was pressed
      if $input.action?
        # Same position and front event determinant
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
        return
      end

      unless @runpath == true

        if @event_at_path != nil
          case @turn_after_path
            when 'd'
              @direction = 2
            when 'l'
              @direction = 4
            when 'r'
              @direction = 6
            when 'u'
              @direction = 8
          end

          # Check if event is adjacent OR counter between
          dx = (self.x - @event_at_path.x).abs
          dy = (self.y - @event_at_path.y).abs
          if dx + dy == 1
            @event_at_path.start
          end
          if @direction == 8 && $map.counter?(@x,@y-1)
              @event_at_path.start
          end
          if @direction == 2 && $map.counter?(@x,@y+1)
              @event_at_path.start
          end
          @event_at_path = nil

        end

      end

    end

  end

  #--------------------------------------------------------------------------
  # * Teleport the Player
  #--------------------------------------------------------------------------
  def transfer_player

    Graphics.freeze
   
    @transferring = false
    $player.clear_path

    old_zone = $map.zone.id

    # Map to teleport to 
    if $map.id != @xfer_data[0]
      $map.setup(@xfer_data[0])      
    end

    if @xfer_data.count == 3

      ev = gev(@xfer_data[1])
      
      if @xfer_data[2] != nil
        case @xfer_data[2]
          when 'd'
            @direction = 2
          when 'l'
            @direction = 4
          when 'r'
            @direction = 6
          when 'u'
            @direction = 8
        end
      end
      dx = 0
      dy = 0
      dx = 1 if @direction == 6
      dx = -1 if @direction == 4
      dy = 1 if @direction == 2
      dy = -1 if @direction == 8

      tx = ev.x + dx
      ty = ev.y + dy

      if ev.width > 1
        tx += ev.width/2
      end

      if ev.height > 1
        ty += ev.height/2
      end

    else

      tx = @xfer_data[1]
      ty = @xfer_data[2]
      @direction = @xfer_data[3]

    end

      $player.moveto(tx,ty)


      #$player.direction = @xfer_data[3]

      $player.straighten  

      $game.update

      # If next zone is different, start fading?
      if $map.zone.id != old_zone
        $audio.fadeout      
      end

      case @trans_type

        when :instant
          Graphics.transition(0)

        when :cross
          Graphics.transition(16)

        when :cave
          $scene.black.opacity = 255
          Graphics.transition(45,'Graphics/Transitions/cave') 
          Graphics.freeze
          $scene.black.opacity = 0
          Graphics.transition(45,'Graphics/Transitions/cave_inv')   

        when :fade
          $scene.black.opacity = 255
          Graphics.transition(45) 
          Graphics.freeze
          $scene.black.opacity = 0
          Graphics.transition(45)    

      end



      # Now do the zone etc
      $map.setup_audio

      #camera snap
      camera_snap

      # Start common event if there is a queue
      # if @next_common != nil

      #   $map.start_common(@next_common)

      # end

    #end

    # AUTO SAVING

    # autosave your game (but not on the ending map)
    $menu.player_x = screen_x
    $menu.player_y = screen_y
    $game.snapshot = Graphics.snap_to_bitmap

    # Force camera on player after xfer
    camera_snap

    $files.autosave
   # if !ENDING_MAPS.include?($game_map.map_id)
   #   save = Scene_Save.new(1)
   #   save.autosave      
   # end
    
  end

end
""8
class Game_Battle

  attr_accessor :map, :weather

  attr_reader :enemies
  attr_reader :minion

  attr_reader :allies

  attr_reader :enemy_types # Enemies for the current zone
  attr_reader :enemy_list # 

  attr_reader :queue # Battle actions, texts and skills

  attr_accessor :next_map

  attr_accessor :victory_text

	def initialize

    @enemy_types = []

    @enemy_list = []
		@enemies = []

    @allies = []

    @props = []

    @actor_index = 0

    @queue = {} # Should it have turn #?

    @skip_minion = false # Don't have minion next battle

    @default_map = 65
    @zone_maps = []
    @next_map = nil

    @victory_text = nil

	end

  # Enemies for this zone from zone data
  def change_enemies(enemies)
    @enemy_types = enemies.split("\n")
  end

  def clear
    @skip_minion = false # Put minion back on
    @enemy_list = []
    #@enemies.each{ |e| e.dispose }
    @enemies = []
    #@props.each{ |p| p.dispose }
    @allies = []
    @props = []
    @queue = {}
    $party.all_battlers.each{ |a| a.ev = nil; a.view = nil }
  end

  def change_maps(maps)
    @zone_maps = maps
  end

  def add(enemy)
    battler = Game_Battler.new
    battler.init_enemy(enemy)
    @enemy_list.push(enemy)
    @enemies.push(battler)
  end

  def add_ally(ally)
    battler = Game_Battler.new
    battler.init_ally(ally)
    @allies.push(battler)
  end

  def skip_minion
    @skip_minion = true
  end

  # Queue up skills to use before battle starts
  def queue_skill(enemy_id,skill_id,turn=1)
    @queue[turn] = [] if !@queue.has_key?(turn)
    @queue[turn].push([:skill,enemy_id,skill_id])
  end

  # Queue up text for scene before battle
  def queue_text(txt,turn=1)
    @queue[turn] = [] if !@queue.has_key?(turn)
    @queue[turn].push([:text,txt])
  end

  def queue_escape(turn=1)
    @queue[turn] = [] if !@queue.has_key?(turn)
    @queue[turn].push([:escape])
  end

  def queue_join(who,turn=1)
    @queue[turn] = [] if !@queue.has_key?(turn)
    @queue[turn].push([:join,who])
  end

  def setup(src_event)

    # Find all enemies in the group
    $map.all_by_name(src_event.name).each{ |mon|

      # Add this guy to battle using name
      enemy = mon.monster
      add(enemy)

    }

    start

  end

  def replace_with_loot(src_event)

    $map.all_by_name(src_event.name).each{ |mon|
      # Add this guy to battle using name
      $state.nospawn(mon.id) if !src_event.name.include?("*")
      mon.force_clone("loot")
    }

  end

  def xp_total
    total = 0
    @enemies.each{ |enemy|
      total += enemy.xp.to_i if enemy.xp != nil
    }
    return total
  end

  def loot_for(src_event)

    drop_loot($data.enemies[src_event.monster])

  end

  def drop(a)
    drop_loot($data.enemies[a])
  end

  def drop_loot(data)

    # Check drops first
    if data.drops != nil
      data.drops.split("\n").each{ |item|

        # If possible, give it
        dta = item.split("=>")
        type = dta[1]
        req = dta[2]
        #chance = dta[3].to_f
        next if rand > 0.4
        pass = case type
            when 'q'
              $progress.quest_active?(req)
            when 'f'
              $state.flag?(req)
            when 'i'
              $party.has_item?(req)
          end
        if pass
          return item(dta[0])
        end
      }
    end

    # Cutting gold chance
    chance = rand

    if chance < 0.12

        # Nothing!
        return pop_nothing         

    end

    if chance < 0.6 && data.loot != nil && data.loot != ''
      possible = []
      data.loot.split("\n").each{ |item| 
        dta = item.split("=>")
        dta[1].to_i.times{
          possible.push(dta[0])
        }
      }
      return item(possible.sample)
    end

    # Check gold
    if data.gold != nil && data.gold != ''
      golds = data.gold.split("-")
      return gold(golds[0].to_i + rand(1+golds[1].to_i-golds[0].to_i))
    end


    return pop_nothing 

  end

  def start

    # Prep the minion
    min = $party.get('boy').slot('minion')
    min = nil if @skip_minion
    if min == nil
      @minion = nil
    else
      @minion = $party.get(min.sub("boy-",""))
    end

    # Set the map for this battle, whether custom or from zone data
    if @next_map
      @map = @next_map
      @next_map = nil
    else
      if @zone_maps
        @map = @zone_maps.split(",").sample.to_i
      else
        @map = @default_map
      end
    end

    $scene.hud.hide
    $scene.overlay.opacity = 0
    $game.push_scene(Scene_Battle.new)

    # Fade in from black
    $scene.black.opacity = 255
    $scene.black.do(to("opacity",0,-5))
    
  end

  def victory?
    return @enemies.select{ |e| !e.down? }.empty?
  end


  def build_attack_queue

    @allies = [] if @allies == nil
    queue = $party.active_battlers + @allies + @enemies 

    # Add minion if there is
    if $party.active.include?('boy') && $battle.minion != nil
      minion = $party.get('boy').slot('minion')
      minion = minion.sub("boy-","")
      queue.push($party.get(minion))
    end

    # Sort by priority, random within same
    return queue.sort_by{ |battler| [battler.attack_priority,rand] }


  end

  def build_attack_plan(attacker)

    plan = Attack_Plan.new

    skill = nil
    if attacker.action == "items"
      skill = $data.items[attacker.item_id]
    else
      skill = $data.skills[attacker.skill_id]
    end

    # How many times does this skill hit
    hits = calc_hits(skill)

    hits.times{ |t|

      round = Attack_Round.new
      round.text = skill.text if skill.text && skill.text.length > 0
      round.anim = skill.anim
      round.skill = skill

      plan.add(round)
    }

    # Add followup attacks


    # Use up the item or mana for the skill used
    # Put it in the attack plan probably


    return plan

  end

  # Happens at the time of using the skill
  # Uses states applied etc realtime
  def build_attack_results(attacker,skill)

    results = []

    # Attack already has skill selected, and targets if scope requires
    targets = build_target_list(attacker,skill)

    # Calculate damage per target i suppose
    targets.each{ |t|

      result = Attack_Result.new

      result.target = t
      # Check damage effects

      dmg_base = 0
      dmg_p = 0.0
      dmg_mod = 0.0 # 1.0 is use str number as damage

      heal_base = 0
      heal_p = 0.0

      is_dmg = false
      is_heal = false

      # Specials
      is_half_armor = true
      empower = false

      # Items have actions, skills have effects, they are the same
      effects = nil
      if skill.is_a?(UsableData)
        effects = skill.action
      else
        effects = skill.effects
      end

      effects.split("\n").each{ |effect|
        data = effect.split("=>")      
        case data[0]
          
          # Damage
          when 'dmg-base'
            dmg_base = data[1].to_i
            is_dmg = true
          when 'dmg-p'
            dmg_p = data[1].to_i
            is_dmg = true
          when 'dmg-mod'
            dmg_mod = data[1].to_f
            is_dmg = true

          # Heals
          when 'heal'
            heal_base = data[1].to_i
            is_heal = true
          when 'heal-p'
            heal_p = data[1].to_f
            is_heal = true

          # Mana
          when 'gain-mana'
            result.gain_mana = data[1].to_i

          # States
          when 'state-add'
            result.state_add = data[1]
          when 'state-remove'
            result.state_remove = data[1]

          # Misc
          when 'transform'
            result.transform = data[1]
          when 'half-armor'
            is_half_armor = true
          when 'empower'
            result.empower = true
          when 'steal'
            result.steal = true
          when 'pocket'
            result.pocket = true
          when 'escape'
            result.escape = true
            
        end
      }

      # ---------------------------------------------
      # CRITS, EVADES, RESISTS
      # ---------------------------------------------

      # Calc evade
      result.evade = rand(100) < t.eva
      result.evade = false if is_heal

      # Calc crit
      result.critical = rand(100) < t.luk || attacker.state?('crit')
      result.critical = false if result.evade

      # Calc resist if state added and its a bad one?
      if result.state_add != nil
        if !['minion-double','crit','protect','curse-life'].include?(result.state_add)
          result.resist = rand(100) < t.res
          if result.resist
            result.state_add = nil
          end
        end
      end

      # --------------------------------------------
      # DAMAGE
      # --------------------------------------------
      # Calc Damage
      result.damage = dmg_base + (attacker.str * dmg_mod)
      result.damage += t.maxhp * dmg_p

      # Add variation
      variation = result.damage * 0.2
      result.damage = (result.damage - variation/2) + (variation * rand)

      # Reduce by armor, less sometimes
      if is_half_armor
        result.damage -= (t.def/2) 
      else
        result.damage -= (t.def)
      end

      # Critical effect
      result.damage *= 1.8 if result.critical

      
      # ---------------------------------------------
      # HEALING
      # ---------------------------------------------
      result.heal = heal_base
      result.heal += t.maxhp * heal_p
      result.heal *= 1.5 if result.critical

      # ---------------------------------------------
      # TIDY
      # ---------------------------------------------

      # If there was no attack, don't have a damage amount
      if result.damage <= 0
        result.damage = is_dmg ? 1 : 0
      end

      if result.evade
        result.damage = 0
      end

      # ---------------------------------------------
      # HACKS
      # ---------------------------------------------

      if t.state?('curse-life')
        if result.damage >= t.hp
          result.damage = t.hp-1
        end
      end

      # Custom hacking
      if skill.id == 'pounce' 
        if t.state?('bleed')
          result.damage *= 2
        end
      end

      # If empowered, double the dmg
      if attacker.state?('empower')
        result.damage *= 2
      end

      # Animal trinks
      if ['acc-frog-boots'].include?(attacker.slot('acc'))
        result.damage *= 1.3
      end

      if t.state?('protect')
        result.damage *= 0.2
      end

      # ---------------------------------------------
      # DONE HERE
      # ---------------------------------------------
      results.push(result)

    }

    return results    

  end


  def possible_targets(attacker)

    data = nil
    if attacker.action == "items"
      data = $data.items[attacker.item_id]
    else
      data = $data.skills[attacker.skill_id]
    end

    if data.scope == 'one'
      return $battle.attackable_enemies
    elsif data.scope == 'ally'
      return $party.attackable_battlers
    elsif data.scope == 'down'
      return $party.active_battlers
    end

  end

  def build_target_list(attacker,skill)

    # Get scope, prepare targets, return list
    case attacker.scope

      when 'one', 'ally', 'down'

        # Will be in attacker, already chosen
        targets = [attacker.target]

        # If the target is not attackable, do somethingelse
        # TODO TODO
        return targets

      when 'rand' # Single random target

        # Hack boyle bug
        if attacker.skill_id == 'xform-bug'
          return [$party.get('boy')]
        end

        if attacker.is_good?
          return [@enemies.select{ |b| b.attackable? }.sample]
        else
          return [$party.active_battlers.select{ |b| b.attackable? }.sample]
        end

      when 'two'

        # Random 2
        if attacker.is_good?
          return @enemies.select{ |b| b.attackable? }.sample(2)
        else
          return $party.active_battlers.select{ |b| b.attackable? }.sample(2)
        end

      when 'three'

        # Random 3
        if attacker.is_good?
          return @enemies.select{ |b| b.attackable? }.sample(3)
        else
          return $party.active_battlers.select{ |b| b.attackable? }.sample(3)
        end

      when 'all'

        # All enemy
        if attacker.is_good?
          return @enemies.select{ |b| b.attackable? }
        else
          return $party.active_battlers.select{ |b| b.attackable? }
        end

      when 'allies'

        # All allies
        if attacker.is_good?
          return $party.active_battlers.select{ |b| b.attackable? && b != attacker }
        else          
          return @enemies.select{ |b| b.attackable? && b != attacker }
        end

      when 'party'

        # All allies
        if attacker.is_good?
          return $party.active_battlers.select{ |b| b.attackable? }
        else          
          return @enemies.select{ |b| b.attackable? }
        end

      when 'any'
        targets = $party.active_battlers.select{ |b| b.attackable? }
        targets.count.times{
          targets += (@enemies.select{ |b| b.attackable? })
        }

        return [targets.sample]

      when 'self'

        return [attacker]

    end

    return []

  end

  def calc_hits(skill)
    return 1 if skill.is_a?(UsableData)
    hits = skill.hits
    if hits.include?("-")
      data = hits.split("-")
      low = data[0].to_i
      high = data[0].to_i
      return (low + rand(high-low)).ceil
    else
      return skill.hits.to_i
    end
  end

  def get_targetable(attacker)

    case $data.skills(attack.skill_id).scope

      when 'one'

      when 'ally'

      when 'down'

    end

  end

  def attackable_enemies
    return @enemies.select{ |a| a.attackable? }
  end

  def all_battlers
    return @enemies + $party.all_battlers
  end
  
end"'
# Menu state
# Hold cursor positions, current character etc etc etc

class MenuState

	attr_accessor :char
	attr_accessor :shop
	attr_accessor :grid_action # <- menu selection

	attr_accessor :menu_page
	attr_accessor :sub_only

	attr_accessor :menu_cursor
	attr_accessor :char_cursor

	# Item chosen from item list
	attr_accessor :use_item
	attr_accessor :common_event

	# Page of the potions book to keep open
	attr_accessor :potion_page

	attr_accessor :chosen
	attr_accessor :chosen_ev
	attr_accessor :choose_cat


	# Player position for saving
	attr_accessor :player_x
	attr_accessor :player_y

	#attr_accessor :category
	#attr_accessor :tab

	def initialize

		@char = 'boy'
		@shop = []

		@menu_page = nil
		@sub_only = false		

		@menu_cursor = "Journal"
		@char_cursor = 'Equip'

		@use_item = nil
		@common_event = nil

		@potion_page = 0

		@chosen = nil
		@chosen_ev = nil
		@choose_cat = nil
		
	end

	def shop_init
		@shop = []
	end

	def shop_add(item)
		@shop.push(item)
	end

end"¢+#==============================================================================
# ** Game_Party
#==============================================================================

class Game_Party

  attr_accessor :active                  # actors
  attr_accessor :reserve                  # reserve party

  attr_reader   :gold                     # amount of gold
  attr_reader   :magics                     # amount of magics

  attr_accessor :all_actors

  attr_accessor :leader

  attr_reader :items, :potions

  # Potion making vars
  attr_accessor :potion_state, :potion_level, :potion_id, :potion_item

  # Passives
  attr_accessor :passive_shop, :passive_scare, :passive_cheekis

  attr_accessor :difficulty

  # HACKS
  attr_accessor :boy_mp_bonus


  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize

    $party = self

    # Create all actors    
    # Will also create minions
    @actors = {}
    $data.actors.each{ |k,v| 
      battler = Game_Battler.new
      if k.include?('minion')
        battler.init_minion(k)
      else
        battler.init_actor(k)
      end
      @actors[k] = battler 
    }

    # Create actor array
    @active = []
    @reserve = []
    @backup = nil # When the party is disolved, this will rebuild

    # Inventory
    @items = {}
    @gold = 250
    @magics = 0

    # Party stats
    @luck = 0 # Cut probably

    # Other things you can have
    @potions = [] # Like inventory? Do you even need to learn these? You just have the items?
    
    # Current state of potions
    @potion_state = :empty # Current potion in progress
    @potion_id = nil # Potion being made once in hack state
    @potion_level = 0 # How many hacks have been completed
    @potion_item = nil # What tool you are using

    # Location when ingrid leaves
    @party_loc = nil

    @difficulty = 'normal'

    # Hacks
    @boy_mp_bonus = 0

    # Hardcode Party Init
    init_party

  end

  #--------------------------------------------------------------------------
  # * Getting Maximum Level
  #--------------------------------------------------------------------------
  def max_level
    return @actors.max_by(&:level).level
  end

  def get(a)
    return actor_by_id(a)
  end

  def actor_by_id(actor)
    return @actors[actor]
  end

  def actor_by_index(idx)
    return @actors[@active[idx]]
  end

  def active_battlers
    return @active.map{ |a| @actors[a] }
  end

  def all_battlers
    return (@active+@reserve).map{ |a| @actors[a] }
  end

  def attackable_battlers
    return active_battlers.select{ |a| a.attackable? }
  end

  def alive_battlers
    return active_battlers.select{ |a| !a.down? }
  end

  def alive_members
    return @active.map{ |a| @actors[a] }.select{ |a| !a.down? }
  end

  def recover_all
    # sfx 'inn'
    @actors.values.each{ |a| a.recover_all }
  end
  
  #--------------------------------------------------------------------------
  # * Add an Actor
  #     actor_id : actor ID
  #--------------------------------------------------------------------------
  def set_active(actor)

    # If already active, forget it
    return if @active.include?(actor)

    # If active is full, somebody gets removed
    if @active.count > 3
      set_reserve(@active[3])
      @active.delete(@active[3])
    end

    # Make sure this actor is not in reserve
    @reserve.delete(actor)
      
    if actor == 'boy'
      @active.unshift(actor)
    else
      @active.push(actor)
    end

  end

  def set_reserve(actor)

    # If already active, forget it
    return if @reserve.include?(actor)

    # If active is full, somebody gets removed
    if @reserve.count > 3
      set_active(@reserve[3])
      @reserve.delete(@reserve[3])
    end

    # Make sure this actor is not in active
    @active.delete(actor)
      
    @reserve.push(actor)

  end

  def back_to_pavillion(actor)
    @active.delete(actor)
    @reserve.delete(actor)
  end

  def backup_party
    @backup = [@active.dup,@reserve.dup]
    @active = []
    @reserve = []
  end

  def restore_party
    @active = @backup[0]
    @reserve = @backup[1]
    @backup = nil
  end


  def swap(a,b)
    return if a == b

    first = nil
    dta = a.split('.')
    if dta[0] == 'a'
      first = @active[dta[1].to_i]
    else
      first = @reserve[dta[1].to_i]
    end

    second = nil
    dta2 = b.split('.')
    if dta2[0] == 'a'
      second = @active[dta2[1].to_i]
    else
      second = @reserve[dta2[1].to_i]
    end

    # Put second in first
    if dta[0] == 'a'
      @active[dta[1].to_i] = second
    else
      @reserve[dta[1].to_i] = second
    end

    # Put first in second
    if dta2[0] == 'a'
      @active[dta2[1].to_i] = first
    else
      @reserve[dta2[1].to_i] = first
    end

    @active.compact!
    @reserve.compact!

  end


  def all
    return @active + @reserve
  end

  def get_next(mem)
    idx = all.index(mem)
    idx += 1
    if idx >= all.count
      idx = 0
    end
    return all[idx]
  end

  def get_prev(mem)
    idx = all.index(mem)
    idx -= 1
    if idx < 0
      idx = all.count - 1
    end
    return all[idx]
  end

  #--------------------------------------------------------------------------
  # * Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def add_item(id,n=1) 
    @items.has_key?(id) ? @items[id] += n : @items[id] = n
    @items.delete(id) if @items[id] <= 0 
    $map.need_refresh = true if $map
  end

  def lose_item(id,n=1) add_item(id,-n) end
  
  def item_number(id) return @items.has_key?(id) ? @items[id] : 0 end
  def has_item?(id) item_number(id) > 0 end


  def add_gold(n)
    @gold += n
    @gold = 0 if @gold < 0
    $map.need_refresh = true
  end

  def has_gold?(n)
    return @gold >= n
  end


  def add_magics(n)
    @magics += n
    @magics = 0 if @magics < 0
  end

  def has_magics?(n)
    return @magics >= n
  end



  def item_list
    items = []
    @items.each{ |k,v|
      items.push(k) if v > 0
    }
    return items
  end

  def battle_item_list
    return @items.keys.select{ |i| 
      $data.items[i].is_a?(UsableData) && !$data.items[i].action.include?("common")
    }
  end

  def defeated?
    return @active.select{ |a| !@actors[a].down? }.empty?
  end
   
  def has_member?(guy)
    return (@active + @reserve).include?(guy)
  end

  #--------------------------------------------------------------------------
  # ‚óè Party Location to return to
  #--------------------------------------------------------------------------
  def save_party_loc
    @party_loc = [$map.id,$player.x,$player.y,$player.direction]
  end

  def restore_party_loc
    $player.transfer(@party_loc[0],@party_loc[1],@party_loc[2],$player.direction)    
    @party_loc = nil
  end

  def party_loc_saved?
    return @party_loc != nil
  end


  #--------------------------------------------------------------------------
  # ‚óè Initialize Party Data
  #--------------------------------------------------------------------------

  def init_party

    @leader = 'boy'

    # -----------------------------------
    # Initial Party Members
    # -----------------------------------

    set_active("boy")
    set_active("rob")
    #set_active("ing")
    #set_active("mys")
    # set_active("rob")
    # set_reserve("hib")
    # set_reserve("row")
    # set_reserve("phy")   
  
    # ----------------------------------
    # Initial Gear

    # Boyle
    @actors['boy'].equip('staff','boy-staff')
    @actors['boy'].equip('mid','boy-arm-start')
    @actors['boy'].equip('minion','boy-minion-fang')

    # Ingrid
    @actors['ing'].equip('wand','ing-wand-start')
    @actors['ing'].equip('athame','ing-athame-start')
    @actors['ing'].equip('light','ing-arm-start')

    # Myst
    @actors['mys'].equip('claw1','mys-claw-start')
    @actors['mys'].equip('claw2','mys-claw-start')
    @actors['mys'].equip('light','mys-arm-start')

    # Robin
    @actors['rob'].equip('sword','rob-hammer-start')
    @actors['rob'].equip('heavy','rob-arm-start')

    # Hiberu
    @actors['hib'].equip('charm','hib-charm-start')
    @actors['hib'].equip('book','hib-book-sleep')
    @actors['hib'].equip('mid','hib-arm-start')
    # Give accessory

    # Rowen
    @actors['row'].equip('wrench','row-wrench-start')
    @actors['row'].equip('gadget','row-gadget-satchel')
    @actors['row'].equip('mid','mid-arm-tor')
    # Give extra gadget

    # Phye
    @actors['phy'].equip('dsword','phy-sword-1')
    @actors['phy'].equip('heavy','phy-arm-start')
    @actors['phy'].equip('helm','phy-helm-start')
    @actors['phy'].equip('belt','phy-belt-start')
    

    # Initial skills per actor
    @actors["boy"].learn('staff')
    @actors["boy"].learn('contempt')
    #@actors["boy"].learn('flames')

    @actors['ing'].learn('wand')
    @actors['ing'].learn('mudball')
    @actors['ing'].learn('missiles')

    # @actors['ing'].learn('curse-life')    
    # @actors['ing'].learn('curse-death')    
    # @actors['ing'].learn('curse-pain')    

    # @actors['ing'].learn('ens-escape')    
    # @actors['ing'].learn('ens-enslave')    
    # @actors['ing'].learn('ens-surrender')    

    # @actors["ing"].learn('xform-frog')
    # @actors["ing"].learn('xform-bug')
    # @actors["ing"].learn('xform-snake')
    # @actors["ing"].learn('xform-cat')
    # @actors["ing"].learn('xform-bear')
    # @actors["ing"].learn('xform-goat')
    # @actors["ing"].learn('xform-squirrel')

    @actors['mys'].learn('envelop')
    @actors['mys'].learn('soothe')
    @actors['mys'].learn('four-legs')
    @actors['mys'].learn('pounce')
    @actors['mys'].learn('swipe')
    @actors['mys'].learn('two-legs')

    @actors['rob'].learn('bash')
    @actors["rob"].learn("team-boy")
    # @actors["rob"].learn("team-ing")
    # @actors["rob"].learn("team-mys")
    # @actors["rob"].learn("team-row")
    # @actors["rob"].learn("team-hib")
    # @actors["rob"].learn("team-phy")

    @actors['hib'].learn('claw')

    @actors['row'].learn('clobber')
    @actors['row'].learn('gadget')
    @actors['row'].learn('blade-waltz')


    @actors['phy'].learn('strike')
    @actors['phy'].learn('provoke')
    @actors['phy'].learn('dragon-fire')

    # Start items
    add_item('flip-deck')
    add_item('cheese')
    add_item('cheese')
    add_item('haunch')


    # Sample items
    # add_item('covey')
    # add_item('haunch')
    # add_item('bread')
    # add_item('cheese')
    # add_item('vamp-teeth')
    # add_item('doll')
    # add_item('quarter-map')
    # add_item('ticket')
    # add_item('wh-weight')
    # add_item('doll-ghost')


  end
        
end"gclass Progress

	attr_accessor :quests, :complete

	attr_accessor :night_rank, :night_xp
  	attr_accessor :attract_boy, :attract_hib, :attract_phy

  	attr_accessor :guild_id

  	attr_reader :creatures, :chester_level

  	attr_reader :demons

  	attr_accessor :store_level, :store_xp, :store_done

	def initialize

		@quests = []
		@complete = []

		add_quest('ch0-domination')


		# Boyle - creatures
		@creatures = {} # Sorted by zone
		@creatures['wyrmwood'] = 0

		# Boyle skills
		@chester_level = 0

		# Phy
		@demons = [] # Demons defeated

		# Nightwatch rank
	    @night_rank = 1
	    @night_xp = 0

	    # Attraction
	    @attract_boy = 0
	    @attract_hib = 0
	    @attract_phy = 0

	    # Guild info
	    @guild_id = 'n' #nil # will be one letter, b, c, or s, or "" for none

	    # Robin Shop
	    @store_level = 2
	    @store_xp = 0
	    @store_done = []

	end


	def add_quest(q)
		@quests.push(q)
		$map.need_refresh = true if $map
		log_info("Quest Added: #{q}")
	end

	def end_quest(q)
		@quests.delete(q)
		@complete.push(q)
		$map.need_refresh = true
		log_info("Quest Ended: #{q}")
	end

	def quest_active?(q)
		return @quests.include?(q)
	end

	def quest_complete?(q)
		return @complete.include?(q)
	end

	def catch_creature(zone)
		if !@creatures.has_key?(zone)
			@creatures[zone] = 1
		else
			@creatures[zone] += 1
		end
	end

	def inc_chester_level(lvl)
		@chester_level = lvl if lvl > @chester_level
	end

	def defeat_demon(demon)
		@demons.push(demon)
	end

	def add_night_xp(amount)
		@night_xp += amount	
	end

end"class State

	def initialize

		@flags = []
		@vars = {}

		# Event modifiers
		@states = {} # Event states
		@locs = {}
		@deleted = []
		@disabled = []

		# Deleted in future
		@nospawn = []

		# Menu indexes?

	end

	def flag(f)
		@flags.push(f) if !@flags.include?(f)
		$scene.map.need_refresh = true if !$scene.is_a?(Scene_Menu)
	end

	def unflag(f)
		@flags.delete(f)
		$scene.map.need_refresh = true
	end

	def flag?(f)
		return @flags.include?(f)
	end

	def var(v,a)
		if @vars.has_key?(v)
			@vars[v] += a
		else
			@vars[v] = a
		end
		$scene.map.need_refresh = true
	end

	def unvar(v,a)
		if @vars.has_key?(v)
			@vars[v] -= a
		else
			@vars[v] = -a
		end
		$scene.map.need_refresh = true
	end

	def var?(v,t)
		return false if !@vars.has_key?(v)
		return @vars[v] >= t
	end

	def varval(v)
		return 0 if !@vars.has_key?(v)
		return @vars[v]
	end

	def state(e,s)
		@states[[$scene.map.id,e,s]] = true
		$scene.map.need_refresh = true
	end

	def unstate(e,s)
		@states[[$scene.map.id,e,s]] = false
		$scene.map.need_refresh = true
	end

	def state?(e,s)
		return false if !@states.has_key?([$scene.map.id,e,s])
		return @states[[$scene.map.id,e,s]]
	end

	def loc(e)
		ev = gev(e)
		@locs[[$scene.map.id,e]] = [ev.x,ev.y,ev.direction,ev.off_x,ev.off_y]
	end
	def nloc(e)
		@locs.delete([$scene.map.id,e])
	end

	def loc?(e)
		return @locs.has_key?([$scene.map.id,e])			
	end

	def getloc(e)
		return @locs[[$scene.map.id,e]]
	end

	def delete(e)
		@deleted.push([$scene.map.id,e])
	end

	def delete?(e)
		return @deleted.include?([$scene.map.id,e])
	end

	def disable(e)
		@disabled.push([$scene.map.id,e])
	end

	def disable?(e)
		return @disabled.include?([$scene.map.id,e])
	end

	def enable(e)
		@disabled.delete([$scene.map.id,e])
	end

	def nospawn(e)
		@nospawn = [] if @nospawn == nil
		@nospawn.push([$scene.map.id,e])
	end

	def nospawn?(e)
		@nospawn = [] if @nospawn == nil
		return @nospawn.include?([$scene.map.id,e])
	end

end
"M!#==============================================================================
# ** Scene_Base
#==============================================================================

class Scene_Base

  attr_reader :map, :player

  attr_reader :panorama, :tilemap
  attr_reader :weather, :fog
  attr_reader :overlay, :black

  attr_reader :hud

  attr_reader :debug

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    $scene = self

    # Prep model
    @map = Game_Map.new
    @player = Game_Player.new

    # Make viewports - Also in the scene
    @vp_under = Viewport.new(0,0,$game.width,$game.height)
    @vp_under.z = 0
    @vp_main = Viewport.new(0,0,$game.width,$game.height)   
    @vp_main.z = 1000
    @vp_weather = Viewport.new(0,0,$game.width,$game.height)
    @vp_weather.z = 1999
    @vp_over = Viewport.new(0,0,$game.width,$game.height)
    @vp_over.z = 2000
    @vp_ui = Viewport.new(0,0,$game.width,$game.height)
    @vp_ui.z = 3000
   
    # Make tilemap
    @panoramas = []
    @tilemap = MapWrap.new(@vp_main)
    
    @characters = []  
    @sparks = []
    @pops = []

    # weather in map data
    @weather = nil#Weather.new(@vp_over)
    @fogs = []

    # Misc Overlay
    @overlay = Sprite.new(@vp_over)
    @overlay.bitmap = Bitmap.new($game.width,$game.height)
    @overlay.bitmap.fill(Color.new(0,0,0))
    @overlay.opacity = 0
    @overlay.z = 999

    # Fadeout
    @black = Sprite.new(@vp_over)
    @black.bitmap = Bitmap.new($game.width,$game.height)
    @black.bitmap.fill(Color.new(0,0,0))
    @black.opacity = 0
    @black.z = 1000
    
    # UI
    @hud = nil # Define in sub
            
  end

  def inviz
    @tilemap.visible= false
    @map.hide
  end

  def viz
    @tilemap.visible= true
    @map.show
  end
  
  def terminate

    # Dispose of things
    @panoramas.each{ |s| s.dispose }
    @panoramas = nil
    @tilemap.dispose
    @characters.each{ |s| s.dispose }
    @characters = nil
    @sparks.each{ |s| s.dispose }
    @pops.each{ |s| s.dispose }
    @weather.dispose if @weather
    @fogs.each{ |s| s.dispose }
    @overlay.dispose
    @black.dispose
    @hud.dispose
    
    # Dispose of viewports
    @vp_under.dispose
    @vp_main.dispose   
    @vp_over.dispose
    @vp_ui.dispose

    #@map.dispose
    #@player.dispose

  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update

    return if $scene.is_a?(Scene_Menu)
    return if $scene.is_a?(Scene_GameOver)

    # Model update
    @map.update      
    return if $scene.is_a?(Scene_Menu)
    return if $scene.is_a?(Scene_GameOver)
    @player.update

    # Elements update
    @panoramas.each{ |p| p.update } # With animated position
    @tilemap.ox = @map.display_x / 4
    @tilemap.oy = @map.display_y / 4
    @tilemap.update
    @characters.each{ |s| s.update }
    @sparks.each{ |s| 
      # Mouse click needs to follow, others do not
      # Maybe just do all
      s.ox = @map.display_x/4
      s.oy = @map.display_y/4
      s.update 
    }
    @pops.each{ |s| 
      #s.ox = @map.display_x/4
      #s.oy = @map.display_y/4
      s.update 
    }
    @fogs.each{ |p| p.update }
    @weather.update if @weather
    #@fog.update
    #@overlay.update
    @hud.update

    # Try to delete anything
    @sparks.delete_if{ |s| s.done? }
    @pops.delete_if{ |s| s.done? }

    # Could delete erased characters here

    @vp_weather.ox = $map.display_x / 4
    @vp_weather.oy = $map.display_y / 4


    # Rebuild the map
    reload_map if @map.id != @tilemap.map_id
    
  end

  def clear_sparks(e=nil)

      if e == nil
        # Clear sparks
        @sparks.each{ |s| s.dispose }
        @sparks.clear
      else

        @sparks.each{ |s| s.dispose if s.ev == e }
        @sparks.delete_if{ |s| s.disposed? }

       end

  end

  def reload_map
    
    @tilemap.refresh(@map)

    @characters.each{ |s| s.dispose }
    @characters = []

    @map.events.keys.sort.each{ |i|
      sprite = Sprite_Character.new(@vp_main, @map.events[i])
      @characters.push(sprite)
    }

    @characters.push(Sprite_Character.new(@vp_main, @player))

  end

  def change_overlay(overlay)
    
    # Nightwatch hack
    overlay = 'night' if flag?('night-time')

    if overlay == '' || overlay == nil
      $scene.overlay.opacity = 0
    else
      $scene.overlay.bitmap = $cache.overlay(overlay)
      $scene.overlay.opacity = 255
    end
  end

  def change_weather(weather)
    @weather.dispose if @weather
    return if !$settings.effects
    @weather = nil
    case weather
      when 'dark-dots'
        @weather = Weather_DarkDots.new(@vp_weather)
      when 'fire-dots'
        @weather = Weather_FireDots.new(@vp_weather)
      when 'leaf-dots'
        @weather = Weather_LeafDots.new(@vp_weather)
      when 'rain'
        @weather = Weather_Rain.new(@vp_weather)
    end
  end

  def change_fogs(fogs)

    @fogs.each{ |p| p.dispose }
    @fogs.clear   

    data = fogs.split("\n")

    data.each{ |fg|

       fog = Panorama.new(@vp_over)
       fog.blend = 1
       fog.opacity = 120

      # Any extra data
      dta = fg.split(" | ")

      if dta.count > 1
        dta.each_index{ |i|
          next if i == 0
          d = dta[i].split("=>")

          case d[0]
            when 'ax'; fog.att_x = d[1].to_f
            when 'ay'; fog.att_y = d[1].to_f
            when 'sx'; fog.spd_x = d[1].to_f
            when 'sy'; fog.spd_y = d[1].to_f
            when 'ox'; fog.start_x = d[1].to_f
            when 'oy'; fog.start_y = d[1].to_f
            when 'px'; fog.pad_x = d[1].to_f
            when 'py'; fog.pad_y = d[1].to_f
            when 'r'; fog.repeat = d[1].to_b

          end

        }
      end

      
      #pano.z = -1000
      fog.bitmap = $cache.fog(dta[0])
      @fogs.push(fog)

    }


  end

  def change_panoramas(panos)

    @panoramas.each{ |p| p.dispose }
    @panoramas.clear   

    data = panos.split("\n")

    data.each{ |pano|

       panorama = Panorama.new(@vp_under)

      # Any extra data
      dta = pano.split(" | ")

      if dta.count > 1
        dta.each_index{ |i|
          next if i == 0
          d = dta[i].split("=>")

          case d[0]
            when 'ax'; panorama.att_x = d[1].to_f
            when 'ay'; panorama.att_y = d[1].to_f
            when 'sx'; panorama.spd_x = d[1].to_f
            when 'sy'; panorama.spd_y = d[1].to_f
            when 'ox'; panorama.start_x = d[1].to_f
            when 'oy'; panorama.start_y = d[1].to_f
            when 'px'; panorama.pad_x = d[1].to_f
            when 'py'; panorama.pad_y = d[1].to_f
            when 'r'; panorama.repeat = d[1].to_b

          end

        }
      end
      
      #pano.z = -1000
      panorama.bitmap = $cache.panorama(dta[0])
      @panoramas.push(panorama)

    }

  end

  def add_spark(fx,x,y,e=nil,vp=@vp_main) # might want custom vp

    sprk = Spark.new(fx,x,y,@vp_main)
    sprk.ev = e
    @sparks.push(sprk)
    return sprk

  end

  def add_icon(ic,x,y,ein,eout,delay=800)

    ico = Pop.new(ein,eout,@vp_over)
    ico.icon = ic
    ico.move(x,y)
    ico.anim_delay = delay
    ico.start
    @pops.push(ico) # Could combine these with spark

  end

  def add_num(nm,x,y,ein,eout)

    ico = Pop.new(ein,eout,@vp_over)
    ico.number = nm
    ico.move(x,y)
    ico.start
    @pops.push(ico) # Could combine these with spark

  end

  def add_pop(pop)
    @pops.push(pop)
  end

  # def pop_dmg(target,amount)
  #   #ev = gev(target)
  #   pop = Popper.new(@vp_over)
  #   pop.value = amount #- amount/10
  #   pop.x = target.screen_x-200-20
  #   pop.y = target.screen_y-40-12+45
  #   @pops.push(pop)

  #   pop.opacity = 1
  #   pop.do(go("value",amount,700,:quad_in_out))
  #   pop.do(sequence(go("opacity",254,500),go("opacity",0,1500),go("opacity",-255,500)))
  #   pop.do(sequence(go("y",-30,500,:quad_in_out),go("y",-20,1500),go("y",-30,500,:quad_in_out)))


  # end

end
"#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Battle < Scene_Base

  attr_accessor :phase, :message, :hud

  def initialize
    super

    @vp_under.z = 4000
    @vp_main.z = 5000
    @vp_weather.z = 5999
    @vp_over.z = 6000
    @vp_ui.z = 7000

    $scene = self

    @phase = :intro_init
    @turn = 0
    @wait_frames = 0
    @active_battler = nil

    @texts = []
    @skill = false # Auto skill happening

    @map.setup($battle.map)
    @map.interpreter.battlemap = true # Allow to run during battle
    @tilemap.refresh(@map)

    # Init player and camera 
    @player.moveto(0,0)
    @player.static
    @map.camera_to(@player)

    # Slide camera up
    @map.cam_oy = 80
    @map.do(
      seq(
        delay(40),
        #go("cam_oy",-110,1000,:quad_out)
        go("cam_oy",-80,700,:quad_out)
      )
    )    
    #@overlay.opacity = 0
    $game.sub_scene.black.opacity = 0

    # Create Hud Elements
    @hud = BattleHud.new(@vp_ui)
    @actor_cmd = ActorCmd.new(@vp_ui)
    @skill_cmd = SkillCmd.new(@vp_ui)
    @item_cmd = ItemCmd.new(@vp_ui)
    @target_cmd = TargetCmd.new(@vp_ui)
    @message = Ui_Message.new(@vp_ui)


    # Find battler events
    [0,1,2,3].each{ |i| 
      
      ev = @map.event_by_evname("A.#{i}")
      
      if ev == nil # Shouldn't happen
        log_err("No event for actor A.#{i}")
        next
      end

      act = $party.actor_by_index(i).id      

      if $party.active.count > i

        $party.actor_by_index(i).ev = ev
        if $party.get(act).down?
          $party.get(act).fall
          $party.get(act).view.down if $party.get(act).view
        else

          ev.character_name = "Player/#{act}"
          ev.step_anime = true

          # Animate in if not dirfix
          if !ev.direction_fix
            case ev.direction
              when 2
                ev.off_y = -32
                ev.do(go("off_y",32,800))
              when 4
                ev.off_x = 32
                ev.do(go("off_x",-32,800))
              when 6
                ev.off_x = -32
                ev.do(go("off_x",32,800))
              when 8
                ev.off_y = 32
                ev.do(go("off_y",-32,800))            
            end
          end
        end

      else

        # This battler not used, hide it
        hide(ev)

      end

    }

    # Do trinket actions
    $party.active_battlers.each{ |b|
      case b.slot('acc') 
         when 'acc-frog-boots'
          b.transform('frog')
        when 'acc-snake-boots'
          b.transform('snake')
        when 'acc-bat-boots'
          b.transform('bat')
        #when 'acc-frog-boots'
        #  @active_battler = b
      end
    }

    # Enemy setups
    [0,1,2,3,4,5,6,7,8,9].each{ |i| 
      ev = @map.event_by_evname("E.#{i}") 
      next if ev == nil
      if $battle.enemies.count > i
        $battle.enemies[i].ev = ev
        ev.character_name = "Monsters/#{$battle.enemy_list[i]}"
      else
        hide(ev)
      end
    }

    # Ally setups
    [0,1,2].each{ |i| 
      ev = @map.event_by_evname("F.#{i}") 
      next if ev == nil
      if $battle.allies.count > i
        $battle.allies[i].ev = ev
        ev.character_name = "Monsters/#{$battle.allies[i].id}"
      else
        hide(ev)
      end
    }

    # Props
    #$battle.add_prop('money')

    # And the minion
    if $party.active.include?('boy') && $battle.minion != nil
      @minion = $battle.minion
      @minion.ev = @map.event_by_evname("MINION")
      @minion.ev.character_name = "Player/#{@minion.id}"
    else
      hide("MINION")
    end
    #hide(@minion)

    reload_map

    start_events

  end
  
  def terminate

    @hud.dispose
    @actor_cmd.dispose
    @skill_cmd.dispose
    @item_cmd.dispose
    @target_cmd.dispose
    @message.dispose
    
    super  
  end

  def busy?
    return false
  end

  def wait(w)
    @wait_frames += w
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------

  def update

    super

    # Force weather
    @vp_weather.ox = 0#$map.display_x / 4
    @vp_weather.oy = 0#$map.display_y / 4

    @hud.update
    @message.update

    # Draw phase
    #@dbg_phase.bitmap.fill(Color.new(0,0,0))
    #@dbg_phase.bitmap.draw_text(10,0,150,30,@phase.to_s,0)

    update_phase

  end

  def start_events
    $scene.map.events.values.each{ |e|
      e.start if e.turn == @turn
    }
  end

  def update_phase

    #$debug.track(self,"phase")

    # Wait count here
    if @wait_frames > 0
      @wait_frames -= 1
      return
    end

    # Currently showing text
    return if @message.busy?
    return if @hud.busy?

    # Currently interpreting
    return if @map.interpreter.running?

    case @phase

      # Introduction Phase
      when :intro_init
        phase_intro_init
      when :intro_prep
        phase_intro_prep
      when :intro_action
        phase_intro_action
      when :intro_end
        phase_intro_end

      when :start_turn
        phase_start_turn

      # Actor Phase
      when :actor_init
        phase_actor_init
      when :actor_action
        phase_actor_action
      when :actor_skill
        phase_actor_skill
      when :actor_item
        phase_actor_item
      when :actor_transform
        phase_actor_transform
      when :actor_re_action
        phase_actor_re_action
      when :actor_strategize
        phase_actor_strategize
      when :actor_target
        phase_actor_target
      when :actor_next
        phase_actor_next

      # Battle phase
      when :main_init
        phase_main_init
      when :main_prep
        phase_main_prep
      when :main_start
        phase_main_start
      when :main_text
        phase_main_text
      when :main_anim
        phase_main_anim
      when :main_transform
        phase_main_transform
      when :main_hit
        phase_main_hit
      when :main_crit
        phase_main_crit
      when :main_gain
        phase_main_gain
      when :main_state
        phase_main_state
      when :main_tick
        phase_main_tick
      when :main_fall
        phase_main_fall
      when :main_next
        phase_main_next
      when :main_end
        phase_main_end

      # Victory Phase
      when :victory_init
        phase_victory_init
      when :victory_xp
        phase_victory_xp
      when :victory_level
        phase_victory_level
      when :victory_end
        phase_victory_end
      when :victory_lose
        phase_victory_lose

      # Misc Phase
      when :misc_text
        phase_misc_text
      when :misc_check
        phase_misc_check

      when :misc_escape
        phase_misc_escape

    end

  end

end"
class Scene_Battle

  def phase_intro_init

    wait(30)
  	@phase = :intro_prep

  end

  def phase_intro_prep

    # Put actors in idle pose

    [0,1,2,3].each{ |i| 

      if $party.active.count > i

        act = $party.actor_by_index(i).id
        
        if !$party.get(act).down? && !$party.get(act).get_transform

            ev = $party.actor_by_index(i).ev
            next if ev == nil
            act = $party.actor_by_index(i).id
            ev.character_name = "Player/#{act}-idle"
            ev.pattern = rand(4)
            #ev.direction = 2
            ev.step_anime = true

        end
      end

    }

    @phase = :intro_end

  end

  def phase_intro_end

    @phase = :start_turn

  end

  def phase_start_turn

    # Start all autoruns for this turn
    start_events

    # Any text or skills will use up a turn of the battle? But states won't remove?

    @texts = []
    @skill = false

    @turn += 1

    if !$battle.queue.has_key?(@turn)
      @phase = :actor_init
      return
    end

    $battle.queue[@turn].each{ |action|

      case action[0]

        when :text
          @texts.push(action[1])
          @phase = :misc_text

          # If text and skill, do skill first, it will queue up after text is done

        when :skill

          @skill = true

          $battle.enemies[action[1]].set_action(action[2])

          @battle_queue = []
          @active_battler = $battle.enemies[action[1]]
          @phase = :main_prep

        when :escape      

          @phase = :misc_escape

        when :join

          join_s 'mys'
          @hud.build_views
          unhide('A.1')
          $party.get('mys').ev = gev('A.1')

      end

    }

  end

end"2

class Scene_Battle

  #==============================================================================
  # ** actor_init
  #==============================================================================

  def phase_actor_init
    @actor_idx = -1  
    @phase = :actor_next
  end

  #==============================================================================
  # ** actor_action
  #==============================================================================

  def phase_actor_action

    if !@active_battler.can_attack?
      @phase = :actor_next
      return
    end

    # Clear previous
    @active_battler.action = nil
    @active_battler.skill_id = nil
    @active_battler.item_id = nil

    @actor_cmd.update

    if $input.cancel? || $input.rclick?
      if @actor_idx != 0
        @actor_idx -= 1
        @active_battler = $party.actor_by_index(@actor_idx)
        
        $scene.hud.deselect_all
        @actor_cmd.setup(@active_battler)
        @active_battler.view.select
      end
    end

    # Player command inputs section
    if $input.action? || $input.click?

      sys 'action'

      action = @actor_cmd.get_action
      @active_battler.action = action
      @actor_cmd.close

      case action 

        when "items"

          @item_cmd.setup
          @phase = :actor_item

        when "skills", "spells", "witchery", "team", "transform", "demon", "dream", "sing"

          @skill_cmd.setup(@active_battler,action)
          
          sys 'action'

          @phase = :actor_skill

        when "two-legs", "four-legs"
          @last_action = action
          @phase = :actor_transform

        else

          # Rowen gadget hack
          if action == 'gadget'
            action = 'gadget-'+(rand(4)+1).to_s
          end

          @active_battler.skill_id = action
          @phase = :actor_strategize

      end

    end 

  end

  #==============================================================================
  # ** actor_skill
  #==============================================================================

  def phase_actor_skill

    @skill_cmd.update

    if $input.cancel? || $input.rclick?
      @actor_idx -= 1
      @phase = :actor_next
      @skill_cmd.close
    end

    if $input.action? || $input.click?
      if @active_battler.can_use_skill?(@skill_cmd.get_skill)
        @skill_cmd.close
        @active_battler.item_id = nil
        skill = @skill_cmd.get_skill
        skill = skillswap(skill)
        @active_battler.skill_id = skill
        @phase = :actor_strategize
        sys 'action'
      else
        sys("buzz")
      end
    end

  end

  # Hack skill changes
  def skillswap(skill)
    case skill
      when 'team-boy'
        return ['tcf-mermaid','tcf-hercules','tcf-cyclops','tcf-gyendal'].sample
      when 'team-hib'
        return ['ntmr-ghost','ntmr-ing','ntmr-spider','ntmr-mutton'].sample
    end
    return skill
  end

  #==============================================================================
  # ** actor_item
  #==============================================================================

  def phase_actor_item

    @item_cmd.update

    if $input.cancel? || $input.rclick?
      @actor_idx -= 1
      @phase = :actor_next
      @item_cmd.close
    end

    if $input.action? || $input.click?
      @item_cmd.close
      @active_battler.skill_id = nil
      @active_battler.item_id = @item_cmd.get_item
      $party.lose_item(@active_battler.item_id)
      @phase = :actor_strategize
    end

  end

  #==============================================================================
  # ** actor_transform
  #==============================================================================

  # Special myst transform
  def phase_actor_transform

    x = @active_battler.ev.screen_x
    y = @active_battler.ev.screen_y - 24
    add_spark('myst',x,y)

    if @last_action == "four-legs"
      @active_battler.transform('fox')
    else
      @active_battler.transform('nil')
    end

    # Repeat back to myst turn
    wait(40)
    @phase = :actor_re_action 

  end

  def phase_actor_re_action

    @active_battler = $party.actor_by_index(@actor_idx)
    @actor_cmd.setup(@active_battler)
    @phase = :actor_action 

  end

  #==============================================================================
  # ** actor_strategize
  #==============================================================================

  def phase_actor_strategize

    data = nil

    # Get the skill or item
    if @active_battler.action == "items"
      data = $data.items[@active_battler.item_id]
    else
      data = $data.skills[@active_battler.skill_id]
    end

    @active_battler.scope = data.scope

    # If single, targetable?
    if ["one","ally",'down'].include?(data.scope)
      targets = $battle.possible_targets(@active_battler)
      @target_cmd.setup(targets)
      @phase = :actor_target      
    else
      @phase = :actor_next
    end


  end

  #==============================================================================
  # ** actor_target
  #==============================================================================

  def phase_actor_target

    @target_cmd.update

    if $input.cancel? || $input.rclick?
      @target_cmd.close
      $party.add_item(@active_battler.item_id) if @active_battler.item_id != nil
      @actor_idx -= 1
      @phase = :actor_next
    end

    if $input.action? || $input.click?
      sys('open')
      @active_battler.target = @target_cmd.active
      @target_cmd.close
      @phase = :actor_next
    end

  end  

  #==============================================================================
  # ** actor_next
  #==============================================================================

  def phase_actor_next

    @actor_idx += 1
    if @actor_idx >= $party.active.count
      @phase = :main_init
    else
      @active_battler = $party.actor_by_index(@actor_idx)
      if @active_battler.down?
        return # Get the next one, this actor is done
      else
        $scene.hud.deselect_all
        @actor_cmd.setup(@active_battler)
        @active_battler.view.select
        @phase = :actor_action 
      end
    end
    
  end

end"é)
class Scene_Battle

  def phase_main_init

    wait(15)

    # Play nice noise
    # sys 'join'
   	
    # Choose enemy actions
    $battle.enemies.each{ |e|
    	e.choose_action
    }
    
    if $battle.allies != nil
      $battle.allies.each{ |a| 
        a.choose_action
      }
    end

    # Choose minion action
    if $party.active.include?('boy') && $battle.minion != nil
      $battle.minion.choose_action
    end


    # Determine order of attacks
    @battle_queue = $battle.build_attack_queue
    
    # certain attacks always go first, robin's team move with phye for example

	  @active_battler = @battle_queue.shift
	  @phase = :main_prep

  end

  # Prepare attack of next guy to attack, next_actor called before this
  def phase_main_prep

    # Apply the cooldown for this skill
    if @active_battler.action != 'items'
      @active_battler.apply_cooldown(@active_battler.skill_id)
    end

  	# Calculate results now, then play out the anims
  	@attack_plan = $battle.build_attack_plan(@active_battler)
    @attack_round = @attack_plan.next_attack

    # If this player has been defeated, skip
    if @active_battler.down?
      @attack_plan.cancel
      @phase = :main_next
      return
    end

    # If nothing attack
    if @active_battler.skill_id == 'nothing'
      @attack_plan.cancel
      @phase = :main_next
      return
    end

    # Show attack name
    if @active_battler.action == "items"
      it = $data.items[@active_battler.item_id]
      @hud.set_help(it.name)
    else
      sk = $data.skills[@active_battler.skill_id]
      @hud.set_help(sk.name)
    end

    @last_attack = nil

  	@phase = :main_start
    @wait = 15

  end

  # Start a round of the attack
  def phase_main_start

    # Play nice noise
    #sys 'talk2'

      # -----------------------------
    # ERROR CORRECTIONS 

    # If specific target, random if down
    if ['one','ally'].include?(@active_battler.scope) && @active_battler.target.down?

      # If a tranform, cancel
      if @active_battler.skill_id != nil
        if @active_battler.skill_id.include?("xform")
          @attack_plan.cancel
          @phase = :main_next
          return
        else
          # Doesn't really work, hmmmmm
          @active_battler.scope = 'rand'
        end
      end

    end

    # If rez, random if up, or cancel
    # NO JUST USE UP THE CASSIA
    # if ['down'].include?(@active_battler.scope)

    #   # Check if target is down
    #   if !@active.battler.target.down?

    #     # Try to find an alternate target, else cancel

    #   end

    #   #@attack_plan.cancel
    #   #@phase = :main_next
    #   #return
    # end

    # -----------------------------

    # Calculate damage here and now
    @attack_results = $battle.build_attack_results(@active_battler,@attack_round.skill)

    # For multi hits, only flash and wait the first time
    if @attack_round.skill != @last_attack
      @active_battler.ev.flash_dur = 15
      wait(15)
      

      # Mana cost
      if @active_battler.action != "items"
        if @attack_round.skill != @last_attack
          @active_battler.lose_mana(@attack_round.skill.cost)
        end
      end

      # Remember attack to avoid double mana use
      @last_attack = @attack_round.skill

    else
      wait(3)
    end

    @active_battler.attack_sfx

    # Show text if there is
    @phase = :main_text
    

  end

  # Show text on attacker
  def phase_main_text

    if @attack_round.text
      $scene.message.force_name = @active_battler.name
      speaker = "A.#{$party.active.index(@active_battler.id)}"
      $scene.message.start(speaker+': '+@attack_round.text)
      #$scene.message.start(@active_battler.ev.name+':'+@attack_round.text)
    end

    @attack_results.each{ |result|
      if result.escape
        @phase = :misc_escape
        return
      end
    }

    @phase = :main_anim
    wait(15)

  end

  # Show anim on defender
  def phase_main_anim

    # Face at target of attack - CUT
    # if @active_battler.target != nil && @active_battler.target.is_enemy?
    #   @active_battler.ev.direction = 10 - @active_battler.target.ev.direction
    #   #@active_battler.ev.turn_toward_event(@active_battler.target.ev.id)      
    # end

    @attack_results.each{ |result|

      # Target face attacker
      #result.target.ev.turn_toward_event(@active_battler.ev.id)
      # if @active_battler.is_enemy?
      #   result.target.ev.direction = 10 - @active_battler.ev.direction
      # end

      if @attack_round.anim
        if @attack_round.anim.include?("spark")
          # Show the hit animation
          x = result.target.ev.screen_x
          y = result.target.ev.screen_y - 32
          add_spark(@attack_round.anim.split("=>")[1],x,y)
        end
      end

    }

  	# Onto the next
  	@phase = :main_transform

  end

  def phase_main_transform

    @attack_results.each{ |result|      
      if result.transform
        result.target.transform(result.transform)
      end
    }

    # Onto the next
    @phase = :main_hit

  end

  def phase_main_hit


    # Do damage or healing
    @attack_results.each{ |result|

        # Damage
        if result.damage > 0

          # Remove state by damage
          result.target.remove_states_shock

          result.target.damage(result.damage)
          pop_dmg(result.target.ev,result.damage)
          
          if result.target.view != nil
            result.target.view.damage
          end

          if result.target.is_enemy? && result.target.down?
            result.target.ev.color = Color.new(0,0,0,200)
          end

        end

        # Heal
        if result.heal > 0

          result.target.heal(result.heal)
          pop_dmg(result.target.ev,result.heal)

          if result.target.view != nil
            result.target.view.grin
          end

        end

    }

    # Onto the next
    @phase = :main_crit
    wait(1)

  end

  def phase_main_crit

    @attack_results.each{ |result|
      if result.critical
        
        # Play nice noise
        sys 'attack'
        pop_crit(result.target.ev)

      end

      # Evade
      if result.evade

        # Play nice noise
        sfx 'whoosh2'
        pop_evade(result.target.ev)

      end

      # Resist
      if result.resist

        # Play nice noise
        sfx 'whoosh2'
        pop_resist(result.target.ev)

      end

    }

    # Onto the next
    @phase = :main_gain
    wait(1)

  end

  def phase_main_gain

    # Show gains of hp or mana or darkness
    @attack_results.each{ |result|

        if result.steal
          item('cheese',1,'rat')
        end

        if result.pocket
          gold(result.target.gold.to_s.split("-")[-1].to_i,'row')
        end

        if result.gain_mana != nil
          @active_battler.gain_mana(result.gain_mana)
          #pop_gain(@active_battler.ev,result.gain_mana,@active_battler.resource)

          # Spark effect
          x = @active_battler.ev.screen_x
          y = @active_battler.ev.screen_y - 15
          add_spark('mana-blue',x,y)
          wait(15)
        end
    }

    @phase = :main_state
    wait(1)

  end

  def phase_main_state

    @attack_results.each{ |result|

      # Empower minion
      if result.empower
        $battle.minion.add_state('empower')
        $battle.minion.ev.character_name = $battle.minion.ev.character_name + '-wild'
        x = $battle.minion.ev.screen_x
        y = $battle.minion.ev.screen_y - 16
        add_spark('redstar',x,y)
      end

      if result.state_remove

        #log_sys(result.state_remove)

          if result.target.state?(result.state_remove)
            result.target.remove_state(result.state_remove)            
            result.target.ev.icons.delete(result.state_remove)
          end

      end

      if result.state_add

        # Only if a new state, else refresh
        if result.target.state?(result.state_add)
          # refresh it
          next
        end

        result.target.add_state(result.state_add)
        #pop_state(result.target.ev,result.state_add)
        
        #result.target.ev.pulse_colors.push($data.states[result.state_add].color)
        #result.target.ev.pulse_colors.push(Color.new(0,240,0,120))

      end

    }

    @phase = :main_tick
    wait(20) # Might wait only if a state was aded

  end

  def phase_main_tick

    # Take damage from poison states
    # This would be after all attacks, then another fall?




    @phase = :main_fall
    wait(1)

  end

  def phase_main_fall

    # Anybody defeated should leave now
    @attack_results.each{ |result|

      if result.target.down?
        if result.target.is_actor?
          #sys('fall')
          if result.target.id == 'mys'
            x = result.target.ev.screen_x
            y = result.target.ev.screen_y - 32
            add_spark("myst",x,y)
          end
          result.target.fall
          result.target.clear_states
          result.target.view.down if result.target.view
          #fade(result.target.ev)
        else
          fade(result.target.ev)
        end
        wait(30)
      end

    }

    # Onto the next
    @phase = :main_next

  end

  def phase_main_next

    # If one side has been defeated, that's it
    if $party.defeated?
      music_fadeout
      wait(120)
      @phase = :victory_lose
      return
    end

    if $battle.victory?
      @phase = :victory_init
      return
    end

  	# If a multi stage, go back to attack
    if !@attack_plan.done?

      # End multi stage attacks early if user is incapable of attack

      @active_attack = @attack_plan.next_attack
      @phase = :main_start
      return

    end

  	# Onto the next battler
	  if !@battle_queue.empty?
		
  		# Good place to check for end of battle also
	 	  @active_battler = @battle_queue.shift
	   	@phase = :main_prep
      return

    end

    # Attack phase done, finalize
    @phase = :main_end    

	end

  def phase_main_end
    
    # Play nice noise
    sys 'open'

    # Remove states and that before next turn starts
    $battle.all_battlers.each{ |b| b.reduce_cooldowns }
    $battle.all_battlers.each{ |b| b.remove_states_turn }

    # Go to next turn
    @phase = :start_turn

  end

end"q
class Scene_Battle

  def phase_victory_init

  	# Everybody grin
  	@hud.all_win
    sys 'fall'
    wait(15)
    music 'victory2'

    # Choose a dialogue
    if $battle.victory_text != nil

       data = $battle.victory_text.split(": ")
       speaker = data[0]
  	   text = data[1]

    else

      # Get dialogue for a party member currently active
      speaker = $party.alive_members.sample.id

      # What will they say?
      idx = 1#rand(1)
      text = $data.victories["#{speaker}-#{idx}"].dialogue

    end

    force = $party.get(speaker).name
    speaker = "A.#{$party.active.index(speaker)}"
    
    $scene.message.force_name = force
    $scene.message.start(speaker+": "+text)
    
  	@phase = :victory_xp  	

  end

  def phase_victory_xp

    xp = $battle.xp_total
    $scene.message.force_name = nil
    $party.alive_members.each{ |b| b.gain_xp(xp) }
  	$scene.message.start("sys:#{xp} XP gained!")

  	@phase = :victory_level
    music_fadeout

  end

  def phase_victory_level    

    # Only show level ups in active party?
    $party.alive_battlers.each{ |b|
      
      if b.level_up?
        b.view.box.wallpaper = $cache.menu_wallpaper("green")        
        $scene.message.start("sys:#{b.name} is now level #{b.level}!")
      end

    }

	  @phase = :victory_end

  end

  def phase_victory_end

    $battle.all_battlers.each{ |b| b.remove_states_battle }

    Graphics.freeze

    $battle.clear
  	$game.pop_scene
    music_restore
    $scene.hud.show

    t = 'Graphics/Transitions/battle'
    Graphics.transition(30,t) 
    
  end

  def phase_victory_lose

          # Fade out show defeat screen etc
      Graphics.freeze
      $game.pop_scene
      $game.push_scene(Scene_GameOver.new)
      t = 'Graphics/Transitions/battle'
      Graphics.transition(30,t) 

  end


end" 
class Scene_Battle

  def phase_misc_text

  	data = @texts.shift


  	# Get speaker name
  	speaker = data.split(":")[0]
  	text = data.split(":")[1]

  	force = speaker

  	# If speaker is enemy, get name somehow
  	if speaker.include?("E.")
  		force = $battle.enemies[speaker.split(".")[1].to_i].name
  	end

  	if $party.active.include?(speaker)
  		force = $party.get(speaker).name
  		speaker = "A.#{$party.active.index(speaker)}"
  	end

	$scene.message.force_name = force

	# Convert actor speaker to event format

	#speaker = $scene.

	#if $party.active.include?()
    $scene.message.start(speaker+": "+text)

    wait(1)

  	@phase = :misc_check

  end

  def phase_misc_check

  	
  	if !@texts.empty?

  		# If text still going, allow it
  		@phase = :misc_text

  	elsif @skill == true

  		# If a skill is queued, start it
  		@phase = :main_prep

  	else

  		# Else back to main
  		@phase = :start_turn

  	end

  end

  def phase_misc_escape

    $battle.all_battlers.each{ |b| b.remove_states_battle }

    $battle.clear
    Graphics.freeze
    $game.pop_scene
    music_restore
    $scene.hud.show

    t = 'Graphics/Transitions/battle'
    Graphics.transition(30,t) 

  end

 end
" #==============================================================================
# ** Scene_GameOver
#==============================================================================

class Scene_GameOver
  
  attr_accessor :next_menu

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    @closing = false

 
    music('sad')

    char = 'mys' 
    char = 'boy' if !$party.active.include?('mys')

    $scene = self

    # Make viewports - Also in the scene
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 3999

    @bg = Sprite.new(@vp)
    @bg.z = -100
    @bg.bitmap = $cache.gameover("sky")

    # Char
    @char = Sprite.new(@vp)
    #@char.x += 50
    @char.bitmap = $cache.gameover('char-'+char)
    #@char.do(go('x',-50,700,:qo))

    @message = Ui_Message.new(@vp)

    if char == 'mys'
      @message.start("vn-mys: Now we'll never save my brother.")
    elsif char == 'boy'
      @message.start("vn-boy: I really am a terrible excuse for a villain.")
    end


    @next_menu = "Title"
    @menu = nil#Mnu_GameOver.new(@vp)

  end
  
  def terminate

    @vp.dispose

  end

  def hide_logo
    #@title.opacity = 0
  end

  def show_logo
    #@title.opacity = 255
  end

  def hide_char
    @char.do(go('opacity',-255,450,:qio))
    @char.do(go('x',50,500,:qio))
  end

  def show_char
    @char.do(go('opacity',255,450,:qio))
    @char.do(go('x',-50,500,:qio))
  end

  def inviz
    @map.hide
  end

  def viz
    @map.show
  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    if @message.busy?
      @message.update
      return
    else
      #@message.hide
    end

    #@sparks.each{ |s| s.update }

    #@bg.do(go("opacity",255,300)) if @bg.opacity == 0

    if @closing && $tweens.done?(self)
      $tweens.clear_all
      $game.pop_scene
    end

    return if @closing


    if @menu == nil

      # Open next menu if not fading in
      if @next_menu == nil
        close
      else
        if $tweens.done?(self)
          open_next_menu
        end
      end

    else

      @menu.update
      if @menu.done?
        
        if @next_menu == nil
          @menu = nil
          close
        else
          open_next_menu
        end
      end

    end



    # if ($input.cancel? || $input.rclick?) #|| (@next_menu == nil && @menu.done?)
    #   close
    # end
    
  end


  def open_next_menu

    if @menu != nil
      @menu.dispose
      @menu = nil
    end

    if @next_menu == "Main"
      @next_menu = nil if $menu.sub_only
    end    

    # The current menu
    case @next_menu

      when "Title"; @menu = Mnu_GameOver.new(@vp)

      when "Continue"; 
        $files.load_game(0)

      when "Load";
        @menu = Mnu_Load_Title.new(@vp)

      when "Quit"; $game.quit

    end

    @next_menu = nil

  end

  def queue_menu(menu)

    @next_menu = menu

  end

  def busy?
    return true
  end

  def close
    sys('close')
    @closing = true
    @bg.do(go("opacity",-255,300))
    self.do(delay(300))
  end




  # def init_boy

  #   # Sky
  #   @sky.bitmap = $cache.title("test-sky")
  #   #@sky.opacity = 0

  #   # Clouds
  #   @clouds.bitmap = $cache.title("test-clouds")
  #   @clouds.x -= 50
  #   #@clouds.opacity = 0
  #   @clouds.do(pingpong("x",100,6000,:qio))

  #   # Wall
  #   @wall.bitmap = $cache.title("test-wall")
  #   #@wall.opacity = 0

  #   sprk = Spark.new('evil-aura',270,60,@vp)
  #   sprk.zoom_x = 2.0
  #   sprk.zoom_y = 2.0
  #   #sprk.opacity = 0
  #   sprk.z = -1
  #   @sparks.push(sprk)

  #   sprk = Spark.new('evil-aura',420,60,@vp)
  #   sprk.zoom_x = 2.0
  #   sprk.zoom_y = 2.0
  #   #sprk.opacity = 0
  #   sprk.z = -1
  #   @sparks.push(sprk)

  #   # Boy
  #   @char.bitmap = $cache.title("test-boy")
  #   #@char.opacity = 0

  #   # Title
  #   @title.bitmap = $cache.title("test-title")
  #   #@title.opacity = 0

  # end

end"“#==============================================================================
# ** Scene_Map
#==============================================================================

class Scene_Map < Scene_Base

   def initialize(map=nil,player=nil)
    super()

    @moblins = []

    # Setup
    if !map
      @map.setup($data.system.start_map_id)
      @map.setup_audio
    else
      @map = map
    end
    
    if !player
      @player.moveto($data.system.start_x, $data.system.start_y)
      @map.camera_to(@player)
      @map.camera_snap
    else
      @player = player
    end

    $map = @map
    $player = @player

    @hud = Ui_Screen.new(@vp_ui)    
            
  end
  
  def terminate
    super

  end

  def busy?
    return @hud.busy?
  end

  #--------------------------------------------------------------------------
  # * Update the map contents and processes input from the player
  #--------------------------------------------------------------------------
  def update
    super

    @moblins.each{ |i| i.update } if !busy?
    
  end

  def add_moblin(ev,delay)
    ev = gev(ev) if !ev.is_a?(Game_Event)
    @moblins.push(Moblin.new(ev,delay))
  end

end
"D#==============================================================================
# ** Scene_Menu
#==============================================================================

class Scene_Menu

  attr_accessor :savequit
  
  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    #Graphics.freeze

    @closing = false
    @savequit = false

    $mouse.change_cursor('Default')
    sys('open')

    # Vp
    @vp = Viewport.new(0,0,$game.width,$game.height)
    @vp.z = 3500

    @snap = Sprite.new(@vp)
    @snap.z = -101
    @snap.bitmap = $game.snapshot

    # Background
    @bg = Sprite.new(@vp)
    @bg.z = -100
    #@bg.bitmap = Bitmap.new(640,480)
    #@bg.bitmap.fill(Color.new(0,0,0,180))
    @bg.bitmap = $cache.menu_background("sample")
    #@bg.bitmap = $cache.menu_background("witch")
    @bg.opacity = 0
    
    #@bg.y = 30
    #@bg.do(seq(go("y",-50,150,:qio),go("y",20,150,:qio)))

    #self.do(delay(300))

    @next_menu = $menu.menu_page
    $menu.menu_page = nil

    @menu = nil

    #Graphics.transition(20,'Graphics/Transitions/trans')     

  end
  
  def terminate

    @menu.dispose if @menu != nil

    @bg.dispose
    @snap.dispose

    @vp.dispose

  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    @bg.do(go("opacity",255,300)) if @bg.opacity == 0

    if @closing && $tweens.done?(self)
      $tweens.clear_all
      if @savequit
        $game.quit 
      else
        $game.pop_scene
      end
    end

    return if @closing


    if @menu == nil

      # Open next menu if not fading in
      if @next_menu == nil
        close
      else
        if $tweens.done?(self)
          open_next_menu
        end
      end

    else

      @menu.update
      if @menu.done?
        
        if @next_menu == nil
          @menu = nil
          close
        else
          open_next_menu
        end
      end

    end



    # if ($input.cancel? || $input.rclick?) #|| (@next_menu == nil && @menu.done?)
    #   close
    # end
    
  end


  def open_next_menu

    if @menu != nil
      @menu.dispose
      @menu = nil
    end

    if @next_menu == "Main"
      @next_menu = nil if $menu.sub_only
    end    

    # The current menu
    case @next_menu

      when "Main"; @menu = Mnu_Main.new(@vp)

      when "Quit"; @menu = Mnu_Quit.new(@vp)
      when "Journal"; @menu = Mnu_Journal.new(@vp)
      when "Items"; @menu = Mnu_Items.new(@vp)
      when "Healing"; @menu = Mnu_Healing.new(@vp)
      when "Party"; @menu = Mnu_Party.new(@vp)
      when "Progress"; @menu = Mnu_Progress.new(@vp)
      when "Options"; @menu = Mnu_Options.new(@vp)
      when "Help"; @menu = Mnu_Help.new(@vp)
      when "Sound"; @menu = Mnu_Sound.new(@vp)

      when "Load"; 
        @menu = Mnu_Save.new(@vp)
        @menu.loadmode
      when "Save"; @menu = Mnu_Save.new(@vp)

      when "Char"; @menu = Mnu_Char.new(@vp)

      when "Equip"; @menu = Mnu_Equip.new(@vp)
      when "Skills"; @menu = Mnu_Skills.new(@vp)
      when "Status"; @menu = Mnu_Status.new(@vp)
      when "Profile"; @menu = Mnu_Profile.new(@vp)

      when "Potions"; @menu = Mnu_Potions.new(@vp)
      when "Chooser"; @menu = Mnu_Chooser.new(@vp)

      # Shops

      # Item Shop
      # Smith
      # Magic

      # Cheekis

      when "Shop","Smith","Magic","Chester"
        @menu = Mnu_Shop.new(@vp)
        @menu.setup(@next_menu)

      when "Sell"
        @menu = Mnu_Shop.new(@vp)
        @menu.setup(@next_menu)
        @menu.sellmode

      when "Boyle"; @menu = Mnu_Boyle.new(@vp)
      when "Ingrid"; @menu = Mnu_Ingrid.new(@vp)
      when "Nightwatch"; @menu = Mnu_Nightwatch.new(@vp)
      when "Hiberu"; @menu = Mnu_Hiberu.new(@vp)
      when "Rowen"; @menu = Mnu_Rowen.new(@vp)
      when "Phye"; @menu = Mnu_Phye.new(@vp)

    end

    @next_menu = nil

  end

  def queue_menu(menu)

    @next_menu = menu

  end



  # def open_sub(menu)
  #   @menu.close
  #   @sub = menu
  #   @sub.open
  # end

  # def change_sub(menu)
  #   @next_sub = menu
  # end

  # def close_sub
  #   @sub.close
  #   @sub.dispose
  #   @menu.open
  # end

  def close
    sys('close')
    @closing = true
    @bg.do(go("opacity",-255,300))
    self.do(delay(300))
  end


end"Ã#==============================================================================
# ** Scene_Splash
#==============================================================================

class Scene_Splash

	def initialize

		music('sample-start')

		@vp = Viewport.new(0,0,$game.width,$game.height)

		@white = Sprite.new(@vp)
		@white.bitmap = $cache.title("white")
		#@white.opacity = 0

		@logo = Sprite.new(@vp)
		@logo.bitmap = $cache.title("logo")
		@logo.x = 320
		@logo.y = 340		
		@logo.ox = 320
		@logo.oy = 340
		@logo.y -= 50
		@logo.opacity = 0

		@sheen = Sprite.new(@vp)
		@sheen.bitmap = $cache.title("sheen")
		@sheen.blend_type = 1
		@sheen.x = -300
		@sheen.opacity = 220

		@mist = Sprite.new(@vp)
		@mist.bitmap = $cache.overlay('mist-portal')
		@mist.opacity = 0

		@round = :logo_appear
		@wait = 15

		#@round = :title
		
	end

	  def inviz
    @map.hide
  end

  def viz
    @map.show
  end

	def terminate

		@logo.dispose
		@vp.dispose

	end

	def update

		@wait -= 1
		return if @wait > 0

		# Go to next movie?
		case @round

			when :logo_appear
				
				@logo.do(go('opacity',255,700,:qio))
				@logo.do(go('y',50,600,:quad_io))

				@round = :logo_sheen
				@wait = 20

			when :logo_sheen

				sys('logo')
				@sheen.do(go('x',800,750,:qio))
				@round = :mist_in
				@wait = 50

			when :mist_in				
				
				Graphics.freeze
				@mist.opacity = 255
				src = "Graphics/Transitions/Cave"
				Graphics.transition(280,src)
				#@logo.do(go('opacity',-255,1500,:qio))

				@wait = 1
				@round = :title

			when :title
				$game.pop_scene
				$game.push_scene Scene_Title.new()
				@round = :enough

		end

	end

end"Ë#==============================================================================
# ** Scene_Title
#==============================================================================

class Scene_Title
  
  attr_accessor :next_menu

  #--------------------------------------------------------------------------
  # * Set up the scene
  #--------------------------------------------------------------------------
  def initialize

    @closing = false

    # Vp
    @vp = Viewport.new(0,0,$game.width,$game.height)
    #@vp.z = 3500

    # Sprites
    @sky = Sprite.new(@vp)
    @sky.z = -2
    @clouds = Sprite.new(@vp)
    @clouds.z = -2
    @wall = Sprite.new(@vp)
    @wall.z = -2
    @wall.opacity = 0

    @sparks = [] # Update all

    # Higher Sprites
    @char = Sprite.new(@vp)
    @title = Sprite.new(@vp)

    # Overlays
    @mist = Sprite.new(@vp)
    @mist.bitmap = $cache.overlay('mist-portal')
    @mist.z = 9999


    # Init 
    init_boy

    Graphics.freeze
    @mist.opacity = 0
    src = "Graphics/Transitions/Cave_inv"
        Graphics.transition(20,src)
 
    @next_menu = nil
    @menu = Mnu_Title.new(@vp)

  end
  
  def terminate

    @vp.dispose

  end

  def hide_logo
    @title.opacity = 0
  end

  def show_logo
    @title.opacity = 255
  end

  def hide_char
    @char.opacity = 0
  end

  def show_char
    @char.opacity = 255
  end


  def inviz
    @map.hide
  end

  def viz
    @map.show
  end

  #--------------------------------------------------------------------------
  # * Update 
  #--------------------------------------------------------------------------
  def update

    @sparks.each{ |s| s.update }

    #@bg.do(go("opacity",255,300)) if @bg.opacity == 0

    if @closing && $tweens.done?(self)
      $tweens.clear_all
      $game.pop_scene
    end

    return if @closing


    if @menu == nil

      # Open next menu if not fading in
      if @next_menu == nil
        close
      else
        if $tweens.done?(self)
          open_next_menu
        end
      end

    else

      @menu.update
      if @menu.done?
        
        if @next_menu == nil
          @menu = nil
          close
        else
          open_next_menu
        end
      end

    end



    # if ($input.cancel? || $input.rclick?) #|| (@next_menu == nil && @menu.done?)
    #   close
    # end
    
  end


  def open_next_menu

    if @menu != nil
      @menu.dispose
      @menu = nil
    end

    if @next_menu == "Main"
      @next_menu = nil if $menu.sub_only
    end    

    # The current menu
    case @next_menu

      when "Title"; @menu = Mnu_Title.new(@vp)

      when "New";
        $game.pop_scene
        $game.push_scene Scene_Map.new()

      when "Continue"; 
        @menu = Mnu_Load_Title.new(@vp)

      when "Options";
        @menu = Mnu_Options_Title.new(@vp)

      when "Quit"; @menu = Mnu_Main.new(@vp)

    end

    @next_menu = nil

  end

  def queue_menu(menu)

    @next_menu = menu

  end



  # def open_sub(menu)
  #   @menu.close
  #   @sub = menu
  #   @sub.open
  # end

  # def change_sub(menu)
  #   @next_sub = menu
  # end

  # def close_sub
  #   @sub.close
  #   @sub.dispose
  #   @menu.open
  # end

  def close
    sys('close')
    @closing = true
    @bg.do(go("opacity",-255,300))
    self.do(delay(300))
  end




  def init_boy

    # Sky
    @sky.bitmap = $cache.title("test-sky")
    #@sky.opacity = 0

    # Clouds
    @clouds.bitmap = $cache.title("test-clouds")
    @clouds.x -= 50
    #@clouds.opacity = 0
    @clouds.do(pingpong("x",100,6000,:qio))

    # Wall
    @wall.bitmap = $cache.title("test-wall")
    #@wall.opacity = 0

    sprk = Spark.new('evil-aura',270,60,@vp)
    sprk.zoom_x = 2.0
    sprk.zoom_y = 2.0
    #sprk.opacity = 0
    sprk.z = -1
    @sparks.push(sprk)

    sprk = Spark.new('evil-aura',420,60,@vp)
    sprk.zoom_x = 2.0
    sprk.zoom_y = 2.0
    #sprk.opacity = 0
    sprk.z = -1
    @sparks.push(sprk)

    # Boy
    @char.bitmap = $cache.title("test-boy")
    #@char.opacity = 0

    # Title
    @title.bitmap = $cache.title("test-title")
    #@title.opacity = 0

  end

end"¬Cmodule Seal

  #LIB_DIR = "System/"
  class SealAPI < Win32API
    STRCPY_S = Win32API.new('msvcrt', 'strcpy_s', 'pll', 'i')

    def initialize(func, arg_types, return_type = 'i', *args)
      @return_string = return_type == 'p'
      library = File.join(defined?(LIB_DIR) ? LIB_DIR : '.', 'seal')
      super(library, "seal_#{func}", arg_types, return_type, *args)
    end

    def [](*args)
      result = call(*args)
      if @return_string and result.is_a? Integer
        # String pointer is returned to Ruby as an integer even though we
        # specified 'p' as the return value - possibly a bug in Ruby 1.9.3's
        # Win32API implementation. Work around it.
        message_buffer = ' ' * 128
        STRCPY_S.call(message_buffer, message_buffer.size, result)
        return message_buffer.strip
      end
      result
    end unless method_defined? :[]
  end

  module Helper
    GET_ERR_MSG = SealAPI.new('get_err_msg', 'i', 'p')

    class << self
      def define_enum(mod, constants, start_value = 0)
        constants.each_with_index do |constant, index|
          mod.const_set(constant, start_value + index)
        end
      end

      # Returns a destructor for a native Seal object. This is most likely
      # called in the initializer method, but we cannot define the proc handler
      # there because that will capture the binding of the implicit `self` (due
      # to the nature of closure), which makes the object that `self` refers to
      # unrecyclable.
      def free(obj, destroyer)
        lambda { |object_id| destroyer[obj] }
      end
    end

  private
    def check_error(error_code)
      raise SealError, GET_ERR_MSG[error_code], caller.shift if error_code != 0
      nil
    end

    def input_audio(media, filename, format, inputter)
      check_error(inputter[media, filename, format])
    end

    def set_obj_int(obj, int, setter)
      check_error(setter[obj, int])
      int
    end

    def get_obj_int(obj, getter)
      buffer = '    '
      check_error(getter[obj, buffer])
      buffer.unpack('i')[0]
    end

    def set_obj_char(obj, bool, setter)
      set_obj_int(obj, bool ? 1 : 0, setter)
    end

    def get_obj_char(obj, getter)
      buffer = ' '
      check_error(getter[obj, buffer])
      buffer.unpack('c')[0] != 0
    end

    # Win32API does not support float argument type, need to pass as integer.
    def set_obj_float(obj, float, setter)
      check_error(setter[obj, [float].pack('f').unpack('i')[0]])
      float
    end

    def get_obj_float(obj, getter)
      float_buffer = '    '
      check_error(getter[obj, float_buffer])
      float_buffer.unpack('f')[0]
    end
  end

  VERSION = SealAPI.new('get_version', 'v', 'p')[]

  class << self
    include Helper

    STARTUP = SealAPI.new('startup', 'p')
    CLEANUP = SealAPI.new('cleanup', 'v', 'v')
    GET_PER_SRC_EFFECT_LIMIT = SealAPI.new('get_per_src_effect_limit', 'v')

    def startup(device = nil)
      check_error(STARTUP[device ? device : 0])
    end

    def cleanup
      CLEANUP[]
    end

    def per_source_effect_limit
      GET_PER_SRC_EFFECT_LIMIT[]
    end
  end

  module Format
    Helper.define_enum(self, [
      :UNKNOWN,
      :WAV,
      :OV,
      :MPG
    ])
  end

  class SealError < Exception
  end

  class Buffer
    include Helper

    INIT = SealAPI.new('init_buf', 'p')
    DESTROY = SealAPI.new('destroy_buf', 'p')
    LOAD = SealAPI.new('load2buf', 'ppi')
    GET_SIZE = SealAPI.new('get_buf_size', 'pp')
    GET_FREQ = SealAPI.new('get_buf_freq', 'pp')
    GET_BPS = SealAPI.new('get_buf_bps', 'pp')
    GET_NCHANNELS = SealAPI.new('get_buf_nchannels', 'pp')

    def initialize(filename, format = Format::UNKNOWN)
      @buffer = '    '
      check_error(INIT[@buffer])
      input_audio(@buffer, filename, format, LOAD)
      ObjectSpace.define_finalizer(self, Helper.free(@buffer, DESTROY))
      self
    end

    def load(filename, format = Format::UNKNOWN)
      input_audio(@buffer, filename, format, LOAD)
      self
    end

    def size
      get_obj_int(@buffer, GET_SIZE)
    end

    def frequency
      get_obj_int(@buffer, GET_FREQ)
    end

    def bit_depth
      get_obj_int(@buffer, GET_BPS)
    end

    def channel_count
      get_obj_int(@buffer, GET_NCHANNELS)
    end
  end

  class Stream
    include Helper

    OPEN = SealAPI.new('open_stream', 'ppi')
    CLOSE = SealAPI.new('close_stream', 'p')
    REWIND = SealAPI.new('rewind_stream', 'p')

    class << self
      alias open new
    end

    def initialize(filename, format = Format::UNKNOWN)
      @stream = '    ' * 5
      input_audio(@stream, filename, format, OPEN)
      ObjectSpace.define_finalizer(self, Helper.free(@stream, CLOSE))
      self
    end

    def frequency
      field(4)
    end

    def bit_depth
      field(2)
    end

    def channel_count
      field(3)
    end

    def rewind
      check_error(REWIND[@stream])
    end

    def close
      check_error(CLOSE[@stream])
    end

  private
    def field(index)
      @stream[index * 4, 4].unpack('i')[0]
    end
  end

  class Reverb
    include Helper

    INIT = SealAPI.new('init_rvb', 'p')
    DESTROY = SealAPI.new('destroy_rvb', 'p')
    LOAD = SealAPI.new('load_rvb', 'pi')
    SET_DENSITY = SealAPI.new('set_rvb_density', 'pi')
    SET_DIFFUSION = SealAPI.new('set_rvb_diffusion', 'pi')
    SET_GAIN = SealAPI.new('set_rvb_gain', 'pi')
    SET_HFGAIN = SealAPI.new('set_rvb_hfgain', 'pi')
    SET_DECAY_TIME = SealAPI.new('set_rvb_decay_time', 'pi')
    SET_HFDECAY_RATIO = SealAPI.new('set_rvb_hfdecay_ratio', 'pi')
    SET_REFLECTIONS_GAIN = SealAPI.new('set_rvb_reflections_gain', 'pi')
    SET_REFLECTIONS_DELAY = SealAPI.new('set_rvb_reflections_delay', 'pi')
    SET_LATE_GAIN = SealAPI.new('set_rvb_late_gain', 'pi')
    SET_LATE_DELAY = SealAPI.new('set_rvb_late_delay', 'pi')
    SET_AIR_ABSORBTION_HFGAIN =
      SealAPI.new('set_rvb_air_absorbtion_hfgain', 'pi')
    SET_ROOM_ROLLOFF_FACTOR = SealAPI.new('set_rvb_room_rolloff_factor', 'pi')
    SET_HFDECAY_LIMITED = SealAPI.new('set_rvb_hfdecay_limited', 'pi')
    GET_DENSITY = SealAPI.new('get_rvb_density', 'pp')
    GET_DIFFUSION = SealAPI.new('get_rvb_diffusion', 'pp')
    GET_GAIN = SealAPI.new('get_rvb_gain', 'pp')
    GET_HFGAIN = SealAPI.new('get_rvb_hfgain', 'pp')
    GET_DECAY_TIME = SealAPI.new('get_rvb_decay_time', 'pp')
    GET_HFDECAY_RATIO = SealAPI.new('get_rvb_hfdecay_ratio', 'pp')
    GET_REFLECTIONS_GAIN = SealAPI.new('get_rvb_reflections_gain', 'pp')
    GET_REFLECTIONS_DELAY = SealAPI.new('get_rvb_reflections_delay', 'pp')
    GET_LATE_GAIN = SealAPI.new('get_rvb_late_gain', 'pp')
    GET_LATE_DELAY = SealAPI.new('get_rvb_late_delay', 'pp')
    GET_AIR_ABSORBTION_HFGAIN =
      SealAPI.new('get_rvb_air_absorbtion_hfgain', 'pp')
    GET_ROOM_ROLLOFF_FACTOR = SealAPI.new('get_rvb_room_rolloff_factor', 'pp')
    IS_HFDECAY_LIMITED = SealAPI.new('is_rvb_hfdecay_limited', 'pp')

    def initialize(preset = nil)
      @effect = '    '
      check_error(INIT[@effect])
      load(preset) if preset
      ObjectSpace.define_finalizer(self, Helper.free(@effect, DESTROY))
      self
    end

    def load(preset)
      check_error(LOAD[@effect, preset])
    end

    def density=(density)
      set_obj_float(@effect, density, SET_DENSITY)
    end

    def diffusion=(diffusion)
      set_obj_float(@effect, diffusion, SET_DIFFUSION)
    end

    def gain=(gain)
      set_obj_float(@effect, gain, SET_GAIN)
    end

    def hfgain=(hfgain)
      set_obj_float(@effect, hfgain, SET_HFGAIN)
    end

    def decay_time=(decay_time)
      set_obj_float(@effect, decay_time, SET_DECAY_TIME)
    end

    def hfdecay_ratio=(hfdecay_ratio)
      set_obj_float(@effect, hfdecay_ratio, SET_HFDECAY_RATIO)
    end

    def reflections_gain=(reflections_gain)
      set_obj_float(@effect, reflections_gain, SET_REFLECTIONS_GAIN)
    end

    def reflections_delay=(reflections_delay)
      set_obj_float(@effect, reflections_delay, SET_REFLECTIONS_DELAY)
    end

    def late_gain=(late_gain)
      set_obj_float(@effect, late_gain, SET_LATE_GAIN)
    end

    def late_delay=(late_delay)
      set_obj_float(@effect, late_delay, SET_LATE_DELAY)
    end

    def air_absorbtion_hfgain=(air_absorbtion_hfgain)
      set_obj_float(@effect, air_absorbtion_hfgain, SET_AIR_ABSORBTION_HFGAIN)
    end

    def room_rolloff_factor=(room_rolloff_factor)
      set_obj_float(@effect, room_rolloff_factor, SET_ROOM_ROLLOFF_FACTOR)
    end

    def hfdecay_limited=(hfdecay_limited)
      set_obj_char(@effect, hfdecay_limited, SET_HFDECAY_LIMITED)
    end

    def density
      get_obj_float(@effect, GET_DENSITY)
    end

    def diffusion
      get_obj_float(@effect, GET_DIFFUSION)
    end

    def gain
      get_obj_float(@effect, GET_GAIN)
    end

    def hfgain
      get_obj_float(@effect, GET_HFGAIN)
    end

    def decay_time
      get_obj_float(@effect, GET_DECAY_TIME)
    end

    def hfdecay_ratio
      get_obj_float(@effect, GET_HFDECAY_RATIO)
    end

    def reflections_gain
      get_obj_float(@effect, GET_REFLECTIONS_GAIN)
    end

    def reflections_delay
      get_obj_float(@effect, GET_REFLECTIONS_DELAY)
    end

    def late_gain
      get_obj_float(@effect, GET_LATE_GAIN)
    end

    def late_delay
      get_obj_float(@effect, GET_LATE_DELAY)
    end

    def air_absorbtion_hfgain
      get_obj_float(@effect, GET_AIR_ABSORBTION_HFGAIN)
    end

    def room_rolloff_factor
      get_obj_float(@effect, GET_ROOM_ROLLOFF_FACTOR)
    end

    def hfdecay_limited
      get_obj_char(@effect, IS_HFDECAY_LIMITED)
    end

    alias hfdecay_limited? hfdecay_limited

    module Preset
      Helper.define_enum(self, [
        :GENERIC,
        :PADDEDCELL,
        :ROOM,
        :BATHROOM,
        :LIVINGROOM,
        :STONEROOM,
        :AUDITORIUM,
        :CONCERTHALL,
        :CAVE,
        :ARENA,
        :HANGAR,
        :CARPETEDHALLWAY,
        :HALLWAY,
        :STONECORRIDOR,
        :ALLEY,
        :FOREST,
        :CITY,
        :MOUNTAINS,
        :QUARRY,
        :PLAIN,
        :PARKINGLOT,
        :SEWERPIPE,
        :UNDERWATER,
        :DRUGGED,
        :DIZZY,
        :PSYCHOTIC
      ])
    end
  end

  class Source
    include Helper

    INIT = SealAPI.new('init_src', 'p')
    DESTROY = SealAPI.new('destroy_src', 'p')
    PLAY = SealAPI.new('play_src', 'p')
    STOP = SealAPI.new('stop_src', 'p')
    REWIND = SealAPI.new('rewind_src', 'p')
    PAUSE = SealAPI.new('pause_src', 'p')
    DETACH = SealAPI.new('detach_src_audio', 'p')
    MOVE = SealAPI.new('move_src', 'p')
    SET_BUF = SealAPI.new('set_src_buf', 'pp')
    SET_STREAM = SealAPI.new('set_src_stream', 'pp')
    FEED_EFS = SealAPI.new('feed_efs', 'ppi')
    UPDATE = SealAPI.new('update_src', 'p')
    SET_POS = SealAPI.new('set_src_pos', 'piii')
    SET_VEL = SealAPI.new('set_src_vel', 'piii')
    SET_GAIN = SealAPI.new('set_src_gain', 'pi')
    SET_PITCH = SealAPI.new('set_src_pitch', 'pi')
    SET_AUTO = SealAPI.new('set_src_auto', 'pi')
    SET_RELATIVE = SealAPI.new('set_src_relative', 'pi')
    SET_LOOPING = SealAPI.new('set_src_looping', 'pi')
    SET_QUEUE_SIZE = SealAPI.new('set_src_queue_size', 'pi')
    SET_CHUNK_SIZE = SealAPI.new('set_src_chunk_size', 'pi')
    GET_POS = SealAPI.new('get_src_pos', 'pppp')
    GET_VEL = SealAPI.new('get_src_vel', 'pppp')
    GET_GAIN = SealAPI.new('get_src_gain', 'pp')
    GET_PITCH = SealAPI.new('get_src_pitch', 'pp')
    GET_AUTO = SealAPI.new('is_src_auto', 'pp')
    GET_RELATIVE = SealAPI.new('is_src_relative', 'pp')
    GET_LOOPING = SealAPI.new('is_src_looping', 'pp')
    GET_QUEUE_SIZE = SealAPI.new('get_src_queue_size', 'pp')
    GET_CHUNK_SIZE = SealAPI.new('get_src_chunk_size', 'pp')
    GET_TYPE = SealAPI.new('get_src_type', 'pp')
    GET_STATE = SealAPI.new('get_src_state', 'pp')

    def initialize
      @source = '    ' * 5
      check_error(INIT[@source])
      ObjectSpace.define_finalizer(self, Helper.free(@source, DESTROY))
      self
    end

    def play
      operate(PLAY)
    end

    def stop
      operate(STOP)
    end

    def rewind
      operate(REWIND)
    end

    def pause
      operate(PAUSE)
    end

    def move
      operate(MOVE)
    end

    def buffer=(buffer)
      set_audio(:@buffer, buffer, SET_BUF)
    end

    def stream=(stream)
      set_audio(:@stream, stream, SET_STREAM)
    end

    attr_reader :buffer, :stream

    def feed(effect_slot, index)
      native_efs_obj = effect_slot.instance_variable_get(:@effect_slot)
      check_error(FEED_EFS[@source, native_efs_obj, index])
      self
    end

    def update
      operate(UPDATE)
    end

    def position=(position)
      set_3float(position, SET_POS)
    end

    def velocity=(velocity)
      set_3float(velocity, SET_VEL)
    end

    def gain=(gain)
      return if gain < 0
      set_obj_float(@source, gain, SET_GAIN)
    end

    def pitch=(pitch)
      set_obj_float(@source, pitch, SET_PITCH)
    end

    def auto=(auto)
      set_obj_char(@source, auto, SET_AUTO)
    end

    def queue_size=(queue_size)
      set_obj_int(@source, queue_size, SET_QUEUE_SIZE)
    end

    def chunk_size=(chunk_size)
      set_obj_int(@source, chunk_size, SET_CHUNK_SIZE)
    end

    def relative=(relative)
      set_obj_char(@source, relative, SET_RELATIVE)
    end

    def looping=(looping)
      set_obj_char(@source, looping, SET_LOOPING)
    end

    def position
      get_3float(GET_POS)
    end

    def velocity
      get_3float(GET_VEL)
    end

    def gain
      get_obj_float(@source, GET_GAIN)
    end

    def pitch
      get_obj_float(@source, GET_PITCH)
    end

    def auto
      get_obj_char(@source, GET_AUTO)
    end

    def relative
      get_obj_char(@source, GET_RELATIVE)
    end

    def looping
      get_obj_char(@source, GET_LOOPING)
    end

    alias auto? auto
    alias relative? relative
    alias looping? looping

    def queue_size
      get_obj_int(@source, GET_QUEUE_SIZE)
    end

    def chunk_size
      get_obj_int(@source, GET_CHUNK_SIZE)
    end

    def type
      case get_obj_int(@source, GET_TYPE)
      when Type::STATIC
        Type::STATIC
      when Type::STREAMING
        Type::STREAMING
      else
        Type::UNDETERMINED
      end
    end

    def state
      case get_obj_int(@source, GET_STATE)
      when State::PLAYING
        State::PLAYING
      when State::PAUSED
        State::PAUSED
      when State::STOPPED
        State::STOPPED
      else
        State::INITIAL
      end
    end

    def playing?
      return state == State::PLAYING
    end

  private
    def operate(operation)
      check_error(operation[@source])
      self
    end

    def set_audio(var, audio, setter)
      if audio.nil?
        operate(DETACH)
      else
        check_error(setter[@source, audio.instance_variable_get(var)])
      end
      instance_variable_set(var, audio)
      audio
    end

    def set_3float(float_tuple, setter)
      integer_tuple = float_tuple.pack('f*').unpack('i*')
      check_error(setter[@source, *integer_tuple])
      float_tuple
    end

    def get_3float(getter)
      float_tuple_buffers = Array.new(3) { '    ' }
      check_error(getter[@source, *float_tuple_buffers])
      float_tuple_buffers.join.unpack('f*')
    end

    module State
      Helper.define_enum(self, [
        :INITIAL,
        :PLAYING,
        :PAUSED,
        :STOPPED
      ])
    end

    module Type
      Helper.define_enum(self, [
        :UNDETERMINED,
        :STATIC,
        :STREAMING
      ])
    end
  end

  class EffectSlot
    include Helper

    INIT = SealAPI.new('init_efs', 'p')
    DESTROY = SealAPI.new('destroy_efs', 'p')
    SET_EFFECT = SealAPI.new('set_efs_effect', 'pp')
    SET_GAIN = SealAPI.new('set_efs_gain', 'pi')
    SET_AUTO = SealAPI.new('set_efs_auto', 'pi')
    GET_GAIN = SealAPI.new('get_efs_gain', 'pp')
    GET_AUTO = SealAPI.new('is_efs_auto', 'pp')

    def initialize(effect = nil)
      @effect_slot = '    '
      check_error(INIT[@effect_slot])
      self.effect = effect if effect
      ObjectSpace.define_finalizer(self, Helper.free(@effect_slot, DESTROY))
      self
    end

    def effect=(effect)
      native_effect_obj = effect ? effect.instance_variable_get(:@effect) : 0
      check_error(SET_EFFECT[@effect_slot, native_effect_obj])
      @effect = effect
      effect
    end

    attr_reader :effect

    def gain=(gain)
      set_obj_float(@effect_slot, gain, SET_GAIN)
    end

    def gain
      get_obj_float(@effect_slot, GET_GAIN)
    end

    def auto=(auto)
      set_obj_char(@effect_slot, auto, SET_AUTO)
    end

    def auto
      get_obj_char(@effect_slot, GET_AUTO)
    end

    alias auto? auto
  end
end"Ö#==============================================================================
# ** Audio Manager
#==============================================================================

class AudioManager

  attr_accessor :music_target, :atmosphere_target
  attr_accessor :music_gain, :atmosphere_gain

  def initialize

    begin
      Seal.startup
    rescue
      retry
    end

    @music = Seal::Source.new
    @atmosphere = Seal::Source.new

    @music_file = nil
    @atmosphere_file = nil

    # Fade targets
    @music_gain = 1.0
    @music_target = 1.0
    @atmosphere_gain = 1.0
    @atmosphere_target = 1.0

    # Looping, fade by distance
    @environmental = [] 

    # System Effects
    @sys = []

    # Sound effects with reverb
    @sfx = []

    # Queue of sfx to play [[file,delay,vol]]
    @queue = [] 

    @mode = :normal
    @effect = nil

    @sfx_vol = 1.0 # Set by mode

    #change_mode(:cave)
    
  end

  def dispose

    # Destroy all the sources

    Seal.cleanup
  end

  def fadeout
    @music_target = 0.0
    @atmosphere_target = 0.0
  end

  def env(file,pos)
    @environmental.each{ |snd|
      if snd.file == file
        snd.addpos(pos)
        return
      end
    }
    @environmental.push(EnviroSource.new(file,pos))
    @environmental.each{ |e| e.update }    
  end

  def clear_env
    @environmental.each{ |e|
      e.stop
      e.dispose
      e = nil
    }
    @environmental.clear
  end

  def music(file,vol=1.0)

    if @music_file == file
        @music_gain = 1.0
        @music_target = 1.0
        @music.play if !@music.playing?
      return
    end

    @music.stop if @music 

    if file == nil || file == ''     
      @music_file = nil    
      return
    end
    
    @music = nil
    @music = Seal::Source.new

    @music_file = file

    @music_gain = 1.0
    @music_target = 1.0

    @music.gain = @music_gain * $settings.music_vol
    @music.looping = true
    @music.stream = Seal::Stream.open("Audio/Music/#{file}.ogg")
    @music.play
    
  end

  def atmosphere(file)

    # Nightwatch hack
    file = 'woods-night' if flag?('night-time')

      if @atmosphere_file == file
        @atmosphere_gain = 1.0
        @atmosphere_target = 1.0
      return
    end


    @atmosphere.stop if @music

    if file == nil  || file == ''
      @atmosphere_file = nil
      return
    end

    @atmosphere = nil
    @atmosphere = Seal::Source.new
    
    @atmosphere_file = file

    @atmosphere_gain = 1.0
    @atmosphere_target = 1.0

    @atmosphere.gain = @atmosphere_gain * $settings.music_vol
    @atmosphere.looping = true
    @atmosphere.stream = Seal::Stream.open("Audio/Atmosphere/#{file}.ogg")
    @atmosphere.play

  end

  def sys(file,vol=1.0)

    # Check through sources, if empty, use, if none, add
    @sys.each{ |src|
      if !src.playing?
        src.buffer = Seal::Buffer.new("Audio/Sys/#{file}.ogg")
        src.gain = vol * $settings.sound_vol
        src.play
        return
      end
    }

    # Add new
    src = Seal::Source.new
    buf = Seal::Buffer.new("Audio/Sys/#{file}.ogg")
    src.gain = vol * $settings.sound_vol
    src.buffer = buf
    src.play
    @sys.push(src)

  end

  def sfx(file,vol=1.0)

    # Check through sources, if empty, use, if none, add
    @sfx.each{ |src|
      if !src.playing?
        src.buffer = Seal::Buffer.new("Audio/Sounds/#{file}.ogg")
        src.gain = vol * $settings.sound_vol
        src.play
        return
      end
    }

    # Add new
    src = Seal::Source.new
    buf = Seal::Buffer.new("Audio/Sounds/#{file}.ogg")
    src.buffer = buf
    src.gain = vol * $settings.sound_vol
    src.feed(@effect, 0) if @effect != nil
    src.play
    @sfx.push(src)

  end

  def queue(file,vol=1.0,delay=0)
    @queue.push([file,delay,vol])
  end

  def pause
    @music.pause
  end

  def unpause
    @music.play
  end

  # Change mode between maps so clear sources also
  def change_mode(mode)

    @mode = mode

    # Create new effect and volume modifier
    case mode
      when 'normal', ''
        preset = nil
        @effect = nil        

      when 'cave'
        preset = Seal::Reverb::Preset::CAVE
        @effect = Seal::EffectSlot.new(Seal::Reverb.new(preset))
        
    end

    @sfx.each{ |s| s = nil }
    @sfx = []
    GC.start
   
  end

  def refresh_sound_volume
    (@sys + @sfx).each{ |s| s.gain = $settings.sound_vol}
  end

  def minimize
    @atmosphere_target = 0.0
    @music_target = 0.0
    @atmosphere_gain = 0.4
    @music_gain = 0.4
  end

  def update

    if @atmosphere != nil
      if @atmosphere_target != @atmosphere_gain
        if @atmosphere_target > @atmosphere.gain
          @atmosphere_gain += 0.02
          @atmosphere_gain = 1.0 if @atmosphere_gain > 1.0
        else
          @atmosphere_gain -= 0.02
          @atmosphere_gain = 0.0 if @atmosphere_gain < 0.0
        end      
      end
      @atmosphere.gain = @atmosphere_gain * $settings.music_vol
    end

    if @music != nil
      if @music_target != @music_gain
        if @music_target > @music.gain
          @music_gain += 0.02
          @music_gain = 1.0 if @music_gain > 1.0
        else
          @music_gain -= 0.02
          @music_gain = 0.0 if @music_gain < 0.0
        end      
      end
      @music.gain = @music_gain * $settings.music_vol
    end

    @environmental.each{ |e| e.update }

    # Play sfx on delay
    @queue.each{ |i|
      i[1] -= 1
      if i[1] <= 0
        sfx(i[0],i[2])
      end
    }

    @queue.delete_if{ |i| i[1] <= 0 }

  end

end

class EnviroSource < Seal::Source

  attr_reader :file

  def initialize(sound,pos)
    super()

    @file = sound

    @positions = [pos]
    self.buffer = Seal::Buffer.new("Audio/Sounds/#{sound}.ogg")
    self.looping = true
    self.gain = 0.0
    self.play

    @short = 96 * 4 # *4 to convert to REAL coords
    @long = 450 * 4

  end

  def dispose

  end

  def addpos(pos)

    @positions.push(pos)

  end

  def update

    # Use player pos for now
    px = $player.real_x
    py = $player.real_y

    # Find closest point
    src = nil
    mn = 999999999
    @positions.each{ |p| 
      dist = ((px-p[0]) * (px-p[0])) +
             ((py-p[1]) * (py-p[1]))
      if dist < mn
        mn = dist
        src = p
      end
    }

    # Use distance to figure volume
    dist = ((px-src[0]) * (px-src[0])) +
           ((py-src[1]) * (py-src[1]))

    dist = Math.sqrt(dist)

    # If under min, full volume
    if dist < @short #* @short
      self.gain = 0.5
      return
    end

    # If over max, off
    if dist > @long #* @long
      self.gain = 0.0
      return
    end

    # Scale
    self.gain = (1.0 - (dist - @short).to_f / (@long-@short).to_f) * 0.5

  end

end"÷
class CacheManager

    def initialize
        @cache = {}
    end

    def get(filename) load("",filename) end

    def animation(filename) load("Animations/", filename) end

    def autotile(filename) load("Autotiles/", filename) end
    def tileset(filename) load("Tilesets/", filename) end
    def character(filename) load("Characters/", filename) end

    
    def panorama(filename) load("Panoramas/", filename) end
    def fog(filename) load("Fogs/", filename) end
    def overlay(filename) load("Overlays/", filename) end
    def particle(filename) load("Particles/", filename) end


    # Menu
    def menu(filename) load("Menus/", filename) end
    def menu_common(filename) load("Menus/Common/", filename) end
    def menu_wallpaper(filename) load("Menus/Wallpapers/", filename) end
    def menu_background(filename) load("Menus/Backgrounds/", filename) end
    def menu_tab(filename) load("Menus/Tabs/", filename) end
    def menu_char(filename) load("Menus/Char/", filename) end
    def menu_page(filename) load("Menus/Page/", filename) end
    def menu_book(filename) load("Menus/Book/", filename) end

    def title(filename) load("Title/", filename) end
    def gameover(filename) load("Gameover/", filename) end

    def cursor(filename) load("Cursors/", filename) end
    def icon(filename) load("Icons/", filename) end
    def numbers(filename) load("Numbers/", filename) end

    # Faces
    def face(filename) face_file("Faces/Message/", filename) end
    def face_vn(filename) face_file("Faces/Vn/", filename) end
    def face_small(filename) face_file("Faces/Small/", filename) end
    def face_large(filename) face_file("Faces/Large/", filename) end
    def face_menu(filename) face_file("Faces/Menu/", filename) end
    def face_battle(filename) face_file("Faces/Battle/", filename) end

    def face_file(folder,filename)
      filename += "."+$progress.guild_id if filename.include?("ing") && $progress.guild_id != nil
      load(folder,filename)
    end
    


    def tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end


    def load(folder_name, filename, hue = 0)
      path = "Graphics/"+folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          begin
            @cache[path] = Bitmap.new(path)
          rescue
            log_err("MISSING GRAPHICS: #{path}")
            @cache[path] = Bitmap.new(32, 32)
          end  
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end

    def clear
      @cache = {}
      GC.start
    end

  end"Û#==============================================================================
# ** Data Manager
#==============================================================================

class DataManager

  # JsonData
	attr_reader :items

  attr_reader :actors
  attr_reader :enemies
  attr_reader :skills
  attr_reader :states

  attr_reader :progress
  attr_reader :quests
  attr_reader :zones

  attr_reader :anims

  attr_reader :numbers
  attr_reader :potions
  attr_reader :profiles
  attr_reader :help

  attr_reader :victories
  attr_reader :books
  attr_reader :shop

  # Clone events
  attr_reader :clones

  # RxData
  attr_reader :commons
  attr_reader :tilesets
  attr_reader :system
  attr_reader :mapinfos

	def initialize

    # Create an icon list
    #create_icon_list if DEBUG

    # Load up json data
    usable = load_json("items",UsableData)
    usable.each{ |k,i| i.tab = "usable"}
    keys = load_json("keyitems",KeyItemData)
    keys.each{ |k,i| i.tab = "keys"}
    shop = load_json("shop",ShopData)
    shop.each{ |k,i| i.tab = "shop"}
    gear = load_json("gear",GearData)
    gear.each{ |k,i| i.tab = "gear"}

    @items = usable.merge(keys).merge(shop).merge(gear)

    @actors = load_json("actors",ActorData)
    @enemies = load_json("enemies",EnemyData)

    @skills = load_json("skills",SkillData)
    @states = load_json("states",StateData)
    
    #@progress = load_json("progress",ProgressData)
    @quests = load_json("quests",QuestData)
    @zones = load_json("zones",ZoneData)
    @anims = load_json("anims",AnimData)

    @numbers = load_json("numbers",NumberData)
    @potions = load_json("potions",PotionData)
    @profiles = load_json("profiles",ProfileData)
    @help = load_json("help",HelpData)

    @victories = load_json("victories",VictoryData)
    @books = load_json("books",BookData)
    @shop = load_json("shop",ShopData)

    @clones = load_clones

		# Convert to json
    @commons = load_data("Data/CommonEvents.rxdata")
    @tilesets = load_data("Data/Tilesets.rxdata")
    @system = load_data("Data/System.rxdata")
    @mapinfos = load_data("Data/MapInfos.rxdata")

	end

  def create_icon_list

    list = Dir.glob('Graphics/Icons/**/*').select{ |e| File.file? e }
    list.each_index { |i|
      list[i] = list[i].gsub("Graphics/Icons/","")
      list[i] = list[i].gsub(".png","")
    }

    File.open('Editor/icons.json', 'w') { |file|
      file.puts("[")
      list.each{ |l| file.puts("\""+l+"\",") }
      file.puts("\"\"")
      file.puts("]")
    }

  end

  def load_clones

    clones = {}
    map = load_data("Data/Map001.rxdata")

    map.events.each{ |k,ev|
      dta = ev.name.split('#').first.split('.')
      if dta.count > 1
        name = dta[1].rstrip
      else
        name = dta[0].rstrip
      end
      clones[name] = ev
    }

    return clones

  end

  def load_json(file,type)

    # Load from rxdata if not debug
    if !DEBUG
      return load_data("Data/Json/#{file}.rxdata")
    end

    # Clear out garbage files
    process_data_files(file)

    # If there is no data file, make blank
    if !FileTest.exist?("Editor/json/#{file}.json")
      log_sys "Missing data file: #{file}.json"
      return {}
    end

    # Load up the data
    json_data = File.read("Editor/json/#{file}.json")
    json_data = json_data.gsub(/[:]/, '=>')
    json_data = eval(json_data)

  
    # Create datas
    data = {}
    json_data.each{ |v|
      item = type.new
      v.each{ |var,val|
        
        # Ignore modified field
        next if var == 'modified'

        # Attempt to convert val to int or float
        if val.numeric?
          if val.include?(".")
            val = val.to_f
          else
            val = val.to_i
          end
        end

        item.instance_variable_set("@#{var}", val)
      }
      data[item.id] = item
      
    }

    # Export to rxdata for later
    # Disabled for now to not crowd up github commits
    #save_data(data,"Data/Json/#{file}.rxdata")

    return data

  end

  def process_data_files(file)

    # RIGHT, START AT 50 DOWN TO NOTHING! WHEN FOUND REPLACE THE BASE
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        # Found it! Delete the base and rename this one
        File.delete("Editor/json/#{file}.json")
        File.rename("Editor/json/#{file}(#{idx}).json","Editor/json/#{file}.json")
        break
      end
      idx -= 1
    end

    # Delete any with brackets
    idx = 50
    while idx > 0
      if FileTest.exist?("Editor/json/#{file}(#{idx}).json") 
        File.delete("Editor/json/#{file}(#{idx}).json")
      end      
      idx -= 1
    end

  end

 end" 	#==============================================================================
# ** Debug
#==============================================================================

def log_err(msg) $debug.log(msg,'ERROR') end
def log_scr(msg) $debug.log(msg,'SCRIPT') end
def log_info(msg) $debug.log(msg,'INFO') end
def log_sys(msg) $debug.log(msg,'SYSTEM') end
def log_ev(msg) $debug.log(msg,'EVENT') end

class DebugManager

	attr_accessor :disable_flags

	OSD_OPACITY = 230

	INFO_COLOR = Color.new(220,171,1,OSD_OPACITY)
	SCRIPT_COLOR = Color.new(128,0,64,OSD_OPACITY)
	ERROR_COLOR = Color.new(202,0,0,OSD_OPACITY)
	SYSTEM_COLOR = Color.new(0,128,128,OSD_OPACITY)
	EVENT_COLOR = Color.new(128,128,128,OSD_OPACITY)

	attr_reader :last_color

	def initialize		
		#return if !DEBUG

		#$DEBUG = true

		# Temp debug options
		@disable_flags = false

		# Prepare log file
		@path = $appdata + "\\log.txt"
		File.open(@path, 'w') { |file| }	

		
		# Prepare on screen log
		@viewport = Viewport.new(0,0,640,480)
		@viewport.z = 9999
		
		@console = DebugConsole.new(@viewport)

		@menu = DebugMenu.new(@viewport)

		@track = Sprite.new(@viewport)
	    @track.bitmap = Bitmap.new(150,30)

		@last_color = INFO_COLOR

	end	

	def update
		#return if !DEBUG

		@console.update if !@menu.active?
		@menu.update if !@console.active?

		# If tracking, do it
		if @track_obj
			@track.bitmap.fill(Color.new(0,0,0))
			@track.bitmap.font = $fonts.debug_min
   	 		@track.bitmap.draw_text(10,0,150,30,@track_obj.send(@track_val).to_s,0)
   	    end

	end

	def track(obj,val)

		@track_obj = obj
		@track_val = val

	end

	def log(msg,type='LOG')
	    #return if !DEBUG

	    msg = "NIL" if msg == nil
	    if msg.is_a?(Array)
	    	msg = "Array: "+msg.join(", ")
	    end
	    if msg.is_a?(Hash)

	    end
		out = type + "\t" + msg.to_s
		File.open(@path, 'a') { |file| file.puts(out) }

		out = msg.to_s
		color = nil

		case type
			when 'INFO'; color = INFO_COLOR
			when 'SCRIPT'; color = SCRIPT_COLOR
			when 'ERROR'; color = ERROR_COLOR
			when 'SYSTEM'; color = SYSTEM_COLOR
			when 'EVENT'; color = EVENT_COLOR
		end

		@console.log([out,color])

		@last_color = color

	end

	def busy?
		return @console.active? || @menu.active?
	end
end"ƒ#==============================================================================
# ** Save File Manager
#==============================================================================

SAVE_FILES = 20

def build_time_string(frames)

    h = frames/60/60/60
    hf = h * 60*60*60
    m = (frames-hf)/60/60
    mf = m*60*60
    s = (frames-hf-mf)/60

    if h > 0
      time = "#{h}h #{m}m"
    elsif m > 0
      time = "#{m}m #{s}s"
    else
      time = "#{s}s"
    end

    return time

end

# For the list
class SaveData
  attr_accessor :name
  attr_accessor :leader
end

class FileManager

  attr_accessor :headers

  def initialize

    @headers = []

    # 0 is auto save, you can't save over it

    # Load save headers
    i = 0
    while i <= SAVE_FILES
      if File.exist?(filename(i))
        @headers.push(load_header(i))
      else
        @headers.push(nil)
      end
      i += 1
    end

  end
  
  def any_save_files?
    !Dir.glob('Av4-*.save').empty?
  end

  def save_exists?(i)
    return @headers[i] != nil
  end

  def save_file_list
    i = 0
    list = []
    while i <= SAVE_FILES
      list.push(i)
      i+=1
    end
    return list
  end
  
  def filename(i)
    return $appdata + "\\Av4-#{i}.save"
  end

  def autosave
    save_game(0)
  end

  def save_game(i)

    # Save sfx
    if i != 0
      sys('save')
    end

    File.open(filename(i), "wb") { |file|
      header = make_save_header  
      body = make_save_contents
      Marshal.dump(header, file)
      Marshal.dump(body, file)
      @last_savefile_index = i
    }

    # Save pic for save file
    w = 256
    h = 128
    x = $menu.player_x - 128#(640-w)/2
    y = $menu.player_y - 96#(480-h)/2
    x = 0 if x < 0
    y = 0 if y < 0
    rect = Rect.new(x,y,w,h)
    mini = Bitmap.new(w,h)
    mini.blt(0,0,$game.snapshot,rect)
    mini.export("#{$appdata}//Av4-#{i}.png")



    @headers[i] = load_header(i)

    return true

  end
  
  # Could be in game? just the contents part here? Strange to give files such power
  def load_game(i)
    sys('load')
    File.open(filename(i), "rb") do |file|
      Marshal.load(file)
      extract_save_contents(Marshal.load(file))
      $game.reload
      @index = i
    end
    return true
  end
  
  def load_header(i)
    File.open(filename(i), "rb") do |file|
      return Marshal.load(file)
    end
    return nil
  end
  
  def make_save_header
    header = {}
    header[:leader] = $party.leader
    header[:leader] = 'mys' if $party.leader == 'mys-x-fox'
    header[:time] = Graphics.frame_count
    header[:members] = $party.active
    header[:gold] = $party.gold
    header[:chars] = $party.all
    header[:levels] = $party.all.map{|p| $party.get(p).level }
    header[:quest] = $data.quests[$progress.quests.reverse[0]].description
    header[:location] = $map.nice_name
    return header
  end
  
  def make_save_contents
    
    contents = {}

    contents[:battle]       = $battle
    contents[:menu]         = $menu
    contents[:party]        = $party
    contents[:progress]     = $progress
    contents[:state]        = $state

    contents[:map]          = $map
    contents[:player]       = $player

    contents[:frame_count]  = Graphics.frame_count

    return contents

  end
  
  def extract_save_contents(contents)

    $battle =    contents[:battle]
    $menu =      contents[:menu]    
    $party =     contents[:party]   
    $progress =  contents[:progress]
    $state =     contents[:state]   

    $map =       contents[:map]     
    $player =    contents[:player]

    Graphics.frame_count = contents[:frame_count]

  end
  
end
"Ó
class FontManager

	attr_reader :debug, :debug_min, :debug_ttl

	attr_reader :subtitle

	attr_reader :message, :message_shadow, :namebox
	attr_reader :message_big, :message_big_shadow
	attr_reader :message_tiny, :message_tiny_shadow

	attr_reader :list, :list_shadow

	attr_reader :pop_ttl, :pop_text, :pop_type

	attr_reader :page_ttl, :page_sub, :page_text, :page_text_color

	attr_reader :hud_hp, :hud_hp_b

	attr_reader :mini, :mini_b

	attr_reader :save_tiny


	def initialize

		# Default font
    	Font.default_size = 22
    	Font.default_name = "Consolas"

    	# Scratch Bitmap
		@scratch = Bitmap.new(800,50)

		# Debug Fonts

		@debug = Font.new
	    @debug.name = "Consolas"
	    @debug.size = 22

	    @debug_min = Font.new
	    @debug_min.name = "Consolas"
	    @debug_min.size = 20

	    @debug_ttl = Font.new
	    @debug_ttl.name = "Consolas"
	    @debug_ttl.size = 28



	    @subtitle = Font.new
    	@subtitle.name = "Verdana"
    	@subtitle.italic = true
    	@subtitle.size = 22 #was 26
    	@subtitle.color = Color.new(245,223,200)



	    # List

	    @list = Font.new
    	@list.name = "Verdana"
    	@list.size = 20 #was 26
    	@list.color = Color.new(245,223,200)

    	@list_shadow = Font.new
    	@list_shadow.name = "Verdana"
    	@list_shadow.size = 20 #was 26
    	@list_shadow.color = Color.new(0,0,0,90)


		# Message box

		@message = Font.new
	    @message.name = "Georgia"
	    @message.size = 24 #30 good for big text
	    #@message.gradient = true
	    @message.color = Color.new(245,223,200)

	    @message_shadow = Font.new
	    @message_shadow.name = "Georgia"
	    @message_shadow.size = 24
	    @message_shadow.color = Color.new(0,0,0,90)

	    @message_tiny = Font.new
	    @message_tiny.name = "Georgia"
	    @message_tiny.size = 20 #30 good for big text
	    #@message.gradient = true
	    @message_tiny.color = Color.new(245,223,200)

	    @message_tiny_shadow = Font.new
	    @message_tiny_shadow.name = "Georgia"
	    @message_tiny_shadow.size = 20
	    @message_tiny_shadow.color = Color.new(0,0,0,90)

	    @message_big = Font.new
	    @message_big.name = "Georgia"
	    @message_big.size = 30
	    #@message.gradient = true
	    @message_big.color = Color.new(245,223,200)

	    @message_big_shadow = Font.new
	    @message_big_shadow.name = "Georgia"
	    @message_big_shadow.size = 30
	    @message_big_shadow.color = Color.new(0,0,0,90)

	    @namebox = Font.new
	    @namebox.name = "Bitter"
	    @namebox.size = 30
	    @namebox.italic = true
	    @namebox.gradient = true


	    # Menus
	    
	    @pop_ttl = Font.new
	    @pop_ttl.name = "Verdana"
	    @pop_ttl.size = 22
	    @pop_ttl.color = Color.new(245,223,200)

	    @pop_text = Font.new
	    @pop_text.name = "Verdana"
	    @pop_text.size = 18
	    #@pop_text.italic = true
	    @pop_text.color = Color.new(245,223,200)

	   	@pop_type = Font.new
	    @pop_type.name = "Verdana"
	    @pop_type.size = 16
	    @pop_type.color = Color.new(245,223,200)


	    # Page 

	    @page_ttl = Font.new
		@page_ttl.name = "Georgia"
	    @page_ttl.size = 28
	    #@page_ttl.bold = true
	    @page_ttl.color = Color.new(44,44,44)

	   	@page_sub = Font.new
		@page_sub.name = "Bitter"
	    @page_sub.size = 20
	    #@page_ttl.bold = true
	    @page_sub.color = Color.new(99,99,99)

	   	@page_text = Font.new
		@page_text.name = "Georgia"
	    @page_text.size = 20
	    @page_text.color = Color.new(44,44,44)

	   	@page_text_color = Font.new
		@page_text_color.name = "Georgia"
	    @page_text_color.size = 20
	    @page_text_color.color = Color.new(71,143,32)


		# Misc

		@hud_hp = Font.new
		@hud_hp.name = "Georgia"
	    @hud_hp.size = 16
	    @hud_hp.color = Color.new(255,255,255)

	    @hud_hp_b = Font.new
		@hud_hp_b.name = "Bitter"
		@hud_hp_b.bold = true
	    @hud_hp_b.size = 16
	    @hud_hp_b.color = Color.new(99,99,99)

	    @mini = Font.new
	    @mini.name = "Verdana"
	    @mini.size = 12
	    @mini.bold = true
	    @mini.color = Color.new(255,255,255)

	    @mini_b = Font.new
	    @mini_b.name = "Verdana"
	    @mini_b.size = 12
	    @mini_b.bold = true
	    @mini_b.color = Color.new(0,0,0)

	    @save_tiny = Font.new
	    @save_tiny.name = "Bitter"
	    @save_tiny.size = 20 #30 good for big text
	    #@message.gradient = true
	    @save_tiny.color = Color.new(80,80,80)

	end

	def size(text,font)
		@scratch.font = font
		return @scratch.text_size(text)
	end

end"	#==============================================================================
# ** Game Manager
#==============================================================================

class GameManager

  attr_reader :width, :height
  attr_accessor :snapshot

  attr_accessor :queue

	def initialize

    $game = self

    Graphics.frame_rate = 60
    resize(640,480)

    @scenes = []
    @queue = nil

    @need_reload = false
    @flip_delay = 0

    # Game State Objects
    $progress = Progress.new
    $state = State.new
    $party = Game_Party.new
    $menu = MenuState.new
    $battle = Game_Battle.new    

    # Make scene object (title screen)
    if DEBUG && $settings.debug_skip_title
      push_scene(Scene_Map.new)    
    else
      push_scene(Scene_Splash.new)
    end

  end

  def reload
    @need_reload = true
  end

  def do_reload
    Graphics.freeze
    @need_reload = false
    @scenes.each{ |s| s.terminate }
    @scenes = []
    $scene = nil
    push_scene(Scene_Map.new($map,$player))
    $map.resetup
    $map.camera_snap
    $scene.update
    t = 'Graphics/Transitions/battle'
    Graphics.transition(30,t) 
  end

  def resize(w,h)
    @width = w
    @height = h
    #set_rez(w,h)
  end

  def push_scene(scene)
    @scenes[-1].inviz if !@scenes.empty?
    $scene = scene
    @scenes.unshift(scene)
  end

  def pop_scene
    #Graphics.freeze
    #$tweens.clear_all
    @scenes.shift.terminate
    $scene = @scenes[0]
    $scene.viz if $scene != nil
  end

  def sub_scene
    return @scenes[0]
  end

  def quit
    @quit = true
  end

  def quit?
    return @quit
  end

  def update

    @flip_delay -= 1

    $audio.update
    $keyboard.update
    $mouse.update
    $debug.update
    $tweens.update
    Graphics.update
    #Input.update
    @scenes[0].update

    if @queue
      push_scene(@queue)
      @queue = nil
    end

    # Reload here
    do_reload if @need_reload

  end

  def flip_window
    return if @flip_delay > 0
    @flip_delay = 30
    $settings.fullscreen = !$settings.fullscreen
    showm = Win32API.new('user32', 'keybd_event', %w(l l l l), '')
    showm.call(18,0,0,0)
    showm.call(13,0,0,0)
    showm.call(13,0,2,0)
    showm.call(18,0,2,0)
  end

end"j#============================================================================== 
# ** Input
#==============================================================================

class InputManager

	def dir4
		return 2 if $keyboard.state?(VK_DOWN) || $keyboard.state?(VK_S)
		return 4 if $keyboard.state?(VK_LEFT) || $keyboard.state?(VK_A)
		return 6 if $keyboard.state?(VK_RIGHT) || $keyboard.state?(VK_D)
		return 8 if $keyboard.state?(VK_UP) || $keyboard.state?(VK_W)
		return 0
	end

	def action?
		return $keyboard.press?(VK_ENTER) ||
			   $keyboard.press?(VK_SPACE) 
	end

	def click?
		return false if !$settings.mouse
		return $keyboard.press?(VK_LBUTTON)
	end

	def cancel?
		return $keyboard.press?(VK_ESC) || $keyboard.press?(VK_NUM0)
	end

	def rclick?
		return false if !$settings.mouse
		return $keyboard.press?(VK_RBUTTON)
	end

	def mclick?
		return false if !$settings.mouse
		return $keyboard.press?(VK_MBUTTON)
	end

	def left?
		return $keyboard.press?(VK_LEFT) || $keyboard.press?(VK_A)
	end

	def right?
		return $keyboard.press?(VK_RIGHT) || $keyboard.press?(VK_D)
	end

	def up?
		return $keyboard.press?(VK_UP) || $keyboard.press?(VK_W)
	end

	def down?
		return $keyboard.press?(VK_DOWN) || $keyboard.press?(VK_S)
	end

	def shortcut?(s)

	end

	def shift?
		return $keyboard.state?(VK_SHIFT)
	end

end"H	#==============================================================================
# ** Keyboard Manager
#==============================================================================

VK_LBUTTON = 1
VK_RBUTTON = 2
VK_MBUTTON = 4

VK_BS = 8
VK_TAB = 9
VK_ENTER = 13
VK_SHIFT = 16
VK_ESC = 27
VK_NUM0 = 96
VK_CTRL = 17

VK_SPACE = 32
VK_TILDE = 192

VK_LEFT = 37
VK_UP = 38
VK_RIGHT = 39
VK_DOWN = 40

VK_A = 65
VK_W = 87
VK_D = 68
VK_S = 83

VK_J = 74
VK_I = 73
VK_P = 80

class KeyboardManager

	KeyState = Win32API.new("user32","GetKeyState",['i'],'i')
	
	def initialize
		@keys_held = {}
	end

	def state?(key)
		check = KeyState.call(key) #& 0x80 == 128
    result = !(check == 1 || check == 0)
    # Disable mouse on keyboard input
    $mouse.mousing = false if key > 4 && result
		return result
	end

	def press?(key)
	  if !@keys_held.has_key?(key) && state?(key)
	  	@keys_held[key] = Graphics.frame_count
	  	return true
	  else
	  	return false
	  end
	end 

  def hold?(key)
    return true if press?(key)
    if @keys_held.has_key?(key)
      if (Graphics.frame_count - @keys_held[key]) % 8 == 7
        return true
      end
    end
    return false
  end 

  def down?(key)
    return state?(key)
  end

  def up?(key)
    return !state?(key)
  end

	def update
		@keys_held.delete_if { |k,v| !state?(k)}
	end

	  # http://www.mods.com.au/budapi_docs/Virtual%20Key%20Codes.htm

  def to_char(key)

    shift = $input.shift?

    case key

      when 32; " "
      when 48; shift ? ')' : '0'
      when 49; shift ? '!' : '1'
      when 50; shift ? '@' : '2'
      when 51; shift ? '#' : '3'
      when 52; shift ? '$' : '4'
      when 53; shift ? '%' : '5'
      when 54; shift ? '^' : '6'
      when 55; shift ? '&' : '7'
      when 56; shift ? '*' : '8'
      when 57; shift ? '(' : '9'

      when 65..90; shift ? key.chr.upcase : key.chr.downcase

      when 186; shift ? ':' : ';' 
      when 187; shift ? '+' : '=' 
      when 188; shift ? '<' : ',' 
      when 189; shift ? '_' : '-' 
      when 190; shift ? '>' : '.' 
      when 191; shift ? '?' : '/' 
      
      when 219; shift ? '{' : '[' 
      when 220; shift ? '|' : '\\'
      when 221; shift ? '}' : ']' 
      when 222; shift ? '"' : '\''

      else; ''

    end

  end

end"=	#============================================================================== 
# ** Modules.Mouse Input (7.0)   By Near Fantastica & SephirothSpawn
#==============================================================================

class MouseManager

  attr_reader :hwnd, :wheel
  attr_accessor :mousing

  #--------------------------------------------------------------------------
  # * API Declaration
  #--------------------------------------------------------------------------
  Cursor_Pos = Win32API.new('user32', 'GetCursorPos', 'p', 'i')
  $ShowCursor = Win32API.new('user32', 'ShowCursor', 'i', 'l')
  Scr2cli = Win32API.new('user32', 'ScreenToClient', %w(l p), 'i')
  Findwindow = Win32API.new('user32', 'FindWindowA',%w(p p),'l')

  def initialize
    @pos = [0,0]
    @hwnd = Findwindow.call(nil, "Aveyond")
    @sprite = Sprite.new()
    @sprite.z = 10000
    @sprite.ox = 32
    @sprite.oy = 32
    @mousing = true # Disabled when keys pressed
    @cursor = nil    
    change_cursor("Default")
  end

  def x() @pos[0] end
  def y() @pos[1] end
  
  def position() 
    $settings.mouse && @mousing ? @pos : [-777,-777]
  end
  def grid() 
    x = (@pos[0] + $map.display_x / 4) / 32
    y = (@pos[1] + $map.display_y / 4) / 32
    return [x.to_i,y.to_i]
  end
  def on_screen?() !(@pos[0] < 0 || @pos[1] < 0 || @pos[0] >= 640 || @pos[1] >= 480); end
        
  #--------------------------------------------------------------------------
  # * Update Mouse Position
  #--------------------------------------------------------------------------
  def update

    if !$settings.mouse
      @sprite.hide
      $ShowCursor.call(1)
    else
      @sprite.show
      $ShowCursor.call(0)
    end
    
    # Update Position
    pos = [0,0].pack('ll')
    Cursor_Pos.call(pos)
    Scr2cli.call(@hwnd, pos) 
    pos2 = pos.unpack('ll')

    # Update sprite pos if moved
    if pos2 != @pos
      @pos = pos2
      @sprite.x = @pos[0]
      @sprite.y = @pos[1]
      @mousing = true
    end

    #on_screen?.to_i) # on_screen && mouse_mode
    
  end

  def change_cursor(c)
    return if c == @cursor
    @cursor = c
    @sprite.bitmap = $cache.cursor(c)
  end

  # For snapshotting
  def hide_cursor() @sprite.opacity = 0 end
  def show_cursor() @sprite.opacity = 255 end

end"=	#==============================================================================
# ** Game_Settings
#==============================================================================

class SettingsManager

  attr_accessor :fullscreen
  attr_accessor :music_vol
  attr_accessor :sound_vol  
  attr_accessor :effects
  attr_accessor :mouse
  attr_accessor :tutorial
  attr_accessor :bottombar

  attr_accessor :debug_skip_title
  attr_accessor :debug_draw_fps
  attr_accessor :debug_draw_helpers
  attr_accessor :debug_power_test
  

  # In settings
  attr_accessor :last_file_index          # last save file no.

  #--------------------------------------------------------------------------
  # * Init
  #--------------------------------------------------------------------------
  def initialize

    # Defaults
    @fullscreen = false
    @music_vol = 1.0
    @sound_vol = 1.0    
    @effects = false
    @mouse = true
    @tutorial = false
    @bottombar = true

    # Debug options
    @debug_skip_title = false
    @debug_draw_fps = false
    @debug_draw_helpers = false
    @debug_power_test = false

    # Create the settings file if needed
    if !FileTest.exist?($appdata+'\settings.txt')
      file = File.new($appdata+'\settings.txt', "w+")
      file.close
    end
        
    # Load from settings file real quick   
    File.open($appdata+'\settings.txt', "r").each do |line|
      dta = line.split(" ")
      val = dta[1]
      if val.to_i.to_s == val
        val = val.to_i
      elsif val.to_f.to_s == val
        val = val.to_f
      elsif val == "true"
        val = true
      elsif val == "false"
        val = false
      end
      self.instance_variable_set(dta[0],val)
    end
    
  end
  
  #--------------------------------------------------------------------------
  # * Get/Set Settings
  #--------------------------------------------------------------------------
  def save() 
    File.open($appdata+'\settings.txt', 'w') { |file|  
      # Write some stats      
      self.instance_variables.each{ |var|
        next if !DEBUG && var.to_s.include?("debug")
        file.puts(var.to_s+" "+self.instance_variable_get(var).to_s)
      }
    }
  end

  def conclude
    @window = Win32API.new('Utils', "IsFullScreen", ["V"], "I").call
    save
  end

end"Õ#==============================================================================
# ** Nano Manager
#==============================================================================

class TweenManager

	def initialize
		@tweens = []
		@tweens_menu = []
		@last = Time.now
	end

	def update

		# calc delta
		delta = ((Time.now - @last) * 1000).to_i
		@last = Time.now

		if $scene.is_a?(Scene_Menu)
			@tweens_menu.delete_if{ |n| (n.is_a?(SpriteGroup) && n.disposed?) || (n.is_a?(Sprite) && n.disposed?) || n == nil || n.done? }		
		    @tweens_menu.each{ |n| n.update(delta) }
		else
			@tweens.delete_if{ |n| (n.is_a?(SpriteGroup) && n.disposed?) || (n.is_a?(Sprite) && n.disposed?) || n == nil || n.done? }		
		    
		    @tweens.each{ |n| 
		    	begin
		    		n.update(delta) 
		    	rescue
				end
		    }
			
		end

	end

	def register(tween)
		# Register to the set for this scene
		if $scene.is_a?(Scene_Menu)
			@tweens_menu.push(tween)	
		else
			@tweens.push(tween)
		end
	end

	def clear(object)
		if $scene.is_a?(Scene_Menu)
			@tweens_menu.delete_if{ |n| n.parent == object } 
		else
			@tweens.delete_if{ |n| n.parent == object } 
		end
	end

	def resolve(object)
		if $scene.is_a?(Scene_Menu)
			@tweens_menu.each{ |n| n.update(5000) if n.parent == object }
		else
			@tweens.each{ |n| n.update(5000) if n.parent == object }
		end
		clear(object)
	end

	def clear_all		
		if $scene.is_a?(Scene_Menu)
			@tweens_menu.clear
		else
			@tweens.clear
		end
	end

	def done?(object)
		if $scene.is_a?(Scene_Menu)
			return @tweens_menu.select{ |n| n.parent == object }.empty?
		else
			return @tweens.select{ |n| n.parent == object }.empty?
		end
	end

end"¯class Bitmap

	def fill(color)
		self.fill_rect(0,0,self.width,self.height,color)
	end

	def fill_rand
		self.fill_rect(0,0,self.width,self.height,Color.new(rand(255),rand(255),rand(255)))
	end

	# xp windowskin style
	def windowskin(skin)
		src = $cache.windowskin(skin)
		dest = rect.dup
		dest.x += 3
		dest.y += 3
		dest.width -= 6
		dest.height -= 6
		stretch_blt(dest,src,Rect.new(0,0,128,128),210)

		w = 16
		h = 16
		sx = 128
		sy = 0

		o = 255

		# CORNERS
	    blt(0,0,src,Rect.new(sx,sy,w,h),o) # top left
	    blt(width-w,0,src,Rect.new(sx+48,sy,w,h),o) # top right
	    blt(0,height-h,src,Rect.new(sx,sy+48,w,h),o) # bottom left
	    blt(width-w,height-h,src,Rect.new(sx+48,sy+48,w,h),o) # bottom right
	    
	    #dest_rect, bmp, src_rect

	   #  # Middle
	   #stretch_blt(Rect.new(w,h,width-16,height-16),src,Rect.new(sx+16,0,w,h),o)

	   #  # left side
	   stretch_blt(Rect.new(0,h,w,height-32),src,Rect.new(sx,h+16,w,h),o)

	   #  # Right
	     stretch_blt(Rect.new(width-w,h,w,height-32),src,Rect.new(sx+48,h,w,h),o)

	   #  #top
	   stretch_blt(Rect.new(w,0,width-32,h),src,Rect.new(sx+16,0,w,h),o)

	   # #bottom
	   stretch_blt(Rect.new(w,height-h,width-32,h),src,Rect.new(sx+16,h+32,w,h),o)


	end

	def borderskin(src)

		# 32px corners, 64px edges

		w = 32
		h = 32

		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(96,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,96,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(96,96,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-64),src,Rect.new(0,h+16,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-64),src,Rect.new(96,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-64,32),src,Rect.new(32,0,64,32))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-64,32),src,Rect.new(32,96,64,32))

	end

	def skin(src)
		
		w = src.width/3
		h = src.height/3


		# Inside
		dest = Rect.new(w,h,width-w,height-h)
		srect = Rect.new(w,h,w,h)
		stretch_blt(dest,src,srect)
    	
		# CORNERS
	    blt(0,0,src,Rect.new(0,0,w,h)) # top left
	    blt(width-w,0,src,Rect.new(w*2,0,w,h)) # top right

	    blt(0,height-h,src,Rect.new(0,h*2,w,h)) # bottom left
	    blt(width-w,height-h,src,Rect.new(w*2,h*2,w,h)) # bottom right
	    
	   # left side
	   stretch_blt(Rect.new(0,h,w,height-h),src,Rect.new(0,w,w,h))

	   # Right
	   stretch_blt(Rect.new(width-w,h,w,height-h),src,Rect.new(w*2,h,w,h))

	   # top
	   stretch_blt(Rect.new(w,0,width-w,h),src,Rect.new(w,0,w,h))

	   # bottom
	   stretch_blt(Rect.new(w,height-h,width-w,h),src,Rect.new(w,h*2,w,h))




	end

	def vskin(src)
		size = src.height/3
    	blt(0,0,src,Rect.new(0,0,src.width,size)) # top left
    	blt(0,height-size,src,Rect.new(0,size*2,src.width,size)) # bottom right    
    	stretch_blt(Rect.new(0,size,size,height-size),src,Rect.new(0,size,src.width,size))
	end

	def hskin(src)
		size = src.width/3
    	blt(0,0,src,Rect.new(0,0,size,src.height)) #left
    	blt(width-size,0,src,Rect.new(size*2,0,size,src.height)) # bottom right    
    	stretch_blt(Rect.new(size,0,width-size*2,src.height),src,Rect.new(size,0,size,src.height))
	end

end
"\
class UsableData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :price
	attr_reader :scope
	attr_reader :priority
	attr_reader :text
	attr_reader :anim
	attr_reader :action
	attr_reader :battle
	attr_accessor :tab
end

class KeyItemData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :price
	attr_reader :notes
	attr_accessor :tab
end

class ShopData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :price
	attr_reader :level
	attr_reader :request
	attr_reader :accept
	attr_reader :deny
	attr_accessor :tab
end

class GearData
	attr_reader :id
	attr_reader :name
	attr_reader :slot
	attr_reader :description
	attr_reader :price
	attr_reader :stats
	attr_reader :mods
	attr_reader :icon
	attr_reader :source
	attr_accessor :tab
end

class SkillData
	attr_reader :id
	attr_reader :name
	attr_reader :book
	attr_reader :description
	attr_reader :icon
	attr_reader :cost
	attr_reader :hits
	attr_reader :cooldown
	attr_reader :priority
	attr_reader :scope
	attr_reader :text
	attr_reader :anim
	attr_reader :stats
	attr_reader :effects
	attr_reader :price
end

class StateData
	attr_reader :id
	attr_reader :name
	attr_reader :color
	attr_reader :stats
	attr_reader :mods
	attr_reader :stun
	attr_reader :rmv_battle
	attr_reader :rmv_shock
	attr_reader :rmv_turn	
end

class ActorData
	attr_reader :id
	attr_reader :name
	attr_reader :actions
	attr_reader :slots
	attr_reader :mods
end

class EnemyData
	attr_reader :id
	attr_reader :name
	attr_reader :actions
	attr_reader :stats
	attr_reader :xp
	attr_reader :gold
	attr_reader :drops
	attr_reader :loot
end

class ZoneData
	attr_reader :id
	attr_reader :music
	attr_reader :atmosphere
	attr_reader :reverb
	attr_reader :overlay
	attr_reader :weather
	attr_reader :fog
	attr_reader :panoramas
	attr_reader :enemies
	attr_reader :battles
end

class ProgressData
	attr_reader :category
	attr_reader :id
	attr_reader :value
end

class QuestData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
	attr_reader :location
	attr_reader :req
	attr_reader :type
end

class AnimData
	attr_reader :id
	attr_reader :frames
	attr_reader :delay
	attr_reader :fadeout
	attr_reader :order
	attr_reader :blend
	attr_reader :opacity
	attr_reader :sound
	attr_reader :loop
	attr_reader :offset
end

class NumberData
	attr_reader :id
	attr_reader :value
end

class ProfileData
	attr_reader :id
	attr_reader :name
	attr_reader :age
	attr_reader :home
	attr_reader :bio
	attr_reader :tip
	attr_reader :fact
end

class PotionData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :ingredient
	attr_reader :problems
	attr_reader :result
end

class VictoryData
	attr_reader :id
	attr_reader :dialogue
end

class HelpData
	attr_reader :id
	attr_reader :name
	attr_reader :description
	attr_reader :icon
end

class BookData
	attr_reader :id
	attr_reader :title
end"r#==============================================================================
# ** Gradient Font Color
#------------------------------------------------------------------------------
#   Original code by poccil
#   Rewritten by Dargor, 2008
#   05/07/08
#   Version 1.0
#------------------------------------------------------------------------------
#   VERSION HISTORY:
#    - 1.0 (05/07/08), Initial release
#------------------------------------------------------------------------------
#   INSTRUCTIONS:
#    - Paste this above main
#    - Edit the font's gradient parameters in a window like that:
#            self.contents.font.gradient = true/false
#            self.contents.font.gradient_color1 = color
#            self.contents.font.gradient_color2 = color
#            self.contents.font.gradient_mode = mode
#                  Modes: (0 : Vertical, 1: Horizontal, 2: Diagonal)
#    - By default, the gradient effect is on. You can turn it off by
#       setting the @gradient flag in the Font class to false. (*line 47)
#------------------------------------------------------------------------------
#   NOTES:
#       This script is compatible with both XP and VX
#==============================================================================
 
#==============================================================================
# ** Font
#==============================================================================
 
class Font
  
  attr_accessor :gradient
  attr_accessor :gradient_color1
  attr_accessor :gradient_color2
  
end
 
#==============================================================================
# ** Bitmap
#==============================================================================
 
class Bitmap

  #--------------------------------------------------------------------------
  # * Draw Text
  #--------------------------------------------------------------------------
  def draw_gtext(x,y,width,height,text,type=0)

      #return draw_text(*args) if !self.font.gradient

      # colors
      case type
        when 0
          c1 = Color.new(215,193,170)
        when 1
          c1 = Color.new(189,186,105)
      end      

      c2 = Color.new(255,255,255)
        
      # Align left only
      align = 0


      original_color = self.font.color
      alpha = original_color.alpha.to_f if alpha.nil?
      # Create temporary text bitmap
      text1=Bitmap.new(width, height)
      text2=Bitmap.new(width, height)
      text1.font.size = self.font.size
      text1.font.name = self.font.name
      text1.font.italic = self.font.italic
      text1.font.bold = self.font.bold
      text1.font.color = c1 #self.font.gradient_color2
      text_height = text1.text_size(text).height
      text_width = text1.text_size(text).width
      return if text_width < 1 or text_height < 1

      # Temporary remove the gradient effect
      text1.draw_text(0, 0, width, height, text, align)

      # What in the world .....
         text_position = (height / 2) - (text_height / 2)
         for i in 0...height
            if i < text_position
               opacity = 0
            elsif i > text_position + text_height
               opacity = 255
            else
               ratio = ((i - text_position) * 1.0 / text_height)
               ratio -=(0.5 - ratio) * 0.5
               #ratio += 0.2
               opacity = ratio * 255.0
               opacity = 255.0 if opacity > 255.0
               opacity = 0.0 if opacity < 0.0
            end
            text2.blt(0, i, text1, Rect.new(0,i,width,1), opacity)
         end


      # Draw gradient text
      self.font.color = c2 #self.font.gradient_color1
      self.font.color.alpha = alpha
      # Temporary remove the gradient effect
      self.font.gradient = false
      draw_text(x,y,width,height,text)
      # Temporary remove the gradient effect
      self.font.gradient = true
      self.font.color = original_color
      self.font.color.alpha = 255#alpha
      self.blt(x, y, text2, text2.rect, alpha)
      # Dispose gradient text bitmap
      text1.dispose
      text2.dispose

  end

end"»
class Group

	def initialize(args)

		@events = args

	end

	def method_missing(m,*args)

		@events.each{ |ev|
			if ev.is_a?(String)
				argstring = " '#{ev}',"
			else
				argstring = " #{ev},"
			end

			args.each{ |a|
				if a.is_a?(String)
					argstring+=(" '"+a+"',")
				else
					argstring+=(" "+a+",")
				end
			}
			eval(m.to_s[1..-1]+argstring.chop)
		}

	end

end

def grp(*args)
	return Group.new(args)
end" class Array
 	def count
 		return length
 	end
 	def sample(n=nil)
    if n != nil
      result = []
      data = shuffle
      n.times{
        next if data.empty?
        result.push(data.shift)
      }
      return result      
    else
      self[rand(length)]
    end
      #
  end
  def shuffle
    return self.sort_by { rand }
  end
 end

 class String
  def is_integer?
    self.to_i.to_s == self
  end
  def numeric?
    return true if self =~ /\A\d+\Z/
    true if Float(self) rescue false
  end
  def to_b
    return self == "true"
  end
end

class FalseClass; def to_i; 0 end end
class TrueClass; def to_i; 1 end end


class Fixnum
	def odd?
		return self % 2 == 1
	end
  def include?(a)
    false
  end
end

";# Extensions to sprite class

class Sprite

	def hide
		self.visible = false
	end

	def show
		self.visible = true
	end

	def move(x,y)
		self.x = x
		self.y = y
	end

	def center(x,y)
		self.x = x - width/2
		self.y = y - height/2
	end

	def width
		return self.bitmap.width
	end

	def height 
		return self.bitmap.height
	end

	def within?(x,y,px=0,py=0)
		return false if x < self.x - px
		return false if y < self.y - py
		return false if x > self.x + width + px
		return false if y > self.y + height + py
		return true
	end

end"“#==============================================================================
# ** Console
#==============================================================================

class DebugConsole

	INPUT_COLOR = Color.new(30,30,30,210)

	MAX_LOGS = 11


	def initialize(vp)

		# Prepare log
		@history = []
		@console_text = ""
		@console_sprite = Sprite.new(vp)
		@console_sprite.move(0,410)
		refresh_console

		# Showing previous
		@logs = []
		@osd_sprite = Sprite.new(vp)

		hide

	end

	def update

		# If console not showing
		if !active?
			show if $keyboard.press?(VK_TAB) 
		end

		# Hide console if press TILDE
		hide if active? && $keyboard.press?(VK_TAB)
		hide if active? && $keyboard.press?(VK_ESC)

		if !active?
			if $keyboard.state?(VK_BS)
				@osd_sprite.show
			else
				@osd_sprite.hide
			end
		end

		return if !active?

		# Show last
		if $keyboard.press?(VK_DOWN)
			@console_text = @history.empty? ? "" : @history.pop
			refresh_console
		end
									
		# Check console input
		console_chars.each{ |c|
			if $keyboard.press?(c)
				@console_text += $keyboard.to_char(c)
				refresh_console
			end
		}

		# Check inputs now
		if $keyboard.press?(VK_ENTER)
			begin
				eval(@console_text)
			rescue Exception => e
			 	log_scr(e.class.to_s+" --- '" + @console_text + "'")		      
		    end
		    @history.push(@console_text)
			@console_text = ""
			refresh_console
		end

		if $keyboard.hold?(VK_BS)
			@console_text.chop!
			refresh_console
		end

	end

	def hide
		@console_sprite.hide
		@osd_sprite.hide
	end

	def show
		@console_sprite.show
		@osd_sprite.show
	end

	def active?
		return @console_sprite.visible
	end

	def refresh_console
		@console_sprite.bitmap = Bitmap.new(640,60)

		@console_sprite.bitmap.fill_rect(0,0,640,30,INPUT_COLOR)
		@console_sprite.bitmap.draw_text(8,0,640,30,"-> "+@console_text) # Make gfx.width

		if !@history.empty?
			@console_sprite.bitmap.fill_rect(0,30,640,30,Color.new(0,0,0,120))
			@console_sprite.bitmap.draw_text(8,30,640,30,"   "+@history[-1]) # Make gfx.width
		end	

	end

	def refresh_osd

		@osd_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		cx = 0
		cy = 6

		@osd_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@osd_sprite.bitmap.font.size = 28
		@osd_sprite.bitmap.draw_text(cx+8,cy,640,50,"::LOG HISTORY::")

		cy += 60

		@osd_sprite.bitmap.font.size = 22

		@logs.each{ |log|

			out = log[0]
			color = log[1]

			size = @osd_sprite.bitmap.text_size(out)
			@osd_sprite.bitmap.fill_rect(cx,cy,size.width+20,size.height+6,color)
			@osd_sprite.bitmap.draw_text(cx+8,cy+3,600,size.height,out)

			cy += 32

		}

	end

	def log(msg)

		@logs.push(msg)
		@logs.shift while @logs.count > MAX_LOGS
		refresh_osd

	end

	def console_chars
		chars = (48..57).to_a
		chars += (65..90).to_a
		chars += (186..222).to_a
		chars += [32]
		return chars
	end

end"Ø# module Graphics
 
#   @fps, @fps_tmp = 0, []
 
#   class << self
    
#     attr_reader :fps
    
#     alias fps_update update unless method_defined?(:fps_update)
#     def update

#       if !$settings.debug_draw_fps
#       	fps_sprite.hide
#       	back_sprite.hide
#       	fps_update
#       	return
#       else
# 		fps_sprite.show
#       	back_sprite.show
#       end

# 	  t = Time.now
# 	  fps_update
# 	  @fps_tmp[frame_count % frame_rate] = Time.now != t
# 	  @fps = 0
# 	  frame_rate.times {|i| @fps += 1 if @fps_tmp[i]}
# 	  fps_sprite.src_rect.y = @fps * 30

# 	  if @old_color != $debug.last_color
# 	  	back_sprite.bitmap.fill($debug.last_color)
# 	  	@old_color = $debug.last_color
# 	  end

#     end
    
#     def fps_sprite
# 	  if !@fps_sprite or @fps_sprite.disposed?
# 	    @fps_sprite = Sprite.new
# 	    @fps_sprite.z = 9999
# 	    @fps_sprite.x = $game.width-45
# 	    @fps_sprite.y = 16
# 	    @fps_sprite.bitmap = Bitmap.new(30, 30*62)
# 	    @fps_sprite.bitmap.font.size = 28
# 	    @fps_sprite.bitmap.font.name = "Consolas"
# 	    @fps_sprite.bitmap.font.color.set(255, 255, 255)
# 	    61.times {|i| @fps_sprite.bitmap.draw_text(-2, i*30, 36, 30, "% 3d"%i)}
# 	    @fps_sprite.bitmap.draw_text(-2, 61*30, 36, 30, "++")
# 	    @fps_sprite.src_rect.height = 30
# 	  end
# 	  return @fps_sprite
#     end

#     def back_sprite
# 	  if !@back_sprite or @back_sprite.disposed?
# 	    @back_sprite = Sprite.new
# 	    @back_sprite.z = 9997
# 	    @back_sprite.x = $game.width-40
# 	    @back_sprite.y = 16
# 	    @back_sprite.bitmap = Bitmap.new(30, 30)
# 	  end
# 	  return @back_sprite
#     end
    
#   end
# end"≤#==============================================================================
# ** Actions
#==============================================================================

class DebugMenu

	def initialize(vp)

		@actions = []
		@idx = 0

		@mnu_sprite = Sprite.new(vp)
		@idx_sprite = Sprite.new(vp)
		@text_sprite = Sprite.new(vp)
		@text_sprite.z += 10

		@idx_sprite.y = 10

		@menu_title = "DEBUG MENU"

		@esc = Proc.new{ hide }

		@cursor_pos = {}

		page(:main)

		hide

	end

	def page(newpage)

		@cursor_pos[@page] = @idx

		clear

		@page = newpage

		case newpage
			when :main

				add(">> Debug Settings",Proc.new{ page(:debug) })
				
				add("-- Disable Flags",Proc.new{ $debug.disable_flags = true })
				add("-- Export Text",Proc.new{ execute_spellcheck })


				@esc = Proc.new{ hide }

			when :settings

				@menu_title = "GENERAL SETTINGS"

				add(":: Toggle Fullscreen",Proc.new{ $game.flip_window })

				@esc = Proc.new{ page(:main) }

			when :debug

				@menu_title = "DEBUG SETTINGS"

				add(":: Toggle skip title - "+$settings.debug_skip_title.to_s.upcase,Proc.new{ $settings.debug_skip_title ^= true })
				add(":: Toggle draw fps - "+$settings.debug_draw_fps.to_s.upcase,Proc.new{ $settings.debug_draw_fps ^= true })
				add(":: Toggle draw helpers - "+$settings.debug_draw_helpers.to_s.upcase,Proc.new{ $settings.debug_draw_helpers ^= true })
				add(":: Toggle power test - "+$settings.debug_power_test.to_s.upcase,Proc.new{ $settings.debug_power_test ^= true })

				@esc = Proc.new{ page(:main) }

		end
		refresh
	end


	def clear
		#@idx = 0
		@actions.clear
		refresh
	end

	def add(text,proc)
		@actions.push([text,proc])
	end

	def update

		if $keyboard.press?(VK_TILDE)
			active? ? @esc.call : show
		end

		if $keyboard.press?(VK_ESC)
			@esc.call if active?
		end

		return if !active?

		if $keyboard.press?(VK_ENTER)
			@actions[@idx][1].call if @actions[@idx][1] != nil
			page(@page)
		end
		
		if $keyboard.press?(VK_DOWN)
			@idx += 1 if @idx != @actions.count - 1
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		if $keyboard.press?(VK_UP)
			@idx -= 1 if @idx != 0
			#@idx_sprite.bitmap.fill(Color.new(rand(255),rand(255),rand(255)))
		end

		@idx_sprite.y = 66 + (@idx * 34)
		

		#refresh

	end

	def refresh


		@idx = @cursor_pos.has_key?(@page) ? @cursor_pos[@page] : 0

		@mnu_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)
		@text_sprite.bitmap = Bitmap.new(640,480)#$game.width,$game.height)

		@idx_sprite.bitmap = Bitmap.new(400,30)
		@idx_sprite.bitmap.fill(Color.new(40,110,170,240))

		cx = 0
		cy = 6

		@mnu_sprite.bitmap.fill_rect(cx,cy,640,50,Color.new(30,30,30,235))
		@text_sprite.bitmap.font.size = 28
		@text_sprite.bitmap.draw_text(cx+8,cy,640,50,"::"+@menu_title+"::")

		cy += 60

		@text_sprite.bitmap.font.size = 22

		@actions.each_index{ |i|

			out = @actions[i][0]
			color = Color.new(30,30,30,210)

			size = @mnu_sprite.bitmap.text_size(out)
			@mnu_sprite.bitmap.fill_rect(cx,cy,400,30,color)
			@text_sprite.bitmap.draw_text(cx+8,cy+0,600,size.height+6,out)

			cy += 34

		}

	end


	def show
		page(:main)
		@mnu_sprite.show
		@idx_sprite.show
		@text_sprite.show
	end

	def hide
		@mnu_sprite.hide
		@idx_sprite.hide
		@text_sprite.hide
	end

	def active?
		@mnu_sprite.visible
	end

end


"S#==============================================================================
# ** SpellCheck
#==============================================================================

def execute_spellcheck
    
    data = {} # map name, dialogues?
    
    # Each map
    $data.mapinfos.each{ |k,v| 
    
      map_id = k
      map_name = v.name
      
      event_list = load_data(sprintf("Data/Map%03d.rxdata",map_id)).events
      next if event_list.empty?
      
      events = {}
      
      # Do for each event
      event_list.each{ |k,v|
      
        ev_id = k
        ev_name = v.name
        
        dialogues = []
        
        # Do for each page
        v.pages.each{ |page|
        
        @cmd_idx = 0        
        while page.list[@cmd_idx] do

            # Do something according to command          
            case page.list[@cmd_idx].code
            
              when 101; # Short text
                
                text = page.list[@cmd_idx].parameters[0]
                while page.list[@cmd_idx+1].code == 401       # Text data
                  @cmd_idx += 1
                  text += page.list[@cmd_idx].parameters[0]
                  text += ' '      
                end
                dialogues.push(text)
            
            end
              
            @cmd_idx += 1  
          
          end # page        
        
        }

        # any dialogues? save it
        if !dialogues.empty?
          #p dialogues
          events[[ev_id,ev_name]] = dialogues
        end
        
      }

      # Add to overall
      if !events.empty?
        data[[map_id,map_name]] = events
      end
      
      #p name
      #p event_list.size
      
      
      #break
      
      
    }
    
    # Output to file
    # Create a new file and write to it  
    File.open('spellcheck.txt', 'w') do |file|  

      # Write some stats
      file.puts("Total Maps: "+$data.mapinfos.size.to_s)
      file.puts("Maps with dialogue: "+data.size.to_s)

      # Word counts
      words = 0
      data.values.each{ |map|
        map.values.each{ |ev|
          ev.each{ |line|
            words += line.split(" ").size
          }
        }
      }
      file.puts("Word Count: "+words.to_s)

      file.puts("\n")
      file.puts("\n")

      # Each Map
      data.each{ |mk,mv|

        # Map name
        file.puts("Map "+mk[0].to_s+": "+mk[1])
        file.puts("----------------------------------------")
        file.puts("\n")

        # Contents
        mv.each{ |ek,ev|

          # Event name
          file.puts("Event "+ek[0].to_s+": "+ek[1])

          # Event contents
          ev.each{ |line|
            file.puts(line)
          }

          file.puts("\n")

        }
        file.puts("\n")
      }

    end  

    
  end"®# # Fullscreen++ v2.2 for VX and VXace by Zeus81
# # Free for non commercial and commercial use
# # Licence : http://creativecommons.org/licenses/by-sa/3.0/
# # Contact : zeusex81@gmail.com
# # (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
# # (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
 
# class << Graphics
#   Disable_VX_Fullscreen = false
 
#   CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
#   GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
#   GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
#   GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
#   GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
#   FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
#   FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
#   ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
#   SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
#   SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
#   SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
#   ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
#   SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
#   UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
#   GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
#   WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
#   CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
#   DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
 
#   unless method_defined?(:zeus_fullscreen_update)
#     HWND     = FindWindow.call('RGSS Player', 0)
#     BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
#     alias zeus_fullscreen_resize_screen resize_screen
#     alias zeus_fullscreen_update        update
#   end
# private
#   def initialize_fullscreen_rects
#     @borders_size    ||= borders_size
#     @fullscreen_rect ||= screen_rect
#     @workarea_rect   ||= workarea_rect
#   end
#   def borders_size
#     GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
#     GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
#     wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
#     Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
#   end
#   def screen_rect
#     Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
#   end
#   def workarea_rect
#     SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
#     rect = rect.unpack('l4')
#     Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
#   end
#   def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
#   def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
#   def hide_back()    ShowWindow.call(BackHWND, 0)              end
#   def show_back
#     ShowWindow.call(BackHWND, 3)
#     UpdateWindow.call(BackHWND)
#     dc    = GetDC.call(BackHWND)
#     rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
#     brush = CreateSolidBrush.call(0)
#     FillRect.call(dc, rect, brush)
#     ReleaseDC.call(BackHWND, dc)
#     DeleteObject.call(brush)
#   end
#   def resize_window(w, h)
#     if @fullscreen
#       x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
#     else
#       w += @borders_size.width
#       h += @borders_size.height
#       x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
#       y = @workarea_rect.y + (@workarea_rect.height - h) / 2
#       z = -2
#     end
#     SetWindowPos.call(HWND, z, x, y, w, h, 0)
#   end
#   def release_alt
#     inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
#     SendInput.call(3, inputs, 28)
#   end
# public
#   def load_fullscreen_settings
#     buffer = [].pack('x256')
#     section = 'Fullscreen++'
#     filename = './Game.ini'
#     get_option = Proc.new do |key, default_value|
#       l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
#       buffer[0, l]
#     end
#     @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
#     @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
#     @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
#     toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
#     fullscreen? ? fullscreen_mode : windowed_mode
#   end
#   def save_fullscreen_settings
#     section = 'Fullscreen++'
#     filename = './Game.ini'
#     set_option = Proc.new do |key, value|
#       WritePrivateProfileString.call(section, key, value.to_s, filename)
#     end
#     set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
#     set_option.call('FullscreenRatio', @fullscreen_ratio)
#     set_option.call('WindowedRatio'  , @windowed_ratio)
#   end
#   def fullscreen?
#     @fullscreen or vx_fullscreen?
#   end
#   def vx_fullscreen?
#     rect = screen_rect
#     rect.width == 640 and rect.height == 480
#   end
#   def toggle_fullscreen
#     fullscreen? ? windowed_mode : fullscreen_mode
#   end
#   def toggle_vx_fullscreen
#     windowed_mode if @fullscreen and !vx_fullscreen?
#     inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
#     SendInput.call(4, inputs, 28)
#     zeus_fullscreen_update
#     self.ratio += 0 # refresh window size
#   end
#   def vx_fullscreen_mode
#     return if vx_fullscreen?
#     toggle_vx_fullscreen
#   end
#   def fullscreen_mode
#     return if vx_fullscreen?
#     initialize_fullscreen_rects
#     show_back
#     hide_borders
#     @fullscreen = true
#     self.ratio += 0 # refresh window size
#   end
#   def windowed_mode
#     toggle_vx_fullscreen if vx_fullscreen?
#     initialize_fullscreen_rects
#     hide_back
#     show_borders
#     @fullscreen = false
#     self.ratio += 0 # refresh window size
#   end
#   def toggle_ratio
#     return if vx_fullscreen?
#     self.ratio += 1
#   end
#   def ratio
#     return 1 if vx_fullscreen?
#     @fullscreen ? @fullscreen_ratio : @windowed_ratio
#   end
#   def ratio=(r)
#     return if vx_fullscreen?
#     initialize_fullscreen_rects
#     r = 0 if r < 0
#     if @fullscreen
#       @fullscreen_ratio = r
#       w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
#     else
#       @windowed_ratio = r
#       w_max = @workarea_rect.width  - @borders_size.width
#       h_max = @workarea_rect.height - @borders_size.height
#     end
#     if r == 0
#       w, h = w_max, w_max * height / width
#       h, w = h_max, h_max * width / height if h > h_max
#     else
#       w, h = width * r, height * r
#       return self.ratio = 0 if w > w_max or h > h_max
#     end
#     resize_window(w, h)
#     save_fullscreen_settings
#   end
#   def update
#     release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
#     zeus_fullscreen_update
#     toggle_fullscreen if Input.trigger?(Input::F5)
#     toggle_ratio      if Input.trigger?(Input::F6)
#   end
#   def resize_screen(width, height)
#     zeus_fullscreen_resize_screen(width, height)
#     self.ratio += 0 # refresh window size
#   end
# end

# Graphics.load_fullscreen_settings"a # Bitmap Export v5.4 for XP, VX and VXace by Zeus81
# Free for commercial use
# Licence : http://creativecommons.org/licenses/by/4.0/
# Contact : zeusex81@gmail.com
# How to Use :
#   - exporting bitmap :
#       bitmap.export(filename)
#    or bitmap.save(filename)
#
#   - serialize bitmap :
#       open(filename, 'wb') {|file| Marshal.dump(bitmap, file)}
#       bitmap = open(filename, 'rb') {|file| Marshal.load(file)}
#   or
#       save_data(bitmap, filename)
#       bitmap = load_data(filename)
#
#  - snapshot :
#      Graphics.export(filename)
#   or Graphics.save(filename)
#   or Graphics.snapshot(filename)
#   Here filename is optional, and will be replaced by datetime if omitted. 
 
$imported ||= {}
$imported[:Zeus_Bitmap_Export] = __FILE__
 
def xp?() false end; alias vx? xp?; alias vxace? xp?
#RUBY_VERSION == '1.8.1' ? defined?(Hangup) ?
def xp?() true  end 
def vx?() false  end 
def vxace?() false  end
 
class String
  alias getbyte  []
  alias setbyte  []=
  alias bytesize size
end unless vxace?
 
class Font
  def marshal_dump()     end
  def marshal_load(dump) end
end
 
class Bitmap
  RtlMoveMemory = Win32API.new('kernel32', 'RtlMoveMemory', 'ppi', 'i')
  def last_row_address
    return 0 if disposed?
    RtlMoveMemory.call(buf=[0].pack('L'), __id__*2+16, 4)
    RtlMoveMemory.call(buf, buf.unpack('L')[0]+8 , 4)
    RtlMoveMemory.call(buf, buf.unpack('L')[0]+16, 4)
    buf.unpack('L')[0]
  end
  def bytesize
    width * height * 4
  end
  def get_data
    data = [].pack('x') * bytesize
    RtlMoveMemory.call(data, last_row_address, data.bytesize)
    data
  end
  def set_data(data)
    RtlMoveMemory.call(last_row_address, data, data.bytesize)
  end
  def get_data_ptr
    data = String.new
    RtlMoveMemory.call(data.__id__*2, [vxace? ? 0x6005 : 0x2007].pack('L'), 4)
    RtlMoveMemory.call(data.__id__*2+8, [bytesize,last_row_address].pack('L2'), 8)
    def data.free() RtlMoveMemory.call(__id__*2, String.new, 16) end
    return data unless block_given?
    yield data ensure data.free
  end
  def _dump(level)
    get_data_ptr do |data|
      dump = Marshal.dump([width, height, Zlib::Deflate.deflate(data, 9)])
      dump.force_encoding('UTF-8') if vxace?
      dump
    end
  end
  def self._load(dump)
    width, height, data = *Marshal.load(dump)
    data.replace(Zlib::Inflate.inflate(data))
    bitmap = new(width, height)
    bitmap.set_data(data)
    bitmap
  end
  def export(filename)
    case format=File.extname(filename)
    when '.bmp'; export_bmp(filename)
    when '.png'; export_png(filename)
    when ''    ; export_png("#{filename}.png")
    else         print("Export format '#{format}' not supported.")
    end
  end
  alias save export
  def export_bmp(filename)
    get_data_ptr do |data|
      File.open(filename, 'wb') do |file|
        file.write(['BM',data.bytesize+54,0,54,40,width,height,
                    1,32,0,data.bytesize,0,0,0,0].pack('a2L6S2L6'))
        file.write(data)
      end
    end
  end
  def export_png(filename)
    data, i = get_data, 0
    if vxace?
      (0).step(data.bytesize-4, 4) do |i|
        byte2 = data.getbyte(i)
        data.setbyte(i, data.getbyte(i+2))
        data.setbyte(i+2, byte2)
      end
    else
      (0).step(data.bytesize-4, 4) do |i|
        data[i,3] = data[i,3].reverse!
      end
    end
    deflate = Zlib::Deflate.new(9)
      null_char, w4 = [].pack('x'), width*4
      (data.bytesize-w4).step(0, -w4) {|i| deflate << null_char << data[i,w4]}
      data.replace(deflate.finish)
    deflate.close
    File.open(filename, 'wb') do |file|
      def file.write_chunk(chunk)
        write([chunk.bytesize-4].pack('N'))
        write(chunk)
        write([Zlib.crc32(chunk)].pack('N'))
      end
      file.write("\211PNG\r\n\32\n")
      file.write_chunk(['IHDR',width,height,8,6,0,0,0].pack('a4N2C5'))
      file.write_chunk(data.insert(0, 'IDAT'))
      file.write_chunk('IEND')
    end
  end
end
 
module Graphics
  if xp?
    FindWindow             = Win32API.new('user32', 'FindWindow'            , 'pp'       , 'i')
    GetDC                  = Win32API.new('user32', 'GetDC'                 , 'i'        , 'i')
    ReleaseDC              = Win32API.new('user32', 'ReleaseDC'             , 'ii'       , 'i')
    BitBlt                 = Win32API.new('gdi32' , 'BitBlt'                , 'iiiiiiiii', 'i')
    CreateCompatibleBitmap = Win32API.new('gdi32' , 'CreateCompatibleBitmap', 'iii'      , 'i')
    CreateCompatibleDC     = Win32API.new('gdi32' , 'CreateCompatibleDC'    , 'i'        , 'i')
    DeleteDC               = Win32API.new('gdi32' , 'DeleteDC'              , 'i'        , 'i')
    DeleteObject           = Win32API.new('gdi32' , 'DeleteObject'          , 'i'        , 'i')
    GetDIBits              = Win32API.new('gdi32' , 'GetDIBits'             , 'iiiiipi'  , 'i')
    SelectObject           = Win32API.new('gdi32' , 'SelectObject'          , 'ii'       , 'i')
    def self.snap_to_bitmap
      bitmap  = Bitmap.new(width, height)
      info    = [40,width,height,1,32,0,0,0,0,0,0].pack('LllSSLLllLL')
      hDC     = GetDC.call(hwnd)
      bmp_hDC = CreateCompatibleDC.call(hDC)
      bmp_hBM = CreateCompatibleBitmap.call(hDC, width, height)
      bmp_obj = SelectObject.call(bmp_hDC, bmp_hBM)
      BitBlt.call(bmp_hDC, 0, 0, width, height, hDC, 0, 0, 0xCC0020)
      #BitBlt.call(bmp_hDC, 0, 0, width, height, hDC, 0, 0, 0xCC0020)
      GetDIBits.call(bmp_hDC, bmp_hBM, 0, height, bitmap.last_row_address, info, 0)
      SelectObject.call(bmp_hDC, bmp_obj)
      DeleteObject.call(bmp_hBM)
      DeleteDC.call(bmp_hDC)
      ReleaseDC.call(hwnd, hDC)
      bitmap
    end
  end
  class << self
    def hwnd() @hwnd ||= FindWindow.call('RGSS Player', nil) end
    def width()  640 end unless method_defined?(:width)
    def height() 480 end unless method_defined?(:height)
    def export(filename=Time.now.strftime("snapshot %Y-%m-%d %Hh%Mm%Ss #{frame_count}"))
      bitmap = snap_to_bitmap
      bitmap.export(filename)
      bitmap.dispose
    end
    alias save     export
    alias snapshot export
  end
end"›.# Zeus Video Player v2.3 for XP, VX and VXace by Zeus81
# Free for commercial use
# Licence : http://creativecommons.org/licenses/by/4.0/
# Contact : zeusex81@gmail.com
#
# How to Use :
#   Graphics.play_movie( filename, cancellable, fit_to_screen )
#   - filename = path of the video file.
#   - cancellable = true if you want to allow the player to stop the video
#                   by pressing Enter or Escape, false otherwise.
#                   This option can be omitted and default value is true.
#   - fit_to_screen = true if you want the video to be stretched to fit the screen in
#                     case it doesn't match, false if you just want it to be centered.
#                     If you're using scripts like Fullscreen++ true is recommended.
#                     This option can be omitted and default value is true.
#   ex : Graphics.play_movie( "Movies/prout.avi", true, true )
#   or   Graphics.play_movie( "Movies/prout.avi" )
#
# Codec choice :
#   I haven't tested all of them but I guess wmv9 (standard) would be a good choice.
#   You can find a list of codecs installed by default on windows here :
#   http://support.microsoft.com/kb/899113
#
# Background Image :
#   You can choose the background image of the player (in case your video doesn't fill all the space).
#   It will automatically load the image named "ZeusVideoPlayer" if found in Pictures folder (the extension doesn't matter).
#   If not found it will be black.
#
# Known bugs :
#  - With some video codecs stretching to fit screen doesn't work in fullscreen mode.
#  - When switching fullscreen mode during playback the display can freeze.
#  - Sometimes the display doesn't render when playing a video for the second time.
#  - Weird behaviour in fullscreen mode.
#
# ZVP_OldAviMode :
#   Just bellow you can enable this mode by setting the variable to true.
#   Advantages :
#     - More stable, no known bugs.
#   Drawbacks :
#     - It can only play avi files.
#     - You must use vfw codecs for video, and windows defaults vfw codecs are very limited.
#       Exhaustive list : MS RLE, MS Video 1, Cinepak, iyuv. And they all sucks.
#       Any other codec will require to be installed on user side to ensure that it's supported.
#       But if it's not a problem then you can find very nice vfw codecs on the internet, eg x264vfw.
#     - You must use acm codecs for audio.
#       Windows defaults : mp3, pcm.
#       You can also find better codecs like aac acm.
 
module Graphics
  ZVP_OldAviMode = false
end
 
$imported ||= {}
$imported[:Zeus_Video_Player] = __FILE__
 
def xp?() true end ; 
def vx?() false end ; 
def vxace?() false end ; 
 
#Cache = RPG::Cache if xp?
 
class String
  alias getbyte  []
  alias setbyte  []=
  alias bytesize size
end unless vxace?
 
module Zeus
  module Encode # 1.1
    MultiByteToWideChar = Win32API.new('kernel32', 'MultiByteToWideChar', 'iipipi'  , 'i')
    WideCharToMultiByte = Win32API.new('kernel32', 'WideCharToMultiByte', 'iipipipp', 'i')
    CodePages = {
      'ANSI'=>0, 'OEM'=>1, 'MAC'=>2, 'THREAD_ANSI'=>3, 'SYMBOL'=>42,
      'WINDOWS874'=>874, 'SHIFT_JIS'=>932, 'BIG5'=>950, 'WINDOWS1250'=>1250,
      'WINDOWS1251'=>1251, 'WINDOWS1252'=>1252, 'WINDOWS1253'=>1253,
      'WINDOWS1254'=>1254, 'WINDOWS1255'=>1255, 'WINDOWS1256'=>1256,
      'WINDOWS1257'=>1257, 'WINDOWS1258'=>1258, 'US_ASCII'=>20127,
      'ISO8859_1'=>28591, 'ISO8859_2'=>28592, 'ISO8859_3'=>28593,
      'ISO8859_4'=>28594, 'ISO8859_5'=>28595, 'ISO8859_6'=>28596,
      'ISO8859_7'=>28597, 'ISO8859_8'=>28598, 'ISO8859_9'=>28599,
      'ISO8859_13'=>28603, 'ISO8859_15'=>28605, 'ISO8859_8I'=>38598,
      'ISO2022_JP'=>50220, 'ISO2022_KR'=>50225, 'ISO2022_CN'=>50227,
      'EUC_JP'=>51932, 'EUC_CN'=>51936, 'EUC_KR'=>51949, 'GB2312'=>52936,
      'UTF7'=>65000, 'UTF8'=>65001, 'UTF16'=>-1
    }
    def self.encode(str, from, to, dchar=nil, dflag=nil)
      if from != -1
        l = MultiByteToWideChar.call(from, 0, str, str.bytesize, nil, 0)
        utf16 = [].pack('x') * (l*2)
        MultiByteToWideChar.call(from, 0, str, str.bytesize, utf16, l)
      else utf16 = str
      end
      if to != -1
        l = WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, nil, 0, dchar, dflag)
        str = [].pack('x') * l
        WideCharToMultiByte.call(to, 0, utf16, utf16.bytesize/2, str, l, dchar, dflag)
      else str = utf16
      end
      case to
      when 20127; str.force_encoding('US-ASCII')
      when 65001; str.force_encoding('UTF-8')
      when    -1; str.force_encoding('UTF-16LE')
      end if vxace?
      str
    rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
    end
    def self.method_missing(method, str, *options)
      from, to = *method.to_s.upcase.split('_TO_', 2).map! {|s| CodePages[s]}
      super unless from and to
      encode(str, from, to, *options)
    rescue raise($!, $!.message, caller(vxace? ? 2 : 1))
    end
  end
end
 
module Graphics
  DefWindowProc       = Win32API.new('user32', 'DefWindowProc'      , 'iiii', 'i')
  DestroyWindow       = Win32API.new('user32', 'DestroyWindow'      , 'i'   , 'i')
  EnableWindow        = Win32API.new('user32', 'EnableWindow'       , 'ii'  , 'i')
  FindWindow          = Win32API.new('user32', 'FindWindow'         , 'pp'  , 'i')
  GetClientRect       = Win32API.new('user32', 'GetClientRect'      , 'ip'  , 'i')
  GetForegroundWindow = Win32API.new('user32', 'GetForegroundWindow', ''    , 'i')
  GetMessage          = Win32API.new('user32', 'GetMessage'         , 'piii', 'i')
  GetWindowLong       = Win32API.new('user32', 'GetWindowLong'      , 'ii'  , 'i')
  PostMessage         = Win32API.new('user32', 'PostMessage'        , 'iiii', 'i')
  RedrawWindow        = Win32API.new('user32', 'RedrawWindow'       , 'ipii', 'i')
  SetWindowLong       = Win32API.new('user32', 'SetWindowLong'      , 'iii' , 'i')
  MciGetErrorString   = Win32API.new('winmm' , 'mciGetErrorStringW' , 'ipi' , 'i')
  MciSendString       = Win32API.new('winmm' , 'mciSendStringW'     , 'ppii', 'i')
  class << self
    def hwnd() @hwnd ||= FindWindow.call(nil,'Aveyond') end
    def play_movie(filename, cancellable = true, fit_to_screen = true)
      @zvp ||= {:buffer => [].pack('x') * 256}
      @zvp[:filename] = Dir["#{filename}.*"][0] || filename
      @zvp[:cancellable] = cancellable
      @zvp[:fit_to_screen] = fit_to_screen
      return unless open_video_player
      back_sprite = Sprite.new
      back_sprite.z = 0x7FFF_FFFF
      begin
        cached = true
        back_sprite.bitmap = $cache.picture('ZeusVideoPlayer')
        back_sprite.zoom_x = width  / back_sprite.bitmap.width.to_f
        back_sprite.zoom_y = height / back_sprite.bitmap.height.to_f
      rescue
        cached = false
        back_sprite.bitmap = Bitmap.new(1, 1)
        back_sprite.bitmap.set_pixel(0, 0, Color.new(0,0,0))
        back_sprite.zoom_x = width
        back_sprite.zoom_y = height
      end
      frame_reset
      update
      update_video_player
      back_sprite.bitmap.dispose unless cached
      back_sprite.dispose
    ensure
      close_video_player
    end
    def width()  640 end unless method_defined?(:width)
    def height() 480 end unless method_defined?(:height)
  private
    def mci(command)
      error = mci_silent(command)
      return true if error == 0
      MciGetErrorString.call(error, @zvp[:buffer], @zvp[:buffer].bytesize/2)
      print(mci_result, "\nCommand : ", command)
      return false
    end
    def mci_silent(command)
      command = Zeus::Encode.utf8_to_utf16("#{command}\0")
      MciSendString.call(command, @zvp[:buffer], @zvp[:buffer].bytesize/2, hwnd)
    end
    def mci_result
      str = Zeus::Encode.utf16_to_utf8(@zvp[:buffer])
      str[0, str.index("\0")]
    end
    def open_video_player(position=0)
      if ZVP_OldAviMode
        return false unless mci("open \"#{@zvp[:filename]}\" type AVIVideo alias ZeusVideoPlayer")
        return false unless mci("window ZeusVideoPlayer handle #{hwnd}")
        return false unless mci("play ZeusVideoPlayer from #{position} notify")
      else
        return false unless mci("open \"#{@zvp[:filename]}\" type MPEGVideo style Child parent #{hwnd} alias ZeusVideoPlayer")
        return false unless mci("play ZeusVideoPlayer from #{position} notify")
        return false unless mci('status ZeusVideoPlayer window handle')
        @zvp[:hwnd] = mci_result.to_i
        EnableWindow.call(@zvp[:hwnd], 0)
        style = GetWindowLong.call(hwnd, -16) #GWL_STYLE
        SetWindowLong.call(hwnd, -16, style | 0x02000000) #WS_CLIPCHILDREN
      end
      return true
    end
    def close_video_player
      if !ZVP_OldAviMode and @zvp[:hwnd]
        DestroyWindow.call(@zvp[:hwnd])
        @zvp[:hwnd] = nil
      end
      mci_silent('stop ZeusVideoPlayer')
      mci_silent('close ZeusVideoPlayer')
    end
    def resize_video_player
      if mci_silent('where ZeusVideoPlayer source') == 0
        x, y, w, h = *mci_result.split(' ', 4).map! {|s| s.to_i}
        GetClientRect.call(hwnd, @zvp[:buffer])
        client_w, client_h = *@zvp[:buffer].unpack('x8L2')
        if @zvp[:fit_to_screen]
          ratio = w / h.to_f
          w, h = client_w, (client_w / ratio).round
          h, w = client_h, (client_h * ratio).round if h > client_h
        end
        x, y = (client_w-w)/2, (client_h-h)/2
        window = ZVP_OldAviMode ? 'destination' : 'window'
        mci_silent("put ZeusVideoPlayer #{window} at #{x} #{y} #{w} #{h}")
      end
      RedrawWindow.call(@zvp[:hwnd] || hwnd, nil, 0, 0)
    end
    def update_video_player
      focus = false
      loop do
        GetMessage.call(@zvp[:buffer], 0, 0, 0)
        DefWindowProc.call(*msg = @zvp[:buffer].unpack('L4'))
        if focus != (GetForegroundWindow.call == hwnd)
          focus = !focus
          mci_silent("#{focus ? 'resume' : 'pause'} ZeusVideoPlayer")
          resize_video_player
        end
        next unless focus
        Input.update
        if Input.trigger?(Input::B) or Input.trigger?(Input::C)
          mci_silent('stop ZeusVideoPlayer') if @zvp[:cancellable]
        elsif Input.trigger?(Input::F5) or Input.trigger?(Input::F6)
          if $imported[:Zeus_Fullscreen] and !vx_fullscreen?
            update
            resize_video_player
          end
        end
        case msg[1]
        when 0x0012 #WM_QUIT
          exit
        when 0x0100 #WM_KEYDOWN
          next if msg[3][30] == 1
          case msg[2]
          when 0x70, 0x7B #VK_F1, VK_F12
            focus = false
            mci_silent('pause ZeusVideoPlayer')
            PostMessage.call(*msg)
            update
          end
        when 0x0104 #WM_SYSKEYDOWN
          next if msg[2] != 0x0D or msg[3][30] == 1
          next if $imported[:Zeus_Fullscreen] and Disable_VX_Fullscreen
          if ZVP_OldAviMode
            PostMessage.call(*msg)
            update
            resize_video_player
          else
            next if mci_silent('status ZeusVideoPlayer position') != 0
            position = mci_result.to_i
            close_video_player
            PostMessage.call(*msg)
            update
            break unless open_video_player(position)
            resize_video_player
          end
        else
          mci_silent('status ZeusVideoPlayer length')
          length = mci_result.to_i
          mci_silent('status ZeusVideoPlayer position')
          break if mci_result.to_i >= length
          mci_silent('status ZeusVideoPlayer mode')
          break if mci_result == 'stopped'
        end
      end
    end
    if xp?
      alias anti_hangup_update_video_player update_video_player
      def update_video_player
        anti_hangup_update_video_player
      rescue Hangup
        retry
      end
    end
  end
end">
# Copyright (c) 2013 Dami√°n Silvani

# MIT License

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# https://github.com/munshkr/easing-ruby

  # Added function
  def easing(t,b,c,d,e)

  	t = t.to_f; b = b.to_f; c = c.to_f; d = d.to_f

  	case e
  		when :linear; linear_tween(t,b,c,d)

  		when :quad_in, :quad_i, :qi; ease_in_quad(t,b,c,d)
  		when :quad_out, :quad_o, :qo; ease_out_quad(t,b,c,d)
  		when :quad_in_out, :quad_io, :qio; ease_in_out_quad(t,b,c,d)

  		when :cubic_in, :cubic_i; ease_in_cubic(t,b,c,d)
  		when :cubic_out, :cubic_o; ease_out_cubic(t,b,c,d)
  		when :cubic_in_out, :cubic_io; ease_in_out_cubic(t,b,c,d)

  		when :quart_in, :quart_i; ease_in_quart(t,b,c,d)
  		when :quart_out, :quart_o; ease_out_quart(t,b,c,d)
  		when :quart_in_out, :quart_io; ease_in_out_quart(t,b,c,d)

  		when :quint_in, :quint_i; ease_in_quint(t,b,c,d)
  		when :quint_out, :quint_i; ease_out_quint(t,b,c,d)
  		when :quint_in_out, :quint_io; ease_in_out_quint(t,b,c,d)

  		when :sine_in, :sine_i; ease_in_sine(t,b,c,d)
  		when :sine_out, :sine_o; ease_out_sine(t,b,c,d)
  		when :sine_in_out, :sine_io; ease_in_out_sine(t,b,c,d)

  		when :expo_in, :expo_i; ease_in_expo(t,b,c,d)
  		when :expo_out, :expo_o; ease_out_expo(t,b,c,d)
  		when :expo_in_out, :expo_io; ease_in_out_expo(t,b,c,d)

  		when :circ_in, :circ_i; ease_in_circ(t,b,c,d)
  		when :circ_out, :circ_o; ease_out_circ(t,b,c,d)
  		when :circ_in_out, :circ_io; ease_in_out_circ(t,b,c,d)

      when :bounce_in, :bounce_i; ease_in_bounce(t,b,c,d)
      when :bounce_out, :bounce_o; ease_out_bounce(t,b,c,d)
      when :bounce_in_out, :bounce_io; ease_in_out_bounce(t,b,c,d)

  	end

  end

  def linear_tween(t, b, c, d)
    c * t / d + b
  end

  def ease_in_quad(t, b, c, d)
    return c*(t/=d)*t + b;
  end

  def ease_out_quad(t, b, c, d)
    return -c *(t/=d)*(t-2) + b;
  end

  def ease_in_out_quad(t, b, c, d)
    t /= d / 2
    return c / 2*t*t + b if (t < 1)
    t -= 1
    return -c/2 * (t*(t-2) - 1) + b
  end

  def ease_in_cubic(t, b, c, d)
    return c*(t/=d)*t*t + b
  end

  def ease_out_cubic(t, b, c, d)
    return c*((t=t/d-1)*t*t + 1) + b
  end

  def ease_in_out_cubic(t, b, c, d)
    return c/2*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t + 2) + b
  end

  def ease_in_quart(t, b, c, d)
    return c*(t/=d)*t*t*t + b
  end

  def ease_out_quart(t, b, c, d)
    return -c * ((t=t/d-1)*t*t*t - 1) + b
  end

  def ease_in_out_quart(t, b, c, d)
    return c/2*t*t*t*t + b if ((t/=d/2) < 1)
    return -c/2 * ((t-=2)*t*t*t - 2) + b
  end

  def ease_in_quint(t, b, c, d)
    return c*(t/=d)*t*t*t*t + b
  end

  def ease_out_quint(t, b, c, d)
    return c*((t=t/d-1)*t*t*t*t + 1) + b
  end

  def ease_in_out_quint(t, b, c, d)
    return c/2*t*t*t*t*t + b if ((t/=d/2) < 1)
    return c/2*((t-=2)*t*t*t*t + 2) + b
  end

  def ease_in_sine(t, b, c, d)
    return -c * Math.cos(t/d * (Math::PI/2)) + c + b
  end

  def ease_out_sine(t, b, c, d)
    return c * Math.sin(t/d * (Math::PI/2)) + b
  end

  def ease_in_out_sine(t, b, c, d)
    return -c/2 * (Math.cos(Math::PI*t/d) - 1) + b
  end

  def ease_in_expo(t, b, c, d)
    return (t==0) ? b : c * (2 ** (10 * (t/d - 1))) + b
  end

  def ease_out_expo(t, b, c, d)
    return (t==d) ? b+c : c * (-2**(-10 * t/d) + 1) + b
  end

  def ease_in_out_expo(t, b, c, d)
    return b if t == 0
    return b + c if t == d
    return (c/2) * 2**(10 * (t-1)) + b if ((t /= d/2) < 1)
    return (c/2) * (-2**(-10 * t-=1) + 2) + b
  end

  def ease_in_circ(t, b, c, d)
    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b
  end

  def ease_out_circ(t, b, c, d)
    return c * Math.sqrt(1 - (t=t/d-1)*t) + b
  end

  def ease_in_out_circ(t, b, c, d)
    return -c/2 * (Math.sqrt(1 - t*t) - 1) + b if ((t/=d/2) < 1)
    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b
  end

  # Added
  def ease_in_bounce(t,b,c,d)
  	return c - ease_out_bounce(d-t,0,c,d) + b
  end

  def ease_out_bounce(t,b,c,d)
  	t /= d
  	if ( (t) < (1 / 2.75))
  		return c * (7.5625 * t * t) + b
  	elsif (t < (2 / 2.75))
  		t -= (1.5 / 2.75)
  		return c * (7.5625 * (t) * t + 0.75) + b
  	elsif (t < (2.5 / 2.75))
  		t -= (2.25 / 2.75)
  		return c * (7.5625 * (t) * t + 0.9375) + b
  	else
  		t -= (2.625 / 2.75)
  		return c * (7.5625 * (t) * t + 0.984375) + b
  	end
  end

  def ease_in_out_bounce(t,b,c,d)
  	if (t < d / 2)
  		return ease_in_bounce(t * 2, 0, c, d) * 0.5 + b;
  	else
  		return ease_out_bounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  	end
  end"Éclass Object
	def do(tween)
		# Register
		tween.set_parent(self)
		$tweens.register(tween)
		tween.start
	end

	# These don't work for some reason
	def go(var,amount,dur,ease=:linear)
		self.do(TimedTween.new(var,amount,dur,ease))
	end

	def to(var,target,speed=nil)
		self.do(TargetTween.new(var,target,speed))
	end

	def done?
		return $tweens.done?(self)
	end
end"K
def sequence(*args)
	return SequenceTween.new(*args)
end

def seq(*args)
	return SequenceTween.new(*args)
end

def repeat(a,times=-1)
	return LoopTween.new(a,times)
end

def parallel(*args)
	return ParallelTween.new(args)
end

def para(*args)
	return ParallelTween.new(args)
end

def pingpong(var,amount,duration,ease=:linear)
	return PingPongTween.new(var,amount,duration,ease)
end

def set(var,value)
	return SetTween.new(var,value)
end

def delay(duration)
	return DelayTween.new(duration)
end

def call(script)
	return CallTween.new(script)
end

def go(var,amount,dur,ease=:linear)
	return TimedTween.new(var,amount,dur,ease)
end

def to(var,target,speed=nil)
	return TargetTween.new(var,target,speed)
end

def proc(prc,delay=0)
	return ProcTween.new(prc,delay)
end


#==============================================================================
# ** Tweens
#==============================================================================

class Tween

	attr_reader :parent

	def initialize
		@parent = nil
	end

	def set_parent(parent)
		@parent = parent
	end

	def disposed?
		return @parent.disposed? if !@parent.nil?
		return false
	end

	def start
	end

end

class SetTween < Tween

	def initialize(var,value)
		@var = var
		@value = value
	end

	def done?
		return true
	end

	def start
		@parent.send(@var+"=",@value)
	end

	def copy
		return SetTween(@var,@value)
	end

end

class CallTween < Tween

	def initialize(script)
		@script = script
		@stopit = false
	end

	def done?
		return true
	end

	def start
		return if @stopit
		eval(@script)
		@stopit = true
	end

	def copy
		nano = CallTween.new(@script)
		nano.set_parent(@parent)
		return nano
	end

end

class ProcTween < Tween

	def initialize(proc,delay)
		@proc = proc
		@delay = delay
	end

	def done?
		if @delay <= 0
			@proc.call()
			return true
		end
		return false
	end

	def update(delta)
		@delay -= delta
		#@proc.call() if done?
	end

end

class DelayTween < Tween

	def initialize(duration)
		@elapsed = 0
		@duration = duration
	end

	def done?
		return @elapsed >= @duration
	end

	def update(delta)
		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
	end

end

# Timed Tween
class TimedTween < Tween

	attr_accessor :elapsed, :duration, :ease

	def initialize(var,amount,duration,ease=:linear)
		@elapsed = 0
		@duration = duration
		@ease = ease
		@var = var
		@amount = amount
	end

	def done?
		return @elapsed >= @duration
	end

	def start
		@initial = @parent.send(@var)
	end

	def update(delta)

		# Error with list with setting x, for now it doesn't slide
		return if @parent.is_a?(Sprite) && @parent.disposed?


		@elapsed += delta
		@elapsed = @duration if @elapsed > @duration
		var = easing(elapsed, @initial, @amount, @duration, @ease)
		@parent.send(@var+"=",var)
	end

	def reverse
		nano = TimedTween.new(@var,-@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

	def copy
		nano = TimedTween.new(@var,@amount,@duration,@ease)
		nano.set_parent(@parent)
		return nano
	end

end

class TargetTween < Tween

	attr_accessor :initial, :target, :speed

	def initialize(var,target,speed=nil) # speed default to 10% distance
		@target = target
		@var = var
		@speed = speed
	end

	def done?
		return @target == @parent.send(@var)
	end

	def start
		@initial = @parent.send(@var)
		@dist = @target - @initial
		@speed = @dist.to_f/10 if @speed == nil
	end

	def update(delta)
		val = @parent.send(@var)
		if (@target-val).abs < @speed.abs
			val = @target
		else
			val += @speed
		end		
		@parent.send(@var+"=",val)
	end

	def reverse

	end

	def copy
		nano = TargetTween.new(@var,@target,@speed)
		nano.set_parent(@parent)
		return nano
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class PingPongTween < TimedTween

	def done?
		# Never ending nano
		return false
	end

	def update(delta)
		super(delta)
		if @elapsed == @duration
			@initial = @parent.send(@var)
			@elapsed = 0
			@amount= -@amount
		end
	end

end

#==============================================================================
# ** Hosts
#==============================================================================

class LoopTween < Tween

	def initialize(child,times=-1)
		#super
		@initial = child.copy
		@child = child
		@times = times
	end

	def done?
		return @child.done? && @times == 0
	end

	def set_parent(parent)
		super(parent)
		@initial.set_parent(parent) if @initial
		@child.set_parent(parent)
	end

	def start
		@child.start
	end

	def update(delta)
		@child.update(delta)
		if @child.done?
			@times -= 1
			if @times != 0
				@child = @initial
				@initial = @child.copy
				@child.set_parent(@parent)
				#log_append 'start child'
				@child.start
			end
		end
	end

	def reverse

	end

	def copy
		nano = LoopTween.new(@child.copy, @times)
		nano.set_parent(@parent)
		return nano
	end

end

class SequenceTween < Tween

	def initialize(*args)
		@sequence = args
	end

	def push(nano)
		@sequence.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@sequence.each{ |n| n.set_parent(parent)}
	end

	def done?
		return @sequence.empty?
	end

	def clear
		@sequence.clear
	end

	def start
		start_instants
	end

	def start_instants
		return if @sequence.empty?
		#log_append @sequence.first
		@sequence.first.start
		while !@sequence.empty? && @sequence.first.done?
			@sequence.shift#.dispose
			@sequence.first.start if !@sequence.empty?
		end
	end

	def update(delta)
		return if @sequence.empty?
		@sequence.first.update(delta)
		if @sequence.first.done?
			@sequence.shift#.dispose
			start_instants
		end
	end

	def count
		return @sequence.count
	end

	def reverse
		nano = SequenceTween.new()
		nano.set_parent(@parent)
		@sequence.reverse.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

	def copy
		nano = SequenceTween.new()
		nano.set_parent(@parent)
		@sequence.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end

class ParallelTween < Tween

	def initialize(*args)
		@nanos = args
	end

	def push(nano)
		@nanos.push(nano)
	end

	def set_parent(parent)
		super(parent)
		@nanos.each{ |n| n.set_parent(parent)}
	end

	def done?
		@nanos.each{ |n|
			return false if !n.done?
		}
		return true
	end

	def start
		@nanos.each{ |n| 
			n.start
		}
	end

	def update(delta)
		@nanos.each{ |n| 
			n.update(delta)
		}
	end

	def reverse

	end

	def copy
		nano = ParallelTween.new()
		@nanos.each{ |n|
			nano.push(n.copy)
		}
		return nano
	end

end